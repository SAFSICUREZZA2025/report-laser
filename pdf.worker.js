/**
 * @licstart Di seguito è riportato l'intero avviso di licenza per il
 * Codice JavaScript in questa pagina
 *
 * Copyright 2023 Mozilla Foundation
 *
 * Concesso in licenza secondo i termini della licenza Apache, versione 2.0 (la "Licenza");
 * Non è possibile utilizzare questo file se non in conformità con la licenza.
 * È possibile ottenere una copia della licenza presso
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Salvo quanto richiesto dalla legge applicabile o concordato per iscritto, il software
 * distribuito sotto la licenza è distribuito "COSÌ COM'È",
 * SENZA GARANZIE O CONDIZIONI DI ALCUN TIPO, esplicite o implicite.
 * Consultare la Licenza per la lingua specifica che regola i permessi e
 * limitazioni previste dalla Licenza.
 *
 * @licend Quanto sopra è l'intero avviso di licenza per il
 * Codice JavaScript in questa pagina
 */

(funzione webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		modulo.esportazioni = root.pdfjsWorker = factory();
	altrimenti se(tipo di definizione === 'funzione' && definisci.amd)
		define("pdfjs-dist/build/pdf.worker", [], () => { return (root.pdfjsWorker = factory()); });
	altrimenti se(tipo di esportazioni === 'oggetto')
		esportazioni["pdfjs-dist/build/pdf.worker"] = root.pdfjsWorker = factory();
	altro
		root["pdfjs-dist/build/pdf.worker"] = root.pdfjsWorker = factory();
})(globaleQuesto, () => {
restituisci /******/ (() => { // webpackBootstrap
/******/ "usa rigoroso";
/******/ var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.WorkerTask = esportazioni.WorkerMessageHandler = void 0;
var _util = __w_pdfjs_require__(2);
var _core_utils = __w_pdfjs_require__(3);
var _primitives = __w_pdfjs_require__(4);
var _pdf_manager = __w_pdfjs_require__(6);
var _annotazione = __w_pdfjs_require__(10);
var _cleanup_helper = __w_pdfjs_require__(68);
var _writer = __w_pdfjs_require__(73);
var _message_handler = __w_pdfjs_require__(104);
var _worker_stream = __w_pdfjs_require__(105);
var _struct_tree = __w_pdfjs_require__(72);
classe WorkerTask {
  costruttore(nome) {
    questo.nome = nome;
    questo.terminato = falso;
    this._capability = new _util.PromiseCapability();
  }
  ottenere finito() {
    restituisci this._capability.promise;
  }
  fine() {
    this._capability.resolve();
  }
  termina() {
    questo.terminato = vero;
  }
  ensureNotTerminated() {
    se (questo.terminato) {
      genera un nuovo errore("L'attività del lavoratore è stata terminata");
    }
  }
}
esportazioni.WorkerTask = WorkerTask;
classe WorkerMessageHandler {
  configurazione statica (gestore, porta) {
    lascia che testMessageProcessed = false;
    handler.on("test", funzione (dati) {
      se (testMessageProcessed) {
        ritorno;
      }
      testMessageProcessed = true;
      handler.send("test", data instanceof Uint8Array);
    });
    handler.on("configura", funzione (dati) {
      (0, _util.setVerbosityLevel)(data.verbosity);
    });
    handler.on("GetDocRequest", funzione (dati) {
      restituisci WorkerMessageHandler.createDocumentHandler(dati, porta);
    });
  }
  static createDocumentHandler(docParams, porta) {
    lascia pdfManager;
    lascia terminato = falso;
    lascia cancelXHRs = null;
    const WorkerTasks = new Set();
    costante verbosità = (0, _util.getVerbosityLevel)();
    costante {
      ID documento,
      Versione API
    } = docParams;
    const workerVersion = '3.11.174';
    se (apiVersion !== workerVersion) {
      throw new Error(`La versione API "${apiVersion}" non corrisponde ` + `alla versione Worker "${workerVersion}".`);
    }
    const enumerableProperties = [];
    per (proprietà costante in []) {
      enumerableProperties.push(proprietà);
    }
    se (enumerableProperties.length) {
      throw new Error("`Array.prototype` contiene proprietà enumerabili inaspettate: " + enumerableProperties.join(", ") + "; interrompendo così, ad esempio, l'iterazione `for...in` di `Array`.");
    }
    const workerHandlerName = docId + "_worker";
    lascia gestore = nuovo _message_handler.MessageHandler(workerHandlerName, docId, porta);
    funzione ensureNotTerminated() {
      se (terminato) {
        genera un nuovo errore("Il lavoratore è stato licenziato");
      }
    }
    funzione startWorkerTask(attività) {
      WorkerTasks.add(attività);
    }
    funzione finishWorkerTask(attività) {
      compito.finire();
      WorkerTasks.delete(attività);
    }
    funzione asincrona loadDocument(recoveryMode) {
      attendi pdfManager.ensureDoc("checkHeader");
      attendi pdfManager.ensureDoc("parseStartXRef");
      attendi pdfManager.ensureDoc("analizzare", [recoveryMode]);
      attendi pdfManager.ensureDoc("checkFirstPage", [recoveryMode]);
      attendi pdfManager.ensureDoc("checkLastPage", [recoveryMode]);
      const isPureXfa = await pdfManager.ensureDoc("isPureXfa");
      se (isPureXfa) {
        const task = new WorkerTask("loadXfaFonts");
        startWorkerTask(attività);
        attendi Promise.all([pdfManager.loadXfaFonts(handler, task).catch(reason => {}).then(() => finishWorkerTask(task)), pdfManager.loadXfaImages()]);
      }
      const [numPages, impronte digitali] = await Promise.all([pdfManager.ensureDoc("numPages"), pdfManager.ensureDoc("impronte digitali")]);
      const htmlForXfa = isPureXfa ? attendono pdfManager.ensureDoc("htmlForXfa") : null;
      ritorno {
        numPagine,
        impronte digitali,
        htmlForXfa
      };
    }
    funzione getPdfManager({
      dati,
      password,
      Disabilita AutoFetch,
      intervalloChunkSize,
      lunghezza,
      docBaseUrl,
      enableXfa,
      Opzioni di valutazione
    }) {
      const pdfManagerArgs = {
        fonte: nullo,
        Disabilita AutoFetch,
        docBaseUrl,
        ID documento,
        enableXfa,
        Opzioni di valutazione,
        gestore,
        lunghezza,
        password,
        intervalloChunkSize
      };
      const pdfManagerCapability = new _util.PromiseCapability();
      lascia nuovoPdfManager;
      se (dati) {
        Tentativo {
          pdfManagerArgs.source = dati;
          newPdfManager = nuovo _pdf_manager.LocalPdfManager(pdfManagerArgs);
          pdfManagerCapability.resolve(newPdfManager);
        } catturare (es.) {
          pdfManagerCapability.reject(ex);
        }
        restituisci pdfManagerCapability.promise;
      }
      lascia pdfStream,
        cachedChunks = [];
      Tentativo {
        pdfStream = new _worker_stream.PDFWorkerStream(gestore);
      } catturare (es.) {
        pdfManagerCapability.reject(ex);
        restituisci pdfManagerCapability.promise;
      }
      const fullRequest = pdfStream.getFullReader();
      fullRequest.headersReady.then(funzione () {
        se (!fullRequest.isRangeSupported) {
          ritorno;
        }
        pdfManagerArgs.source = pdfStream;
        pdfManagerArgs.length = fullRequest.contentLength;
        pdfManagerArgs.disableAutoFetch ||= fullRequest.isStreamingSupported;
        newPdfManager = new _pdf_manager.NetworkPdfManager(pdfManagerArgs);
        per (const chunk di cachedChunks) {
          newPdfManager.sendProgressiveData(chunk);
        }
        cachedChunks = [];
        pdfManagerCapability.resolve(newPdfManager);
        cancelXHRs = null;
      }).catch(funzione (motivo) {
        pdfManagerCapability.reject(motivo);
        cancelXHRs = null;
      });
      lascia caricato = 0;
      const flushChunks = funzione () {
        const pdfFile = (0, _core_utils.arrayBuffersToBytes)(cachedChunks);
        se (lunghezza && pdfFile.length !== lunghezza) {
          (0, _util.warn)("la lunghezza HTTP segnalata è diversa da quella effettiva");
        }
        Tentativo {
          pdfManagerArgs.source = pdfFile;
          newPdfManager = nuovo _pdf_manager.LocalPdfManager(pdfManagerArgs);
          pdfManagerCapability.resolve(newPdfManager);
        } catturare (es.) {
          pdfManagerCapability.reject(ex);
        }
        cachedChunks = [];
      };
      nuova Promessa(funzione (risolvi, rifiuta) {
        const readChunk = funzione ({
          valore,
          Fatto
        }) {
          Tentativo {
            ensureNotTerminated();
            se (fatto) {
              se (!newPdfManager) {
                flushChunks();
              }
              cancelXHRs = null;
              ritorno;
            }
            caricato += valore.byteLength;
            se (!fullRequest.isStreamingSupported) {
              gestore.invia("DocProgress", {
                caricato,
                totale: Math.max(caricato, fullRequest.contentLength || 0)
              });
            }
            se (nuovoPdfManager) {
              newPdfManager.sendProgressiveData(valore);
            } altro {
              cachedChunks.push(valore);
            }
            fullRequest.read().then(readChunk, reject);
          } cattura (e) {
            rifiutare(e);
          }
        };
        fullRequest.read().then(readChunk, reject);
      }).catch(funzione (e) {
        pdfManagerCapability.reject(e);
        cancelXHRs = null;
      });
      cancelXHRs = funzione (motivo) {
        pdfStream.cancelAllRequests(motivo);
      };
      restituisci pdfManagerCapability.promise;
    }
    funzione setupDoc(dati) {
      funzione onSuccess(doc) {
        ensureNotTerminated();
        gestore.invia("OttieniDoc", {
          pdfInfo: doc
        });
      }
      funzione onFailure(ex) {
        ensureNotTerminated();
        se (ad esempio instanceof _util.PasswordException) {
          const task = new WorkerTask(`PasswordException: risposta ${ex.code}`);
          startWorkerTask(attività);
          handler.sendWithPromise("PasswordRequest", es.).then(function ({
            password
          }) {
            finishWorkerTask(attività);
            pdfManager.updatePassword(password);
            pdfManagerReady();
          }).catch(funzione () {
            finishWorkerTask(attività);
            gestore.send("DocException", ex);
          });
        } else if (ex instanceof _util.InvalidPDFException || ex instanceof _util.MissingPDFException || ex instanceof _util.UnexpectedResponseException || ex instanceof _util.UnknownErrorException) {
          gestore.send("DocException", ex);
        } altro {
          handler.send("DocException", new _util.UnknownErrorException(ex.message, ex.toString()));
        }
      }
      funzione pdfManagerReady() {
        ensureNotTerminated();
        loadDocument(false).then(onSuccess, function (reason) {
          ensureNotTerminated();
          se (!(motivo instanceof _core_utils.XRefParseException)) {
            onFailure(motivo);
            ritorno;
          }
          pdfManager.requestLoadedStream().then(funzione () {
            ensureNotTerminated();
            loadDocument(true).then(onSuccess, onFailure);
          });
        });
      }
      ensureNotTerminated();
      getPdfManager(dati).then(funzione (nuovoPdfManager) {
        se (terminato) {
          newPdfManager.terminate(new _util.AbortException("Il lavoratore è stato terminato."));
          genera un nuovo errore("Il lavoratore è stato licenziato");
        }
        pdfManager = nuovoPdfManager;
        pdfManager.requestLoadedStream(true).then(stream => {
          handler.send("Dati caricati", {
            lunghezza: stream.bytes.byteLength
          });
        });
      }).then(pdfManagerReady, onFailure);
    }
    handler.on("GetPage", funzione (dati) {
      restituisci pdfManager.getPage(data.pageIndex).then(funzione (pagina) {
        restituisci Promise.all([pdfManager.ensure(page, "rotate"), pdfManager.ensure(page, "ref"), pdfManager.ensure(page, "userUnit"), pdfManager.ensure(page, "view")]).then(function ([rotate, ref, userUnit, view]) {
          ritorno {
            ruotare,
            rif.
            Unità utente,
            visualizzazione
          };
        });
      });
    });
    handler.on("GetPageIndex", funzione (dati) {
      const pageRef = _primitives.Ref.get(data.num, data.gen);
      restituisci pdfManager.ensureCatalog("getPageIndex", [pageRef]);
    });
    handler.on("GetDestinations", funzione (dati) {
      restituisci pdfManager.ensureCatalog("destinazioni");
    });
    handler.on("GetDestination", funzione (dati) {
      restituisci pdfManager.ensureCatalog("getDestination", [data.id]);
    });
    handler.on("GetPageLabels", funzione (dati) {
      restituisci pdfManager.ensureCatalog("pageLabels");
    });
    handler.on("GetPageLayout", funzione (dati) {
      return pdfManager.ensureCatalog("pageLayout");
    });
    handler.on("GetPageMode", funzione (dati) {
      restituisci pdfManager.ensureCatalog("pageMode");
    });
    handler.on("GetViewerPreferences", funzione (dati) {
      restituisci pdfManager.ensureCatalog("viewerPreferences");
    });
    handler.on("GetOpenAction", funzione (dati) {
      restituisci pdfManager.ensureCatalog("openAction");
    });
    handler.on("GetAttachments", funzione (dati) {
      restituisci pdfManager.ensureCatalog("allegati");
    });
    handler.on("GetDocJSActions", funzione (dati) {
      restituisci pdfManager.ensureCatalog("jsActions");
    });
    handler.on("GetPageJSActions", funzione ({
      indice della pagina
    }) {
      restituisci pdfManager.getPage(pageIndex).then(funzione (pagina) {
        restituisci pdfManager.ensure(pagina, "jsActions");
      });
    });
    handler.on("GetOutline", funzione (dati) {
      restituisci pdfManager.ensureCatalog("documentOutline");
    });
    handler.on("GetOptionalContentConfig", funzione (dati) {
      restituisci pdfManager.ensureCatalog("optionalContentConfig");
    });
    handler.on("Ottieni permessi", funzione (dati) {
      restituisci pdfManager.ensureCatalog("autorizzazioni");
    });
    handler.on("GetMetadata", funzione (dati) {
      restituisci Promise.all([pdfManager.ensureDoc("documentInfo"), pdfManager.ensureCatalog("metadati")]);
    });
    handler.on("GetMarkInfo", funzione (dati) {
      restituisci pdfManager.ensureCatalog("markInfo");
    });
    handler.on("GetData", funzione (dati) {
      restituisci pdfManager.requestLoadedStream().then(funzione (flusso) {
        restituisci stream.bytes;
      });
    });
    handler.on("OttieniAnnotazioni", funzione ({
      indice della pagina,
      intento
    }) {
      restituisci pdfManager.getPage(pageIndex).then(funzione (pagina) {
        const task = new WorkerTask(`GetAnnotations: pagina ${pageIndex}`);
        startWorkerTask(attività);
        restituisci pagina.getAnnotationsData(gestore, attività, intento).then(dati => {
          finishWorkerTask(attività);
          restituire i dati;
        }, motivo => {
          finishWorkerTask(attività);
          gettare la ragione;
        });
      });
    });
    handler.on("GetFieldObjects", funzione (dati) {
      restituisci pdfManager.ensureDoc("fieldObjects");
    });
    handler.on("HasJSActions", funzione (dati) {
      restituisci pdfManager.ensureDoc("hasJSActions");
    });
    handler.on("GetCalculationOrderIds", funzione (dati) {
      restituisci pdfManager.ensureDoc("calculationOrderIds");
    });
    handler.on("SaveDocument", funzione asincrona ({
      èPureXfa,
      numPagine,
      annotazioneArchiviazione,
      nome del file
    }) {
      const globalPromises = [pdfManager.requestLoadedStream(), pdfManager.ensureCatalog("acroForm"), pdfManager.ensureCatalog("acroFormRef"), pdfManager.ensureDoc("startXRef"), pdfManager.ensureDoc("xref"), pdfManager.ensureDoc("linearizzazione"), pdfManager.ensureCatalog("structTreeRoot")];
      promesse costanti = [];
      const newAnnotationsByPage = !isPureXfa ? (0, _core_utils.getNewAnnotationsMap)(annotationStorage) : null;
      const [stream, acroForm, acroFormRef, startXRef, xref, linearizzazione, _structTreeRoot] = await Promise.all(globalPromises);
      const catalogRef = xref.trailer.getRaw("Root") || null;
      lascia structTreeRoot;
      se (nuoveAnnotazioniPerPagina) {
        se (!_structTreeRoot) {
          se (attendi _struct_tree.StructTreeRoot.canCreateStructureTree({
            catalogoRef,
            pdfManager,
            nuoveAnnotazioniPerPagina
          })) {
            structTreeRoot = null;
          }
        } altrimenti se (attendi _structTreeRoot.canUpdateStructTree({
          pdfManager,
          nuoveAnnotazioniPerPagina
        })) {
          structTreeRoot = _structTreeRoot;
        }
        const imagePromises = _annotation.AnnotationFactory.generateImages(annotationStorage.values(), xref, pdfManager.evaluatorOptions.isOffscreenCanvasSupported);
        const newAnnotationPromises = structTreeRoot === indefinito ? promesse : [];
        per (const [pageIndex, annotazioni] di newAnnotationsByPage) {
          newAnnotationPromises.push(pdfManager.getPage(pageIndex).then(page => {
            const task = new WorkerTask(`Salva (editor): pagina ${pageIndex}`);
            restituisci pagina.saveNewAnnotations(gestore, attività, annotazioni, imagePromises).finally(funzione () {
              finishWorkerTask(attività);
            });
          }));
        }
        se (structTreeRoot === null) {
          promesse.push(Promise.all(newAnnotationPromises).then(async newRefs => {
            attendi _struct_tree.StructTreeRoot.createStructureTree({
              nuoveAnnotazioniPerPagina,
              riferimento esterno,
              catalogoRef,
              pdfManager,
              nuovi Riferimenti
            });
            restituisci nuovi Riferimenti;
          }));
        } altrimenti se (structTreeRoot) {
          promesse.push(Promise.all(newAnnotationPromises).then(async newRefs => {
            attendi structTreeRoot.updateStructureTree({
              nuoveAnnotazioniPerPagina,
              pdfManager,
              nuovi Riferimenti
            });
            restituisci nuovi Riferimenti;
          }));
        }
      }
      se (isPureXfa) {
        promises.push(pdfManager.serializeXfaData(annotationStorage));
      } altro {
        per (let pageIndex = 0; pageIndex < numPages; pageIndex++) {
          promises.push(pdfManager.getPage(pageIndex).then(function (page) {
            const task = new WorkerTask(`Salva: pagina ${pageIndex}`);
            restituisci pagina.save(gestore, attività, annotazioneStorage).finally(funzione () {
              finishWorkerTask(attività);
            });
          }));
        }
      }
      const refs = await Promise.all(promesse);
      lascia nuoviRif = [];
      lascia xfaData = null;
      se (isPureXfa) {
        xfaData = refs[0];
        se (!xfaData) {
          restituisci stream.bytes;
        }
      } altro {
        nuoviRiferimenti = refs.flat(2);
        se (nuoviRif.lunghezza === 0) {
          restituisci stream.bytes;
        }
      }
      const needAppearances = acroFormRef && acroForm instanceof _primitives.Dict && newRefs.some(ref => ref.needAppearances);
      const xfa = acroForm instanceof _primitives.Dict && acroForm.get("XFA") || null;
      lascia xfaDatasetsRef = null;
      lascia che hasXfaDatasetsEntry = false;
      se (Array.isArray(xfa)) {
        per (lascia che i = 0, ii = xfa.length; i < ii; i += 2) {
          se (xfa[i] === "set di dati") {
            xfaDatasetsRef = xfa[i + 1];
            hasXfaDatasetsEntry = true;
          }
        }
        se (xfaDatasetsRef === null) {
          xfaDatasetsRef = xref.getNewTemporaryRef();
        }
      } altrimenti se (xfa) {
        (0, _util.warn)("Tipo XFA non supportato.");
      }
      lascia newXrefInfo = Object.create(null);
      se (xref.trailer) {
        const infoObj = Object.create(null);
        const xrefInfo = xref.trailer.get("Info") || null;
        se (xrefInfo instanceof _primitives.Dict) {
          xrefInfo.forEach((chiave, valore) => {
            se (tipo di valore === "stringa") {
              infoObj[chiave] = (0, _util.stringToPDFString)(valore);
            }
          });
        }
        newXrefInfo = {
          Riferimento radice: Riferimento catalogo,
          encryptRef: xref.trailer.getRaw("Crittografa") || null,
          nuovoRif: xref.getNewTemporaryRef(),
          infoRef: xref.trailer.getRaw("Info") || null,
          informazioni: infoObj,
          fileId: xref.trailer.get("ID") || null,
          startXRef: linearizzazione ? startXRef : xref.lastXRefStreamPos ?? startXRef,
          nome del file
        };
      }
      restituisci (0, _writer.incrementalUpdate)({
        dati originali: stream.bytes,
        xrefInfo: newXrefInfo,
        nuovi Riferimenti,
        riferimento esterno,
        hasXfa: !!xfa,
        xfaDatasetsRef,
        hasXfaDatasetsEntry,
        bisognoApparenze,
        acroFormRef,
        acroForm,
        xfaData
      }).finally(() => {
        xref.resetNewTemporaryRef();
      });
    });
    handler.on("GetOperatorList", funzione (dati, sink) {
      const pageIndex = data.pageIndex;
      pdfManager.getPage(pageIndex).then(funzione (pagina) {
        const task = new WorkerTask(`GetOperatorList: pagina ${pageIndex}`);
        startWorkerTask(attività);
        const start = verbosità >= _util.VerbosityLevel.INFOS ? Date.now() : 0;
        pagina.getOperatorList({
          gestore,
          lavello,
          compito,
          intento: dati.intento,
          cacheKey: dati.cacheKey,
          annotationStorage: dati.annotationStorage
        }).then(funzione (operatoreListInfo) {
          finishWorkerTask(attività);
          se (inizio) {
            (0, _util.info)(`page=${pageIndex + 1} - getOperatorList: time=` + `${Date.now() - start}ms, len=${operatorListInfo.length}`);
          }
          lavandino.chiudi();
        }, funzione (ragione) {
          finishWorkerTask(attività);
          se (attività terminata) {
            ritorno;
          }
          sink.error(motivo);
        });
      });
    });
    handler.on("GetTextContent", funzione (dati, sink) {
      costante {
        indice della pagina,
        includeMarkedContent,
        Disabilita la normalizzazione
      } = dati;
      pdfManager.getPage(pageIndex).then(funzione (pagina) {
        const task = new WorkerTask("GetTextContent: pagina " + pageIndex);
        startWorkerTask(attività);
        const start = verbosità >= _util.VerbosityLevel.INFOS ? Date.now() : 0;
        pagina.extractTextContent({
          gestore,
          compito,
          lavello,
          includeMarkedContent,
          Disabilita la normalizzazione
        }).then(funzione () {
          finishWorkerTask(attività);
          se (inizio) {
            (0, _util.info)(`page=${pageIndex + 1} - getTextContent: time=` + `${Date.now() - start}ms`);
          }
          lavandino.chiudi();
        }, funzione (ragione) {
          finishWorkerTask(attività);
          se (attività terminata) {
            ritorno;
          }
          sink.error(motivo);
        });
      });
    });
    handler.on("GetStructTree", funzione (dati) {
      restituisci pdfManager.getPage(data.pageIndex).then(funzione (pagina) {
        restituisci pdfManager.ensure(pagina, "getStructTree");
      });
    });
    handler.on("FontFallback", funzione (dati) {
      restituisci pdfManager.fontFallback(data.id, handler);
    });
    handler.on("Pulizia", ​​funzione (dati) {
      restituisci pdfManager.cleanup(true);
    });
    handler.on("Termina", funzione (dati) {
      terminato = vero;
      const waitOn = [];
      se (pdfManager) {
        pdfManager.terminate(new _util.AbortException("Il lavoratore è stato terminato."));
        const cleanupPromise = pdfManager.cleanup();
        waitOn.push(cleanupPromise);
        pdfManager = null;
      } altro {
        (0, _cleanup_helper.clearGlobalCaches)();
      }
      se (cancelXHRs) {
        cancelXHRs(new _util.AbortException("Il lavoratore è stato licenziato."));
      }
      per (attività costante di WorkerTasks) {
        waitOn.push(attività.finita);
        compito.termina();
      }
      restituisci Promise.all(waitOn).then(function () {
        gestore.distruggi();
        gestore = null;
      });
    });
    handler.on("Pronto", funzione (dati) {
      setupDoc(docParams);
      docParams = null;
    });
    restituisci workerHandlerName;
  }
  static initializeFromPort(porta) {
    const handler = new _message_handler.MessageHandler("worker", "main", port);
    WorkerMessageHandler.setup(gestore, porta);
    handler.send("pronto", null);
  }
}
esportazioni.WorkerMessageHandler = WorkerMessageHandler;
funzione isMessagePort(maybePort) {
  restituisci il tipo di maybePort.postMessage === "funzione" && "onmessage" in maybePort;
}
se (tipo di finestra === "non definito" && !_util.isNodeJS && tipo di sé !== "non definito" && isMessagePort(self)) {
  WorkerMessageHandler.initializeFromPort(self);
}

/***/ }),
/* 2 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
exports.VerbosityLevel = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.TextRenderingMode = exports.RenderingIntentFlag = exports.PromiseCapability = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.MAX_IMAGE_SIZE_TO_CACHE = exports.LINE_FACTOR = exports.LINE_DESCENT_FACTOR = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FeatureTest = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.CMapCompressionType = exports.BaseException = exports.BASELINE_FACTOR = exports.AnnotationType = exports.AnnotationReplyType = exports.AnnotationPrefix = exports.AnnotationMode = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationEditorType = exports.AnnotationEditorPrefix = exports.AnnotationEditorParamsType = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0;
esportazioni.asserzione = asserzione;
esportazioni.bytesToString = bytesToString;
esportazioni.createValidAbsoluteUrl = createValidAbsoluteUrl;
exports.getModificationDate = getModificationDate;
esportazioni.getUuid = getUuid;
esportazioni.getVerbosityLevel = getVerbosityLevel;
exports.info = informazioni;
esportazioni.isArrayBuffer = isArrayBuffer;
esportazioni.isArrayEqual = isArrayEqual;
esportazioni.isNodeJS = void 0;
esportazioni.normalizeUnicode = normalizeUnicode;
esportazioni.objectFromMap = objectFromMap;
esportazioni.objectSize = objectSize;
esportazioni.setVerbosityLevel = setVerbosityLevel;
esportazioni.ombra = ombra;
esportazioni.string32 = string32;
esportazioni.stringToBytes = stringToBytes;
esportazioni.stringToPDFString = stringToPDFString;
esportazioni.stringToUTF8String = stringToUTF8String;
exports.unreachable = irraggiungibile;
esportazioni.utf8StringToString = utf8StringToString;
exports.warn = avvisa;
const isNodeJS = typeof process === "oggetto" && processo + "" === "[oggetto processo]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
esportazioni.isNodeJS = isNodeJS;
const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
esportazioni.IDENTITY_MATRIX = IDENTITY_MATRIX;
const FONT_IDENTITY_MATRIX = [0,001, 0, 0, 0,001, 0, 0];
esportazioni.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
const MAX_IMAGE_SIZE_TO_CACHE = 10e6;
esportazioni.MAX_IMAGE_SIZE_TO_CACHE = MAX_IMAGE_SIZE_TO_CACHE;
const LINE_FACTOR = 1.35;
esportazioni.LINE_FACTOR = LINE_FACTOR;
const FATTORE_DI_discesa_LINEA = 0,35;
esportazioni.LINE_DESCENT_FACTOR = LINE_DESCENT_FACTOR;
const BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;
esportazioni.BASELINE_FACTOR = BASELINE_FACTOR;
const RenderingIntentFlag = {
  QUALSIASI: 0x01,
  VISUALIZZAZIONE: 0x02,
  STAMPA: 0x04,
  SALVA: 0x08,
  ANNOTAZIONI_FORM: 0x10,
  ANNOTAZIONI_ARCHIVIAZIONE: 0x20,
  ANNOTATIONS_DISABLE: 0x40,
  OPLIST: 0x100
};
esportazioni.RenderingIntentFlag = RenderingIntentFlag;
const AnnotationMode = {
  DISABILITA: 0,
  ABILITA: 1,
  ABILITA_FORME: 2,
  ABILITA_ARCHIVIAZIONE: 3
};
exports.AnnotationMode = AnnotationMode;
const AnnotationEditorPrefix = "pdfjs_internal_editor_";
esportazioni.AnnotationEditorPrefix = AnnotationEditorPrefix;
const AnnotationEditorType = {
  DISABILITA: -1,
  NESSUNO: 0,
  TESTO LIBERO: 3,
  FRANCOBOLLO: 13,
  INCHIOSTRO: 15
};
esportazioni.AnnotationEditorType = AnnotationEditorType;
const AnnotationEditorParamsType = {
  RIDIMENSIONA: 1,
  CREA: 2,
  DIMENSIONE_TESTO LIBERO: 11,
  COLORE_TESTO_GRATIS: 12,
  OPACITÀ DEL TESTO LIBERO: 13,
  COLORE INCHIOSTRO: 21,
  SPESSORE INCHIOSTRO: 22,
  INK_OPACITY: 23
};
esportazioni.AnnotationEditorParamsType = AnnotationEditorParamsType;
const PermissionFlag = {
  STAMPA: 0x04,
  MODIFICA_CONTENUTO: 0x08,
  COPIA: 0x10,
  MODIFICA_ANNOTAZIONI: 0x20,
  COMPILA_MODULI_INTERATTIVI: 0x100,
  COPIA_PER_ACCESSIBILITÀ: 0x200,
  ASSEMBLAGGIO: 0x400,
  STAMPA_ALTA_QUALITÀ: 0x800
};
esportazioni.PermissionFlag = PermissionFlag;
const TextRenderingMode = {
  RIEMPIMENTO: 0,
  CORSA: 1,
  FILL_STROKE: 2,
  INVISIBILE: 3,
  FILL_ADD_TO_PATH: 4,
  STROKE_ADD_TO_PATH: 5,
  FILL_STROKE_AGGIUNGI_AL_PERCORSO: 6,
  AGGIUNGI AL PERCORSO: 7,
  FILL_STROKE_MASK: 3,
  AGGIUNGI_AL_FLAG_DEL_PERCORSO: 4
};
esportazioni.TextRenderingMode = TextRenderingMode;
const TipoImmagine = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
};
esportazioni.ImageKind = ImmagineKind;
const Tipo di annotazione = {
  TESTO 1,
  COLLEGAMENTO: 2,
  TESTO LIBERO: 3,
  LINEA: 4,
  QUADRATO: 5,
  CERCHIO: 6,
  POLIGONO: 7,
  POLILINEA: 8,
  IN EVIDENZA: 9,
  SOTTOLINEARE: 10,
  SQUIGGLY: 11,
  STRIKEOUT: 12,
  FRANCOBOLLO: 13,
  ACCENTO: 14,
  INCHIOSTRO: 15,
  POPUP: 16,
  FILEALLEGATO: 17,
  SUONO: 18,
  FILM: 19,
  WIDGET: 20,
  SCHERMO: 21,
  SEGNO DI STAMPA: 22,
  TRAPPOLA: 23,
  FILIGRANA: 24,
  TRE: 25,
  REDATTO: 26
};
esportazioni.AnnotationType = AnnotationType;
const AnnotationReplyType = {
  GRUPPO: "Gruppo",
  RISPOSTA: "R"
};
esportazioni.AnnotationReplyType = AnnotationReplyType;
const AnnotationFlag = {
  INVISIBILE: 0x01,
  NASCOSTO: 0x02,
  STAMPA: 0x04,
  NOZOOM: 0x08,
  NOROTATE: 0x10,
  NESSUNA VISUALIZZAZIONE: 0x20,
  SOLA LETTURA: 0x40,
  BLOCCATO: 0x80,
  TOGGLENOVIEW: 0x100,
  CONTENUTI BLOCCATI: 0x200
};
esportazioni.AnnotationFlag = AnnotationFlag;
const AnnotationFieldFlag = {
  SOLA LETTURA: 0x0000001,
  OBBLIGATORIO: 0x0000002,
  NOEXPORT: 0x0000004,
  MULTILINEA: 0x0001000,
  PASSWORD: 0x0002000,
  NOTOGGLETOOFF: 0x0004000,
  RADIO: 0x0008000,
  PULSANTE: 0x0010000,
  COMBO: 0x0020000,
  MODIFICA: 0x0040000,
  ORDINA: 0x0080000,
  SELEZIONA FILE: 0x0100000,
  SELEZIONE MULTIPLA: 0x0200000,
  NON ESEGUIRE IL CONTROLLO ORTOGRAFICO: 0x0400000,
  DONOTSCROLL: 0x0800000,
  PETTINE: 0x1000000,
  RICHTEXT: 0x2000000,
  RADIOSINUNISON: 0x2000000,
  COMMITTONSELCHANGE: 0x4000000
};
esportazioni.AnnotationFieldFlag = AnnotationFieldFlag;
const AnnotationBorderStyleType = {
  SOLIDO: 1,
  TRATTEGGIATO: 2,
  SMUSSATO: 3,
  RIQUADRO: 4,
  SOTTOLINEARE: 5
};
esportazioni.AnnotationBorderStyleType = AnnotationBorderStyleType;
const AnnotationActionEventType = {
  E: "Invio del mouse",
  X: "Uscita del mouse",
  D: "Mouse giù",
  U: "Mouse su",
  Fo: "Concentrarsi",
  Bl: "Sfocatura",
  PO: "Pagina aperta",
  PC: "ChiudiPagina",
  PV: "Pagina visibile",
  PI: "PaginaInvisibile",
  K: "Battitura di tasti",
  F: "Formato",
  V: "Convalida",
  C: "Calcola"
};
esportazioni.AnnotationActionEventType = AnnotationActionEventType;
const DocumentActionEventType = {
  WC: "WillClose",
  WS: "Salverà",
  DS: "DidSave",
  WP: "WillPrint",
  DP: "DidPrint"
};
esportazioni.DocumentActionEventType = DocumentActionEventType;
const PageActionEventType = {
  O: "Pagina aperta",
  C: "ChiudiPagina"
};
esportazioni.PageActionEventType = PageActionEventType;
const Livello di Verbosità = {
  ERRORI: 0,
  AVVERTENZE: 1,
  INFORMAZIONI: 5
};
esportazioni.Livello di verbosità = Livello di verbosità;
const CMapCompressionType = {
  NESSUNO: 0,
  BINARIO: 1
};
esportazioni.CMapCompressionType = CMapCompressionType;
const OPS = {
  dipendenza: 1,
  imposta larghezza riga: 2,
  setLineCap: 3,
  setLineJoin: 4,
  impostaMiterLimit: 5,
  imposta trattino: 6,
  impostaRenderingIntent: 7,
  setPlaneità: 8,
  impostaGState: 9,
  risparmia: 10,
  ripristinare: 11,
  trasformare: 12,
  sposta a: 13,
  lineaA: 14,
  curvaA: 15,
  curveTo2: 16,
  curveTo3: 17,
  chiudiPercorso: 18,
  rettangolo: 19,
  ictus: 20,
  chiudiColpo: 21,
  riempimento: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  chiudiFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  inizioTesto: 31,
  fineTesto: 32,
  imposta spaziatura caratteri: 33,
  impostaSpaziaturaParole: 34,
  setHScale: 35,
  setLeading: 36,
  impostaFont: 37,
  imposta la modalità di rendering del testo: 38,
  impostaAumentoTesto: 39,
  spostaTesto: 40,
  setLeadingMoveText: 41,
  impostaMatriceTesto: 42,
  riga successiva: 43,
  mostraTesto: 44,
  mostraTesto distanziato: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  impostaCarattereLarghezza: 48,
  imposta larghezza carattere e limiti: 49,
  impostaStrokeColorSpace: 50,
  impostaFillColorSpace: 51,
  impostaColoreTratto: 52,
  setStrokeColorN: 53,
  imposta colore di riempimento: 54,
  impostaFillColorN: 55,
  setStrokeGray: 56,
  impostaFillGray: 57,
  impostaStrokeRGBColor: 58,
  impostaRiempimentoRGBColore: 59,
  setStrokeCMYKColor: 60,
  impostaFillCMYKColor: 61,
  ombreggiaturaRiempimento: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  Punto di riferimento: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  gruppo finale: 77,
  inizioAnnotazione: 80,
  endAnnotation: 81,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  Percorso di costruzione: 91
};
esportazioni.OPS = OPS;
const Risposte alla password = {
  PASSWORD NECESSARIA: 1,
  PASSWORD_ERRATA: 2
};
esportazioni.PasswordResponses = PasswordResponses;
lascia che verbosità = VerbosityLevel.WARNINGS;
funzione setVerbosityLevel(livello) {
  se (Numero.èIntero(livello)) {
    verbosità = livello;
  }
}
funzione getVerbosityLevel() {
  restituire verbosità;
}
funzione info(msg) {
  se (verbosità >= VerbosityLevel.INFOS) {
    console.log(`Informazioni: ${msg}`);
  }
}
funzione warn(msg) {
  se (verbosità >= VerbosityLevel.WARNINGS) {
    console.log(`Avviso: ${msg}`);
  }
}
funzione irraggiungibile(msg) {
  lancia un nuovo errore (msg);
}
funzione assert(cond, msg) {
  se (!cond) {
    irraggiungibile(msg);
  }
}
funzione _isValidProtocol(url) {
  switch (url?.protocollo) {
    caso "http:":
    caso "https:":
    caso "ftp:":
    caso "mailto:":
    caso "tel:":
      restituisci vero;
    predefinito:
      restituisci falso;
  }
}
funzione createValidAbsoluteUrl(url, baseUrl = null, opzioni = null) {
  se (!url) {
    restituisci null;
  }
  Tentativo {
    se (opzioni e tipo di URL === "stringa") {
      se (opzioni.aggiungiProtocolloPredefinito && url.avviaCon("www.")) {
        const dots = url.match(/\./g);
        se (punti?.lunghezza >= 2) {
          url = `http://${url}`;
        }
      }
      se (opzioni.tryConvertEncoding) {
        Tentativo {
          url = stringToUTF8String(url);
        } presa {}
      }
    }
    const absoluteUrl = baseUrl ? nuovo URL(url, baseUrl) : nuovo URL(url);
    se (_isValidProtocol(absoluteUrl)) {
      restituisci URL assoluto;
    }
  } presa {}
  restituisci null;
}
funzione shadow(obj, prop, valore, nonSerializable = false) {
  Object.defineProperty(obj, prop, {
    valore,
    enumerabile: !nonSerializable,
    configurabile: vero,
    scrivibile: falso
  });
  valore di ritorno;
}
const BaseException = funzione BaseExceptionClosure() {
  funzione BaseException(messaggio, nome) {
    se (questo.costruttore === BaseException) {
      unreachable("Impossibile inizializzare BaseException.");
    }
    this.message = messaggio;
    questo.nome = nome;
  }
  BaseException.prototype = nuovo Errore();
  BaseException.constructor = BaseException;
  restituisci BaseException;
}();
esportazioni.BaseException = BaseException;
classe PasswordException estende BaseException {
  costruttore(msg, codice) {
    super(msg, "PasswordException");
    questo.codice = codice;
  }
}
esportazioni.PasswordException = PasswordException;
classe UnknownErrorException estende BaseException {
  costruttore(msg, dettagli) {
    super(msg, "UnknownErrorException");
    this.details = dettagli;
  }
}
esportazioni.UnknownErrorException = UnknownErrorException;
classe InvalidPDFException estende BaseException {
  costruttore(msg) {
    super(msg, "InvalidPDFException");
  }
}
esportazioni.InvalidPDFException = InvalidPDFException;
classe MissingPDFException estende BaseException {
  costruttore(msg) {
    super(msg, "MissingPDFException");
  }
}
esportazioni.MissingPDFException = MissingPDFException;
classe UnexpectedResponseException estende BaseException {
  costruttore(msg, stato) {
    super(msg, "UnexpectedResponseException");
    questo.stato = stato;
  }
}
esportazioni.UnexpectedResponseException = UnexpectedResponseException;
classe FormatError estende BaseException {
  costruttore(msg) {
    super(msg, "Errore di formato");
  }
}
esportazioni.FormatError = FormatError;
classe AbortException estende BaseException {
  costruttore(msg) {
    super(msg, "AbortException");
  }
}
esportazioni.AbortException = AbortException;
funzione bytesToString(byte) {
  se (tipo di byte !== "oggetto" || byte?.lunghezza === indefinito) {
    unreachable("Argomento non valido per bytesToString");
  }
  lunghezza costante = byte.lunghezza;
  const MAX_ARGUMENT_COUNT = 8192;
  se (lunghezza < MAX_ARGUMENT_COUNT) {
    restituisci String.fromCharCode.apply(null, byte);
  }
  const strBuf = [];
  per (lascia che i = 0; i < lunghezza; i += MAX_ARGUMENT_COUNT) {
    const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, lunghezza);
    const chunk = bytes.subarray(i, chunkEnd);
    strBuf.push(String.fromCharCode.apply(null, chunk));
  }
  restituisci strBuf.join("");
}
funzione stringToBytes(str) {
  se (tipo di str !== "stringa") {
    unreachable("Argomento non valido per stringToBytes");
  }
  lunghezza costante = str.length;
  const byte = new Uint8Array(lunghezza);
  per (lascia che i = 0; i < lunghezza; ++i) {
    byte[i] = str.charCodeAt(i) & 0xff;
  }
  restituire byte;
}
funzione string32(valore) {
  return String.fromCharCode(valore >> 24 & 0xff, valore >> 16 & 0xff, valore >> 8 & 0xff, valore & 0xff);
}
funzione objectSize(obj) {
  restituisci Object.keys(obj).length;
}
funzione objectFromMap(mappa) {
  const obj = Object.create(null);
  per (const [chiave, valore] della mappa) {
    obj[chiave] = valore;
  }
  restituisci oggetto;
}
funzione isLittleEndian() {
  const buffer8 = new Uint8Array(4);
  buffer8[0] = 1;
  const view32 = new Uint32Array(buffer8.buffer, 0, 1);
  torna view32[0] === 1;
}
funzione isEvalSupported() {
  Tentativo {
    nuova funzione("");
    restituisci vero;
  } presa {
    restituisci falso;
  }
}
classe FeatureTest {
  static get isLittleEndian() {
    return shadow(questo, "isLittleEndian", isLittleEndian());
  }
  static get isEvalSupported() {
    restituisci shadow(questo, "isEvalSupported", isEvalSupported());
  }
  static get isOffscreenCanvasSupported() {
    return shadow(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas !== "undefined");
  }
  piattaforma statica get() {
    se (tipo di navigatore === "non definito") {
      restituisci shadow(questo, "piattaforma", {
        isWin: falso,
        isMac: falso
      });
    }
    restituisci shadow(questo, "piattaforma", {
      isWin: navigator.platform.includes("Win"),
      isMac: navigator.platform.includes("Mac")
    });
  }
  static get isCSSRoundSupported() {
    return shadow(this, "isCSSSroundSupported", globalThis.CSS?.supports?.("width: round(1.5px, 1px)"));
  }
}
esportazioni.FeatureTest = FeatureTest;
const hexNumbers = [...Array(256).keys()].map(n => n.toString(16).padStart(2, "0"));
classe Util {
  statico makeHexColor(r, g, b) {
    restituisci `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;
  }
  scala staticaMinMax(trasforma, minMax) {
    lasciare la temperatura;
    se (trasforma[0]) {
      se (trasforma[0] < 0) {
        temperatura = minMax[0];
        minMax[0] = minMax[1];
        minMax[1] = temperatura;
      }
      minMax[0] *= trasforma[0];
      minMax[1] *= trasforma[0];
      se (trasforma[3] < 0) {
        temperatura = minMax[2];
        minMax[2] = minMax[3];
        minMax[3] = temperatura;
      }
      minMax[2] *= trasforma[3];
      minMax[3] *= trasforma[3];
    } altro {
      temperatura = minMax[0];
      minMax[0] = minMax[2];
      minMax[2] = temperatura;
      temperatura = minMax[1];
      minMax[1] = minMax[3];
      minMax[3] = temperatura;
      se (trasforma[1] < 0) {
        temperatura = minMax[2];
        minMax[2] = minMax[3];
        minMax[3] = temperatura;
      }
      minMax[2] *= trasforma[1];
      minMax[3] *= trasforma[1];
      se (trasforma[2] < 0) {
        temperatura = minMax[0];
        minMax[0] = minMax[1];
        minMax[1] = temperatura;
      }
      minMax[0] *= trasforma[2];
      minMax[1] *= trasforma[2];
    }
    minMax[0] += trasforma[4];
    minMax[1] += trasforma[4];
    minMax[2] += trasforma[5];
    minMax[3] += trasforma[5];
  }
  trasformata statica(m1, m2) {
    ritorno [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
  }
  statico applicaTrasforma(p, m) {
    costante xt = p[0] * m[0] + p[1] * m[2] + m[4];
    costante yt = p[0] * m[1] + p[1] * m[3] + m[5];
    ritorno [xt, yt];
  }
  statico applicaInversaTrasformazione(p, m) {
    costante d = m[0] * m[3] - m[1] * m[2];
    costante xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
    costante yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
    ritorno [xt, yt];
  }
  getAxialAlignedBoundingBox statico(r, m) {
    const p1 = this.applyTransform(r, m);
    const p2 = this.applyTransform(r.slice(2, 4), m);
    const p3 = this.applyTransform([r[0], r[3]], m);
    const p4 = this.applyTransform([r[2], r[1]], m);
    ritorno [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
  }
  Trasformazione inversa statica(m) {
    costante d = m[0] * m[3] - m[1] * m[2];
    ritorna [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
  }
  static singularValueDecompose2dScale(m) {
    const trasposizione = [m[0], m[2], m[1], m[3]];
    const a = m[0] * trasponi[0] + m[1] * trasponi[2];
    const b = m[0] * trasponi[1] + m[1] * trasponi[3];
    const c = m[2] * trasponi[0] + m[3] * trasponi[2];
    const d = m[2] * trasponi[1] + m[3] * trasponi[3];
    const primo = (a + d) / 2;
    const secondo = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;
    const sx = primo + secondo || 1;
    const sy = primo - secondo || 1;
    return [Math.sqrt(sx), Math.sqrt(sy)];
  }
  statico normalizeRect(rect) {
    const r = rect.slice(0);
    se (rect[0] > rect[2]) {
      r[0] = rettangolo[2];
      r[2] = rettangolo[0];
    }
    se (rett[1] > rect[3]) {
      r[1] = rettangolo[3];
      r[3] = rettangolo[1];
    }
    restituisci r;
  }
  intersezione statica(rect1, rect2) {
    const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));
    const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));
    se (xBasso > xAlto) {
      restituisci null;
    }
    const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));
    const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));
    se (yBasso > yAlto) {
      restituisci null;
    }
    ritorno [xBasso, yBasso, xAlto, yAlto];
  }
  static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {
    valori costanti = [],
      limiti = [[], []];
    siano a, b, c, t, t1, t2, b2ac, sqrtb2ac;
    per (lascia che i = 0; i < 2; ++i) {
      se (i === 0) {
        b = 6 * x0 - 12 * x1 + 6 * x2;
        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
        c = 3 * x1 - 3 * x0;
      } altro {
        b = 6 * y0 - 12 * y1 + 6 * y2;
        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
        c = 3 * y1 - 3 * y0;
      }
      se (Math.abs(a) < 1e-12) {
        se (Math.abs(b) < 1e-12) {
          continuare;
        }
        t = -c / b;
        se (0 < t && t < 1) {
          valori t.push(t);
        }
        continuare;
      }
      b2ac = b * b - 4 * c * a;
      sqrtb2ac = Math.sqrt(b2ac);
      se (b2ac < 0) {
        continuare;
      }
      t1 = (-b + sqrtb2ac) / (2 * a);
      se (0 < t1 && t1 < 1) {
        valori t.push(t1);
      }
      t2 = (-b - sqrtb2ac) / (2 * a);
      se (0 < t2 && t2 < 1) {
        valori t.push(t2);
      }
    }
    lascia j = tvalues.length,
      mt;
    const jlen = j;
    mentre (j--) {
      t = tvalori[j];
      mt = 1 - t;
      limiti[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
      limiti[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
    }
    limiti[0][jlen] = x0;
    limiti[1][jlen] = y0;
    limiti[0][jlen + 1] = x3;
    limiti[1][jlen + 1] = y3;
    limiti[0].lunghezza = limiti[1].lunghezza = jlen + 2;
    restituisci [Math.min(...limiti[0]), Math.min(...limiti[1]), Math.max(...limiti[0]), Math.max(...limiti[1])];
  }
}
esportazioni.Util = Util;
const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8, 0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018, 0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d, 0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac];
funzione stringToPDFString(str) {
  se (str[0] >= "\xEF") {
    lascia codifica;
    se (str[0] === "\xFE" && str[1] === "\xFF") {
      codifica = "utf-16be";
    } altrimenti se (str[0] === "\xFF" && str[1] === "\xFE") {
      codifica = "utf-16le";
    } altrimenti se (str[0] === "\xEF" && str[1] === "\xBB" && str[2] === "\xBF") {
      codifica = "utf-8";
    }
    se (codifica) {
      Tentativo {
        const decoder = new TextDecoder(codifica, {
          fatale: vero
        });
        const buffer = stringToBytes(str);
        restituisci decoder.decode(buffer);
      } catturare (es.) {
        warn(`stringToPDFString: "${ex}".`);
      }
    }
  }
  const strBuf = [];
  per (lascia che i = 0, ii = str.length; i < ii; i++) {
    codice costante = PDFStringTranslateTable[str.charCodeAt(i)];
    strBuf.push(codice ? String.fromCharCode(codice) : str.charAt(i));
  }
  restituisci strBuf.join("");
}
funzione stringToUTF8String(str) {
  restituisci decodeURIComponent(escape(str));
}
funzione utf8StringToString(str) {
  restituisci unescape(encodeURIComponent(str));
}
funzione isArrayBuffer(v) {
  restituisci tipo di v === "oggetto" && v?.byteLength !== indefinito;
}
funzione èArrayEqual(arr1, arr2) {
  se (arr1.length !== arr2.length) {
    restituisci falso;
  }
  per (lascia che i = 0, ii = arr1.length; i < ii; i++) {
    se (arr1[i] !== arr2[i]) {
      restituisci falso;
    }
  }
  restituisci vero;
}
funzione getModificationDate(data = nuova data()) {
  const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
  restituisci buffer.join("");
}
classe PromiseCapability {
  #sistemato = falso;
  costruttore() {
    this.promise = new Promise((resolve, reject) => {
      questo.risolvere = dati => {
        questo.#sistemato = vero;
        risolvere(dati);
      };
      this.reject = motivo => {
        questo.#sistemato = vero;
        rifiutare(motivo);
      };
    });
  }
  sistemarsi() {
    restituisci questo.#sistemato;
  }
}
esportazioni.PromiseCapability = PromiseCapability;
lascia NormalizeRegex = null;
lascia NormalizationMap = null;
funzione normalizzaUnicode(str) {
  se (!NormalizeRegex) {
    NormalizeRegex = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\uf bb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\u fcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu;
    NormalizationMap = new Map([["f", "ſt"]]);
  }
  restituisci str.replaceAll(NormalizeRegex, (_, p1, p2) => {
    restituisci p1 ? p1.normalize("NFKC") : NormalizationMap.get(p2);
  });
}
funzione getUuid() {
  if (typeof crypto !== "undefined" && typeof crypto?.randomUUID === "function") {
    restituisci crypto.randomUUID();
  }
  const buf = new Uint8Array(32);
  if (typeof crypto !== "undefined" && typeof crypto?.getRandomValues ​​=== "function") {
    crypto.getRandomValues(buf);
  } altro {
    per (lascia che i = 0; i < 32; i++) {
      buf[i] = Math.floor(Math.random() * 255);
    }
  }
  restituisci bytesToString(buf);
}
const AnnotationPrefix = "pdfjs_internal_id_";
esportazioni.AnnotationPrefix = AnnotationPrefix;

/***/ }),
/* 3 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.XRefParseException = esportazioni.XRefEntryException = esportazioni.ParserEOFException = esportazioni.PDF_VERSION_REGEXP = esportazioni.MissingDataException = void 0;
esportazioni.arrayBuffersToBytes = arrayBuffersToBytes;
esportazioni.raccogliAzioni = raccogliAzioni;
esportazioni.encodeToXmlString = encodeToXmlString;
esportazioni.escapePDFName = escapePDFName;
esportazioni.escapeString = escapeString;
esportazioni.getInheritableProperty = getInheritableProperty;
esportazioni.getLookupTableFactory = getLookupTableFactory;
esportazioni.getNewAnnotationsMap = getNewAnnotationsMap;
esportazioni.getRotationMatrix = getRotationMatrix;
esportazioni.isAscii = isAscii;
esportazioni.isWhiteSpace = isWhiteSpace;
esportazioni.log2 = log2;
esportazioni.numeroInStringa = numeroInStringa;
esportazioni.parseXFAPath = parseXFAPath;
esportazioni.readInt8 = readInt8;
esportazioni.readUint16 = readUint16;
esportazioni.readUint32 = readUint32;
esportazioni.recoverJsURL = recoverJsURL;
esportazioni.stringToUTF16HexString = stringToUTF16HexString;
esportazioni.stringToUTF16String = stringToUTF16String;
exports.toRomanNumerals = toRomanNumerals;
esportazioni.validateCSSFont = validateCSSFont;
esportazioni.validateFontName = validateFontName;
var _util = __w_pdfjs_require__(2);
var _primitives = __w_pdfjs_require__(4);
var _base_stream = __w_pdfjs_require__(5);
const PDF_VERSION_REGEXP = /^[1-9]\.\d$/;
esportazioni.PDF_VERSION_REGEXP = PDF_VERSION_REGEXP;
funzione getLookupTableFactory(inizializzatore) {
  lascia cercare;
  funzione di ritorno () {
    se (inizializzatore) {
      ricerca = Object.create(null);
      inizializzatore(ricerca);
      inizializzatore = null;
    }
    ricerca di ritorno;
  };
}
classe MissingDataException estende _util.BaseException {
  costruttore(inizio, fine) {
    super(`Dati mancanti [${begin}, ${end})`, "MissingDataException");
    questo.inizio = inizio;
    questo.fine = fine;
  }
}
esportazioni.MissingDataException = MissingDataException;
classe ParserEOFException estende _util.BaseException {
  costruttore(msg) {
    super(msg, "ParserEOFException");
  }
}
esportazioni.ParserEOFException = ParserEOFException;
classe XRefEntryException estende _util.BaseException {
  costruttore(msg) {
    super(msg, "XRefEntryException");
  }
}
esportazioni.XRefEntryException = XRefEntryException;
classe XRefParseException estende _util.BaseException {
  costruttore(msg) {
    super(msg, "XRefParseException");
  }
}
esportazioni.XRefParseException = XRefParseException;
funzione arrayBuffersToBytes(arr) {
  lunghezza costante = lunghezza arr.;
  se (lunghezza === 0) {
    restituisci nuovo Uint8Array(0);
  }
  se (lunghezza === 1) {
    restituisci nuovo Uint8Array(arr[0]);
  }
  lascia dataLength = 0;
  per (lascia che i = 0; i < lunghezza; i++) {
    lunghezzadati += arr[i].lunghezzabyte;
  }
  const data = new Uint8Array(dataLength);
  lascia pos = 0;
  per (lascia che i = 0; i < lunghezza; i++) {
    elemento costante = nuovo Uint8Array(arr[i]);
    data.set(elemento, pos);
    pos += item.byteLength;
  }
  restituire i dati;
}
funzione getInheritableProperty({
  dizionario,
  chiave,
  getArray = falso,
  stopWhenFound = true
}) {
  lascia i valori;
  const visitato = new _primitives.RefSet();
  while (dict instanceof _primitives.Dict && !(dict.objId && visited.has(dict.objId))) {
    se (dict.objId) {
      visitato.put(dict.objId);
    }
    valore costante = getArray ? dict.getArray(chiave) : dict.get(chiave);
    se (valore !== indefinito) {
      se (stopQuandoTrovato) {
        valore di ritorno;
      }
      (valori ||= []).push(valore);
    }
    dict = dict.get("Genitore");
  }
  valori di ritorno;
}
const ROMAN_NUMBER_MAP = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
funzione toRomanNumerals(numero, minuscolo = falso) {
  (0, _util.assert)(Number.isInteger(number) && number > 0, "Il numero deve essere un numero intero positivo.");
  const romanBuf = [];
  lascia pos;
  mentre (numero >= 1000) {
    numero -= 1000;
    romanBuf.push("M");
  }
  pos = numero / 100 | 0;
  numero %= 100;
  romanBuf.push(ROMAN_NUMBER_MAP[pos]);
  pos = numero / 10 | 0;
  numero %= 10;
  romanBuf.push(ROMAN_NUMBER_MAP[10 + pos]);
  romanBuf.push(ROMAN_NUMBER_MAP[20 + numero]);
  const romanStr = romanBuf.join("");
  restituisci minuscolo? romanStr.toLowerCase() : romanStr;
}
funzione log2(x) {
  se (x <= 0) {
    restituisci 0;
  }
  restituisci Math.ceil(Math.log2(x));
}
funzione readInt8(dati, offset) {
  restituisci dati[offset] << 24 >> 24;
}
funzione readUint16(dati, offset) {
  restituisci dati[offset] << 8 | dati[offset + 1];
}
funzione readUint32(dati, offset) {
  ritorno (dati[offset] << 24 | dati[offset + 1] << 16 | dati[offset + 2] << 8 | dati[offset + 3]) >>> 0;
}
funzione isWhiteSpace(ch) {
  ritorna ch === 0x20 || ch === 0x09 || ch === 0x0d || ch === 0x0a;
}
funzione parseXFAPath(percorso) {
  const positionPattern = /(.+)\[(\d+)\]$/;
  restituisci percorso.split(".").map(componente => {
    const m = componente.match(posizionePattern);
    se (m) {
      ritorno {
        nome: m[1],
        posizione: analizzaInt(m[2], 10)
      };
    }
    ritorno {
      nome: componente,
      posizione: 0
    };
  });
}
funzione escapePDFName(str) {
  buffer costante = [];
  lascia inizio = 0;
  per (lascia che i = 0, ii = str.length; i < ii; i++) {
    const char = str.charCodeAt(i);
    se (char < 0x21 || char > 0x7e || char === 0x23 || char === 0x28 || char === 0x29 || char === 0x3c || char === 0x3e || char === 0x5b || char === 0x5d || char === 0x7b || char === 0x7d || char === 0x2f || char === 0x25) {
      se (inizio < i) {
        buffer.push(str.substring(inizio, i));
      }
      buffer.push(`#${char.toString(16)}`);
      inizio = i + 1;
    }
  }
  se (lunghezza buffer === 0) {
    ritorno str;
  }
  se (inizio < lunghezza str) {
    buffer.push(str.substring(inizio, str.length));
  }
  restituisci buffer.join("");
}
funzione escapeString(str) {
  restituisci str.replaceAll(/([()\\\n\r])/g, corrispondenza => {
    se (corrispondenza === "\n") {
      restituisci "\\n";
    } altrimenti se (corrispondenza === "\r") {
      restituisci "\\r";
    }
    restituisci `\\${match}`;
  });
}
funzione _collectJS(voce, riferimento esterno, elenco, genitori) {
  se (!voce) {
    ritorno;
  }
  lascia che il genitore = null;
  se (istanza di voce _primitives.Ref) {
    se (genitori.has(voce)) {
      ritorno;
    }
    genitore = voce;
    genitori.metti(genitore);
    voce = xref.fetch(voce);
  }
  se (Array.isArray(voce)) {
    per (elemento costante della voce) {
      _collectJS(elemento, xrif, elenco, genitori);
    }
  } altrimenti se (istanza di voce _primitives.Dict) {
    se ((0, _primitives.isName)(entry.get("S"), "JavaScript")) {
      const js = entry.get("JS");
      lascia il codice;
      se (istanza js di _base_stream.BaseStream) {
        codice = js.getString();
      } altrimenti se (tipo js === "stringa") {
        codice = js;
      }
      codice &&= (0, _util.stringToPDFString)(codice).replaceAll("\x00", "");
      se (codice) {
        list.push(codice);
      }
    }
    _collectJS(entry.getRaw("Successivo"), xref, elenco, genitori);
  }
  se (genitore) {
    genitori.rimuovi(genitore);
  }
}
funzione collectActions(xref, dict, eventType) {
  azioni costanti = Object.create(null);
  const additionalActionsDicts = getInheritableProperty({
    dizionario,
    chiave: "AA",
    stopWhenFound: falso
  });
  se (AdditionalActionsDicts) {
    per (lascia che i = additionalActionsDicts.length - 1; i >= 0; i--) {
      const azioniaggiuntive = azioniaggiuntiveDicts[i];
      se (!(additionalActions instanceof _primitives.Dict)) {
        continuare;
      }
      per (const chiave di additionalActions.getKeys()) {
        azione costante = tipoevento[chiave];
        se (!azione) {
          continuare;
        }
        const actionDict = additionalActions.getRaw(key);
        const genitori = new _primitives.RefSet();
        elenco costante = [];
        _collectJS(actionDict, xref, list, parents);
        se (lunghezza elenco > 0) {
          azioni[azione] = elenco;
        }
      }
    }
  }
  se (dict.has("A")) {
    const actionDict = dict.get("A");
    const genitori = new _primitives.RefSet();
    elenco costante = [];
    _collectJS(actionDict, xref, list, parents);
    se (lunghezza elenco > 0) {
      azioni.Azione = elenco;
    }
  }
  return (0, _util.objectSize)(azioni) > 0 ? azioni : null;
}
const XMLEntities = {
  0x3c: "<",
  0x3e: ">",
  0x26: "&",
  0x22: """,
  0x27: "'"
};
funzione encodeToXmlString(str) {
  buffer costante = [];
  lascia inizio = 0;
  per (lascia che i = 0, ii = str.length; i < ii; i++) {
    const char = str.codePointAt(i);
    se (0x20 <= carattere && carattere <= 0x7e) {
      const entity = XMLEntities[char];
      se (entità) {
        se (inizio < i) {
          buffer.push(str.substring(inizio, i));
        }
        buffer.push(entità);
        inizio = i + 1;
      }
    } altro {
      se (inizio < i) {
        buffer.push(str.substring(inizio, i));
      }
      buffer.push(`&#x${char.toString(16).toUpperCase()};`);
      se (char > 0xd7ff && (char < 0xe000 || char > 0xfffd)) {
        i++;
      }
      inizio = i + 1;
    }
  }
  se (lunghezza buffer === 0) {
    ritorno str;
  }
  se (inizio < lunghezza str) {
    buffer.push(str.substring(inizio, str.length));
  }
  restituisci buffer.join("");
}
funzione validateFontName(fontFamily, mustWarn = false) {
  const m = /^("|').*("|')$/.exec(fontFamily);
  se (m && m[1] === m[2]) {
    const re = new RegExp(`[^\\\\]${m[1]}`);
    se (re.test(fontFamily.slice(1, -1))) {
      se (deveAvvisare) {
        (0, _util.warn)(`FontFamily contiene ${m[1]} non sottoposto a escape: ${fontFamily}.`);
      }
      restituisci falso;
    }
  } altro {
    per (costante ident di fontFamily.split(/[ \t]+/)) {
      se (/^(\d|(-(\d|-)))/.test(ident) || !/^[\w-\\]+$/.test(ident)) {
        se (deveAvvisare) {
          (0, _util.warn)(`FontFamily contiene un <custom-ident> non valido: ${fontFamily}.`);
        }
        restituisci falso;
      }
    }
  }
  restituisci vero;
}
funzione validateCSSFont(cssFontInfo) {
  const DEFAULT_CSS_FONT_OBLIQUE = "14";
  const DEFAULT_CSS_FONT_WEIGHT = "400";
  const CSS_FONT_WEIGHT_VALUES = new Set(["100", "200", "300", "400", "500", "600", "700", "800", "900", "1000", "normale", "grassetto", "più grassetto", "più chiaro"]);
  costante {
    famiglia di caratteri,
    fontWeight,
    Angolo corsivo
  } = cssFontInfo;
  se (!validateFontName(fontFamily, true)) {
    restituisci falso;
  }
  const peso = fontWeight ? fontWeight.toString() : "";
  cssFontInfo.fontWeight = CSS_FONT_WEIGHT_VALUES.has(peso) ? peso : DEFAULT_CSS_FONT_WEIGHT;
  const angolo = parseFloat(italicAngle);
  cssFontInfo.italicAngle = isNaN(angolo) || angolo < -90 || angolo > 90 ? DEFAULT_CSS_FONT_OBLIQUE : italicAngle.toString();
  restituisci vero;
}
funzione recoverJsURL(str) {
  const URL_OPEN_METHODS = ["app.launchURL", "window.open", "xfa.host.gotoURL"];
  const regex = new RegExp("^\\s*(" + URL_OPEN_METHODS.join("|").replaceAll(".", "\\.") + ")\\((?:'|\")([^'\"]*)(?:'|\")(?:,\\s*(\\w+)\\)|\\))", "i");
  const jsUrl = regex.exec(str);
  se (jsUrl?.[2]) {
    costante url = jsUrl[2];
    lascia nuovaFinestra = false;
    se (jsUrl[3] === "vero" && jsUrl[1] === "app.launchURL") {
      nuovaFinestra = vero;
    }
    ritorno {
      URL,
      nuova finestra
    };
  }
  restituisci null;
}
funzione numberToString(valore) {
  se (Numero.èIntero(valore)) {
    valore di ritorno.toString();
  }
  const roundedValue = Math.round(value * 100);
  se (valorearrotondato % 100 === 0) {
    restituisci (valorearrotondato / 100).toString();
  }
  se (valorearrotondato % 10 === 0) {
    valore di ritorno.toFixed(1);
  }
  valore di ritorno.toFixed(2);
}
funzione getNewAnnotationsMap(annotationStorage) {
  se (!annotazioneArchiviazione) {
    restituisci null;
  }
  const newAnnotationsByPage = new Map();
  per (const [chiave, valore] di annotationStorage) {
    se (!key.startsWith(_util.AnnotationEditorPrefix)) {
      continuare;
    }
    lascia annotazioni = newAnnotationsByPage.get(value.pageIndex);
    se (!annotazioni) {
      annotazioni = [];
      newAnnotationsByPage.set(value.pageIndex, annotations);
    }
    annotazioni.push(valore);
  }
  restituisci newAnnotationsByPage.size > 0 ? newAnnotationsByPage : null;
}
funzione isAscii(str) {
  restituisci /^[\x00-\x7F]*$/.test(str);
}
funzione stringToUTF16HexString(str) {
  const buf = [];
  per (lascia che i = 0, ii = str.length; i < ii; i++) {
    const char = str.charCodeAt(i);
    buf.push((char >> 8 & 0xff).toString(16).padStart(2, "0"), (char & 0xff).toString(16).padStart(2, "0"));
  }
  restituisci buf.join("");
}
funzione stringToUTF16String(str, bigEndian = false) {
  const buf = [];
  se (bigEndian) {
    buf.push("\xFE\xFF");
  }
  per (lascia che i = 0, ii = str.length; i < ii; i++) {
    const char = str.charCodeAt(i);
    buf.push(String.fromCharCode(char >> 8 & 0xff), String.fromCharCode(char & 0xff));
  }
  restituisci buf.join("");
}
funzione getRotationMatrix(rotazione, larghezza, altezza) {
  interruttore (rotazione) {
    caso 90:
      ritorno [0, 1, -1, 0, larghezza, 0];
    caso 180:
      ritorno [-1, 0, 0, -1, larghezza, altezza];
    caso 270:
      ritorno [0, -1, 1, 0, 0, altezza];
    predefinito:
      genera un nuovo errore("Rotazione non valida");
  }
}

/***/ }),
/* 4 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
exports.RefSetCache = exports.RefSet = exports.Ref = exports.Name = exports.EOF = exports.Dict = exports.Cmd = exports.CIRCULAR_REF = void 0;
esportazioni.clearPrimitiveCaches = clearPrimitiveCaches;
esportazioni.isCmd = isCmd;
esportazioni.isDict = isDict;
esportazioni.isName = isName;
esportazioni.isRefsEqual = isRefsEqual;
var _util = __w_pdfjs_require__(2);
const CIRCULAR_REF = Symbol("CIRCULAR_REF");
esportazioni.CIRCULAR_REF = CIRCULAR_REF;
const EOF = Simbolo("EOF");
esportazioni.EOF = EOF;
lascia CmdCache = Object.create(null);
lascia NameCache = Object.create(null);
lascia RefCache = Object.create(null);
funzione clearPrimitiveCaches() {
  CmdCache = Object.create(null);
  NameCache = Object.create(null);
  RefCache = Object.create(null);
}
Nome della classe {
  costruttore(nome) {
    questo.nome = nome;
  }
  static get(nome) {
    restituisci NameCache[nome] ||= nuovo Name(nome);
  }
}
exports.Name = Nome;
classe Cmd {
  costruttore(cmd) {
    questo.cmd = cmd;
  }
  get statico(cmd) {
    restituisci CmdCache[cmd] ||= nuovo Cmd(cmd);
  }
}
esportazioni.Cmd = Cmd;
const nonSerializable = function nonSerializableClosure() {
  restituisci nonSerializable;
};
classe Dict {
  costruttore(xref = null) {
    this._map = Object.create(null);
    questo.xref = xref;
    questo.objId = null;
    this.suppressEncryption = false;
    this.__nonSerializable__ = nonSerializable;
  }
  assegnaXref(nuovoXref) {
    questo.xref = nuovoXref;
  }
  ottieni dimensione() {
    restituisci Object.keys(this._map).length;
  }
  ottieni(chiave1, chiave2, chiave3) {
    lascia valore = this._map[key1];
    se (valore === indefinito e chiave2 !== indefinito) {
      valore = this._map[key2];
      se (valore === indefinito e chiave3 !== indefinito) {
        valore = this._map[key3];
      }
    }
    se (valore instanceof Ref && this.xref) {
      restituisci this.xref.fetch(valore, this.suppressEncryption);
    }
    valore di ritorno;
  }
  asincrono getAsync(chiave1, chiave2, chiave3) {
    lascia valore = this._map[key1];
    se (valore === indefinito e chiave2 !== indefinito) {
      valore = this._map[key2];
      se (valore === indefinito e chiave3 !== indefinito) {
        valore = this._map[key3];
      }
    }
    se (valore instanceof Ref && this.xref) {
      restituisci this.xref.fetchAsync(valore, this.suppressEncryption);
    }
    valore di ritorno;
  }
  getArray(chiave1, chiave2, chiave3) {
    lascia valore = this._map[key1];
    se (valore === indefinito e chiave2 !== indefinito) {
      valore = this._map[key2];
      se (valore === indefinito e chiave3 !== indefinito) {
        valore = this._map[key3];
      }
    }
    se (valore instanceof Ref && this.xref) {
      valore = this.xref.fetch(valore, this.suppressEncryption);
    }
    se (Array.isArray(valore)) {
      valore = valore.fetta();
      per (lascia che i = 0, ii = valore.lunghezza; i < ii; i++) {
        se (valore[i] istanza di Ref && this.xref) {
          valore[i] = this.xref.fetch(valore[i], this.suppressEncryption);
        }
      }
    }
    valore di ritorno;
  }
  getRaw(chiave) {
    restituisci questo._map[chiave];
  }
  getKeys() {
    restituisci Object.keys(this._map);
  }
  ottieniValoriRaw() {
    restituisci Object.values(this._map);
  }
  set(chiave, valore) {
    this._map[chiave] = valore;
  }
  ha(chiave) {
    restituisci questo._map[chiave] !== indefinito;
  }
  perOgni(richiamata) {
    per (chiave costante in this._map) {
      callback(chiave, this.get(chiave));
    }
  }
  static get empty() {
    const emptyDict = new Dict(null);
    emptyDict.set = (chiave, valore) => {
      (0, _util.unreachable)("Non dovrebbe chiamare `set` sul dizionario vuoto.");
    };
    return (0, _util.shadow)(this, "empty", emptyDict);
  }
  unione statica({
    riferimento esterno,
    dictArray,
    mergeSubDicts = falso
  }) {
    const mergedDict = new Dict(xref),
      proprietà = nuova mappa();
    per (const dict di dictArray) {
      se (!(dict instanceof Dict)) {
        continuare;
      }
      per (const [chiave, valore] di Object.entries(dict._map)) {
        lascia proprietà = proprietà.get(chiave);
        se (proprietà === indefinita) {
          proprietà = [];
          proprietà.set(chiave, proprietà);
        } else if (!mergeSubDicts || !(value instanceof Dict)) {
          continuare;
        }
        proprietà.push(valore);
      }
    }
    per (const [nome, valori] delle proprietà) {
      se (valori.lunghezza === 1 || !(valori[0] istanza di Dict)) {
        mergedDict._map[nome] = valori[0];
        continuare;
      }
      const subDict = new Dict(xref);
      per (const dizionario di valori) {
        per (const [chiave, valore] di Object.entries(dict._map)) {
          se (subDict._map[chiave] === non definito) {
            subDict._map[chiave] = valore;
          }
        }
      }
      se (subDict.size > 0) {
        mergedDict._map[name] = subDict;
      }
    }
    proprietà.clear();
    restituisci mergedDict.size > 0 ? mergedDict : Dict.empty;
  }
  clona() {
    const dict = new Dict(this.xref);
    per (const chiave di this.getKeys()) {
      dict.set(chiave, questo è.getRaw(chiave));
    }
    restituisci dizionario;
  }
}
esportazioni.Dict = Dict;
classe Rif {
  costruttore(num, gen) {
    questo.num = num;
    questo.gen = gen;
  }
  alla stringa() {
    se (this.gen === 0) {
      restituisci `${this.num}R`;
    }
    restituisci `${this.num}R${this.gen}`;
  }
  statico daStringa(str) {
    const ref = RefCache[str];
    se (rif) {
      restituisci ref;
    }
    const m = /^(\d+)R(\d*)$/.exec(str);
    se (!m || m[1] === "0") {
      restituisci null;
    }
    restituisci RefCache[str] = nuovo Ref(parseInt(m[1]), !m[2] ? 0 : parseInt(m[2]));
  }
  static get(num, gen) {
    const key = gen === 0 ? `${num}R` : `${num}R${gen}`;
    restituisci RefCache[chiave] ||= nuovo Ref(num, gen);
  }
}
esportazioni.Rif = Rif;
classe RefSet {
  costruttore(genitore = null) {
    this._set = new Set(genitore?._set);
  }
  ha(rif) {
    restituisci questo._set.has(ref.toString());
  }
  mettere(rif) {
    questo._set.add(ref.toString());
  }
  rimuovere(rif) {
    this._set.delete(ref.toString());
  }
  [Simbolo.iteratore]() {
    restituisci questo._set.values();
  }
  chiaro() {
    questo._set.clear();
  }
}
esportazioni.RefSet = RefSet;
classe RefSetCache {
  costruttore() {
    this._map = nuova mappa();
  }
  ottieni dimensione() {
    restituisci questa._map.size;
  }
  ottenere(rif) {
    restituisci this._map.get(ref.toString());
  }
  ha(rif) {
    restituisci this._map.has(ref.toString());
  }
  metti(rif, oggetto) {
    this._map.set(ref.toString(), obj);
  }
  putAlias(rif, aliasRef) {
    this._map.set(ref.toString(), this.get(aliasRef));
  }
  [Simbolo.iteratore]() {
    restituisci questo._map.values();
  }
  chiaro() {
    this._map.clear();
  }
}
esportazioni.RefSetCache = RefSetCache;
funzione isName(v, nome) {
  restituisci v instanceof Nome && (nome === indefinito || v.nome === nome);
}
funzione isCmd(v, cmd) {
  restituisci v instanceof Cmd && (cmd === indefinito || v.cmd === cmd);
}
funzione isDict(v, tipo) {
  restituisci v instanceof Dict && (tipo === indefinito || isName(v.get("Tipo"), tipo));
}
funzione isRefsEqual(v1, v2) {
  restituisci v1.num === v2.num && v1.gen === v2.gen;
}

/***/ }),
/* 5 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.BaseStream = void 0;
var _util = __w_pdfjs_require__(2);
classe BaseStream {
  costruttore() {
    se (questo.costruttore === BaseStream) {
      (0, _util.unreachable)("Impossibile inizializzare BaseStream.");
    }
  }
  ottieni lunghezza() {
    (0, _util.unreachable)("Accesso al getter astratto `length`");
  }
  ottieni isEmpty() {
    (0, _util.unreachable)("Accesso al getter astratto `isEmpty`");
  }
  ottieni isDataLoaded() {
    return (0, _util.shadow)(this, "isDataLoaded", true);
  }
  getByte() {
    (0, _util.unreachable)("Metodo astratto `getByte` chiamato");
  }
  getBytes(lunghezza) {
    (0, _util.unreachable)("Metodo astratto `getBytes` chiamato");
  }
  peekByte() {
    const peekedByte = this.getByte();
    se (peekedByte !== -1) {
      questo.pos--;
    }
    restituisci peekedByte;
  }
  peekBytes(lunghezza) {
    const byte = this.getBytes(lunghezza);
    this.pos -= byte.lunghezza;
    restituire byte;
  }
  getUint16() {
    const b0 = this.getByte();
    const b1 = this.getByte();
    se (b0 === -1 || b1 === -1) {
      restituisci -1;
    }
    ritorno (b0 << 8) + b1;
  }
  ottieniInt32() {
    const b0 = this.getByte();
    const b1 = this.getByte();
    const b2 = this.getByte();
    const b3 = this.getByte();
    ritorno (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
  }
  getByteRange(inizio, fine) {
    (0, _util.unreachable)("Metodo astratto `getByteRange` chiamato");
  }
  getString(lunghezza) {
    restituisci (0, _util.bytesToString)(this.getBytes(lunghezza));
  }
  salta(n) {
    questo.pos += n || 1;
  }
  reimposta() {
    (0, _util.unreachable)("Metodo astratto `reset` chiamato");
  }
  spostaInizio() {
    (0, _util.unreachable)("Metodo astratto `moveStart` chiamato");
  }
  makeSubStream(inizio, lunghezza, dizionario = null) {
    (0, _util.unreachable)("Metodo astratto `makeSubStream` chiamato");
  }
  getBaseStreams() {
    restituisci null;
  }
}
esportazioni.BaseStream = BaseStream;

/***/ }),
/* 6 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.NetworkPdfManager = esportazioni.LocalPdfManager = void 0;
var _util = __w_pdfjs_require__(2);
var _chunked_stream = __w_pdfjs_require__(7);
var _core_utils = __w_pdfjs_require__(3);
var _documento = __w_pdfjs_require__(9);
var _stream = __w_pdfjs_require__(8);
funzione parseDocBaseUrl(url) {
  se (url) {
    const absoluteUrl = (0, _util.createValidAbsoluteUrl)(url);
    se (URL assoluto) {
      restituisci absoluteUrl.href;
    }
    (0, _util.warn)(`DocBaseUrl assoluto non valido: "${url}".`);
  }
  restituisci null;
}
classe BasePdfManager {
  costruttore(argomenti) {
    se (questo.costruttore === BasePdfManager) {
      (0, _util.unreachable)("Impossibile inizializzare BasePdfManager.");
    }
    this._docBaseUrl = parseDocBaseUrl(args.docBaseUrl);
    this._docId = args.docId;
    this._password = args.password;
    questo.abilitaXfa = argomenti.abilitaXfa;
    args.evaluatorOptions.isOffscreenCanvasSupported &&= _util.FeatureTest.isOffscreenCanvasSupported;
    this.evaluatorOptions = args.evaluatorOptions;
  }
  ottieni docId() {
    restituisci questo._docId;
  }
  ottieni password() {
    restituisci questa._password;
  }
  ottieni docBaseUrl() {
    restituisci questo._docBaseUrl;
  }
  ottieni catalogo() {
    restituisci questo.pdfDocument.catalog;
  }
  ensureDoc(prop, argomenti) {
    restituisci this.ensure(this.pdfDocument, prop, args);
  }
  ensureXRef(prop, argomenti) {
    restituisci this.ensure(this.pdfDocument.xref, prop, args);
  }
  ensureCatalog(prop, argomenti) {
    restituisci this.ensure(this.pdfDocument.catalog, prop, args);
  }
  getPage(indicepagina) {
    restituisci this.pdfDocument.getPage(pageIndex);
  }
  fontFallback(id, gestore) {
    restituisci this.pdfDocument.fontFallback(id, handler);
  }
  loadXfaFonts(gestore, attività) {
    restituisci this.pdfDocument.loadXfaFonts(gestore, attività);
  }
  caricaXfaImages() {
    restituisci this.pdfDocument.loadXfaImages();
  }
  serializeXfaData(annotationStorage) {
    restituisci this.pdfDocument.serializeXfaData(annotationStorage);
  }
  cleanup(attivato manualmente = false) {
    restituisci this.pdfDocument.cleanup(manuallyTriggered);
  }
  async ensure(obj, prop, args) {
    (0, _util.unreachable)("Metodo astratto `ensure` chiamato");
  }
  requestRange(inizio, fine) {
    (0, _util.unreachable)("Metodo astratto `requestRange` chiamato");
  }
  requestLoadedStream(noFetch = false) {
    (0, _util.unreachable)("Metodo astratto `requestLoadedStream` chiamato");
  }
  inviaProgressiveData(chunk) {
    (0, _util.unreachable)("Metodo astratto `sendProgressiveData` chiamato");
  }
  aggiornaPassword(password) {
    this._password = password;
  }
  terminare(motivo) {
    (0, _util.unreachable)("Metodo astratto `terminate` chiamato");
  }
}
classe LocalPdfManager estende BasePdfManager {
  costruttore(argomenti) {
    super(argomenti);
    const stream = new _stream.Stream(args.source);
    this.pdfDocument = new _document.PDFDocument(this, stream);
    this._loadedStreamPromise = Promise.resolve(stream);
  }
  async ensure(obj, prop, args) {
    valore costante = obj[prop];
    se (tipo di valore === "funzione") {
      valore di ritorno.apply(obj, args);
    }
    valore di ritorno;
  }
  requestRange(inizio, fine) {
    restituisci Promise.resolve();
  }
  requestLoadedStream(noFetch = false) {
    restituisci questo._loadedStreamPromise;
  }
  terminare(motivo) {}
}
esportazioni.LocalPdfManager = LocalPdfManager;
classe NetworkPdfManager estende BasePdfManager {
  costruttore(argomenti) {
    super(argomenti);
    this.streamManager = new _chunked_stream.ChunkedStreamManager(args.source, {
      msgHandler: gestore argomenti,
      lunghezza: args.length,
      disableAutoFetch: argomenti.disableAutoFetch,
      rangeChunkSize: argomenti.rangeChunkSize
    });
    this.pdfDocument = new _document.PDFDocument(this, this.streamManager.getStream());
  }
  async ensure(obj, prop, args) {
    Tentativo {
      valore costante = obj[prop];
      se (tipo di valore === "funzione") {
        valore di ritorno.apply(obj, args);
      }
      valore di ritorno;
    } catturare (es.) {
      se (!(ex instanceof _core_utils.MissingDataException)) {
        lanciare ex;
      }
      attendi questo.requestRange(es.inizio, es.fine);
      restituisci questo.assicurati(oggetto, prop, argomenti);
    }
  }
  requestRange(inizio, fine) {
    restituisci this.streamManager.requestRange(inizio, fine);
  }
  requestLoadedStream(noFetch = false) {
    restituisci this.streamManager.requestAllChunks(noFetch);
  }
  inviaProgressiveData(chunk) {
    this.streamManager.onReceiveData({
      pezzo
    });
  }
  terminare(motivo) {
    this.streamManager.abort(motivo);
  }
}
esportazioni.NetworkPdfManager = NetworkPdfManager;

/***/ }),
/* 7 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.ChunkedStreamManager = esportazioni.ChunkedStream = void 0;
var _core_utils = __w_pdfjs_require__(3);
var _util = __w_pdfjs_require__(2);
var _stream = __w_pdfjs_require__(8);
classe ChunkedStream estende _stream.Stream {
  costruttore(lunghezza, dimensione del pezzo, gestore) {
    super(new Uint8Array(lunghezza), 0, lunghezza, null);
    this.chunkSize = chunkSize;
    this._loadedChunks = new Set();
    this.numChunks = Math.ceil(lunghezza / chunkSize);
    questo.manager = gestore;
    this.progressiveDataLength = 0;
    this.lastSuccessfulEnsureByteChunk = -1;
  }
  getMissingChunks() {
    const blocchi = [];
    per (lascia che chunk = 0, n = this.numChunks; chunk < n; ++chunk) {
      se (!this._loadedChunks.has(chunk)) {
        pezzi.push(pezzo);
      }
    }
    restituire i pezzi;
  }
  ottieni numChunksLoaded() {
    restituisci questo._loadedChunks.size;
  }
  ottieni isDataLoaded() {
    restituisci this.numChunksLoaded === this.numChunks;
  }
  onReceiveData(inizio, frammento) {
    const chunkSize = this.chunkSize;
    se (inizio % chunkSize !== 0) {
      lancia un nuovo errore(`Offset di inizio errato: ${begin}`);
    }
    const end = begin + chunk.byteLength;
    se (fine % chunkSize !== 0 && fine !== questa.lunghezza.byte) {
      lancia un nuovo errore(`Offset finale errato: ${end}`);
    }
    this.bytes.set(new Uint8Array(chunk), begin);
    const beginChunk = Math.floor(begin / chunkSize);
    const endChunk = Math.floor((end - 1) / chunkSize) + 1;
    per (lascia che curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
      this._loadedChunks.add(curChunk);
    }
  }
  onReceiveProgressiveData(dati) {
    lascia posizione = this.progressiveDataLength;
    const beginChunk = Math.floor(posizione / this.chunkSize);
    this.bytes.set(new Uint8Array(data), position);
    posizione += data.byteLength;
    this.progressiveDataLength = posizione;
    const endChunk = posizione >= this.end ? this.numChunks : Math.floor(posizione / this.chunkSize);
    per (lascia che curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
      this._loadedChunks.add(curChunk);
    }
  }
  ensureByte(pos) {
    se (pos < this.progressiveDataLength) {
      ritorno;
    }
    const chunk = Math.floor(pos / this.chunkSize);
    se (chunk > this.numChunks) {
      ritorno;
    }
    se (chunk === this.lastSuccessfulEnsureByteChunk) {
      ritorno;
    }
    se (!this._loadedChunks.has(chunk)) {
      genera una nuova eccezione _core_utils.MissingDataException(pos, pos + 1);
    }
    this.lastSuccessfulEnsureByteChunk = frammento;
  }
  ensureRange(inizio, fine) {
    se (inizio >= fine) {
      ritorno;
    }
    se (fine <= this.progressiveDataLength) {
      ritorno;
    }
    const beginChunk = Math.floor(begin / this.chunkSize);
    se (beginChunk > this.numChunks) {
      ritorno;
    }
    const endChunk = Math.min(Math.floor((end - 1) / this.chunkSize) + 1, this.numChunks);
    per (lascia che chunk = beginChunk; chunk < endChunk; ++chunk) {
      se (!this._loadedChunks.has(chunk)) {
        genera una nuova eccezione _core_utils.MissingDataException(inizio, fine);
      }
    }
  }
  nextEmptyChunk(beginChunk) {
    const numChunks = this.numChunks;
    per (lascia che i = 0; i < numChunks; ++i) {
      const chunk = (beginChunk + i) % numChunks;
      se (!this._loadedChunks.has(chunk)) {
        restituisci il pezzo;
      }
    }
    restituisci null;
  }
  haChunk(pezzo) {
    restituisci questo._loadedChunks.has(chunk);
  }
  getByte() {
    const pos = this.pos;
    se (pos >= this.end) {
      restituisci -1;
    }
    se (pos >= this.progressiveDataLength) {
      questo.ensureByte(pos);
    }
    restituisci questo.byte[questo.pos++];
  }
  getBytes(lunghezza) {
    const byte = questo.byte;
    const pos = this.pos;
    const strEnd = this.end;
    se (!lunghezza) {
      se (strEnd > this.progressiveDataLength) {
        this.ensureRange(pos, strEnd);
      }
      restituisci byte.subarray(pos, strEnd);
    }
    lascia fine = pos + lunghezza;
    se (fine > strEnd) {
      fine = strEnd;
    }
    se (fine > this.progressiveDataLength) {
      this.ensureRange(pos, end);
    }
    questo.pos = fine;
    restituisci byte.subarray(pos, end);
  }
  getByteRange(inizio, fine) {
    se (inizio < 0) {
      inizio = 0;
    }
    se (fine > questo.fine) {
      fine = questo.fine;
    }
    se (fine > this.progressiveDataLength) {
      this.ensureRange(inizio, fine);
    }
    restituisci questo.bytes.subarray(inizio, fine);
  }
  makeSubStream(inizio, lunghezza, dizionario = null) {
    se (lunghezza) {
      se (inizio + lunghezza > this.progressiveDataLength) {
        this.ensureRange(inizio, inizio + lunghezza);
      }
    } altrimenti se (inizio >= this.progressiveDataLength) {
      this.ensureByte(inizio);
    }
    funzione ChunkedStreamSubstream() {}
    ChunkedStreamSubstream.prototype = Object.create(this);
    ChunkedStreamSubstream.prototype.getMissingChunks = funzione () {
      const chunkSize = this.chunkSize;
      const beginChunk = Math.floor(this.start / chunkSize);
      const endChunk = Math.floor((this.end - 1) / chunkSize) + 1;
      const missingChunks = [];
      per (lascia che chunk = beginChunk; chunk < endChunk; ++chunk) {
        se (!this._loadedChunks.has(chunk)) {
          missingChunks.push(chunk);
        }
      }
      restituisci i pezzi mancanti;
    };
    Object.defineProperty(ChunkedStreamSubstream.prototype, "isDataLoaded", {
      Ottenere() {
        se (this.numChunksLoaded === this.numChunks) {
          restituisci vero;
        }
        restituisci this.getMissingChunks().length === 0;
      },
      configurabile: vero
    });
    const subStream = new ChunkedStreamSubstream();
    subStream.pos = subStream.start = inizio;
    subStream.end = inizio + lunghezza || this.end;
    subStream.dict = dizionario;
    restituisci subStream;
  }
  getBaseStreams() {
    restituisci [questo];
  }
}
esportazioni.ChunkedStream = ChunkedStream;
classe ChunkedStreamManager {
  costruttore(pdfNetworkStream, argomenti) {
    questa.lunghezza = argomenti.lunghezza;
    this.chunkSize = args.rangeChunkSize;
    questo.stream = nuovo ChunkedStream(questa.lunghezza, questa.dimensionechunk, questo);
    questo.pdfNetworkStream = pdfNetworkStream;
    this.disableAutoFetch = args.disableAutoFetch;
    this.msgHandler = args.msgHandler;
    questo.currRequestId = 0;
    this._chunksNeededByRequest = new Map();
    this._requestsByChunk = nuova mappa();
    this._promisesByRequest = nuova mappa();
    this.progressiveDataLength = 0;
    questo.interrotto = falso;
    this._loadedStreamCapability = new _util.PromiseCapability();
  }
  inviaRichiesta(inizio, fine) {
    const rangeReader = this.pdfNetworkStream.getRangeReader(inizio, fine);
    se (!rangeReader.isStreamingSupported) {
      rangeReader.onProgress = this.onProgress.bind(this);
    }
    lascia che i pezzi = [],
      caricato = 0;
    restituisci nuova promessa((risolvi, rifiuta) => {
      const readChunk = ({
        valore,
        Fatto
      }) => {
        Tentativo {
          se (fatto) {
            const chunkData = (0, _core_utils.arrayBuffersToBytes)(chunk);
            pezzi = null;
            risolvere(chunkData);
            ritorno;
          }
          caricato += valore.byteLength;
          se (rangeReader.isStreamingSupported) {
            questo.onProgress({
              caricato
            });
          }
          chunks.push(valore);
          rangeReader.read().then(readChunk, reject);
        } cattura (e) {
          rifiutare(e);
        }
      };
      rangeReader.read().then(readChunk, reject);
    }).then(dati => {
      se (questo.interrotto) {
        ritorno;
      }
      questo.onReceiveData({
        pezzo: dati,
        inizio
      });
    });
  }
  requestAllChunks(noFetch = false) {
    se (!noFetch) {
      const missingChunks = this.stream.getMissingChunks();
      this._requestChunks(missingChunks);
    }
    restituisci this._loadedStreamCapability.promise;
  }
  _requestChunks(frammenti) {
    const requestId = this.currRequestId++;
    const chunksNeeded = new Set();
    this._chunksNeededByRequest.set(requestId, chunksNeeded);
    per (const pezzo di pezzi) {
      se (!this.stream.hasChunk(chunk)) {
        pezzi necessari.add(pezzo);
      }
    }
    se (chunksNeeded.size === 0) {
      restituisci Promise.resolve();
    }
    const capability = new _util.PromiseCapability();
    this._promisesByRequest.set(requestId, capacità);
    const chunksToRequest = [];
    per (const pezzo di pezzi necessari) {
      lascia requestIds = this._requestsByChunk.get(chunk);
      se (!requestIds) {
        IDRichiesta = [];
        this._requestsByChunk.set(chunk, requestIds);
        chunksToRequest.push(chunk);
      }
      requestIds.push(requestId);
    }
    se (chunksToRequest.length > 0) {
      const groupedChunksToRequest = this.groupChunks(chunksToRequest);
      per (const groupedChunk di groupedChunksToRequest) {
        const begin = groupedChunk.beginChunk * this.chunkSize;
        const end = Math.min(groupedChunk.endChunk * this.chunkSize, this.length);
        this.sendRequest(inizio, fine).catch(capacità.rifiuto);
      }
    }
    restituisci capability.promise.catch(reason => {
      se (questo.interrotto) {
        ritorno;
      }
      gettare la ragione;
    });
  }
  getStream() {
    restituisci questo.stream;
  }
  requestRange(inizio, fine) {
    fine = Math.min(fine, questa.lunghezza);
    const beginChunk = this.getBeginChunk(begin);
    const endChunk = this.getEndChunk(fine);
    const blocchi = [];
    per (lascia che chunk = beginChunk; chunk < endChunk; ++chunk) {
      pezzi.push(pezzo);
    }
    restituisci questo._requestChunks(chunks);
  }
  requestRanges(intervalli = []) {
    const chunksToRequest = [];
    per (intervallo costante di intervalli) {
      const beginChunk = this.getBeginChunk(range.begin);
      const endChunk = this.getEndChunk(range.end);
      per (lascia che chunk = beginChunk; chunk < endChunk; ++chunk) {
        se (!chunksToRequest.includes(chunk)) {
          chunksToRequest.push(chunk);
        }
      }
    }
    chunksToRequest.sort(funzione (a, b) {
      restituisci a - b;
    });
    restituisci questo._requestChunks(chunksToRequest);
  }
  groupChunks(frammenti) {
    const groupedChunks = [];
    lascia beginChunk = -1;
    lascia che prevChunk = -1;
    per (lascia che i = 0, ii = chunks.length; i < ii; ++i) {
      const chunk = chunks[i];
      se (inizioChunk < 0) {
        beginChunk = pezzo;
      }
      se (prevChunk >= 0 && prevChunk + 1 !== chunk) {
        groupedChunks.push({
          beginChunk,
          endChunk: prevChunk + 1
        });
        beginChunk = pezzo;
      }
      se (i + 1 === lunghezza dei blocchi) {
        groupedChunks.push({
          beginChunk,
          endChunk: frammento + 1
        });
      }
      prevChunk = pezzo;
    }
    restituisci groupedChunks;
  }
  onProgress(argomenti) {
    this.msgHandler.send("DocProgress", {
      caricato: this.stream.numChunksLoaded * this.chunkSize + args.loaded,
      totale: questa lunghezza
    });
  }
  onReceiveData(argomenti) {
    const chunk = args.chunk;
    const isProgressive = args.begin === indefinito;
    const begin = isProgressive ? this.progressiveDataLength : args.begin;
    const end = begin + chunk.byteLength;
    const beginChunk = Math.floor(begin / this.chunkSize);
    const endChunk = fine < this.length ? Math.floor(fine / this.chunkSize) : Math.ceil(fine / this.chunkSize);
    se (èProgressivo) {
      this.stream.onReceiveProgressiveData(chunk);
      this.progressiveDataLength = fine;
    } altro {
      this.stream.onReceiveData(inizio, frammento);
    }
    se (questo.stream.isDataLoaded) {
      this._loadedStreamCapability.resolve(this.stream);
    }
    const loadedRequests = [];
    per (lascia che curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
      const requestIds = this._requestsByChunk.get(curChunk);
      se (!requestIds) {
        continuare;
      }
      this._requestsByChunk.delete(curChunk);
      per (const requestId di requestId) {
        const chunksNeeded = this._chunksNeededByRequest.get(requestId);
        se (chunksNeeded.has(curChunk)) {
          chunksNeeded.delete(curChunk);
        }
        se (chunksNeeded.size > 0) {
          continuare;
        }
        loadedRequests.push(requestId);
      }
    }
    se (!this.disableAutoFetch && this._requestsByChunk.size === 0) {
      lascia nextEmptyChunk;
      se (this.stream.numChunksLoaded === 1) {
        const lastChunk = this.stream.numChunks - 1;
        se (!this.stream.hasChunk(lastChunk)) {
          nextEmptyChunk = lastChunk;
        }
      } altro {
        nextEmptyChunk = this.stream.nextEmptyChunk(endChunk);
      }
      se (Numero.èIntero(nextEmptyChunk)) {
        this._requestChunks([nextEmptyChunk]);
      }
    }
    per (const requestId di loadedRequests) {
      capacità costante = this._promisesByRequest.get(requestId);
      this._promisesByRequest.delete(requestId);
      capacità.risolvi();
    }
    this.msgHandler.send("DocProgress", {
      caricato: this.stream.numChunksLoaded * this.chunkSize,
      totale: questa lunghezza
    });
  }
  onError(err) {
    this._loadedStreamCapability.reject(err);
  }
  getBeginChunk(inizio) {
    restituisci Math.floor(inizio / this.chunkSize);
  }
  getEndChunk(fine) {
    restituisci Math.floor((end - 1) / this.chunkSize) + 1;
  }
  abort(motivo) {
    questo.interrotto = vero;
    this.pdfNetworkStream?.cancelAllRequests(motivo);
    per (capacità costante di this._promisesByRequest.values()) {
      capacità.rifiuta(motivo);
    }
  }
}
esportazioni.ChunkedStreamManager = ChunkedStreamManager;

/***/ }),
/* 8 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.StringStream = esportazioni.Stream = esportazioni.NullStream = void 0;
var _base_stream = __w_pdfjs_require__(5);
var _util = __w_pdfjs_require__(2);
classe Stream estende _base_stream.BaseStream {
  costruttore(arrayBuffer, inizio, lunghezza, dizionario) {
    super();
    this.bytes = arrayBuffer instanceof Uint8Array ? arrayBuffer : new Uint8Array(arrayBuffer);
    questo.inizio = inizio || 0;
    questo.pos = questo.inizio;
    this.end = inizio + lunghezza || this.bytes.length;
    questo.dizionario = dizionario;
  }
  ottieni lunghezza() {
    restituisci questo.fine - questo.inizio;
  }
  ottieni isEmpty() {
    restituisci questa lunghezza === 0;
  }
  getByte() {
    se (this.pos >= this.end) {
      restituisci -1;
    }
    restituisci questo.byte[questo.pos++];
  }
  getBytes(lunghezza) {
    const byte = questo.byte;
    const pos = this.pos;
    const strEnd = this.end;
    se (!lunghezza) {
      restituisci byte.subarray(pos, strEnd);
    }
    lascia fine = pos + lunghezza;
    se (fine > strEnd) {
      fine = strEnd;
    }
    questo.pos = fine;
    restituisci byte.subarray(pos, end);
  }
  getByteRange(inizio, fine) {
    se (inizio < 0) {
      inizio = 0;
    }
    se (fine > questo.fine) {
      fine = questo.fine;
    }
    restituisci questo.bytes.subarray(inizio, fine);
  }
  reimposta() {
    questo.pos = questo.inizio;
  }
  spostaInizio() {
    questo.inizio = questo.posizione;
  }
  makeSubStream(inizio, lunghezza, dizionario = null) {
    restituisci nuovo Stream(this.bytes.buffer, inizio, lunghezza, dizionario);
  }
}
esportazioni.Stream = Stream;
classe StringStream estende Stream {
  costruttore(str) {
    super((0, _util.stringToBytes)(str));
  }
}
esportazioni.StringStream = StringStream;
classe NullStream estende Stream {
  costruttore() {
    super(nuovo Uint8Array(0));
  }
}
esportazioni.NullStream = NullStream;

/***/ }),
/* 9 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.Pagina = esportazioni.DocumentoPDF = void 0;
var _util = __w_pdfjs_require__(2);
var _annotazione = __w_pdfjs_require__(10);
var _core_utils = __w_pdfjs_require__(3);
var _primitives = __w_pdfjs_require__(4);
var _xfa_fonts = __w_pdfjs_require__(51);
var _base_stream = __w_pdfjs_require__(5);
var _crypto = __w_pdfjs_require__(74);
var _catalog = __w_pdfjs_require__(66);
var _cleanup_helper = __w_pdfjs_require__(68);
var _dataset_reader = __w_pdfjs_require__(102);
var _parser = __w_pdfjs_require__(16);
var _stream = __w_pdfjs_require__(8);
var _object_loader = __w_pdfjs_require__(76);
var _operator_list = __w_pdfjs_require__(64);
var _evaluator = __w_pdfjs_require__(13);
var _decode_stream = __w_pdfjs_require__(18);
var _struct_tree = __w_pdfjs_require__(72);
var _writer = __w_pdfjs_require__(73);
var _factory = __w_pdfjs_require__(77);
var _xref = __w_pdfjs_require__(103);
const DEFAULT_USER_UNIT = 1.0;
const LETTER_SIZE_MEDIABOX = [0, 0, 612, 792];
classe Pagina {
  costruttore({
    pdfManager,
    riferimento esterno,
    indice della pagina,
    pageDict,
    rif.
    globalIdFactory,
    fontCache,
    builtInCMapCache,
    standardFontDataCache,
    globalImageCache,
    systemFontCache,
    nonBlendModesSet,
    xfaFactory
  }) {
    questo.pdfManager = pdfManager;
    this.pageIndex = pageIndex;
    this.pageDict = pageDict;
    questo.xref = xref;
    questo.rif = rif;
    this.fontCache = fontCache;
    this.builtInCMapCache = builtInCMapCache;
    this.standardFontDataCache = standardFontDataCache;
    this.globalImageCache = globalImageCache;
    this.systemFontCache = systemFontCache;
    questo.nonBlendModesSet = nonBlendModesSet;
    this.evaluatorOptions = pdfManager.evaluatorOptions;
    this.resourcesPromise = null;
    this.xfaFactory = xfaFactory;
    const idCounters = {
      oggetto: 0
    };
    this._localIdFactory = la classe estende globalIdFactory {
      statico createObjId() {
        restituisci `p${pageIndex}_${++idCounters.obj}`;
      }
      getPageObjId() statico {
        restituisci `p${ref.toString()}`;
      }
    };
  }
  _getInheritableProperty(chiave, getArray = false) {
    valore costante = (0, _core_utils.getInheritableProperty)({
      dizionario: this.pageDict,
      chiave,
      ottieniArray,
      stopWhenFound: falso
    });
    se (!Array.isArray(valore)) {
      valore di ritorno;
    }
    se (valore.lunghezza === 1 || !(valore[0] istanza di _primitives.Dict)) {
      valore di ritorno[0];
    }
    restituisci _primitives.Dict.merge({
      xrif: questo.xrif,
      dictArray: valore
    });
  }
  ottieni contenuto() {
    restituisci this.pageDict.getArray("Contenuto");
  }
  ottenere risorse() {
    const risorse = this._getInheritableProperty("Risorse");
    return (0, _util.shadow)(this, "resources", resources instanceof _primitives.Dict ? resources : _primitives.Dict.empty);
  }
  _getBoundingBox(nome) {
    se (this.xfaData) {
      restituisci this.xfaData.bbox;
    }
    lascia box = this._getInheritableProperty(nome, vero);
    se (Array.isArray(box) && box.length === 4) {
      box = _util.Util.normalizeRect(box);
      se (box[2] - box[0] > 0 e box[3] - box[1] > 0) {
        scatola di reso;
      }
      (0, _util.warn)(`Voce /${name} vuota o non valida.`);
    }
    restituisci null;
  }
  ottieni mediaBox() {
    return (0, _util.shadow)(this, "mediaBox", this._getBoundingBox("MediaBox") || LETTER_SIZE_MEDIABOX);
  }
  ottieni cropBox() {
    return (0, _util.shadow)(this, "cropBox", this._getBoundingBox("CropBox") || this.mediaBox);
  }
  ottieni userUnit() {
    lascia che obj = this.pageDict.get("UserUnit");
    se (tipo di oggetto !== "numero" || oggetto <= 0) {
      obj = DEFAULT_USER_UNIT;
    }
    return (0, _util.shadow)(this, "userUnit", obj);
  }
  ottieni vista() {
    costante {
      cropBox,
      mediaBox
    } = questo;
    if (cropBox !== mediaBox && !(0, _util.isArrayEqual)(cropBox, mediaBox)) {
      const box = _util.Util.intersect(cropBox, mediaBox);
      se (box && box[2] - box[0] > 0 && box[3] - box[1] > 0) {
        return (0, _util.shadow)(this, "view", box);
      }
      (0, _util.warn)("Intersezione vuota tra /CropBox e /MediaBox.");
    }
    return (0, _util.shadow)(this, "view", mediaBox);
  }
  ottieni ruota() {
    lascia ruotare = this._getInheritableProperty("Ruota") || 0;
    se (ruota % 90 !== 0) {
      ruota = 0;
    } altrimenti se (ruota >= 360) {
      ruota %= 360;
    } altrimenti se (ruota < 0) {
      ruota = (ruota % 360 + 360) % 360;
    }
    return (0, _util.shadow)(this, "ruota", ruota);
  }
  _onSubStreamError(motivo, objId) {
    se (this.evaluatorOptions.ignoreErrors) {
      (0, _util.warn)(`getContentStream - ignorando il sottoflusso (${objId}): "${reason}".`);
      ritorno;
    }
    gettare la ragione;
  }
  getContentStream() {
    restituisci this.pdfManager.ensure(this, "content").then(content => {
      se (istanza di contenuto di _base_stream.BaseStream) {
        restituire il contenuto;
      }
      se (Array.isArray(contenuto)) {
        restituisci nuovo _decode_stream.StreamsSequenceStream(contenuto, this._onSubStreamError.bind(this));
      }
      restituisci nuovo _stream.NullStream();
    });
  }
  ottieni xfaData() {
    return (0, _util.shadow)(questo, "xfaData", questo.xfaFactory ? {
      bbox: this.xfaFactory.getBoundingBox(this.pageIndex)
    } : nullo);
  }
  #replaceIdByRef(annotazioni, annotazioni eliminate, annotazioni esistenti) {
    per (annotazione costante di annotazioni) {
      se (annotazione.id) {
        const ref = _primitives.Ref.fromString(annotation.id);
        se (!rif) {
          (0, _util.warn)(`Un'annotazione non collegata non può essere modificata: ${annotation.id}`);
          continuare;
        }
        se (annotazione.eliminata) {
          cancellatoAnnotazioni.put(ref);
          continuare;
        }
        annotazioni esistenti?.put(ref);
        annotazione.rif = ref;
        elimina annotation.id;
      }
    }
  }
  async saveNewAnnotations(gestore, attività, annotazioni, imagePromises) {
    se (this.xfaFactory) {
      genera un nuovo errore("XFA: Impossibile salvare le nuove annotazioni.");
    }
    const partialEvaluator = new _evaluator.PartialEvaluator({
      xrif: questo.xrif,
      gestore,
      pageIndex: this.pageIndex,
      idFactory: this._localIdFactory,
      fontCache: this.fontCache,
      builtInCMapCache: questo.builtInCMapCache,
      standardFontDataCache: this.standardFontDataCache,
      globalImageCache: this.globalImageCache,
      systemFontCache: this.systemFontCache,
      opzioni: this.evaluatorOptions
    });
    const deleteAnnotations = new _primitives.RefSet();
    const esistenteAnnotations = new _primitives.RefSet();
    questo.#replaceIdByRef(annotazioni, annotazioni eliminate, annotazioni esistenti);
    const pageDict = this.pageDict;
    const annotationsArray = this.annotations.filter(a => !(a instanceof _primitives.Ref && deletedAnnotations.has(a)));
    const newData = await _annotation.AnnotationFactory.saveNewAnnotations(partialEvaluator, task, annotations, imagePromises);
    per (cost {
      rif.
    } di newData.annotations) {
      se (ref instanceof _primitives.Ref && !existingAnnotations.has(ref)) {
        annotazioniArray.push(ref);
      }
    }
    const savedDict = pageDict.get("Annots");
    pageDict.set("Annotazioni", annotationsArray);
    buffer costante = [];
    attendi (0, _writer.writeObject)(this.ref, pageDict, buffer, this.xref);
    se (savedDict) {
      pageDict.set("Annotazioni", savedDict);
    }
    oggetti costanti = nuovi dati.dipendenze;
    oggetti.push({
      rif: this.ref,
      dati: buffer.join("")
    }, ...nuoveannotazioni di dati);
    restituire oggetti;
  }
  salva(gestore, attività, annotazioneArchiviazione) {
    const partialEvaluator = new _evaluator.PartialEvaluator({
      xrif: questo.xrif,
      gestore,
      pageIndex: this.pageIndex,
      idFactory: this._localIdFactory,
      fontCache: this.fontCache,
      builtInCMapCache: questo.builtInCMapCache,
      standardFontDataCache: this.standardFontDataCache,
      globalImageCache: this.globalImageCache,
      systemFontCache: this.systemFontCache,
      opzioni: this.evaluatorOptions
    });
    restituisci this._parsedAnnotations.then(function (annotations) {
      const newRefsPromises = [];
      per (annotazione costante di annotazioni) {
        se (!annotazione.mustBePrinted(annotazioneStorage)) {
          continuare;
        }
        newRefsPromises.push(annotation.save(partialEvaluator, task, annotationStorage).catch(function (reason) {
          (0, _util.warn)("salva - ignora i dati di annotazione durante l'attività " + `"${task.name}": "${reason}".`);
          restituisci null;
        }));
      }
      restituisci Promise.all(newRefsPromises).then(function (newRefs) {
        restituisci newRefs.filter(newRef => !!newRef);
      });
    });
  }
  caricaRisorse(chiavi) {
    se (!this.resourcesPromise) {
      this.resourcesPromise = this.pdfManager.ensure(this, "risorse");
    }
    restituisci this.resourcesPromise.then(() => {
      const objectLoader = new _object_loader.ObjectLoader(this.resources, keys, this.xref);
      restituisci objectLoader.load();
    });
  }
  getOperatorList({
    gestore,
    lavello,
    compito,
    intento,
    chiave della cache,
    annotationStorage = null
  }) {
    const contentStreamPromise = this.getContentStream();
    const resourcesPromise = this.loadResources(["ColorSpace", "ExtGState", "Font", "Pattern", "Proprietà", "Shading", "XObject"]);
    const partialEvaluator = new _evaluator.PartialEvaluator({
      xrif: questo.xrif,
      gestore,
      pageIndex: this.pageIndex,
      idFactory: this._localIdFactory,
      fontCache: this.fontCache,
      builtInCMapCache: questo.builtInCMapCache,
      standardFontDataCache: this.standardFontDataCache,
      globalImageCache: this.globalImageCache,
      systemFontCache: this.systemFontCache,
      opzioni: this.evaluatorOptions
    });
    const newAnnotationsByPage = !this.xfaFactory ? (0, _core_utils.getNewAnnotationsMap)(annotationStorage) : null;
    lascia che le Annotazioni eliminate = null;
    lascia newAnnotationsPromise = Promise.resolve(null);
    se (nuoveAnnotazioniPerPagina) {
      const newAnnotations = newAnnotationsByPage.get(this.pageIndex);
      se (nuoveAnnotazioni) {
        const annotationGlobalsPromise = this.pdfManager.ensureDoc("annotationGlobals");
        lascia imagePromises;
        const missingBitmaps = new Set();
        per (cost {
          bitmapId,
          mappa di bit
        } di nuoveAnnotazioni) {
          se (bitmapId && !bitmap && !missingBitmaps.has(bitmapId)) {
            missingBitmaps.add(bitmapId);
          }
        }
        costante {
          èOffscreenCanvasSupported
        } = this.evaluatorOptions;
        se (dimensioneBitmapmancanti > 0) {
          const annotationWithBitmaps = newAnnotations.slice();
          per (const [chiave, annotazione] di annotationStorage) {
            se (!key.startsWith(_util.AnnotationEditorPrefix)) {
              continuare;
            }
            se (annotazione.bitmap && missingBitmaps.has(annotazione.bitmapId)) {
              annotazioneConBitmap.push(annotazione);
            }
          }
          imagePromises = _annotation.AnnotationFactory.generateImages(annotationWithBitmaps, this.xref, isOffscreenCanvasSupported);
        } altro {
          imagePromises = _annotation.AnnotationFactory.generateImages(newAnnotations, this.xref, isOffscreenCanvasSupported);
        }
        deleteAnnotations = new _primitives.RefSet();
        questo.#replaceIdByRef(nuoveAnnotazioni, cancellateAnnotazioni, null);
        newAnnotationsPromise = annotationGlobalsPromise.then(annotationGlobals => {
          se (!annotationGlobals) {
            restituisci null;
          }
          restituisci _annotation.AnnotationFactory.printNewAnnotations(annotationGlobals, partialEvaluator, task, newAnnotations, imagePromises);
        });
      }
    }
    const dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);
    const pageListPromise = dataPromises.then(([contentStream]) => {
      const opList = new _operator_list.OperatorList(intento, sink);
      handler.send("StartRenderPage", {
        trasparenza: partialEvaluator.hasBlendModes(this.resources, this.nonBlendModesSet),
        pageIndex: this.pageIndex,
        chiave della cache
      });
      restituisci partialEvaluator.getOperatorList({
        flusso: contentStream,
        compito,
        risorse: questo.risorse,
        operatorList: opList
      }).then(funzione () {
        restituisci opList;
      });
    });
    restituisci Promise.all([pageListPromise, this._parsedAnnotations, newAnnotationsPromise]).then(function ([pageOpList, annotations, newAnnotations]) {
      se (nuoveAnnotazioni) {
        annotazioni = annotazioni.filter(a => !(a.ref && deletedAnnotations.has(a.ref)));
        per (lascia che i = 0, ii = newAnnotations.length; i < ii; i++) {
          const newAnnotation = newAnnotations[i];
          se (nuovaAnnotazione.refDaSostituire) {
            const j = annotations.findIndex(a => a.ref && (0, _primitives.isRefsEqual)(a.ref, newAnnotation.refToReplace));
            se (j >= 0) {
              annotazioni.splice(j, 1, nuovaAnnotazione);
              nuoveAnnotazioni.splice(i--, 1);
              ii--;
            }
          }
        }
        annotazioni = annotazioni.concat(nuoveAnnotazioni);
      }
      se (annotazioni.lunghezza === 0 || intento & _util.RenderingIntentFlag.ANNOTATIONS_DISABLE) {
        pageOpList.flush(true);
        ritorno {
          lunghezza: pageOpList.totalLength
        };
      }
      const renderForms = !!(intent & _util.RenderingIntentFlag.ANNOTATIONS_FORMS),
        intentAny = !!(intent & _util.RenderingIntentFlag.ANY),
        intentDisplay = !!(intent & _util.RenderingIntentFlag.DISPLAY),
        intentPrint = !!(intent & _util.RenderingIntentFlag.PRINT);
      const opListPromises = [];
      per (annotazione costante di annotazioni) {
        se (intentAny || intentDisplay && annotation.mustBeViewed(annotationStorage, renderForms) || intentPrint && annotation.mustBePrinted(annotationStorage)) {
          opListPromises.push(annotation.getOperatorList(partialEvaluator, task, intent, renderForms, annotationStorage).catch(function (reason) {
            (0, _util.warn)("getOperatorList - ignora i dati di annotazione durante l'attività " + `"${task.name}": "${reason}".`);
            ritorno {
              opList: null,
              separateForm: falso,
              separateCanvas: falso
            };
          }));
        }
      }
      restituisci Promise.all(opListPromises).then(function (opLists) {
        lascia che la forma = falso,
          tela = falso;
        per (cost {
          opList,
          separateForm,
          separateCanvas
        } di opList) {
          pageOpList.addOpList(opList);
          modulo ||= separateForm;
          tela ||= separateCanvas;
        }
        pageOpList.flush(true, {
          modulo,
          tela
        });
        ritorno {
          lunghezza: pageOpList.totalLength
        };
      });
    });
  }
  estrai il contenuto del testo ({
    gestore,
    compito,
    includeMarkedContent,
    Disabilita la normalizzazione,
    lavello
  }) {
    const contentStreamPromise = this.getContentStream();
    const resourcesPromise = this.loadResources(["ExtGState", "Font", "Proprietà", "XObject"]);
    const dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);
    restituisci dataPromises.then(([contentStream]) => {
      const partialEvaluator = new _evaluator.PartialEvaluator({
        xrif: questo.xrif,
        gestore,
        pageIndex: this.pageIndex,
        idFactory: this._localIdFactory,
        fontCache: this.fontCache,
        builtInCMapCache: questo.builtInCMapCache,
        standardFontDataCache: this.standardFontDataCache,
        globalImageCache: this.globalImageCache,
        systemFontCache: this.systemFontCache,
        opzioni: this.evaluatorOptions
      });
      restituisci partialEvaluator.getTextContent({
        flusso: contentStream,
        compito,
        risorse: questo.risorse,
        includeMarkedContent,
        Disabilita la normalizzazione,
        lavello,
        viewBox: questa vista
      });
    });
  }
  getStructTree asincrono() {
    const structTreeRoot = await this.pdfManager.ensureCatalog("structTreeRoot");
    se (!structTreeRoot) {
      restituisci null;
    }
    attendi questo._parsedAnnotations;
    const structTree = await this.pdfManager.ensure(this, "_parseStructTree", [structTreeRoot]);
    restituisci structTree.serializable;
  }
  _parseStructTree(structTreeRoot) {
    const tree = new _struct_tree.StructTreePage(structTreeRoot, this.pageDict);
    albero.parse(questo.rif);
    albero di ritorno;
  }
  async getAnnotationsData(gestore, attività, intento) {
    const annotations = await this._parsedAnnotations;
    se (annotazioni.lunghezza === 0) {
      restituire annotazioni;
    }
    annotazioni costantiData = [],
      textContentPromises = [];
    lascia partialEvaluator;
    const intentAny = !!(intent & _util.RenderingIntentFlag.ANY),
      intentDisplay = !!(intent & _util.RenderingIntentFlag.DISPLAY),
      intentPrint = !!(intent & _util.RenderingIntentFlag.PRINT);
    per (annotazione costante di annotazioni) {
      const isVisible = intentAny || intentDisplay && annotation.viewable;
      se (isVisible || intentPrint && annotation.printable) {
        annotazioniData.push(annotazione.dati);
      }
      se (annotazione.hasTextContent && isVisible) {
        partialEvaluator ||= nuovo _evaluator.PartialEvaluator({
          xrif: questo.xrif,
          gestore,
          pageIndex: this.pageIndex,
          idFactory: this._localIdFactory,
          fontCache: this.fontCache,
          builtInCMapCache: questo.builtInCMapCache,
          standardFontDataCache: this.standardFontDataCache,
          globalImageCache: this.globalImageCache,
          systemFontCache: this.systemFontCache,
          opzioni: this.evaluatorOptions
        });
        textContentPromises.push(annotation.extractTextContent(partialEvaluator, task, [-Infinity, -Infinity, Infinity, Infinity]).catch(function (reason) {
          (0, _util.warn)(`getAnnotationsData - ignorare textContent durante l'attività "${task.name}": "${reason}".`);
        }));
      }
    }
    attendi Promise.all(textContentPromises);
    restituisci annotazioniDati;
  }
  ottenere annotazioni() {
    const annots = this._getInheritableProperty("Annots");
    return (0, _util.shadow)(this, "annotations", Array.isArray(annots) ? annots : []);
  }
  ottieni _parsedAnnotations() {
    const promise = this.pdfManager.ensure(this, "annotazioni").then(async annots => {
      se (annots.length === 0) {
        restituisci annotazioni;
      }
      const annotationGlobals = await this.pdfManager.ensureDoc("annotationGlobals");
      se (!annotationGlobals) {
        ritorno [];
      }
      const annotationPromises = [];
      per (const annotationRef di annots) {
        annotationPromises.push(_annotation.AnnotationFactory.create(this.xref, annotationRef, annotationGlobals, this._localIdFactory, false, this.ref).catch(function (reason) {
          (0, _util.warn)(`_parsedAnnotations: "${reason}".`);
          restituisci null;
        }));
      }
      const ordinateAnnotazioni = [];
      lascia popupAnnotazioni;
      per (annotazione costante di await Promise.all(annotationPromises)) {
        se (!annotazione) {
          continuare;
        }
        se (annotazione instanceof _annotation.PopupAnnotation) {
          (popupAnnotazioni ||= []).push(annotazione);
          continuare;
        }
        sortedAnnotations.push(annotazione);
      }
      se (popupAnnotazioni) {
        sortedAnnotations.push(...popupAnnotations);
      }
      restituisci Annotazioni ordinate;
    });
    return (0, _util.shadow)(this, "_parsedAnnotations", promise);
  }
  ottieni jsActions() {
    azioni costanti = (0, _core_utils.collectActions)(this.xref, this.pageDict, _util.PageActionEventType);
    return (0, _util.shadow)(this, "jsActions", actions);
  }
}
esportazioni.Pagina = Pagina;
const PDF_HEADER_SIGNATURE = new Uint8Array([0x25, 0x50, 0x44, 0x46, 0x2d]);
const STARTXREF_SIGNATURE = new Uint8Array([0x73, 0x74, 0x61, 0x72, 0x74, 0x78, 0x72, 0x65, 0x66]);
const ENDOBJ_SIGNATURE = new Uint8Array([0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a]);
const FINGERPRINT_FIRST_BYTES = 1024;
const EMPTY_FINGERPRINT = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";
funzione find(stream, firma, limite = 1024, indietro = falso) {
  const signatureLength = signature.length;
  const scanBytes = stream.peekBytes(limite);
  const scanLength = scanBytes.length - signatureLength;
  se (lunghezza scansione <= 0) {
    restituisci falso;
  }
  se (all'indietro) {
    const signatureEnd = signatureLength - 1;
    lascia pos = scanBytes.length - 1;
    while (pos >= signatureEnd) {
      sia j = 0;
      while (j < signatureLength && scanBytes[pos - j] === signature[signatureEnd - j]) {
        j++;
      }
      se (j >= lunghezzafirma) {
        stream.pos += pos - signatureEnd;
        restituisci vero;
      }
      pos--;
    }
  } altro {
    lascia pos = 0;
    while (pos <= lunghezza scansione) {
      sia j = 0;
      while (j < signatureLength && scanBytes[pos + j] === signature[j]) {
        j++;
      }
      se (j >= lunghezzafirma) {
        flusso.pos += pos;
        restituisci vero;
      }
      posizione++;
    }
  }
  restituisci falso;
}
classe PDFDocument {
  costruttore(pdfManager, flusso) {
    se (lunghezza del flusso <= 0) {
      throw new _util.InvalidPDFException("Il file PDF è vuoto, ovvero la sua dimensione è pari a zero byte.");
    }
    questo.pdfManager = pdfManager;
    questo.flusso = flusso;
    this.xref = new _xref.XRef(stream, pdfManager);
    this._pagePromises = nuova mappa();
    this._version = null;
    const idCounters = {
      carattere: 0
    };
    this._globalIdFactory = classe {
      getDocId() statico {
        restituisci `g_${pdfManager.docId}`;
      }
      statico createFontId() {
        restituisci `f${++idCounters.font}`;
      }
      statico createObjId() {
        (0, _util.unreachable)("Metodo astratto `createObjId` chiamato.");
      }
      getPageObjId() statico {
        (0, _util.unreachable)("Metodo astratto `getPageObjId` chiamato.");
      }
    };
  }
  analizza(modalitàdirecupero) {
    this.xref.parse(recoveryMode);
    questo.catalogo = nuovo _catalogo.Catalog(questo.pdfManager, questo.xref);
  }
  ottenere linearizzazione() {
    lascia linearizzazione = null;
    Tentativo {
      linearizzazione = _parser.Linearization.create(this.stream);
    } cattura (error) {
      se (errore instanceof _core_utils.MissingDataException) {
        lanciare err;
      }
      (0, _util.info)(err);
    }
    return (0, _util.shadow)(this, "linearizzazione", linearizzazione);
  }
  ottieni startXRef() {
    const stream = this.stream;
    lascia startXRef = 0;
    se (questa.linearizzazione) {
      stream.reset();
      se (trova(flusso, ENDOBJ_SIGNATURE)) {
        startXRef = stream.pos + 6 - stream.start;
      }
    } altro {
      passo costante = 1024;
      const startXRefLength = STARTXREF_SIGNATURE.length;
      lascia trovato = falso,
        pos = stream.end;
      mentre (!found && pos > 0) {
        pos -= passo - startXRefLength;
        se (pos < 0) {
          posizione = 0;
        }
        flusso.pos = pos;
        trovato = trova(flusso, STARTXREF_SIGNATURE, passo, vero);
      }
      se (trovato) {
        flusso.salta(9);
        lascia ch;
        Fare {
          ch = stream.getByte();
        } while ((0, _core_utils.isWhiteSpace)(ch));
        lascia str = "";
        mentre (ch >= 0x20 e ch <= 0x39) {
          str += String.fromCharCode(ch);
          ch = stream.getByte();
        }
        startXRef = parseInt(str, 10);
        se (isNaN(startXRef)) {
          inizioXRif = 0;
        }
      }
    }
    return (0, _util.shadow)(this, "startXRef", startXRef);
  }
  controllaIntestazione() {
    const stream = this.stream;
    stream.reset();
    se (!find(flusso, PDF_HEADER_SIGNATURE)) {
      ritorno;
    }
    stream.moveStart();
    stream.skip(PDF_HEADER_SIGNATURE.length);
    lascia versione = "",
      cap;
    while ((ch = stream.getByte()) > 0x20 && version.length < 7) {
      versione += String.fromCharCode(ch);
    }
    se (_core_utils.PDF_VERSION_REGEXP.test(versione)) {
      this._version = versione;
    } altro {
      (0, _util.warn)(`Versione dell'intestazione PDF non valida: ${version}`);
    }
  }
  parseStartXRef() {
    questo.xref.setStartXRef(questo.startXRef);
  }
  ottieni numPages() {
    lascia num = 0;
    se (questo.catalogo.hasActualNumPages) {
      num = questo.catalogo.numPagine;
    } altrimenti se (this.xfaFactory) {
      num = this.xfaFactory.getNumPages();
    } altrimenti se (questa.linearizzazione) {
      num = this.linearization.numPages;
    } altro {
      num = questo.catalogo.numPagine;
    }
    return (0, _util.shadow)(this, "numPages", num);
  }
  _hasOnlyDocumentSignatures(campi, profondità ricorsione = 0) {
    const LIMITE_RICURSIONE = 10;
    se (!Array.isArray(campi)) {
      restituisci falso;
    }
    restituisci campi.ogni(campo => {
      campo = this.xref.fetchIfRef(campo);
      se (!(campo instanceof _primitives.Dict)) {
        restituisci falso;
      }
      se (campo.has("Bambini")) {
        se (++profonditàricorsione > LIMITE_RICORSIONE) {
          (0, _util.warn)("_hasOnlyDocumentSignatures: raggiunta la profondità massima di ricorsione");
          restituisci falso;
        }
        restituisci questo._hasOnlyDocumentSignatures(field.get("Bambini"), recursionDepth);
      }
      const isSignature = (0, _primitives.isName)(field.get("FT"), "Sig");
      const rettangolo = campo.get("Rettangolo");
      const isInvisible = Array.isArray(rettangolo) && rettangolo.ogni(valore => valore === 0);
      restituisci isSignature && isInvisible;
    });
  }
  ottieni _xfaStreams() {
    const acroForm = this.catalog.acroForm;
    se (!acroForm) {
      restituisci null;
    }
    const xfa = acroForm.get("XFA");
    voci costanti = {
      "xdp:xdp": "",
      modello: "",
      set di dati: "",
      configurazione: "",
      set di connessione: "",
      localeSet: "",
      foglio di stile: "",
      "/xdp:xdp": ""
    };
    if (xfa istanza di _base_stream.BaseStream && !xfa.isEmpty) {
      voci["xdp:xdp"] = xfa;
      voci di ritorno;
    }
    if (!Array.isArray(xfa) || xfa.lunghezza === 0) {
      restituisci null;
    }
    per (lascia che i = 0, ii = xfa.length; i < ii; i += 2) {
      lascia il nome;
      se (i === 0) {
        nome = "xdp:xdp";
      } altrimenti se (i === ii - 2) {
        nome = "/xdp:xdp";
      } altro {
        nome = xfa[i];
      }
      se (!entries.hasOwnProperty(nome)) {
        continuare;
      }
      dati costanti = this.xref.fetchIfRef(xfa[i + 1]);
      se (!(istanza di dati di _base_stream.BaseStream) || dati.èVuoto) {
        continuare;
      }
      voci[nome] = dati;
    }
    voci di ritorno;
  }
  ottieni xfaDatasets() {
    flussi costanti = this._xfaStreams;
    se (!flussi) {
      return (0, _util.shadow)(this, "xfaDatasets", null);
    }
    per (chiave costante di ["dataset", "xdp:xdp"]) {
      const stream = streams[chiave];
      se (!flusso) {
        continuare;
      }
      Tentativo {
        const str = (0, _util.stringToUTF8String)(stream.getString());
        dati costanti = {
          [chiave]: str
        };
        return (0, _util.shadow)(this, "xfaDatasets", new _dataset_reader.DatasetReader(data));
      } presa {
        (0, _util.warn)("XFA - Stringa utf-8 non valida.");
        rottura;
      }
    }
    return (0, _util.shadow)(this, "xfaDatasets", null);
  }
  ottieni xfaData() {
    flussi costanti = this._xfaStreams;
    se (!flussi) {
      restituisci null;
    }
    dati costanti = Object.create(null);
    per (const [chiave, flusso] di Object.entries(flussi)) {
      se (!flusso) {
        continuare;
      }
      Tentativo {
        dati[chiave] = (0, _util.stringToUTF8String)(stream.getString());
      } presa {
        (0, _util.warn)("XFA - Stringa utf-8 non valida.");
        restituisci null;
      }
    }
    restituire i dati;
  }
  ottieni xfaFactory() {
    lascia i dati;
    se (this.pdfManager.enableXfa && this.catalog.needsRendering && this.formInfo.hasXfa && !this.formInfo.hasAcroForm) {
      dati = questo.xfaData;
    }
    return (0, _util.shadow)(this, "xfaFactory", data ? new _factory.XFAFactory(data) : null);
  }
  ottieni isPureXfa() {
    restituisci this.xfaFactory ? this.xfaFactory.isValid() : false;
  }
  ottenere htmlForXfa() {
    restituisci this.xfaFactory ? this.xfaFactory.getPages() : null;
  }
  caricamento asincronoXfaImages() {
    const xfaImagesDict = await this.pdfManager.ensureCatalog("xfaImages");
    se (!xfaImagesDict) {
      ritorno;
    }
    chiavi costanti = xfaImagesDict.getKeys();
    const objectLoader = new _object_loader.ObjectLoader(xfaImagesDict, keys, this.xref);
    attendi objectLoader.load();
    const xfaImages = new Map();
    per (const chiave di chiavi) {
      flusso costante = xfaImagesDict.get(chiave);
      se (istanza di flusso di _base_stream.BaseStream) {
        xfaImages.set(chiave, stream.getBytes());
      }
    }
    this.xfaFactory.setImages(xfaImages);
  }
  async loadXfaFonts(gestore, attività) {
    const acroForm = await this.pdfManager.ensureCatalog("acroForm");
    se (!acroForm) {
      ritorno;
    }
    const resources = await acroForm.getAsync("DR");
    se (!(risorse instanceof _primitives.Dict)) {
      ritorno;
    }
    const objectLoader = new _object_loader.ObjectLoader(risorse, ["Font"], this.xref);
    attendi objectLoader.load();
    const fontRes = resources.get("Font");
    se (!(fontRes instanceof _primitives.Dict)) {
      ritorno;
    }
    const options = Object.assign(Object.create(null), this.pdfManager.evaluatorOptions);
    opzioni.useSystemFonts = false;
    const partialEvaluator = new _evaluator.PartialEvaluator({
      xrif: questo.xrif,
      gestore,
      Indice pagina: -1,
      idFactory: this._globalIdFactory,
      fontCache: this.catalog.fontCache,
      builtInCMapCache: this.catalog.builtInCMapCache,
      standardFontDataCache: this.catalog.standardFontDataCache,
      opzioni
    });
    const operatorList = new _operator_list.OperatorList();
    const pdfFonts = [];
    const statoiniziale = {
      ottieni font() {
        restituisci pdfFonts.at(-1);
      },
      imposta font(font) {
        pdfFonts.push(font);
      },
      clona() {
        restituisci questo;
      }
    };
    const fonts = new Map();
    fontRes.forEach((fontName, font) => {
      fonts.set(nomefont, font);
    });
    promesse costanti = [];
    per (const [fontName, font] di font) {
      const descrittore = font.get("FontDescriptor");
      se (!(descrittore instanceof _primitives.Dict)) {
        continuare;
      }
      lascia fontFamily = descriptor.get("FontFamily");
      fontFamily = fontFamily.replaceAll(/[ ]+(\d)/g, "$1");
      const fontWeight = descriptor.get("FontWeight");
      const italicAngle = -descriptor.get("ItalicAngle");
      const cssFontInfo = {
        famiglia di caratteri,
        fontWeight,
        Angolo corsivo
      };
      se (!(0, _core_utils.validateCSSFont)(cssFontInfo)) {
        continuare;
      }
      promises.push(partialEvaluator.handleSetFont(resources, [_primitives.Name.get(fontName), 1], null, operatorList, task, initialState, null, cssFontInfo).catch(function (reason) {
        (0, _util.warn)(`loadXfaFonts: "${reason}".`);
        restituisci null;
      }));
    }
    attendi Promise.all(promesse);
    const missingFonts = this.xfaFactory.setFonts(pdfFonts);
    se (!caratterimancanti) {
      ritorno;
    }
    opzioni.ignoreErrors = true;
    promesse.lunghezza = 0;
    pdfFonts.length = 0;
    const reallyMissingFonts = new Set();
    per (const mancante di missingFonts) {
      se (!(0, _xfa_fonts.getXfaFontName)(`${missing}-Regular`)) {
        reallyMissingFonts.add(mancante);
      }
    }
    se (reallyMissingFonts.size) {
      missingFonts.push("PdfJS-Fallback");
    }
    per (const mancante di missingFonts) {
      se (reallyMissingFonts.has(mancante)) {
        continuare;
      }
      per (const fontInfo di [{
        nome: "Regolare",
        fontWeight: 400,
        Angolo corsivo: 0
      }, {
        nome: "Grassetto",
        fontWeight: 700,
        Angolo corsivo: 0
      }, {
        nome: "Corsivo",
        fontWeight: 400,
        Angolo corsivo: 12
      }, {
        nome: "GrassettoCorsivo",
        fontWeight: 700,
        Angolo corsivo: 12
      }]) {
        const name = `${missing}-${fontInfo.name}`;
        const dict = (0, _xfa_fonts.getXfaFontDict)(nome);
        promises.push(partialEvaluator.handleSetFont(resources, [_primitives.Name.get(name), 1], null, operatorList, task, initialState, dict, {
          fontFamily: mancante,
          fontWeight: fontInfo.fontWeight,
          italicAngle: fontInfo.italicAngle
        }).catch(funzione (motivo) {
          (0, _util.warn)(`loadXfaFonts: "${reason}".`);
          restituisci null;
        }));
      }
    }
    attendi Promise.all(promesse);
    this.xfaFactory.appendFonts(pdfFonts, reallyMissingFonts);
  }
  serializzazione asincrona XfaData (annotazione archiviazione) {
    restituisci this.xfaFactory ? this.xfaFactory.serializeData(annotationStorage) : null;
  }
  ottieni versione() {
    restituisci questa.versione.catalogo || questa._versione;
  }
  ottieni formInfo() {
    const formInfo = {
      hasFields: falso,
      hasAcroForm: falso,
      hasXfa: falso,
      hasSignatures: falso
    };
    const acroForm = this.catalog.acroForm;
    se (!acroForm) {
      return (0, _util.shadow)(this, "formInfo", formInfo);
    }
    Tentativo {
      const fields = acroForm.get("Campi");
      const hasFields = Array.isArray(campi) && campi.lunghezza > 0;
      formInfo.hasFields = haFields;
      const xfa = acroForm.get("XFA");
      formInfo.hasXfa = Array.isArray(xfa) && xfa.length > 0 || xfa istanza di _base_stream.BaseStream && !xfa.isEmpty;
      const sigFlags = acroForm.get("SigFlags");
      const haFirme = !!(sigFlags & 0x1);
      const hasOnlyDocumentSignatures = hasSignatures && this._hasOnlyDocumentSignatures(campi);
      formInfo.hasAcroForm = hasFields && !hasOnlyDocumentSignatures;
      formInfo.hasSignatures = haFirme;
    } catturare (es.) {
      se (ad esempio instanceof _core_utils.MissingDataException) {
        lanciare ex;
      }
      (0, _util.warn)(`Impossibile recuperare le informazioni del modulo: "${ex}".`);
    }
    return (0, _util.shadow)(this, "formInfo", formInfo);
  }
  ottieni documentInfo() {
    const docInfo = {
      PDFFormatVersion: questa.versione,
      Lingua: this.catalog.lang,
      EncryptFilterName: this.xref.encrypt ? this.xref.encrypt.filterName : null,
      IsLinearized: !!this.linearization,
      IsAcroFormPresent: this.formInfo.hasAcroForm,
      IsXFAPresent: this.formInfo.hasXfa,
      IsCollectionPresent: !!this.catalog.collection,
      IsSignaturesPresent: this.formInfo.hasSignatures
    };
    lascia infoDict;
    Tentativo {
      infoDict = this.xref.trailer.get("Info");
    } cattura (error) {
      se (errore instanceof _core_utils.MissingDataException) {
        lanciare err;
      }
      (0, _util.info)("Il dizionario delle informazioni del documento non è valido.");
    }
    se (!(infoDict instanceof _primitives.Dict)) {
      return (0, _util.shadow)(this, "documentInfo", docInfo);
    }
    per (const chiave di infoDict.getKeys()) {
      valore costante = infoDict.get(chiave);
      interruttore (chiave) {
        caso "Titolo":
        caso "Autore":
        caso "Soggetto":
        caso "Parole chiave":
        caso "Creatore":
        caso "Produttore":
        caso "CreationDate":
        caso "ModDate":
          se (tipo di valore === "stringa") {
            docInfo[chiave] = (0, _util.stringToPDFString)(valore);
            continuare;
          }
          rottura;
        caso "Intrappolato":
          se (valore instanceof _primitives.Name) {
            docInfo[chiave] = valore;
            continuare;
          }
          rottura;
        predefinito:
          lascia valorepersonalizzato;
          switch (tipo di valore) {
            caso "stringa":
              customValue = (0, _util.stringToPDFString)(valore);
              rottura;
            caso "numero":
            caso "booleano":
              customValue = valore;
              rottura;
            predefinito:
              se (valore instanceof _primitives.Name) {
                customValue = valore;
              }
              rottura;
          }
          se (customValue === indefinito) {
            (0, _util.warn)(`Valore non valido per la chiave personalizzata "${key}", in Info: ${value}.`);
            continuare;
          }
          se (!docInfo.Custom) {
            docInfo.Custom = Object.create(null);
          }
          docInfo.Custom[chiave] = valorepersonalizzato;
          continuare;
      }
      (0, _util.warn)(`Valore non valido, per la chiave "${key}", in Info: ${value}.`);
    }
    return (0, _util.shadow)(this, "documentInfo", docInfo);
  }
  ottenere impronte digitali() {
    funzione validate(data) {
      restituisci tipo di dati === "stringa" && lunghezza dati > 0 && dati !== EMPTY_FINGERPRINT;
    }
    funzione hexString(hash) {
      const buf = [];
      per (const numero di hash) {
        const hex = num.toString(16);
        buf.push(hex.padStart(2, "0"));
      }
      restituisci buf.join("");
    }
    const idArray = this.xref.trailer.get("ID");
    lascia hashOriginal, hashModified;
    se (Array.isArray(idArray) && validate(idArray[0])) {
      hashOriginal = (0, _util.stringToBytes)(idArray[0]);
      se (idArray[1] !== idArray[0] && validate(idArray[1])) {
        hashModificato = (0, _util.stringToBytes)(idArray[1]);
      }
    } altro {
      hashOriginal = (0, _crypto.calculateMD5)(this.stream.getByteRange(0, FINGERPRINT_FIRST_BYTES), 0, FINGERPRINT_FIRST_BYTES);
    }
    return (0, _util.shadow)(this, "impronte digitali", [hexString(hashOriginal), hashModified ? hexString(hashModified) : null]);
  }
  async _getLinearizationPage(pageIndex) {
    costante {
      catalogare,
      linearizzazione,
      riferimento esterno
    } = questo;
    const ref = _primitives.Ref.get(linearization.objectNumberFirst, 0);
    Tentativo {
      const obj = attendi xref.fetchAsync(ref);
      se (oggetto istanza di _primitives.Dict) {
        lascia tipo = obj.getRaw("Tipo");
        se (tipo instanceof _primitives.Ref) {
          tipo = attendi xref.fetchAsync(tipo);
        }
        se ((0, _primitives.isName)(tipo, "Pagina") || !obj.has("Tipo") && !obj.has("Bambini")) {
          se (!catalog.pageKidsCountCache.has(ref)) {
            catalog.pageKidsCountCache.put(ref, 1);
          }
          se (!catalog.pageIndexCache.has(ref)) {
            catalogo.pageIndexCache.put(ref, 0);
          }
          restituisci [oggetto, riferimento];
        }
      }
      throw new _util.FormatError("Il dizionario di linearizzazione non punta a un dizionario di pagina valido.");
    } cattura (motivo) {
      (0, _util.warn)(`_getLinearizationPage: "${reason.message}".`);
      restituisci catalog.getPageDict(pageIndex);
    }
  }
  getPage(indicepagina) {
    const cachedPromise = this._pagePromises.get(pageIndex);
    se (cachedPromise) {
      restituisci cachedPromise;
    }
    costante {
      catalogare,
      linearizzazione,
      xfaFactory
    } = questo;
    lascia promettere;
    se (xfaFactory) {
      promessa = Promise.resolve([_primitives.Dict.empty, null]);
    } altrimenti se (linearizzazione?.pageFirst === pageIndex) {
      promessa = this._getLinearizationPage(pageIndex);
    } altro {
      promessa = catalogo.getPageDict(indicepagina);
    }
    promessa = promessa.then(([pageDict, ref]) => {
      restituisci nuova pagina({
        pdfManager: questo.pdfManager,
        xrif: questo.xrif,
        indice della pagina,
        pageDict,
        rif.
        globalIdFactory: this._globalIdFactory,
        fontCache: catalogo.fontCache,
        builtInCMapCache: catalogo.builtInCMapCache,
        standardFontDataCache: catalogo.standardFontDataCache,
        globalImageCache: catalogo.globalImageCache,
        systemFontCache: catalogo.systemFontCache,
        nonBlendModesSet: catalog.nonBlendModesSet,
        xfaFactory
      });
    });
    this._pagePromises.set(pageIndex, promise);
    promessa di ritorno;
  }
  async checkFirstPage(recoveryMode = false) {
    se (modalità di recupero) {
      ritorno;
    }
    Tentativo {
      attendi questo.getPage(0);
    } cattura (motivo) {
      se (motivo instanceof _core_utils.XRefEntryException) {
        this._pagePromises.delete(0);
        attendi questo.cleanup();
        genera una nuova eccezione _core_utils.XRefParseException();
      }
    }
  }
  async checkLastPage(recoveryMode = false) {
    costante {
      catalogare,
      pdfManager
    } = questo;
    catalogo.setActualNumPages();
    lascia numPages;
    Tentativo {
      attendi Promise.all([pdfManager.ensureDoc("xfaFactory"), pdfManager.ensureDoc("linearizzazione"), pdfManager.ensureCatalog("numPages")]);
      se (this.xfaFactory) {
        ritorno;
      } altrimenti se (questa.linearizzazione) {
        numPages = this.linearization.numPages;
      } altro {
        numPages = catalogo.numPages;
      }
      se (!Numero.èIntero(numPagine)) {
        throw new _util.FormatError("Il conteggio delle pagine non è un numero intero.");
      } altrimenti se (numPagine <= 1) {
        ritorno;
      }
      attendi questo.getPage(numPages - 1);
    } cattura (motivo) {
      this._pagePromises.delete(numPages - 1);
      attendi questo.cleanup();
      se (motivo instanceof _core_utils.XRefEntryException && !recoveryMode) {
        genera una nuova eccezione _core_utils.XRefParseException();
      }
      (0, _util.warn)(`checkLastPage - albero /Pages non valido /Count: ${numPages}.`);
      lascia pagesTree;
      Tentativo {
        pagesTree = attendi catalog.getAllPageDicts(recoveryMode);
      } cattura (motivoTutti) {
        se (motivoTutte le istanze di _core_utils.XRefEntryException && !recoveryMode) {
          genera una nuova eccezione _core_utils.XRefParseException();
        }
        catalogo.setActualNumPages(1);
        ritorno;
      }
      per (const [pageIndex, [pageDict, ref]] di pagesTree) {
        lascia promettere;
        se (pageDict instanceof Errore) {
          promessa = Promise.reject(pageDict);
          promessa.catch(() => {});
        } altro {
          promessa = Promessa.risolvi(nuova pagina({
            pdfManager,
            xrif: questo.xrif,
            indice della pagina,
            pageDict,
            rif.
            globalIdFactory: this._globalIdFactory,
            fontCache: catalogo.fontCache,
            builtInCMapCache: catalogo.builtInCMapCache,
            standardFontDataCache: catalogo.standardFontDataCache,
            globalImageCache: catalogo.globalImageCache,
            systemFontCache: catalogo.systemFontCache,
            nonBlendModesSet: catalog.nonBlendModesSet,
            xfaFactory: null
          }));
        }
        this._pagePromises.set(pageIndex, promise);
      }
      catalog.setActualNumPages(pagesTree.size);
    }
  }
  fontFallback(id, gestore) {
    restituisci this.catalog.fontFallback(id, gestore);
  }
  pulizia asincrona (attivata manualmente = false) {
    restituisci questo.catalogo ? this.catalog.cleanup(manuallyTriggered) : (0, _cleanup_helper.clearGlobalCaches)();
  }
  #collectFieldObjects(nome, fieldRef, promesse, annotationGlobals) {
    const campo = this.xref.fetchIfRef(fieldRef);
    se (campo.has("T")) {
      const partName = (0, _util.stringToPDFString)(field.get("T"));
      nome = nome === "" ? nomeparte : `${nome}.${nomeparte}`;
    }
    se (!promesse.has(nome)) {
      promises.set(nome, []);
    }
    promises.get(name).push(_annotation.AnnotationFactory.create(this.xref, fieldRef, annotationGlobals, this._localIdFactory, true, null).then(annotation => annotation?.getFieldObject()).catch(function (reason) {
      (0, _util.warn)(`#collectFieldObjects: "${reason}".`);
      restituisci null;
    }));
    se (campo.has("Bambini")) {
      per (const bambino di campo.get("Bambini")) {
        questo.#collectFieldObjects(nome, bambino, promesse, annotazioniGlobals);
      }
    }
  }
  ottieni fieldObjects() {
    se (!this.formInfo.hasFields) {
      return (0, _util.shadow)(this, "fieldObjects", Promise.resolve(null));
    }
    const promise = this.pdfManager.ensureDoc("annotationGlobals").then(async annotationGlobals => {
      se (!annotationGlobals) {
        restituisci null;
      }
      const allFields = Object.create(null);
      const fieldPromises = new Map();
      per (const fieldRef di this.catalog.acroForm.get("Campi")) {
        questo.#collectFieldObjects("", fieldRef, fieldPromises, annotationGlobals);
      }
      const allPromises = [];
      per (const [nome, promesse] di fieldPromises) {
        allPromises.push(Promise.all(promesse).then(campi => {
          campi = campi.filtro(campo => !!campo);
          se (lunghezza campi > ​​0) {
            allFields[nome] = campi;
          }
        }));
      }
      attendi Promise.all(allPromises);
      restituisci tutti i campi;
    });
    return (0, _util.shadow)(this, "fieldObjects", promise);
  }
  ottieni hasJSActions() {
    promessa costante = this.pdfManager.ensureDoc("_parseHasJSActions");
    return (0, _util.shadow)(this, "hasJSActions", promise);
  }
  asincrono _parseHasJSActions() {
    const [catalogJsActions, fieldObjects] = await Promise.all([this.pdfManager.ensureCatalog("jsActions"), this.pdfManager.ensureDoc("fieldObjects")]);
    se (catalogJsActions) {
      restituisci vero;
    }
    se (fieldObjects) {
      restituisci Object.values(fieldObjects).some(fieldObject => fieldObject.some(object => object.actions !== null));
    }
    restituisci falso;
  }
  ottenere calculationOrderIds() {
    const acroForm = this.catalog.acroForm;
    se (!acroForm?.has("CO")) {
      return (0, _util.shadow)(this, "calculationOrderIds", null);
    }
    const calculationOrder = acroForm.get("CO");
    se (!Array.isArray(calculationOrder) || calculationOrder.length === 0) {
      return (0, _util.shadow)(this, "calculationOrderIds", null);
    }
    const id = [];
    per (id costante di calculationOrder) {
      se (id instanceof _primitives.Ref) {
        ids.push(id.toString());
      }
    }
    se (ids.length === 0) {
      return (0, _util.shadow)(this, "calculationOrderIds", null);
    }
    return (0, _util.shadow)(this, "calculationOrderIds", ids);
  }
  ottieni annotationGlobals() {
    return (0, _util.shadow)(this, "annotationGlobals", _annotation.AnnotationFactory.createGlobals(this.pdfManager));
  }
}
esportazioni.PDFDocument = PDFDocument;

/***/ }),
/* 10 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
exports.PopupAnnotation = exports.MarkupAnnotation = exports.AnnotationFactory = exports.AnnotationBorderStyle = exports.Annotation = void 0;
esportazioni.getQuadPoints = getQuadPoints;
var _util = __w_pdfjs_require__(2);
var _core_utils = __w_pdfjs_require__(3);
var _default_appearance = __w_pdfjs_require__(11);
var _primitives = __w_pdfjs_require__(4);
var _stream = __w_pdfjs_require__(8);
var _base_stream = __w_pdfjs_require__(5);
var _bidi = __w_pdfjs_require__(60);
var _catalog = __w_pdfjs_require__(66);
var _colorspace = __w_pdfjs_require__(12);
var _file_spec = __w_pdfjs_require__(69);
var _jpeg_stream = __w_pdfjs_require__(26);
var _object_loader = __w_pdfjs_require__(76);
var _operator_list = __w_pdfjs_require__(64);
var _writer = __w_pdfjs_require__(73);
var _factory = __w_pdfjs_require__(77);
classe AnnotationFactory {
  static createGlobals(pdfManager) {
    restituisci Promise.all([pdfManager.ensureCatalog("acroForm"), pdfManager.ensureDoc("xfaDatasets"), pdfManager.ensureCatalog("structTreeRoot"), pdfManager.ensureCatalog("baseUrl"), pdfManager.ensureCatalog("allegati")]).then(([acroForm, xfaDatasets, structTreeRoot, baseUrl, allegati]) => {
      ritorno {
        pdfManager,
        acroForm: acroForm instanceof _primitives.Dict ? acroForm : _primitives.Dict.empty,
        xfaDatasets,
        structTreeRoot,
        baseUrl,
        allegati
      };
    }, motivo => {
      (0, _util.warn)(`createGlobals: "${reason}".`);
      restituisci null;
    });
  }
  static async create(xref, ref, annotationGlobals, idFactory, collectFields, pageRef) {
    const pageIndex = collectFields ? await this._getPageIndex(xref, ref, annotationGlobals.pdfManager) : null;
    restituisci annotationGlobals.pdfManager.ensure(this, "_create", [xref, ref, annotationGlobals, idFactory, collectFields, pageIndex, pageRef]);
  }
  static _create(xref, ref, annotationGlobals, idFactory, collectFields = false, pageIndex = null, pageRef = null) {
    const dict = xref.fetchIfRef(ref);
    se (!(dict instanceof _primitives.Dict)) {
      restituisci indefinito;
    }
    costante {
      acroForm,
      pdfManager
    } = annotationGlobals;
    const id = ref instanceof _primitives.Ref ? ref.toString() : `annot_${idFactory.createObjId()}`;
    lascia sottotipo = dict.get("Sottotipo");
    sottotipo = sottotipo instanceof _primitives.Name ? sottotipo.name : null;
    parametri costanti = {
      riferimento esterno,
      rif.
      dizionario,
      sottotipo,
      id,
      annotazioneGlobals,
      raccogliereCampi,
      needAppearances: !collectFields && acroForm.get("NeedAppearances") === true,
      indice della pagina,
      evaluatorOptions: pdfManager.evaluatorOptions,
      pageRef
    };
    switch (sottotipo) {
      caso "Link":
        restituisci nuovo LinkAnnotation(parametri);
      caso "Testo":
        restituisci nuovo TextAnnotation(parametri);
      caso "Widget":
        lascia fieldType = (0, _core_utils.getInheritableProperty)({
          dizionario,
          chiave: "FT"
        });
        fieldType = fieldType instanceof _primitives.Name ? fieldType.name : null;
        switch (tipocampo) {
          caso "Tx":
            restituisci nuovo TextWidgetAnnotation(parametri);
          caso "Btn":
            restituisci nuovo ButtonWidgetAnnotation(parametri);
          caso "Ch":
            restituisci nuovo ChoiceWidgetAnnotation(parametri);
          caso "Sig":
            restituisci nuovo SignatureWidgetAnnotation(parametri);
        }
        (0, _util.warn)(`Tipo di campo widget non implementato "${fieldType}", ` + "ritorno al tipo di campo base.");
        restituisci nuovo WidgetAnnotation(parametri);
      caso "Popup":
        restituisci nuovo PopupAnnotation(parametri);
      caso "Testo libero":
        restituisci nuovo FreeTextAnnotation(parametri);
      caso "Linea":
        restituisci nuova LineAnnotation(parametri);
      caso "Quadrato":
        restituisci nuovo SquareAnnotation(parametri);
      caso "Cerchio":
        restituisci nuovo CircleAnnotation(parametri);
      caso "Polilinea":
        restituisci nuovo PolylineAnnotation(parametri);
      caso "Poligono":
        restituisci nuovo PolygonAnnotation(parametri);
      caso "Caret":
        restituisci nuovo CaretAnnotation(parametri);
      caso "Inchiostro":
        restituisci nuovo InkAnnotation(parametri);
      caso "Evidenzia":
        restituisci nuovo HighlightAnnotation(parametri);
      caso "Sottolineato":
        restituisci nuovo UnderlineAnnotation(parametri);
      caso "Squiggly":
        restituisci nuovo SquigglyAnnotation(parametri);
      caso "StrikeOut":
        restituisci nuovo StrikeOutAnnotation(parametri);
      caso "Timbro":
        restituisci nuovo StampAnnotation(parametri);
      caso "FileAttachment":
        restituisci nuovo FileAttachmentAnnotation(parametri);
      predefinito:
        se (!raccogliCampi) {
          se (!sottotipo) {
            (0, _util.warn)("Nell'annotazione manca il /Subtype richiesto.");
          } altro {
            (0, _util.warn)(`Tipo di annotazione non implementato "${subtype}", ` + "ritorno all'annotazione di base.");
          }
        }
        restituisci nuova Annotazione(parametri);
    }
  }
  statico asincrono _getPageIndex(xref, ref, pdfManager) {
    Tentativo {
      const annotDict = await xref.fetchIfRefAsync(ref);
      se (!(annotDict instanceof _primitives.Dict)) {
        restituisci -1;
      }
      const pageRef = annotDict.getRaw("P");
      se (pageRef instanceof _primitives.Ref) {
        Tentativo {
          const pageIndex = await pdfManager.ensureCatalog("getPageIndex", [pageRef]);
          restituisci paginaIndice;
        } catturare (es.) {
          (0, _util.info)(`_getPageIndex -- non è un riferimento di pagina valido: "${ex}".`);
        }
      }
      se (annotDict.has("Bambini")) {
        restituisci -1;
      }
      const numPages = await pdfManager.ensureDoc("numPages");
      per (let pageIndex = 0; pageIndex < numPages; pageIndex++) {
        const page = await pdfManager.getPage(pageIndex);
        const annotations = await pdfManager.ensure(page, "annotations");
        per (const annotRef di annotazioni) {
          se (annotRef instanceof _primitives.Ref && (0, _primitives.isRefsEqual)(annotRef, ref)) {
            restituisci paginaIndice;
          }
        }
      }
    } catturare (es.) {
      (0, _util.warn)(`_getPageIndex: "${ex}".`);
    }
    restituisci -1;
  }
  static generateImages(annotazioni, xref, isOffscreenCanvasSupported) {
    se (!isOffscreenCanvasSupported) {
      (0, _util.warn)("generateImages: OffscreenCanvas non è supportato, non è possibile salvare o stampare alcune annotazioni con immagini.");
      restituisci null;
    }
    lascia imagePromises;
    per (cost {
      bitmapId,
      mappa di bit
    } di annotazioni) {
      se (!bitmap) {
        continuare;
      }
      imagePromises ||= nuova mappa();
      imagePromises.set(bitmapId, StampAnnotation.createImage(bitmap, xref));
    }
    restituisci imagePromises;
  }
  static async saveNewAnnotations(valutatore, attività, annotazioni, imagePromises) {
    const xref = evaluator.xref;
    lascia baseFontRef;
    dipendenze costanti = [];
    promesse costanti = [];
    costante {
      èOffscreenCanvasSupported
    } = valutatore.opzioni;
    per (annotazione costante di annotazioni) {
      se (annotazione.eliminata) {
        continuare;
      }
      switch (annotazione.tipo di annotazione) {
        caso _util.AnnotationEditorType.FREETEXT:
          se (!baseFontRef) {
            const baseFont = new _primitives.Dict(xref);
            baseFont.set("BaseFont", _primitives.Name.get("Helvetica"));
            baseFont.set("Tipo", _primitives.Name.get("Carattere"));
            baseFont.set("Sottotipo", _primitives.Name.get("Tipo1"));
            baseFont.set("Codifica", _primitives.Name.get("WinAnsiEncoding"));
            buffer costante = [];
            baseFontRef = xref.getNewTemporaryRef();
            attendi (0, _writer.writeObject)(baseFontRef, baseFont, buffer, xref);
            dipendenze.push({
              rif: baseFontRef,
              dati: buffer.join("")
            });
          }
          promises.push(FreeTextAnnotation.createNewAnnotation(xref, annotazione, dipendenze, {
            valutatore,
            compito,
            baseFontRef
          }));
          rottura;
        caso _util.AnnotationEditorType.INK:
          promises.push(InkAnnotation.createNewAnnotation(xref, annotazione, dipendenze));
          rottura;
        caso _util.AnnotationEditorType.STAMP:
          se (!isOffscreenCanvasSupported) {
            rottura;
          }
          const image = await imagePromises.get(annotation.bitmapId);
          se (immagine.imageStream) {
            costante {
              flusso di immagini,
              smaskStream
            } = immagine;
            buffer costante = [];
            se (smaskStream) {
              const smaskRef = xref.getNewTemporaryRef();
              attendi (0, _writer.writeObject)(smaskRef, smaskStream, buffer, xref);
              dipendenze.push({
                rif: smaskRef,
                dati: buffer.join("")
              });
              imageStream.dict.set("SMask", smaskRef);
              buffer.lunghezza = 0;
            }
            const imageRef = image.imageRef = xref.getNewTemporaryRef();
            attendi (0, _writer.writeObject)(imageRef, imageStream, buffer, xref);
            dipendenze.push({
              rif: imageRef,
              dati: buffer.join("")
            });
            immagine.imageStream = immagine.smaskStream = null;
          }
          promises.push(StampAnnotation.createNewAnnotation(xref, annotazione, dipendenze, {
            immagine
          }));
          rottura;
      }
    }
    ritorno {
      annotazioni: attendi Promise.all(promesse),
      dipendenze
    };
  }
  static async printNewAnnotations(annotationGlobals, evaluator, task, annotations, imagePromises) {
    se (!annotazioni) {
      restituisci null;
    }
    costante {
      opzioni,
      riferimento esterno
    } = valutatore;
    promesse costanti = [];
    per (annotazione costante di annotazioni) {
      se (annotazione.eliminata) {
        continuare;
      }
      switch (annotazione.tipo di annotazione) {
        caso _util.AnnotationEditorType.FREETEXT:
          promises.push(FreeTextAnnotation.createNewPrintAnnotation(annotationGlobals, xref, annotazione, {
            valutatore,
            compito,
            evaluatorOptions: opzioni
          }));
          rottura;
        caso _util.AnnotationEditorType.INK:
          promises.push(InkAnnotation.createNewPrintAnnotation(annotationGlobals, xref, annotazione, {
            evaluatorOptions: opzioni
          }));
          rottura;
        caso _util.AnnotationEditorType.STAMP:
          se (!options.isOffscreenCanvasSupported) {
            rottura;
          }
          const image = await imagePromises.get(annotation.bitmapId);
          se (immagine.imageStream) {
            costante {
              flusso di immagini,
              smaskStream
            } = immagine;
            se (smaskStream) {
              imageStream.dict.set("SMask", smaskStream);
            }
            image.imageRef = new _jpeg_stream.JpegStream(imageStream, imageStream.length);
            immagine.imageStream = immagine.smaskStream = null;
          }
          promises.push(StampAnnotation.createNewPrintAnnotation(annotationGlobals, xref, annotazione, {
            immagine,
            evaluatorOptions: opzioni
          }));
          rottura;
      }
    }
    restituisci Promise.all(promesse);
  }
}
esportazioni.AnnotationFactory = AnnotationFactory;
funzione getRgbColor(colore, defaultColor = new Uint8ClampedArray(3)) {
  se (!Array.isArray(colore)) {
    restituisci colore predefinito;
  }
  const rgbColor = defaultColor || new Uint8ClampedArray(3);
  switch (colore.lunghezza) {
    caso 0:
      restituisci null;
    caso 1:
      _colorspace.ColorSpace.singletons.gray.getRgbItem(colore, 0, rgbColor, 0);
      restituisci rgbColor;
    caso 3:
      _colorspace.ColorSpace.singletons.rgb.getRgbItem(colore, 0, rgbColor, 0);
      restituisci rgbColor;
    caso 4:
      _colorspace.ColorSpace.singletons.cmyk.getRgbItem(colore, 0, rgbColor, 0);
      restituisci rgbColor;
    predefinito:
      restituisci colore predefinito;
  }
}
funzione getPdfColorArray(colore) {
  restituisci Array.from(colore, c => c / 255);
}
funzione getQuadPoints(dict, rect) {
  const quadPoints = dict.getArray("QuadPoints");
  se (!Array.isArray(quadPoints) || quadPoints.length === 0 || quadPoints.length % 8 > 0) {
    restituisci null;
  }
  const quadPointsLists = [];
  per (lascia che i = 0, ii = quadPoints.length / 8; i < ii; i++) {
    lascia minX = Infinito,
      maxX = -Infinito,
      minY = Infinito,
      maxY = -Infinito;
    per (sia j = i * 8, jj = i * 8 + 8; j < jj; j += 2) {
      const x = quadPoints[j];
      const y = quadPoints[j + 1];
      minX = Math.min(x, minX);
      maxX = Math.max(x, maxX);
      minY = Math.min(y, minY);
      maxY = Math.max(y, maxY);
    }
    se (rect !== null && (minX < rect[0] || maxX > rect[2] || minY < rect[1] || maxY > rect[3])) {
      restituisci null;
    }
    quadPointsLists.push([{
      x: minX,
      y: maxY
    }, {
      x: maxX,
      y: maxY
    }, {
      x: minX,
      y: minY
    }, {
      x: maxX,
      y: minY
    }]);
  }
  restituisci quadPointsLists;
}
funzione getTransformMatrix(rect, bbox, matrice) {
  const [minX, minY, maxX, maxY] = _util.Util.getAxialAlignedBoundingBox(bbox, matrice);
  se (minX === maxX || minY === maxY) {
    ritorno [1, 0, 0, 1, rettangolo[0], rettangolo[1]];
  }
  const xRatio = (rect[2] - rect[0]) / (maxX - minX);
  const yRatio = (rect[3] - rect[1]) / (maxY - minY);
  ritorna [xRatio, 0, 0, yRatio, rect[0] - minX * xRatio, rect[1] - minY * yRatio];
}
classe Annotazione {
  costruttore(parametri) {
    costante {
      dizionario,
      riferimento esterno,
      annotazioneGlobals
    } = parametri;
    this.setTitle(dict.get("T"));
    this.setContents(dict.get("Contenuto"));
    this.setModificationDate(dict.get("M"));
    this.setFlags(dict.get("F"));
    this.setRectangle(dict.getArray("Rect"));
    this.setColor(dict.getArray("C"));
    this.setBorderStyle(dict);
    this.setAppearance(dict);
    this.setOptionalContent(dict);
    const MK = dict.get("MK");
    questo.impostaBorderAndBackgroundColors(MK);
    this.setRotation(MK, dizionario);
    this.ref = params.ref instanceof _primitives.Ref ? params.ref : null;
    questo._flussi = [];
    se (questo.aspetto) {
      questo._streams.push(questo.aspetto);
    }
    const isLocked = !!(this.flags & _util.AnnotationFlag.LOCKED);
    const isContentLocked = !!(this.flags & _util.AnnotationFlag.LOCKEDCONTENTS);
    se (annotationGlobals.structTreeRoot) {
      lascia structParent = dict.get("StructParent");
      structParent = Number.isInteger(structParent) && structParent >= 0 ? structParent : -1;
      annotationGlobals.structTreeRoot.addAnnotationIdToPage(params.pageRef, structParent);
    }
    questo.dato = {
      annotationFlags: this.flags,
      borderStyle: questo.borderStyle,
      colore: questo.colore,
      backgroundColor: questo.backgroundColor,
      borderColor: this.borderColor,
      rotazione: questa.rotazione,
      contentsObj: questo._contenuto,
      hasAppearance: !!this.appearance,
      id: params.id,
      data di modifica: questa.data di modifica,
      rect: questo rettangolo,
      sottotipo: params.subtype,
      hasOwnCanvas: falso,
      noRotate: !!(this.flags & _util.AnnotationFlag.NOROTATE),
      noHTML: è bloccato e il contenuto è bloccato
    };
    se (params.collectFields) {
      const kids = dict.get("Bambini");
      se (Array.isArray(bambini)) {
        const kidIds = [];
        per (const bambino di bambini) {
          se (istanza bambino di _primitives.Ref) {
            kidIds.push(kid.toString());
          }
        }
        se (lunghezzaKidIds!== 0) {
          this.data.kidIds = kidIds;
        }
      }
      this.data.actions = (0, _core_utils.collectActions)(xref, dict, _util.AnnotationActionEventType);
      questo.data.fieldName = questo._constructFieldName(dict);
      this.data.pageIndex = params.pageIndex;
    }
    this._isOffscreenCanvasSupported = params.evaluatorOptions.isOffscreenCanvasSupported;
    this._fallbackFontDict = null;
    this._needAppearances = false;
  }
  _hasFlag(bandiere, bandiera) {
    ritorno !!(bandiere & bandiera);
  }
  _isViewable(flag) {
    restituisci !this._hasFlag(flags, _util.AnnotationFlag.INVISIBLE) && !this._hasFlag(flags, _util.AnnotationFlag.NOVIEW);
  }
  _isPrintable(flag) {
    restituisci this._hasFlag(flags, _util.AnnotationFlag.PRINT) && !this._hasFlag(flags, _util.AnnotationFlag.HIDDEN) && !this._hasFlag(flags, _util.AnnotationFlag.INVISIBLE);
  }
  mustBeViewed(annotationStorage, _renderForms) {
    const noView = annotationStorage?.get(this.data.id)?.noView;
    se (noView !== indefinito) {
      restituisci !noView;
    }
    restituisci this.viewable && !this._hasFlag(this.flags, _util.AnnotationFlag.HIDDEN);
  }
  mustBePrinted(annotationStorage) {
    const noPrint = annotationStorage?.get(this.data.id)?.noPrint;
    se (noPrint !== indefinito) {
      ritorna !noPrint;
    }
    restituisci questo.stampabile;
  }
  ottenere visibile() {
    se (this.data.quadPoints === null) {
      restituisci falso;
    }
    se (questo.flags === 0) {
      restituisci vero;
    }
    restituisci this._isViewable(this.flags);
  }
  ottieni stampabile() {
    se (this.data.quadPoints === null) {
      restituisci falso;
    }
    se (questo.flags === 0) {
      restituisci falso;
    }
    restituisci this._isPrintable(this.flags);
  }
  _parseStringHelper(dati) {
    const str = tipo di dati === "stringa" ? (0, _util.stringToPDFString)(dati) : "";
    const dir = str && (0, _bidi.bidi)(str).dir === "rtl" ? "rtl" : "ltr";
    ritorno {
      str,
      direzione
    };
  }
  setDefaultAppearance(parametri) {
    costante {
      dizionario,
      annotazioneGlobals
    } = parametri;
    const defaultAppearance = (0, _core_utils.getInheritableProperty)({
      dizionario,
      chiave: "DA"
    }) || annotationGlobals.acroForm.get("DA");
    this._defaultAppearance = typeof defaultAppearance === "stringa" ? defaultAppearance : "";
    this.data.defaultAppearanceData = (0, _default_appearance.parseDefaultAppearance)(this._defaultAppearance);
  }
  setTitle(titolo) {
    this._title = this._parseStringHelper(title);
  }
  setContents(contenuto) {
    questo._contenuto = questo._parseStringHelper(contenuto);
  }
  setModificationDate(datamodifica) {
    this.modificationDate = typeof modificationDate === "string" ? modificationDate : null;
  }
  setFlags(flag) {
    this.flags = Number.isInteger(flags) && flags > 0 ? flags : 0;
  }
  haFlag(bandiera) {
    restituisci this._hasFlag(this.flags, flag);
  }
  setRectangle(rettangolo) {
    this.rectangle = Array.isArray(rettangolo) && rectangle.length === 4 ? _util.Util.normalizeRect(rettangolo) : [0, 0, 0, 0];
  }
  setColor(colore) {
    questo.colore = getRgbColor(colore);
  }
  setLineEndings(lineEndings) {
    this.lineEndings = ["Nessuno", "Nessuno"];
    se (Array.isArray(lineEndings) && lineEndings.length === 2) {
      per (lascia che i = 0; i < 2; i++) {
        const obj = lineEndings[i];
        se (oggetto istanza di _primitives.Nome) {
          switch (nome oggetto) {
            caso "Nessuno":
              continuare;
            caso "Quadrato":
            caso "Cerchio":
            caso "Diamante":
            caso "OpenArrow":
            caso "ClosedArrow":
            caso "Butt":
            caso "ROpenArrow":
            caso "RClosedArrow":
            caso "Barra":
              this.lineEndings[i] = obj.name;
              continuare;
          }
        }
        (0, _util.warn)(`Ignorando la fine della riga non valida: ${obj}`);
      }
    }
  }
  setRotation(mk, dizionario) {
    questa.rotazione = 0;
    lascia angolo = mk instanceof _primitives.Dict ? mk.get("R") || 0 : dict.get("Ruota") || 0;
    se (Number.isInteger(angolo) && angolo !== 0) {
      angolo %= 360;
      se (angolo < 0) {
        angolo += 360;
      }
      se (angolo % 90 === 0) {
        this.rotation = angolo;
      }
    }
  }
  impostaBorderAndBackgroundColors(mk) {
    se (mk instanceof _primitives.Dict) {
      this.borderColor = getRgbColor(mk.getArray("BC"), null);
      this.backgroundColor = getRgbColor(mk.getArray("BG"), null);
    } altro {
      questo.coloredelbordo = questo.coloredellosfondo = null;
    }
  }
  impostaStileBorder(stilebordo) {
    this.borderStyle = new AnnotationBorderStyle();
    se (!(borderStyle instanceof _primitives.Dict)) {
      ritorno;
    }
    se (borderStyle.has("BS")) {
      const dict = borderStyle.get("BS");
      const dictType = dict.get("Tipo");
      se (!dictType || (0, _primitives.isName)(dictType, "Bordo")) {
        this.borderStyle.setWidth(dict.get("W"), this.rectangle);
        this.borderStyle.setStyle(dict.get("S"));
        this.borderStyle.setDashArray(dict.getArray("D"));
      }
    } altrimenti se (borderStyle.has("Bordo")) {
      const array = borderStyle.getArray("Bordo");
      se (Array.isArray(array) && array.length >= 3) {
        this.borderStyle.setHorizontalCornerRadius(array[0]);
        this.borderStyle.setVerticalCornerRadius(array[1]);
        this.borderStyle.setWidth(array[2], this.rectangle);
        se (lunghezza array === 4) {
          this.borderStyle.setDashArray(array[3], true);
        }
      }
    } altro {
      questo.borderStyle.setWidth(0);
    }
  }
  setAppearance(dict) {
    questo.aspetto = null;
    const appearanceStates = dict.get("AP");
    se (!(appearanceStates instanceof _primitives.Dict)) {
      ritorno;
    }
    const normalAppearanceState = appearanceStates.get("N");
    se (normalAppearanceState instanceof _base_stream.BaseStream) {
      this.appearance = normalAppearanceState;
      ritorno;
    }
    se (!(normalAppearanceState instanceof _primitives.Dict)) {
      ritorno;
    }
    const come = dict.get("COME");
    se (!(come instanceof _primitives.Name) || !normalAppearanceState.has(come.name)) {
      ritorno;
    }
    aspetto costante = normalAppearanceState.get(as.name);
    se (istanza di aspetto di _base_stream.BaseStream) {
      this.appearance = apparenza;
    }
  }
  setOptionalContent(dict) {
    this.oc = null;
    const oc = dict.get("OC");
    se (oc instanceof _primitives.Name) {
      (0, _util.warn)("setOptionalContent: il supporto per /Name-entry non è implementato.");
    } altrimenti se (oc instanceof _primitives.Dict) {
      questo.oc = oc;
    }
  }
  loadResources(chiavi, aspetto) {
    restituisci appearance.dict.getAsync("Risorse").then(risorse => {
      se (!risorse) {
        restituisci indefinito;
      }
      const objectLoader = new _object_loader.ObjectLoader(risorse, chiavi, risorse.xref);
      restituisci objectLoader.load().then(funzione () {
        restituire le risorse;
      });
    });
  }
  async getOperatorList(valutatore, attività, intento, renderForms, annotationStorage) {
    const data = this.data;
    lascia che l'aspetto = questo.aspetto;
    const isUsingOwnCanvas = !!(this.data.hasOwnCanvas && intent & _util.RenderingIntentFlag.DISPLAY);
    se (!aspetto) {
      se (!isUsingOwnCanvas) {
        ritorno {
          opList: nuovo _operator_list.OperatorList(),
          separateForm: falso,
          separateCanvas: falso
        };
      }
      aspetto = nuovo _stream.StringStream("");
      aspetto.dizionario = nuovi _primitivi.Dizionario();
    }
    const appearanceDict = appearance.dict;
    const resources = await this.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"], appearance);
    const bbox = appearanceDict.getArray("BBox") || [0, 0, 1, 1];
    matrice costante = appearanceDict.getArray("Matrice") || [1, 0, 0, 1, 0, 0];
    const transform = getTransformMatrix(data.rect, bbox, matrix);
    const opList = new _operator_list.OperatorList();
    lascia optionalContent;
    se (questo.oc) {
      optionalContent = attendi evaluator.parseMarkedContentProps(this.oc, null);
    }
    se (optionalContent !== indefinito) {
      opList.addOp(_util.OPS.beginMarkedContentProps, ["OC", optionalContent]);
    }
    opList.addOp(_util.OPS.beginAnnotation, [data.id, data.rect, trasforma, matrice, isUsingOwnCanvas]);
    attendi valutatore.getOperatorList({
      flusso: aspetto,
      compito,
      risorse,
      operatorList: opList,
      fallbackFontDict: questo._fallbackFontDict
    });
    opList.addOp(_util.OPS.endAnnotation, []);
    se (optionalContent !== indefinito) {
      opList.addOp(_util.OPS.endMarkedContent, []);
    }
    questo.reset();
    ritorno {
      opList,
      separateForm: falso,
      separateCanvas: isUsingOwnCanvas
    };
  }
  async save(valutatore, attività, annotationStorage) {
    restituisci null;
  }
  ottieni hasTextContent() {
    restituisci falso;
  }
  async extractTextContent(valutatore, attività, viewBox) {
    se (!questo.aspetto) {
      ritorno;
    }
    const resources = await this.loadResources(["ExtGState", "Font", "Properties", "XObject"], this.appearance);
    testo costante = [];
    buffer costante = [];
    lascia primaPosizione = null;
    lavandino costante = {
      desiredSize: Math.Infinity,
      pronto: vero,
      accoda(pezzo, dimensione) {
        per (const elemento di chunk.items) {
          se (item.str === indefinito) {
            continuare;
          }
          primaPosizione ||= elemento.trasformazione.fetta(-2);
          buffer.push(elemento.str);
          se (elemento.hasEOL) {
            testo.push(buffer.join(""));
            buffer.lunghezza = 0;
          }
        }
      }
    };
    attendi evaluator.getTextContent({
      flusso: questo.aspetto,
      compito,
      risorse,
      includeMarkedContent: vero,
      lavello,
      viewBox
    });
    questo.reset();
    se (lunghezza buffer) {
      testo.push(buffer.join(""));
    }
    se (lunghezza testo > 1 || testo[0]) {
      const appearanceDict = this.appearance.dict;
      const bbox = appearanceDict.getArray("BBox") || [0, 0, 1, 1];
      matrice costante = appearanceDict.getArray("Matrice") || [1, 0, 0, 1, 0, 0];
      const rect = this.data.rect;
      const transform = getTransformMatrix(rect, bbox, matrix);
      trasforma[4] -= rect[0];
      trasforma[5] -= rect[1];
      firstPosition = _util.Util.applyTransform(firstPosition, transform);
      primaPosizione = _util.Util.applyTransform(primaPosizione, matrice);
      this.data.textPosition = firstPosition;
      this.data.textContent = testo;
    }
  }
  getFieldObject() {
    se (this.data.kidIds) {
      ritorno {
        id: questo.data.id,
        azioni: questo.dati.azioni,
        nome: this.data.fieldName,
        strokeColor: this.data.borderColor,
        fillColor: this.data.backgroundColor,
        tipo: "",
        kidIds: questo.dati.kidIds,
        pagina: this.data.pageIndex,
        rotazione: this.rotation
      };
    }
    restituisci null;
  }
  reimposta() {
    per (flusso costante di this._streams) {
      stream.reset();
    }
  }
  _constructFieldName(dict) {
    se (!dict.has("T") && !dict.has("Genitore")) {
      (0, _util.warn)("Nome campo sconosciuto, si torna al nome campo vuoto.");
      ritorno "";
    }
    se (!dict.has("Genitore")) {
      restituisci (0, _util.stringToPDFString)(dict.get("T"));
    }
    const fieldName = [];
    se (dict.has("T")) {
      fieldName.unshift((0, _util.stringToPDFString)(dict.get("T")));
    }
    lascia loopDict = dict;
    const visitato = new _primitives.RefSet();
    se (dict.objId) {
      visitato.put(dict.objId);
    }
    while (loopDict.has("Genitore")) {
      loopDict = loopDict.get("Genitore");
      se (!(loopDict instanceof _primitives.Dict) || loopDict.objId && visited.has(loopDict.objId)) {
        rottura;
      }
      se (loopDict.objId) {
        visitato.put(loopDict.objId);
      }
      se (loopDict.has("T")) {
        fieldName.unshift((0, _util.stringToPDFString)(loopDict.get("T")));
      }
    }
    restituisci fieldName.join(".");
  }
}
exports.Annotation = Annotazione;
classe AnnotationBorderStyle {
  costruttore() {
    questa.larghezza = 1;
    questo.stile = _util.AnnotationBorderStyleType.SOLID;
    questo.dashArray = [3];
    questo.raggioangoloorizzontale = 0;
    this.verticalCornerRadius = 0;
  }
  setWidth(larghezza, rettangolo = [0, 0, 0, 0]) {
    se (larghezza instanceof _primitives.Name) {
      questa.larghezza = 0;
      ritorno;
    }
    se (tipo di larghezza === "numero") {
      se (larghezza > 0) {
        const maxWidth = (rect[2] - rect[0]) / 2;
        const maxHeight = (rect[3] - rect[1]) / 2;
        se (larghezza massima > 0 e altezza massima > 0 e (larghezza > larghezza massima || larghezza > altezza massima)) {
          (0, _util.warn)(`AnnotationBorderStyle.setWidth - ignorando la larghezza: ${width}`);
          larghezza = 1;
        }
      }
      this.width = larghezza;
    }
  }
  setStyle(stile) {
    se (!(stile instanceof _primitives.Name)) {
      ritorno;
    }
    switch (style.name) {
      caso "S":
        questo.stile = _util.AnnotationBorderStyleType.SOLID;
        rottura;
      caso "D":
        questo.stile = _util.AnnotationBorderStyleType.DASHED;
        rottura;
      caso "B":
        questo.stile = _util.AnnotationBorderStyleType.BEVELED;
        rottura;
      caso "I":
        this.style = _util.AnnotationBorderStyleType.INSET;
        rottura;
      caso "U":
        questo.stile = _util.AnnotationBorderStyleType.UNDERLINE;
        rottura;
      predefinito:
        rottura;
    }
  }
  setDashArray(dashArray, forceStyle = false) {
    se (Array.isArray(dashArray) && dashArray.length > 0) {
      lascia che sia valido = vero;
      lascia che tutti gli zeri = true;
      per (elemento costante di dashArray) {
        const validNumber = +elemento >= 0;
        se (!numerovalido) {
          è valido = falso;
          rottura;
        } altrimenti se (elemento > 0) {
          tuttiZeros = falso;
        }
      }
      se (isValid && !allZeros) {
        questo.dashArray = dashArray;
        se (forceStyle) {
          this.setStyle(_primitives.Name.get("D"));
        }
      } altro {
        questa.larghezza = 0;
      }
    } altrimenti se (dashArray) {
      questa.larghezza = 0;
    }
  }
  setHorizontalCornerRadius(raggio) {
    se (Numero.èIntero(raggio)) {
      this.horizontalCornerRadius = raggio;
    }
  }
  setVerticalCornerRadius(raggio) {
    se (Numero.èIntero(raggio)) {
      this.verticalCornerRadius = raggio;
    }
  }
}
esportazioni.AnnotationBorderStyle = AnnotationBorderStyle;
classe MarkupAnnotation estende Annotation {
  costruttore(parametri) {
    super(parametri);
    costante {
      dizionario
    } = parametri;
    se (dict.has("IRT")) {
      const rawIRT = dict.getRaw("IRT");
      this.data.inReplyTo = rawIRT instanceof _primitives.Ref ? rawIRT.toString() : null;
      const rt = dict.get("RT");
      this.data.replyType = rt instanceof _primitives.Name ? rt.name : _util.AnnotationReplyType.REPLY;
    }
    lascia popupRef = null;
    se (this.data.replyType === _util.AnnotationReplyType.GROUP) {
      const genitore = dict.get("IRT");
      this.setTitle(parent.get("T"));
      questo.data.titleObj = questo._titolo;
      this.setContents(parent.get("Contenuto"));
      questo.dato.contenutoObj = questo._contenuto;
      se (!parent.has("Data di creazione")) {
        this.data.creationDate = null;
      } altro {
        this.setCreationDate(parent.get("Data di creazione"));
        questo.data.creazione = questo.creazione;
      }
      se (!genitore.has("M")) {
        this.data.modificationDate = null;
      } altro {
        this.setModificationDate(parent.get("M"));
        questo.data.modifica = questo.datamodifica;
      }
      popupRef = parent.getRaw("Popup");
      se (!genitore.has("C")) {
        questo.dati.colore = null;
      } altro {
        this.setColor(parent.getArray("C"));
        questo.dati.colore = questo.colore;
      }
    } altro {
      questo.data.titleObj = questo._titolo;
      this.setCreationDate(dict.get("Data di creazione"));
      questo.data.creazione = questo.creazione;
      popupRef = dict.getRaw("Popup");
      se (!dict.has("C")) {
        questo.dati.colore = null;
      }
    }
    this.data.popupRef = popupRef instanceof _primitives.Ref ? popupRef.toString() : null;
    se (dict.has("RC")) {
      this.data.richText = _factory.XFAFactory.getRichTextAsHtml(dict.get("RC"));
    }
  }
  impostaDataCreazione(DataCreazione) {
    this.creationDate = typeof creationDate === "string" ? creationDate : null;
  }
  _setDefaultAppearance({
    riferimento esterno,
    extra,
    Colore tratto,
    colore di riempimento,
    modalità di fusione,
    colpoAlfa,
    fillAlpha,
    puntiCallback
  }) {
    lascia minX = Numero.VALORE_MAX;
    lascia minY = Numero.VALORE_MAX;
    lascia maxX = Numero.MIN_VALUE;
    lascia maxY = Numero.MIN_VALUE;
    const buffer = ["q"];
    se (extra) {
      buffer.push(extra);
    }
    se (strokeColor) {
      buffer.push(`${strokeColor[0]} ${strokeColor[1]} ${strokeColor[2]} RG`);
    }
    se (fillColor) {
      buffer.push(`${fillColor[0]} ${fillColor[1]} ${fillColor[2]} rg`);
    }
    lascia pointsArray = this.data.quadPoints;
    se (!pointsArray) {
      puntiArray = [[{
        x: questo.rettangolo[0],
        y: questo.rettangolo[3]
      }, {
        x: questo.rettangolo[2],
        y: questo.rettangolo[3]
      }, {
        x: questo.rettangolo[0],
        y: questo.rettangolo[1]
      }, {
        x: questo.rettangolo[2],
        y: questo.rettangolo[1]
      }]];
    }
    per (const punti di pointsArray) {
      const [mX, MX, mY, MY] = pointsCallback(buffer, punti);
      minX = Math.min(minX, mX);
      maxX = Math.max(maxX, MX);
      minY = Math.min(minY, mY);
      maxY = Math.max(maxY, MY);
    }
    buffer.push("Q");
    const formDict = new _primitives.Dict(xref);
    const appearanceStreamDict = new _primitives.Dict(xref);
    appearanceStreamDict.set("Sottotipo", _primitives.Name.get("Form"));
    const appearanceStream = new _stream.StringStream(buffer.join(" "));
    appearanceStream.dict = appearanceStreamDict;
    formDict.set("Fm0", appearanceStream);
    const gsDict = new _primitives.Dict(xref);
    se (blendMode) {
      gsDict.set("BM", _primitives.Name.get(blendMode));
    }
    se (tipo di trattoAlfa === "numero") {
      gsDict.set("CA", strokeAlpha);
    }
    se (tipo di fillAlpha === "numero") {
      gsDict.set("ca", fillAlpha);
    }
    const stateDict = new _primitives.Dict(xref);
    stateDict.set("GS0", gsDict);
    const resources = new _primitives.Dict(xref);
    risorse.set("ExtGState", stateDict);
    risorse.set("XObject", formDict);
    const appearanceDict = new _primitives.Dict(xref);
    appearanceDict.set("Risorse", risorse);
    const bbox = this.data.rect = [minX, minY, maxX, maxY];
    appearanceDict.set("BBox", bbox);
    this.appearance = new _stream.StringStream("/GS0 gs /Fm0 Do");
    questo.aspetto.dict = appearanceDict;
    this._streams.push(this.appearance, appearanceStream);
  }
  static async createNewAnnotation(xref, annotazione, dipendenze, parametri) {
    const annotationRef = annotation.ref ||= xref.getNewTemporaryRef();
    const ap = await this.createNewAppearanceStream(annotazione, xref, parametri);
    buffer costante = [];
    lascia annotationDict;
    se (ap) {
      const apRef = xref.getNewTemporaryRef();
      annotationDict = this.createNewDict(annotazione, xrif, {
        apRef
      });
      attendi (0, _writer.writeObject)(apRef, ap, buffer, xref);
      dipendenze.push({
        rif: apRef,
        dati: buffer.join("")
      });
    } altro {
      annotationDict = this.createNewDict(annotazione, xref, {});
    }
    se (Numero.èIntero(annotazione.IDAlberoParente)) {
      annotationDict.set("StructParent", annotation.parentTreeId);
    }
    buffer.lunghezza = 0;
    attendi (0, _writer.writeObject)(annotationRef, annotationDict, buffer, xref);
    ritorno {
      rif: annotazioneRef,
      dati: buffer.join("")
    };
  }
  static async createNewPrintAnnotation(annotationGlobals, xref, annotation, params) {
    const ap = await this.createNewAppearanceStream(annotazione, xref, parametri);
    const annotationDict = this.createNewDict(annotazione, xref, {
      una persona
    });
    const newAnnotation = new this.prototype.constructor({
      dizionario: annotazioneDict,
      riferimento esterno,
      annotazioneGlobals,
      evaluatorOptions: params.evaluatorOptions
    });
    se (annotazione.rif) {
      newAnnotation.ref = newAnnotation.refToReplace = annotation.ref;
    }
    restituisci nuovaAnnotazione;
  }
}
esportazioni.MarkupAnnotation = MarkupAnnotation;
classe WidgetAnnotation estende Annotation {
  costruttore(parametri) {
    super(parametri);
    costante {
      dizionario,
      riferimento esterno,
      annotazioneGlobals
    } = parametri;
    const data = this.data;
    this._needAppearances = params.needAppearances;
    dati.tipo di annotazione = _util.Tipo di annotazione.WIDGET;
    se (data.fieldName === non definito) {
      dati.fieldName = this._constructFieldName(dict);
    }
    se (dati.azioni === indefinito) {
      dati.azioni = (0, _core_utils.collectActions)(xref, dict, _util.AnnotationActionEventType);
    }
    lascia fieldValue = (0, _core_utils.getInheritableProperty)({
      dizionario,
      chiave: "V",
      getArray: vero
    });
    dati.valorecampo = this._decodeFormValue(valorecampo);
    const defaultFieldValue = (0, _core_utils.getInheritableProperty)({
      dizionario,
      chiave: "DV",
      getArray: vero
    });
    dati.defaultFieldValue = this._decodeFormValue(defaultFieldValue);
    se (fieldValue === indefinito e annotationGlobals.xfaDatasets) {
      const path = this._title.str;
      se (percorso) {
        this._hasValueFromXFA = true;
        dati.valorecampo = valorecampo = annotazioneGlobals.xfaDatasets.getValue(percorso);
      }
    }
    se (fieldValue === indefinito e dati.defaultFieldValue !== null) {
      dati.valorecampo = dati.valorecampopredefinito;
    }
    dati.testo alternativo = (0, _util.stringToPDFString)(dict.get("TU") || "");
    this.setDefaultAppearance(parametri);
    data.hasAppearance ||= this._needAppearances && data.fieldValue !== undefined && data.fieldValue !== null;
    const fieldType = (0, _core_utils.getInheritableProperty)({
      dizionario,
      chiave: "FT"
    });
    data.fieldType = fieldType instanceof _primitives.Name ? fieldType.name : null;
    const localResources = (0, _core_utils.getInheritableProperty)({
      dizionario,
      chiave: "DR"
    });
    const acroFormResources = annotationGlobals.acroForm.get("DR");
    const appearanceResources = this.appearance?.dict.get("Risorse");
    questo._campoRisorse = {
      Risorse locali,
      acroFormResources,
      aspettoRisorse,
      Risorse unite: _primitives.Dict.merge({
        riferimento esterno,
        dictArray: [localResources, optimizationResources, acroFormResources],
        mergeSubDicts: vero
      })
    };
    dati.fieldFlags = (0, _core_utils.getInheritableProperty)({
      dizionario,
      tasto: "Ff"
    });
    se (!Number.isInteger(data.fieldFlags) || data.fieldFlags < 0) {
      dati.fieldFlags = 0;
    }
    dati.readOnly = this.hasFieldFlag(_util.AnnotationFieldFlag.READONLY);
    dati.richiesto = this.hasFieldFlag(_util.AnnotationFieldFlag.REQUIRED);
    dati.nascosti = this._hasFlag(data.annotationFlags, _util.AnnotationFlag.NASCOSTO) || this._hasFlag(data.annotationFlags, _util.AnnotationFlag.NOVIEW);
  }
  _decodeFormValue(formValue) {
    se (Array.isArray(formValue)) {
      restituisci formValue.filter(item => typeof item === "string").map(item => (0, _util.stringToPDFString)(item));
    } altrimenti se (formValue instanceof _primitives.Name) {
      restituisci (0, _util.stringToPDFString)(formValue.name);
    } altrimenti se (tipo di formValue === "stringa") {
      restituisci (0, _util.stringToPDFString)(formValue);
    }
    restituisci null;
  }
  hasFieldFlag(flag) {
    restituisci !!(this.data.fieldFlags & flag);
  }
  _isViewable(flag) {
    restituisci !this._hasFlag(flags, _util.AnnotationFlag.INVISIBLE);
  }
  mustBeViewed(annotationStorage, renderForms) {
    se (renderForms) {
      restituisci questo.visibile;
    }
    restituisci super.mustBeViewed(annotationStorage, renderForms) && !this._hasFlag(this.flags, _util.AnnotationFlag.NOVIEW);
  }
  getRotationMatrix(annotationStorage) {
    lascia rotazione = annotationStorage?.get(this.data.id)?.rotation;
    se (rotazione === indefinito) {
      rotazione = this.rotation;
    }
    se (rotazione === 0) {
      restituisci _util.IDENTITY_MATRIX;
    }
    larghezza costante = this.data.rect[2] - this.data.rect[0];
    altezza costante = this.data.rect[3] - this.data.rect[1];
    return (0, _core_utils.getRotationMatrix)(rotazione, larghezza, altezza);
  }
  getBorderAndBackgroundAppearances(annotationStorage) {
    lascia rotazione = annotationStorage?.get(this.data.id)?.rotation;
    se (rotazione === indefinito) {
      rotazione = this.rotation;
    }
    se (!this.backgroundColor && !this.borderColor) {
      ritorno "";
    }
    larghezza costante = this.data.rect[2] - this.data.rect[0];
    altezza costante = this.data.rect[3] - this.data.rect[1];
    const rect = rotazione === 0 || rotazione === 180 ? `0 0 ${larghezza} ${altezza} re` : `0 0 ${altezza} ${larghezza} re`;
    lascia str = "";
    se (questo.coloredisfondo) {
      str = `${(0, _default_appearance.getPdfColor)(this.backgroundColor, true)} ${rect} f `;
    }
    se (questo.coloredelbordo) {
      const borderWidth = this.borderStyle.width || 1;
      str += `${borderWidth} w ${(0, _default_appearance.getPdfColor)(this.borderColor, false)} ${rect} S `;
    }
    ritorno str;
  }
  async getOperatorList(valutatore, attività, intento, renderForms, annotationStorage) {
    se (renderForms && !(questa istanza di SignatureWidgetAnnotation) && !this.data.noHTML && !this.data.hasOwnCanvas) {
      ritorno {
        opList: nuovo _operator_list.OperatorList(),
        separateForm: vero,
        separateCanvas: falso
      };
    }
    se (!this._hasText) {
      restituisci super.getOperatorList(valutatore, attività, intento, renderForms, annotationStorage);
    }
    const content = await this._getAppearance(evaluator, task, intent, annotationStorage);
    se (questo.aspetto e contenuto === null) {
      restituisci super.getOperatorList(valutatore, attività, intento, renderForms, annotationStorage);
    }
    const opList = new _operator_list.OperatorList();
    se (!this._defaultAppearance || contenuto === null) {
      ritorno {
        opList,
        separateForm: falso,
        separateCanvas: falso
      };
    }
    const isUsingOwnCanvas = !!(this.data.hasOwnCanvas && intent & _util.RenderingIntentFlag.DISPLAY);
    matrice costante = [1, 0, 0, 1, 0, 0];
    const bbox = [0, 0, questo.data.rect[2] - questo.data.rect[0], questo.data.rect[3] - questo.data.rect[1]];
    const transform = getTransformMatrix(this.data.rect, bbox, matrix);
    lascia optionalContent;
    se (questo.oc) {
      optionalContent = attendi evaluator.parseMarkedContentProps(this.oc, null);
    }
    se (optionalContent !== indefinito) {
      opList.addOp(_util.OPS.beginMarkedContentProps, ["OC", optionalContent]);
    }
    opList.addOp(_util.OPS.beginAnnotation, [this.data.id, this.data.rect, transform, this.getRotationMatrix(annotationStorage), isUsingOwnCanvas]);
    const stream = new _stream.StringStream(content);
    attendi valutatore.getOperatorList({
      flusso,
      compito,
      risorse: this._fieldResources.mergedResources,
      operatorList: opList
    });
    opList.addOp(_util.OPS.endAnnotation, []);
    se (optionalContent !== indefinito) {
      opList.addOp(_util.OPS.endMarkedContent, []);
    }
    ritorno {
      opList,
      separateForm: falso,
      separateCanvas: isUsingOwnCanvas
    };
  }
  _getMKDict(rotazione) {
    const mk = new _primitives.Dict(null);
    se (rotazione) {
      mk.set("R", rotazione);
    }
    se (questo.coloredelbordo) {
      mk.set("BC", getPdfColorArray(this.borderColor));
    }
    se (questo.coloredisfondo) {
      mk.set("BG", getPdfColorArray(this.backgroundColor));
    }
    restituisci mk.size > 0 ? mk : null;
  }
  amendSavedDict(annotationStorage, dict) {}
  async save(valutatore, attività, annotationStorage) {
    const storageEntry = annotationStorage?.get(this.data.id);
    lascia valore = storageEntry?.value,
      rotazione = storageEntry?.rotation;
    se (valore === this.data.fieldValue || valore === indefinito) {
      se (!this._hasValueFromXFA && rotazione === indefinito) {
        restituisci null;
      }
      valore ||= questo.dato.campoValore;
    }
    se (rotazione === indefinito && !this._hasValueFromXFA && Array.isArray(valore) && Array.isArray(this.data.fieldValue) && valore.lunghezza === this.data.fieldValue.lunghezza && valore.ogni((x, i) => x === this.data.fieldValue[i])) {
      restituisci null;
    }
    se (rotazione === indefinito) {
      rotazione = this.rotation;
    }
    lascia che l'aspetto = null;
    se (!this._needAppearances) {
      aspetto = attendi questo._getAppearance(valutatore, attività, _util.RenderingIntentFlag.SAVE, annotationStorage);
      se (aspetto === null) {
        restituisci null;
      }
    } altro {}
    lascia che needAppearances = false;
    se (aspetto?.needAppearances) {
      needAppearances = true;
      aspetto = nullo;
    }
    costante {
      riferimento esterno
    } = valutatore;
    const originalDict = xref.fetchIfRef(this.ref);
    se (!(originalDict instanceof _primitives.Dict)) {
      restituisci null;
    }
    const dict = new _primitives.Dict(xref);
    per (const chiave di originalDict.getKeys()) {
      se (chiave !== "AP") {
        dict.set(chiave, originalDict.getRaw(chiave));
      }
    }
    costante xfa = {
      percorso: this.data.fieldName,
      valore
    };
    codificatore costante = val => {
      restituisci (0, _core_utils.isAscii)(val) ? val : (0, _core_utils.stringToUTF16String)(val, true);
    };
    dict.set("V", Array.isArray(valore) ? valore.map(encoder) : encoder(valore));
    this.amendSavedDict(annotationStorage, dict);
    const maybeMK = this._getMKDict(rotazione);
    se (forseMK) {
      dict.set("MK", ​​forseMK);
    }
    buffer costante = [];
    modifiche costanti = [{
      rif: this.ref,
      dati: "",
      xfa,
      bisognoApparenze
    }];
    se (aspetto !== null) {
      const newRef = xref.getNewTemporaryRef();
      const AP = new _primitives.Dict(xref);
      dict.set("AP", AP);
      AP.set("N", newRef);
      const risorse = this._getSaveFieldResources(xref);
      const appearanceStream = new _stream.StringStream(appearance);
      const appearanceDict = appearanceStream.dict = new _primitives.Dict(xref);
      appearanceDict.set("Sottotipo", _primitives.Name.get("Form"));
      appearanceDict.set("Risorse", risorse);
      appearanceDict.set("BBox", [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]]);
      const rotationMatrix = this.getRotationMatrix(annotationStorage);
      se (rotationMatrix !== _util.IDENTITY_MATRIX) {
        appearanceDict.set("Matrice", rotationMatrix);
      }
      attendi (0, _writer.writeObject)(newRef, appearanceStream, buffer, xref);
      modifiche.push({
        rif: newRef,
        dati: buffer.join(""),
        xfa: nullo,
        needAppearances: falso
      });
      buffer.lunghezza = 0;
    }
    dict.set("M", `D:${(0, _util.getModificationDate)()}`);
    attendi (0, _writer.writeObject)(this.ref, dict, buffer, xref);
    modifiche[0].data = buffer.join("");
    restituire i cambiamenti;
  }
  async _getAppearance(valutatore, attività, intento, annotazioneStorage) {
    const isPassword = this.hasFieldFlag(_util.AnnotationFieldFlag.PASSWORD);
    se (èPassword) {
      restituisci null;
    }
    const storageEntry = annotationStorage?.get(this.data.id);
    lascia valore, rotazione;
    se (storageEntry) {
      valore = storageEntry.formattedValue || storageEntry.value;
      rotazione = storageEntry.rotation;
    }
    se (rotazione === indefinito e valore === indefinito e !this._needAppearances) {
      se (!this._hasValueFromXFA || this.appearance) {
        restituisci null;
      }
    }
    const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
    se (valore === indefinito) {
      valore = questo.dato.campoValore;
      se (!valore) {
        restituisci `/Tx BMC q ${colori}Q EMC`;
      }
    }
    se (Array.isArray(valore) && valore.lunghezza === 1) {
      valore = valore[0];
    }
    (0, _util.assert)(typeof value === "string", "Ci si aspettava che `value` fosse una stringa.");
    valore = valore.trim();
    se (questo.data.combo) {
      opzione costante = this.data.options.find(({
        valore di esportazione
      }) => valore === exportValue);
      valore = opzione?.displayValue || valore;
    }
    se (valore === "") {
      restituisci `/Tx BMC q ${colori}Q EMC`;
    }
    se (rotazione === indefinito) {
      rotazione = this.rotation;
    }
    lascia lineCount = -1;
    lascia linee;
    se (questo.dati.multilinea) {
      linee = valore.split(/\r\n?|\n/).map(linea => linea.normalizza("NFC"));
      lineCount = lunghezza linee;
    } altro {
      linee = [valore.sostituisci(/\r\n?|\n/, "").normalizza("NFC")];
    }
    const defaultPadding = 1;
    const defaultHPadding = 2;
    lascia altezza totale = this.data.rect[3] - this.data.rect[1];
    lascia totalWidth = this.data.rect[2] - this.data.rect[0];
    se (rotazione === 90 || rotazione === 270) {
      [larghezza totale, altezza totale] = [altezza totale, larghezza totale];
    }
    se (!this._defaultAppearance) {
      this.data.defaultAppearanceData = (0, _default_appearance.parseDefaultAppearance)(this._defaultAppearance = "/Helvetica 0 Tf 0 g");
    }
    lascia font = attendi WidgetAnnotation._getFontData(valutatore, attività, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
    lascia defaultAppearance, fontSize, lineHeight;
    const encodedLines = [];
    lascia che encodingError = false;
    per (const riga di righe) {
      const encodedString = font.encodeString(line);
      se (encodedString.length > 1) {
        encodingError = true;
      }
      encodedLines.push(encodedString.join(""));
    }
    se (encodingError && intent & _util.RenderingIntentFlag.SAVE) {
      ritorno {
        needAppearances: vero
      };
    }
    se (encodingError && this._isOffscreenCanvasSupported) {
      const fontFamily = this.data.comb ? "monospace" : "sans-serif";
      const fakeUnicodeFont = new _default_appearance.FakeUnicodeFont(evaluator.xref, fontFamily);
      const resources = fakeUnicodeFont.createFontResources(lines.join(""));
      const newFont = resources.getRaw("Font");
      se (this._fieldResources.mergedResources.has("Font")) {
        const oldFont = this._fieldResources.mergedResources.get("Font");
        per (const chiave di newFont.getKeys()) {
          oldFont.set(chiave, newFont.getRaw(chiave));
        }
      } altro {
        this._fieldResources.mergedResources.set("Carattere", newFont);
      }
      const fontName = fakeUnicodeFont.fontName.name;
      font = attendi WidgetAnnotation._getFontData(valutatore, attività, {
        NomeFont,
        dimensione carattere: 0
      }, risorse);
      per (lascia che i = 0, ii = encodedLines.length; i < ii; i++) {
        encodedLines[i] = (0, _core_utils.stringToUTF16String)(lines[i]);
      }
      const savedDefaultAppearance = Object.assign(Object.create(null), this.data.defaultAppearanceData);
      this.data.defaultAppearanceData.fontSize = 0;
      this.data.defaultAppearanceData.fontName = fontName;
      [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(totalHeight - 2 * defaultPadding, totalWidth - 2 * defaultHPadding, value, font, lineCount);
      this.data.defaultAppearanceData = savedDefaultAppearance;
    } altro {
      se (!this._isOffscreenCanvasSupported) {
        (0, _util.warn)("_getAppearance: OffscreenCanvas non è supportato, l'annotazione potrebbe non essere visualizzata correttamente.");
      }
      [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(totalHeight - 2 * defaultPadding, totalWidth - 2 * defaultHPadding, value, font, lineCount);
    }
    lascia discesa = font.discesa;
    se (isNaN(discesa)) {
      discesa = _util.BASELINE_FACTOR * lineHeight;
    } altro {
      discesa = Math.max(_util.BASELINE_FACTOR * lineHeight, Math.abs(descent) * fontSize);
    }
    const defaultVPadding = Math.min(Math.floor((totalHeight - fontSize) / 2), defaultPadding);
    allineamento costante = this.data.textAlignment;
    se (questo.dati.multilinea) {
      restituisci questo._getMultilineAppearance(defaultAppearance, encodedLines, font, fontSize, totalWidth, totalHeight, alignment, defaultHPadding, defaultVPadding, descent, lineHeight, annotationStorage);
    }
    se (this.data.comb) {
      restituisci questo._getCombAppearance(defaultAppearance, font, encodedLines[0], fontSize, totalWidth, totalHeight, defaultHPadding, defaultVPadding, descent, lineHeight, annotationStorage);
    }
    const bottomPadding = defaultVPadding + descent;
    se (allineamento === 0 || allineamento > 2) {
      restituisci `/Tx BMC q ${colors}BT ` + defaultAppearance + ` 1 0 0 1 ${(0, _core_utils.numberToString)(defaultHPadding)} ${(0, _core_utils.numberToString)(bottomPadding)} Tm (${(0, _core_utils.escapeString)(encodedLines[0])}) Tj` + " ET Q EMC";
    }
    const prevInfo = {
      spostamento: 0
    };
    const renderedText = this._renderText(encodedLines[0], font, fontSize, totalWidth, allineamento, prevInfo, defaultHPadding, bottomPadding);
    return `/Tx BMC q ${colors}BT ` + defaultAppearance + ` 1 0 0 1 0 0 Tm ${renderedText}` + " ET Q EMC";
  }
  static async _getFontData(valutatore, attività, appearanceData, risorse) {
    const operatorList = new _operator_list.OperatorList();
    const statoiniziale = {
      carattere: nullo,
      clona() {
        restituisci questo;
      }
    };
    costante {
      NomeFont,
      dimensione del carattere
    } = datiaspetto;
    attendi evaluator.handleSetFont(resources, [fontName && _primitives.Name.get(fontName), fontSize], null, operatorList, task, initialState, null);
    restituisci initialState.font;
  }
  _getTextWidth(testo, carattere) {
    restituisci font.charsToGlyphs(testo).reduce((larghezza, glifo) => larghezza + glifo.larghezza, 0) / 1000;
  }
  _computeFontSize(altezza, larghezza, testo, carattere, numero di righe) {
    permettere {
      dimensione del carattere
    } = questo.dati.datiApparenzaPredefiniti;
    lascia lineHeight = (fontSize || 12) * _util.LINE_FACTOR,
      numeroDiLinee = Math.round(altezza / altezzaLinea);
    se (!fontSize) {
      const roundWithTwoDigits = x => Math.floor(x * 100) / 100;
      se (conteggiorighe === -1) {
        const textWidth = this._getTextWidth(testo, carattere);
        fontSize = roundWithTwoDigits(Math.min(altezza / _util.LINE_FACTOR, textWidth > larghezza ? larghezza / textWidth : Infinito));
        numeroDiRighe = 1;
      } altro {
        const lines = text.split(/\r\n?|\n/);
        const cachedLines = [];
        per (const riga di righe) {
          const codificato = font.encodeString(line).join("");
          const glyphs = font.charsToGlyphs(encoded);
          posizioni costanti = font.getCharPositions(codificato);
          cachedLines.push({
            linea: codificata,
            glifi,
            posizioni
          });
        }
        const è troppo grande = fsize => {
          lascia altezza totale = 0;
          per (const cache di cachedLines) {
            const chunks = this._splitLine(null, font, fsize, width, cache);
            altezza totale += chunks.length * fsize;
            se (altezzatotale > altezza) {
              restituisci vero;
            }
          }
          restituisci falso;
        };
        numeroDiRighe = Math.max(numeroDiRighe, conteggioRighe);
        mentre (vero) {
          lineHeight = altezza / numero di linee;
          fontSize = roundWithTwoDigits(lineHeight / _util.LINE_FACTOR);
          se (ètroppogrande(dimensionecarattere)) {
            numeroDiRighe++;
            continuare;
          }
          rottura;
        }
      }
      costante {
        NomeFont,
        colore del carattere
      } = questo.dati.datiApparenzaPredefiniti;
      this._defaultAppearance = (0, _default_appearance.createDefaultAppearance)({
        dimensione del carattere,
        NomeFont,
        colore del carattere
      });
    }
    restituisci [this._defaultAppearance, fontSize, altezza / numero di linee];
  }
  _renderText(testo, font, fontSize, totalWidth, allineamento, prevInfo, hPadding, vPadding) {
    lascia spostare;
    se (allineamento === 1) {
      const width = this._getTextWidth(testo, font) * fontSize;
      shift = (larghezzatotale - larghezza) / 2;
    } altrimenti se (allineamento === 2) {
      const width = this._getTextWidth(testo, font) * fontSize;
      shift = totalWidth - larghezza - hPadding;
    } altro {
      shift = hPadding;
    }
    const shiftStr = (0, _core_utils.numberToString)(shift - prevInfo.shift);
    prevInfo.shift = spostamento;
    vPadding = (0, _core_utils.numberToString)(vPadding);
    restituisci `${shiftStr} ${vPadding} Td (${(0, _core_utils.escapeString)(text)}) Tj`;
  }
  _getSaveFieldResources(xrif) {
    costante {
      Risorse locali,
      aspettoRisorse,
      acroFormResources
    } = this._fieldResources;
    const fontName = this.data.defaultAppearanceData?.fontName;
    se (!fontName) {
      restituisci localResources || _primitives.Dict.empty;
    }
    per (const risorse di [localResources, appearanceResources]) {
      se (risorse instanceof _primitives.Dict) {
        const localFont = resources.get("Font");
        se (localFont instanceof _primitives.Dict && localFont.has(fontName)) {
          restituire le risorse;
        }
      }
    }
    se (acroFormResources instanceof _primitives.Dict) {
      const acroFormFont = acroFormResources.get("Carattere");
      se (acroFormFont instanceof _primitives.Dict && acroFormFont.has(fontName)) {
        const subFontDict = new _primitives.Dict(xref);
        subFontDict.set(fontName, acroFormFont.getRaw(fontName));
        const subResourcesDict = new _primitives.Dict(xref);
        subResourcesDict.set("Carattere", subFontDict);
        restituisci _primitives.Dict.merge({
          riferimento esterno,
          dictArray: [subResourcesDict, localResources],
          mergeSubDicts: vero
        });
      }
    }
    restituisci localResources || _primitives.Dict.empty;
  }
  getFieldObject() {
    restituisci null;
  }
}
classe TextWidgetAnnotation estende WidgetAnnotation {
  costruttore(parametri) {
    super(parametri);
    this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML;
    this._hasText = true;
    const dict = params.dict;
    se (tipo di questo.dato.campoValore !== "stringa") {
      questo.valore.campo.dati = "";
    }
    lascia che l'allineamento = (0, _core_utils.getInheritableProperty)({
      dizionario,
      tasto: "Q"
    });
    se (!Number.isInteger(allineamento) || allineamento < 0 || allineamento > 2) {
      allineamento = nullo;
    }
    this.data.textAlignment = allineamento;
    lascia che maximumLength = (0, _core_utils.getInheritableProperty)({
      dizionario,
      chiave: "MaxLen"
    });
    se (!Number.isInteger(lunghezzamassima) || lunghezzamassima < 0) {
      lunghezzamassima = 0;
    }
    this.data.maxLen = lunghezzamassima;
    this.data.multiLine = this.hasFieldFlag(_util.AnnotationFieldFlag.MULTILINE);
    this.data.comb = this.hasFieldFlag(_util.AnnotationFieldFlag.COMB) && !this.hasFieldFlag(_util.AnnotationFieldFlag.MULTILINE) && !this.hasFieldFlag(_util.AnnotationFieldFlag.PASSWORD) && !this.hasFieldFlag(_util.AnnotationFieldFlag.FILESELECT) && this.data.maxLen !== 0;
    this.data.doNotScroll = this.hasFieldFlag(_util.AnnotationFieldFlag.DONOTSCROLL);
  }
  ottieni hasTextContent() {
    restituisci !!this.appearance && !this._needAppearances;
  }
  _getCombAppearance(defaultAppearance, font, text, fontSize, width, height, hPadding, vPadding, descent, lineHeight, annotationStorage) {
    const combWidth = larghezza / this.data.maxLen;
    const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
    const buf = [];
    posizioni costanti = font.getCharPositions(testo);
    per (const [inizio, fine] di posizioni) {
      buf.push(`(${(0, _core_utils.escapeString)(text.substring(inizio, fine))}) Tj`);
    }
    const renderedComb = buf.join(` ${(0, _core_utils.numberToString)(combWidth)} 0 Td `);
    return `/Tx BMC q ${colors}BT ` + defaultAppearance + ` 1 0 0 1 ${(0, _core_utils.numberToString)(hPadding)} ${(0, _core_utils.numberToString)(vPadding + descent)} Tm ${renderedComb}` + " ET Q EMC";
  }
  _getMultilineAppearance(defaultAppearance, linee, font, fontSize, larghezza, altezza, allineamento, hPadding, vPadding, discesa, lineHeight, annotationStorage) {
    const buf = [];
    const totalWidth = larghezza - 2 * hPadding;
    const prevInfo = {
      spostamento: 0
    };
    per (lascia che i = 0, ii = lunghezza linee; i < ii; i++) {
      const line = lines[i];
      const chunks = this._splitLine(line, font, fontSize, totalWidth);
      per (lascia che j = 0, jj = chunks.length; j < jj; j++) {
        const chunk = chunks[j];
        const vShift = i === 0 && j === 0 ? -vPadding - (lineHeight - discesa) : -lineHeight;
        buf.push(this._renderText(chunk, font, fontSize, width, alignment, prevInfo, hPadding, vShift));
      }
    }
    const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
    const renderedText = buf.join("\n");
    return `/Tx BMC q ${colors}BT ` + defaultAppearance + ` 1 0 0 1 0 ${(0, _core_utils.numberToString)(height)} Tm ${renderedText}` + " ET Q EMC";
  }
  _splitLine(linea, carattere, dimensione carattere, larghezza, cache = {}) {
    riga = cache.riga || riga;
    const glifi = cache.glifi || font.charsToGlyphs(linea);
    se (glifi.lunghezza <= 1) {
      ritorno [linea];
    }
    posizioni costanti = cache.posizioni || font.getCharPositions(linea);
    const scale = fontSize / 1000;
    const blocchi = [];
    lascia lastSpacePosInStringStart = -1,
      lastSpacePosInStringEnd = -1,
      ultimaPos.Spazio = -1,
      startChunk = 0,
      larghezzacorrente = 0;
    per (lascia che i = 0, ii = glyphs.length; i < ii; i++) {
      const [inizio, fine] = posizioni[i];
      const glyph = glyphs[i];
      const glyphWidth = glyph.width * scale;
      se (glifo.unicode === " ") {
        se (larghezzacorrente + larghezzaglifo > larghezza) {
          chunks.push(line.substring(startChunk, start));
          startChunk = inizio;
          larghezzacorrente = larghezzaglifo;
          lastSpacePosInStringStart = -1;
          ultimaPosizioneSpaziale = -1;
        } altro {
          larghezzacorrente += larghezzaglifo;
          lastSpacePosInStringStart = inizio;
          lastSpacePosInStringEnd = fine;
          ultimaPosizioneSpaziale = i;
        }
      } altrimenti se (larghezzacorrente + larghezzaglifo > larghezza) {
        se (lastSpacePosInStringStart !== -1) {
          chunks.push(line.substring(startChunk, lastSpacePosInStringEnd));
          startChunk = lastSpacePosInStringEnd;
          i = ultimaPosizioneSpazio + 1;
          lastSpacePosInStringStart = -1;
          larghezzacorrente = 0;
        } altro {
          chunks.push(line.substring(startChunk, start));
          startChunk = inizio;
          larghezzacorrente = larghezzaglifo;
        }
      } altro {
        larghezzacorrente += larghezzaglifo;
      }
    }
    se (startChunk < lunghezza riga) {
      chunks.push(line.substring(startChunk, line.length));
    }
    restituire i pezzi;
  }
  getFieldObject() {
    ritorno {
      id: questo.data.id,
      valore: this.data.fieldValue,
      defaultValue: questo.dato.defaultFieldValue || "",
      multilinea: this.data.multiLine,
      password: this.hasFieldFlag(_util.AnnotationFieldFlag.PASSWORD),
      charLimit: this.data.maxLen,
      pettine: this.data.comb,
      modificabile: !this.data.readOnly,
      nascosto: questo.dato.nascosto,
      nome: this.data.fieldName,
      rect: questo.dato.rect,
      azioni: questo.dati.azioni,
      pagina: this.data.pageIndex,
      strokeColor: this.data.borderColor,
      fillColor: this.data.backgroundColor,
      rotazione: questa.rotazione,
      tipo: "testo"
    };
  }
}
classe ButtonWidgetAnnotation estende WidgetAnnotation {
  costruttore(parametri) {
    super(parametri);
    this.checkedAppearance = null;
    this.uncheckedAppearance = null;
    this.data.checkBox = !this.hasFieldFlag(_util.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(_util.AnnotationFieldFlag.PUSHBUTTON);
    this.data.radioButton = this.hasFieldFlag(_util.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(_util.AnnotationFieldFlag.PUSHBUTTON);
    this.data.pushButton = this.hasFieldFlag(_util.AnnotationFieldFlag.PUSHBUTTON);
    this.data.isTooltipOnly = false;
    se (questo.dati.checkBox) {
      this._processCheckBox(parametri);
    } altrimenti se (this.data.radioButton) {
      this._processRadioButton(parametri);
    } altrimenti se (this.data.pushButton) {
      this.data.hasOwnCanvas = true;
      this._processPushButton(parametri);
    } altro {
      (0, _util.warn)("Flag di campo non validi per l'annotazione del widget pulsante");
    }
  }
  async getOperatorList(valutatore, attività, intento, renderForms, annotationStorage) {
    se (questo.dati.pulsante) {
      restituisci super.getOperatorList(valutatore, attività, intento, falso, annotationStorage);
    }
    lascia valore = null;
    lascia che la rotazione sia nulla;
    se (annotazioneArchiviazione) {
      const storageEntry = annotationStorage.get(this.data.id);
      valore = storageEntry ? storageEntry.value : null;
      rotazione = storageEntry ? storageEntry.rotation : null;
    }
    se (valore === null && this.appearance) {
      restituisci super.getOperatorList(valutatore, attività, intento, renderForms, annotationStorage);
    }
    se (valore === null || valore === indefinito) {
      valore = this.data.checkBox ? this.data.fieldValue === this.data.exportValue : this.data.fieldValue === this.data.buttonValue;
    }
    const appearance = value ? this.checkedAppearance : this.uncheckedAppearance;
    se (aspetto) {
      const savedAppearance = this.appearance;
      const savedMatrix = appearance.dict.getArray("Matrice") || _util.IDENTITY_MATRIX;
      se (rotazione) {
        appearance.dict.set("Matrice", this.getRotationMatrix(annotationStorage));
      }
      this.appearance = apparenza;
      const operatorList = super.getOperatorList(valutatore, attività, intento, renderForms, annotationStorage);
      questo.aspetto = aspetto salvato;
      appearance.dict.set("Matrice", savedMatrix);
      restituisci operatoreElenco;
    }
    ritorno {
      opList: nuovo _operator_list.OperatorList(),
      separateForm: falso,
      separateCanvas: falso
    };
  }
  async save(valutatore, attività, annotationStorage) {
    se (questo.dati.checkBox) {
      restituisci questo._saveCheckbox(valutatore, attività, annotationStorage);
    }
    se (questo.dati.pulsanteradio) {
      restituisci questo._saveRadioButton(valutatore, attività, annotationStorage);
    }
    restituisci null;
  }
  async _saveCheckbox(valutatore, attività, annotationStorage) {
    se (!annotazioneArchiviazione) {
      restituisci null;
    }
    const storageEntry = annotationStorage.get(this.data.id);
    lascia che rotation = storageEntry?.rotation,
      valore = storageEntry?.value;
    se (rotazione === indefinito) {
      se (valore === indefinito) {
        restituisci null;
      }
      const defaultValue = this.data.fieldValue === this.data.exportValue;
      se (valorepredefinito === valore) {
        restituisci null;
      }
    }
    const dict = evaluator.xref.fetchIfRef(this.ref);
    se (!(dict instanceof _primitives.Dict)) {
      restituisci null;
    }
    se (rotazione === indefinito) {
      rotazione = this.rotation;
    }
    se (valore === indefinito) {
      valore = questo.valore.campo.dati === questo.valore.esportazione.dati;
    }
    costante xfa = {
      percorso: this.data.fieldName,
      valore: valore ? this.data.exportValue : ""
    };
    const name = _primitives.Name.get(value ? this.data.exportValue : "Off");
    dict.set("V", nome);
    dict.set("AS", nome);
    dict.set("M", `D:${(0, _util.getModificationDate)()}`);
    const maybeMK = this._getMKDict(rotazione);
    se (forseMK) {
      dict.set("MK", ​​forseMK);
    }
    buffer costante = [];
    attendi (0, _writer.writeObject)(this.ref, dict, buffer, evaluator.xref);
    ritorno [{
      rif: this.ref,
      dati: buffer.join(""),
      xfa
    }];
  }
  async _saveRadioButton(valutatore, attività, annotationStorage) {
    se (!annotazioneArchiviazione) {
      restituisci null;
    }
    const storageEntry = annotationStorage.get(this.data.id);
    lascia che rotation = storageEntry?.rotation,
      valore = storageEntry?.value;
    se (rotazione === indefinito) {
      se (valore === indefinito) {
        restituisci null;
      }
      const defaultValue = this.data.fieldValue === this.data.buttonValue;
      se (valorepredefinito === valore) {
        restituisci null;
      }
    }
    const dict = evaluator.xref.fetchIfRef(this.ref);
    se (!(dict instanceof _primitives.Dict)) {
      restituisci null;
    }
    se (valore === indefinito) {
      valore = questo.valore.campo.dati === questo.valore.pulsante.dati;
    }
    se (rotazione === indefinito) {
      rotazione = this.rotation;
    }
    costante xfa = {
      percorso: this.data.fieldName,
      valore: valore ? this.data.buttonValue : ""
    };
    const name = _primitives.Name.get(value ? this.data.buttonValue : "Off");
    buffer costante = [];
    lascia parentData = null;
    se (valore) {
      se (this.parent instanceof _primitives.Ref) {
        const parent = evaluator.xref.fetch(this.parent);
        parent.set("V", nome);
        attendi (0, _writer.writeObject)(this.parent, parent, buffer, evaluator.xref);
        parentData = buffer.join("");
        buffer.lunghezza = 0;
      } altrimenti se (this.parent instanceof _primitives.Dict) {
        this.parent.set("V", nome);
      }
    }
    dict.set("AS", nome);
    dict.set("M", `D:${(0, _util.getModificationDate)()}`);
    const maybeMK = this._getMKDict(rotazione);
    se (forseMK) {
      dict.set("MK", ​​forseMK);
    }
    attendi (0, _writer.writeObject)(this.ref, dict, buffer, evaluator.xref);
    const nuoviRiferimenti = [{
      rif: this.ref,
      dati: buffer.join(""),
      xfa
    }];
    se (datigenitori) {
      newRefs.push({
        rif: this.parent,
        dati: parentData,
        xfa: null
      });
    }
    restituisci nuovi Riferimenti;
  }
  _getDefaultCheckedAppearance(parametri, tipo) {
    larghezza costante = this.data.rect[2] - this.data.rect[0];
    altezza costante = this.data.rect[3] - this.data.rect[1];
    const bbox = [0, 0, larghezza, altezza];
    costante FONT_RATIO = 0,8;
    const fontSize = Math.min(larghezza, altezza) * FONT_RATIO;
    lascia metriche, char;
    se (tipo === "controlla") {
      metriche = {
        larghezza: 0,755 * fontSize,
        altezza: 0,705 * fontSize
      };
      carattere = "\x33";
    } else if (tipo === "disco") {
      metriche = {
        larghezza: 0,791 * fontSize,
        altezza: 0,705 * fontSize
      };
      carattere = "\x6C";
    } altro {
      (0, _util.unreachable)(`_getDefaultCheckedAppearance - tipo non supportato: ${type}`);
    }
    const xShift = (0, _core_utils.numberToString)((larghezza - metriche.larghezza) / 2);
    const yShift = (0, _core_utils.numberToString)((altezza - metriche.altezza) / 2);
    aspetto costante = `q BT /PdfJsZaDb ${fontSize} Tf 0 g ${xShift} ${yShift} Td (${char}) Tj ET Q`;
    const appearanceStreamDict = new _primitives.Dict(params.xref);
    appearanceStreamDict.set("FormType", 1);
    appearanceStreamDict.set("Sottotipo", _primitives.Name.get("Form"));
    appearanceStreamDict.set("Tipo", _primitives.Name.get("XObject"));
    appearanceStreamDict.set("BBox", bbox);
    appearanceStreamDict.set("Matrice", [1, 0, 0, 1, 0, 0]);
    appearanceStreamDict.set("Lunghezza", appearance.length);
    const resources = new _primitives.Dict(params.xref);
    const font = new _primitives.Dict(params.xref);
    font.set("PdfJsZaDb", this.fallbackFontDict);
    risorse.set("Carattere", font);
    appearanceStreamDict.set("Risorse", risorse);
    this.checkedAppearance = new _stream.StringStream(aspetto);
    this.checkedAppearance.dict = appearanceStreamDict;
    this._streams.push(this.checkedAppearance);
  }
  _processCheckBox(parametri) {
    const customAppearance = params.dict.get("AP");
    se (!(customAppearance instanceof _primitives.Dict)) {
      ritorno;
    }
    const normalAppearance = customAppearance.get("N");
    se (!(normalAppearance instanceof _primitives.Dict)) {
      ritorno;
    }
    const asValue = this._decodeFormValue(params.dict.get("AS"));
    se (tipo di asValue === "stringa") {
      questo.data.fieldValue = asValue;
    }
    const yes = this.data.fieldValue !== null && this.data.fieldValue !== "Off" ? this.data.fieldValue : "Sì";
    const exportValues ​​= normalAppearance.getKeys();
    se (exportValues.length === 0) {
      exportValues.push("Spento", sì);
    } altrimenti se (exportValues.length === 1) {
      se (exportValues[0] === "Off") {
        exportValues.push(sì);
      } altro {
        exportValues.unshift("Spento");
      }
    } altrimenti se (exportValues.includes(yes)) {
      exportValues.length = 0;
      exportValues.push("Spento", sì);
    } altro {
      const otherYes = exportValues.find(v => v !== "Off");
      exportValues.length = 0;
      exportValues.push("Off", otherYes);
    }
    se (!exportValues.includes(this.data.fieldValue)) {
      this.data.fieldValue = "Spento";
    }
    questo.dati.valore di esportazione = exportValues[1];
    const checkedAppearance = normalAppearance.get(this.data.exportValue);
    this.checkedAppearance = checkedAppearance instanceof _base_stream.BaseStream ? checkedAppearance : null;
    const uncheckedAppearance = normalAppearance.get("Off");
    this.uncheckedAppearance = uncheckedAppearance instanceof _base_stream.BaseStream ? uncheckedAppearance : null;
    se (this.checkedAppearance) {
      this._streams.push(this.checkedAppearance);
    } altro {
      this._getDefaultCheckedAppearance(parametri, "controlla");
    }
    se (this.uncheckedAppearance) {
      this._streams.push(this.uncheckedAppearance);
    }
    questo._fallbackFontDict = questo.fallbackFontDict;
    se (this.data.defaultFieldValue === null) {
      this.data.defaultFieldValue = "Spento";
    }
  }
  _processRadioButton(parametri) {
    questo.data.fieldValue = questo.data.buttonValue = null;
    const fieldParent = params.dict.get("Genitore");
    se (campoParent instanceof _primitives.Dict) {
      this.parent = params.dict.getRaw("Genitore");
      const fieldParentValue = fieldParent.get("V");
      se (campoParentValue instanceof _primitives.Name) {
        questo.data.fieldValue = questo._decodeFormValue(fieldParentValue);
      }
    }
    const appearanceStates = params.dict.get("AP");
    se (!(appearanceStates instanceof _primitives.Dict)) {
      ritorno;
    }
    const normalAppearance = appearanceStates.get("N");
    se (!(normalAppearance instanceof _primitives.Dict)) {
      ritorno;
    }
    per (const chiave di normalAppearance.getKeys()) {
      se (tasto !== "Off") {
        this.data.buttonValue = this._decodeFormValue(key);
        rottura;
      }
    }
    const checkedAppearance = normalAppearance.get(this.data.buttonValue);
    this.checkedAppearance = checkedAppearance instanceof _base_stream.BaseStream ? checkedAppearance : null;
    const uncheckedAppearance = normalAppearance.get("Off");
    this.uncheckedAppearance = uncheckedAppearance instanceof _base_stream.BaseStream ? uncheckedAppearance : null;
    se (this.checkedAppearance) {
      this._streams.push(this.checkedAppearance);
    } altro {
      this._getDefaultCheckedAppearance(parametri, "disco");
    }
    se (this.uncheckedAppearance) {
      this._streams.push(this.uncheckedAppearance);
    }
    questo._fallbackFontDict = questo.fallbackFontDict;
    se (this.data.defaultFieldValue === null) {
      this.data.defaultFieldValue = "Spento";
    }
  }
  _processPushButton(parametri) {
    costante {
      dizionario,
      annotazioneGlobals
    } = parametri;
    se (!dict.has("A") && !dict.has("AA") && !this.data.alternativeText) {
      (0, _util.warn)("I pulsanti senza dizionari di azioni non sono supportati");
      ritorno;
    }
    this.data.isTooltipOnly = !dict.has("A") && !dict.has("AA");
    _catalog.Catalog.parseDestDictionary({
      destDict: dizionario,
      resultObj: questo.dato,
      docBaseUrl: annotationGlobals.baseUrl,
      docAttachments: annotationGlobals.attachments
    });
  }
  getFieldObject() {
    lascia tipo = "pulsante";
    lascia esportareValori;
    se (questo.dati.checkBox) {
      tipo = "casella di controllo";
      exportValues ​​= questo.dati.exportValue;
    } altrimenti se (this.data.radioButton) {
      tipo = "pulsante di scelta";
      exportValues ​​= this.data.buttonValue;
    }
    ritorno {
      id: questo.data.id,
      valore: this.data.fieldValue || "Off",
      defaultValue: this.data.defaultFieldValue,
      valori di esportazione,
      modificabile: !this.data.readOnly,
      nome: this.data.fieldName,
      rect: questo.dato.rect,
      nascosto: questo.dato.nascosto,
      azioni: questo.dati.azioni,
      pagina: this.data.pageIndex,
      strokeColor: this.data.borderColor,
      fillColor: this.data.backgroundColor,
      rotazione: questa.rotazione,
      tipo
    };
  }
  ottieni fallbackFontDict() {
    const dict = new _primitives.Dict();
    dict.set("BaseFont", _primitives.Name.get("ZapfDingbats"));
    dict.set("Tipo", _primitives.Name.get("FallbackType"));
    dict.set("Sottotipo", _primitives.Name.get("FallbackType"));
    dict.set("Codifica", _primitives.Name.get("ZapfDingbatsEncoding"));
    return (0, _util.shadow)(this, "fallbackFontDict", dict);
  }
}
classe ChoiceWidgetAnnotation estende WidgetAnnotation {
  costruttore(parametri) {
    super(parametri);
    costante {
      dizionario,
      riferimento esterno
    } = parametri;
    this.indices = dict.getArray("I");
    this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0;
    queste.opzioni.dati = [];
    opzioni costanti = (0, _core_utils.getInheritableProperty)({
      dizionario,
      chiave: "Opt"
    });
    se (Array.isArray(opzioni)) {
      per (lascia che i = 0, ii = opzioni.lunghezza; i < ii; i++) {
        const option = xref.fetchIfRef(opzioni[i]);
        const isOptionArray = Array.isArray(opzione);
        questo.dati.opzioni[i] = {
          exportValue: this._decodeFormValue(isOptionArray ? xref.fetchIfRef(option[0]) : option),
          displayValue: this._decodeFormValue(isOptionArray ? xref.fetchIfRef(option[1]) : option)
        };
      }
    }
    se (!this.hasIndices) {
      se (tipo di questo.dato.campoValore === "stringa") {
        questo.valore.campo.dati = [questo.valore.campo.dati];
      } altrimenti se (!this.data.fieldValue) {
        questo.valore.campo.dati = [];
      }
    } altro {
      questo.valore.campo.dati = [];
      const ii = this.data.options.length;
      per (const i di questo.indice) {
        se (Number.isInteger(i) && i >= 0 && i < ii) {
          questo.data.fieldValue.push(questo.data.options[i].exportValue);
        }
      }
    }
    this.data.combo = this.hasFieldFlag(_util.AnnotationFieldFlag.COMBO);
    this.data.multiSelect = this.hasFieldFlag(_util.AnnotationFieldFlag.MULTISELECT);
    this._hasText = true;
  }
  getFieldObject() {
    const type = this.data.combo ? "combobox" : "listbox";
    valore costante = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
    ritorno {
      id: questo.data.id,
      valore,
      defaultValue: this.data.defaultFieldValue,
      modificabile: !this.data.readOnly,
      nome: this.data.fieldName,
      rect: questo.dato.rect,
      numItems: questo.data.fieldValue.length,
      Selezione multipla: this.data.multiSelect,
      nascosto: questo.dato.nascosto,
      azioni: questo.dati.azioni,
      elementi: this.data.options,
      pagina: this.data.pageIndex,
      strokeColor: this.data.borderColor,
      fillColor: this.data.backgroundColor,
      rotazione: questa.rotazione,
      tipo
    };
  }
  amendSavedDict(annotationStorage, dict) {
    se (!this.hasIndices) {
      ritorno;
    }
    lascia valori = annotationStorage?.get(this.data.id)?.value;
    se (!Array.isArray(valori)) {
      valori = [valori];
    }
    indici costanti = [];
    costante {
      opzioni
    } = questo.dato;
    per (lascia che i = 0, j = 0, ii = opzioni.lunghezza; i < ii; i++) {
      se (opzioni[i].exportValue === valori[j]) {
        indici.push(i);
        j += 1;
      }
    }
    dict.set("I", indici);
  }
  async _getAppearance(valutatore, attività, intento, annotazioneStorage) {
    se (questo.data.combo) {
      restituisci super._getAppearance(valutatore, attività, intento, annotationStorage);
    }
    lascia exportedValue, rotazione;
    const storageEntry = annotationStorage?.get(this.data.id);
    se (storageEntry) {
      rotazione = storageEntry.rotation;
      exportedValue = storageEntry.value;
    }
    se (rotazione === indefinito && exportedValue === indefinito && !this._needAppearances) {
      restituisci null;
    }
    se (valoreesportato === indefinito) {
      exportedValue = this.data.fieldValue;
    } altrimenti se (!Array.isArray(valoreesportato)) {
      valoreesportato = [valoreesportato];
    }
    const defaultPadding = 1;
    const defaultHPadding = 2;
    lascia altezza totale = this.data.rect[3] - this.data.rect[1];
    lascia totalWidth = this.data.rect[2] - this.data.rect[0];
    se (rotazione === 90 || rotazione === 270) {
      [larghezza totale, altezza totale] = [altezza totale, larghezza totale];
    }
    const lineCount = this.data.options.length;
    const valueIndices = [];
    per (lascia che i = 0; i < lineCount; i++) {
      costante {
        valore di esportazione
      } = this.data.options[i];
      se (valoreesportato.include(valoreesportato)) {
        valueIndices.push(i);
      }
    }
    se (!this._defaultAppearance) {
      this.data.defaultAppearanceData = (0, _default_appearance.parseDefaultAppearance)(this._defaultAppearance = "/Helvetica 0 Tf 0 g");
    }
    const font = await WidgetAnnotation._getFontData(evaluator, task, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
    lascia defaultAppearance;
    permettere {
      dimensione del carattere
    } = questo.dati.datiApparenzaPredefiniti;
    se (!fontSize) {
      const lineHeight = (totalHeight - defaultPadding) / lineCount;
      lascia che lineWidth = -1;
      lascia valore;
      per (cost {
        valore di visualizzazione
      } di this.data.options) {
        const width = this._getTextWidth(displayValue, font);
        se (larghezza > larghezzalinea) {
          lineWidth = larghezza;
          valore = valorevisualizzato;
        }
      }
      [defaultAppearance, fontSize] = this._computeFontSize(lineHeight, totalWidth - 2 * defaultHPadding, value, font, -1);
    } altro {
      defaultAppearance = this._defaultAppearance;
    }
    const lineHeight = fontSize * _util.LINE_FACTOR;
    const vPadding = (altezzalinea - dimensionecarattere) / 2;
    const numberOfVisibleLines = Math.floor(totalHeight / lineHeight);
    lascia primoIndice = 0;
    se (valueIndexes.length > 0) {
      const minIndex = Math.min(...valueIndexs);
      const maxIndex = Math.max(...valueIndexs);
      firstIndex = Math.max(0, maxIndex - numberOfVisibleLines + 1);
      se (primoIndice > minimoIndice) {
        primoIndice = indice minimo;
      }
    }
    const end = Math.min(firstIndex + numberOfVisibleLines + 1, lineCount);
    const buf = ["/Tx BMC q", `1 1 ${totalWidth} ${totalHeight} re W n`];
    se (valoreIndici.lunghezza) {
      buf.push("0,600006 0,756866 0,854904 rg");
      per (indice costante di valueIndices) {
        se (primoIndice <= indice e indice < fine) {
          buf.push(`1 ${totalHeight - (indice - firstIndex + 1) * lineHeight} ${totalWidth} ${lineHeight} re f`);
        }
      }
    }
    buf.push("BT", defaultAppearance, `1 0 0 1 0 ${totalHeight} Tm`);
    const prevInfo = {
      spostamento: 0
    };
    per (lascia che i = primoIndice; i < fine; i++) {
      costante {
        valore di visualizzazione
      } = this.data.options[i];
      const vpadding = i === primoIndice ? vPadding : 0;
      buf.push(this._renderText(displayValue, font, fontSize, totalWidth, 0, prevInfo, defaultHPadding, -lineHeight + vpadding));
    }
    buf.push("ET Q EMC");
    restituisci buf.join("\n");
  }
}
classe SignatureWidgetAnnotation estende WidgetAnnotation {
  costruttore(parametri) {
    super(parametri);
    questo.data.fieldValue = null;
    this.data.hasOwnCanvas = this.data.noRotate;
  }
  getFieldObject() {
    ritorno {
      id: questo.data.id,
      valore: nullo,
      pagina: this.data.pageIndex,
      tipo: "firma"
    };
  }
}
classe TextAnnotation estende MarkupAnnotation {
  costruttore(parametri) {
    const DEFAULT_ICON_SIZE = 22;
    super(parametri);
    this.data.noRotate = true;
    this.data.hasOwnCanvas = this.data.noRotate;
    costante {
      dizionario
    } = parametri;
    questo.data.annotationType = _util.AnnotationType.TEXT;
    se (questo.dato.hasAppearance) {
      this.data.name = "NoIcon";
    } altro {
      this.data.rect[1] = this.data.rect[3] - DEFAULT_ICON_SIZE;
      questo.data.rect[2] = questo.data.rect[0] + DEFAULT_ICON_SIZE;
      this.data.name = dict.has("Nome") ? dict.get("Nome").name : "Nota";
    }
    se (dict.has("Stato")) {
      this.data.state = dict.get("Stato") || null;
      this.data.stateModel = dict.get("StateModel") || null;
    } altro {
      questo.stato.dati = null;
      questo.data.stateModel = null;
    }
  }
}
classe LinkAnnotation estende Annotation {
  costruttore(parametri) {
    super(parametri);
    costante {
      dizionario,
      annotazioneGlobals
    } = parametri;
    questo.data.annotationType = _util.AnnotationType.LINK;
    const quadPoints = getQuadPoints(dict, this.rectangle);
    se (quadPoints) {
      questo.dati.quadPoints = quadPoints;
    }
    questo.data.borderColor ||= questo.data.colore;
    _catalog.Catalog.parseDestDictionary({
      destDict: dizionario,
      resultObj: questo.dato,
      docBaseUrl: annotationGlobals.baseUrl,
      docAttachments: annotationGlobals.attachments
    });
  }
}
classe PopupAnnotation estende Annotation {
  costruttore(parametri) {
    super(parametri);
    costante {
      dizionario
    } = parametri;
    questo.data.annotationType = _util.AnnotationType.POPUP;
    se (questo.dato.rect[0] === questo.dato.rect[2] || questo.dato.rect[1] === questo.dato.rect[3]) {
      questo.dato.rect = null;
    }
    lascia parentItem = dict.get("Genitore");
    se (!elemento genitore) {
      (0, _util.warn)("L'annotazione popup ha un'annotazione padre mancante o non valida.");
      ritorno;
    }
    const parentRect = parentItem.getArray("Rect");
    this.data.parentRect = Array.isArray(parentRect) && parentRect.length === 4 ? _util.Util.normalizeRect(parentRect) : null;
    const rt = parentItem.get("RT");
    se ((0, _primitives.isName)(rt, _util.AnnotationReplyType.GROUP)) {
      parentItem = parentItem.get("IRT");
    }
    se (!parentItem.has("M")) {
      this.data.modificationDate = null;
    } altro {
      this.setModificationDate(parentItem.get("M"));
      questo.data.modifica = questo.datamodifica;
    }
    se (!parentItem.has("C")) {
      questo.dati.colore = null;
    } altro {
      this.setColor(parentItem.getArray("C"));
      questo.dati.colore = questo.colore;
    }
    se (!this.viewable) {
      const parentFlags = parentItem.get("F");
      se (this._isViewable(parentFlags)) {
        questo.setFlags(parentFlags);
      }
    }
    this.setTitle(parentItem.get("T"));
    questo.data.titleObj = questo._titolo;
    this.setContents(parentItem.get("Contenuto"));
    questo.dato.contenutoObj = questo._contenuto;
    se (parentItem.has("RC")) {
      this.data.richText = _factory.XFAFactory.getRichTextAsHtml(parentItem.get("RC"));
    }
    this.data.open = !!dict.get("Apri");
  }
}
esportazioni.PopupAnnotation = PopupAnnotation;
classe FreeTextAnnotation estende MarkupAnnotation {
  costruttore(parametri) {
    super(parametri);
    this.data.hasOwnCanvas = true;
    costante {
      Opzioni di valutazione,
      riferimento esterno
    } = parametri;
    this.data.annotationType = _util.AnnotationType.FREETEXT;
    this.setDefaultAppearance(parametri);
    se (questo.aspetto) {
      costante {
        colore del carattere,
        dimensione del carattere
      } = (0, _default_appearance.parseAppearanceStream)(this.appearance, evaluatorOptions, xref);
      this.data.defaultAppearanceData.fontColor = fontColor;
      this.data.defaultAppearanceData.fontSize = fontSize || 10;
    } altrimenti se (this._isOffscreenCanvasSupported) {
      const strokeAlpha = params.dict.get("CA");
      const fakeUnicodeFont = new _default_appearance.FakeUnicodeFont(xref, "sans-serif");
      questo.dati.defaultAppearanceData.fontSize ||= 10;
      costante {
        colore del carattere,
        dimensione del carattere
      } = questo.dati.datiApparenzaPredefiniti;
      this.appearance = fakeUnicodeFont.createAppearance(this._contents.str, this.rectangle, this.rotation, fontSize, fontColor, strokeAlpha);
      this._streams.push(this.appearance, _default_appearance.FakeUnicodeFont.toUnicodeStream);
    } altro {
      (0, _util.warn)("FreeTextAnnotation: OffscreenCanvas non è supportato, l'annotazione potrebbe non essere visualizzata correttamente.");
    }
  }
  ottieni hasTextContent() {
    restituisci !!questo.aspetto;
  }
  static createNewDict(annotazione, xrif, {
    apRef,
    una persona
  }) {
    costante {
      colore,
      dimensione del carattere,
      dritto,
      rotazione,
      utente,
      valore
    } = annotazione;
    const freetext = new _primitives.Dict(xref);
    freetext.set("Tipo", _primitives.Name.get("Annot"));
    freetext.set("Sottotipo", _primitives.Name.get("FreeText"));
    freetext.set("Data di creazione", `D:${(0, _util.getModificationDate)()}`);
    freetext.set("Rettangolo", rettangolo);
    const da = `/Helv ${fontSize} Tf ${(0, _default_appearance.getPdfColor)(color, true)}`;
    testo libero.set("DA", da);
    freetext.set("Contenuto", (0, _core_utils.isAscii)(valore) ? valore : (0, _core_utils.stringToUTF16String)(valore, vero));
    testo libero.set("F", 4);
    freetext.set("Bordo", [0, 0, 0]);
    freetext.set("Ruota", rotazione);
    se (utente) {
      freetext.set("T", (0, _core_utils.isAscii)(utente) ? utente : (0, _core_utils.stringToUTF16String)(utente, true));
    }
    se (apRef || ap) {
      const n = new _primitives.Dict(xref);
      freetext.set("AP", n);
      se (apRef) {
        n.set("N", apRef);
      } altro {
        n.set("N", ap);
      }
    }
    restituisci testo libero;
  }
  static async createNewAppearanceStream(annotazione, xref, parametri) {
    costante {
      baseFontRef,
      valutatore,
      compito
    } = parametri;
    costante {
      colore,
      dimensione del carattere,
      dritto,
      rotazione,
      valore
    } = annotazione;
    const resources = new _primitives.Dict(xref);
    const font = new _primitives.Dict(xref);
    se (baseFontRef) {
      font.set("Helv", baseFontRef);
    } altro {
      const baseFont = new _primitives.Dict(xref);
      baseFont.set("BaseFont", _primitives.Name.get("Helvetica"));
      baseFont.set("Tipo", _primitives.Name.get("Carattere"));
      baseFont.set("Sottotipo", _primitives.Name.get("Tipo1"));
      baseFont.set("Codifica", _primitives.Name.get("WinAnsiEncoding"));
      font.set("Helv", baseFont);
    }
    risorse.set("Carattere", font);
    const helv = await WidgetAnnotation._getFontData(valutatore, attività, {
      Nome font: "Helv",
      dimensione del carattere
    }, risorse);
    const [x1, y1, x2, y2] = rect;
    sia w = x2 - x1;
    sia h = y2 - y1;
    se (rotazione % 180 !== 0) {
      [l, a] = [a, l];
    }
    const lines = value.split("\n");
    const scale = fontSize / 1000;
    lascia che totalWidth = -Infinity;
    const encodedLines = [];
    per (lascia la linea delle linee) {
      const codificato = helv.encodeString(linea);
      se (encoded.length > 1) {
        restituisci null;
      }
      riga = codificato.join("");
      encodedLines.push(linea);
      lascia che lineWidth = 0;
      const glifi = helv.charsToGlyphs(linea);
      per (glifo costante di glifi) {
        lineWidth += glyph.width * scale;
      }
      larghezzatotale = Math.max(larghezzatotale, larghezzalinea);
    }
    lascia hscale = 1;
    se (larghezza totale > w) {
      hscale = w / larghezzatotale;
    }
    lascia che vscale = 1;
    const lineHeight = _util.LINE_FACTOR * fontSize;
    const lineAscent = (_util.LINE_FACTOR - _util.LINE_DESCENT_FACTOR) * fontSize;
    const totalHeight = lineHeight * lines.length;
    se (altezza totale > h) {
      vscale = h / altezzatotale;
    }
    const fscale = Math.min(hscale, vscale);
    const newFontSize = fontSize * fscale;
    lascia firstPoint, clipBox, matrice;
    interruttore (rotazione) {
      caso 0:
        matrice = [1, 0, 0, 1];
        clipBox = [rect[0], rect[1], w, h];
        primoPunto = [rect[0], rect[3] - lineAscent];
        rottura;
      caso 90:
        matrice = [0, 1, -1, 0];
        clipBox = [rect[1], -rect[2], w, h];
        primoPunto = [rect[1], -rect[0] - lineAscent];
        rottura;
      caso 180:
        matrice = [-1, 0, 0, -1];
        clipBox = [-rect[2], -rect[3], w, h];
        primoPunto = [-rect[2], -rect[1] - lineAscent];
        rottura;
      caso 270:
        matrice = [0, -1, 1, 0];
        clipBox = [-rect[3], rect[0], w, h];
        primoPunto = [-rect[3], rect[2] - lineAscent];
        rottura;
    }
    const buffer = ["q", `${matrix.join(" ")} 0 0 cm`, `${clipBox.join(" ")} re W n`, `BT`, `${(0, _default_appearance.getPdfColor)(color, true)}`, `0 Tc /Helv ${(0, _core_utils.numberToString)(newFontSize)} Tf`];
    buffer.push(`${firstPoint.join(" ")} Td (${(0, _core_utils.escapeString)(encodedLines[0])}) Tj`);
    const vShift = (0, _core_utils.numberToString)(lineHeight);
    per (lascia che i = 1, ii = encodedLines.length; i < ii; i++) {
      const line = encodedLines[i];
      buffer.push(`0 -${vShift} Td (${(0, _core_utils.escapeString)(line)}) Tj`);
    }
    buffer.push("ET", "Q");
    aspetto costante = buffer.join("\n");
    const appearanceStreamDict = new _primitives.Dict(xref);
    appearanceStreamDict.set("FormType", 1);
    appearanceStreamDict.set("Sottotipo", _primitives.Name.get("Form"));
    appearanceStreamDict.set("Tipo", _primitives.Name.get("XObject"));
    appearanceStreamDict.set("BBox", rect);
    appearanceStreamDict.set("Risorse", risorse);
    appearanceStreamDict.set("Matrice", [1, 0, 0, 1, -rect[0], -rect[1]]);
    const ap = new _stream.StringStream(aspetto);
    ap.dict = appearanceStreamDict;
    ritorno ap;
  }
}
classe LineAnnotation estende MarkupAnnotation {
  costruttore(parametri) {
    super(parametri);
    costante {
      dizionario,
      riferimento esterno
    } = parametri;
    questo.data.annotationType = _util.AnnotationType.LINE;
    this.data.hasOwnCanvas = this.data.noRotate;
    const lineCoordinates = dict.getArray("L");
    this.data.lineCoordinates = _util.Util.normalizeRect(lineCoordinates);
    this.setLineEndings(dict.getArray("LE"));
    this.data.lineEndings = this.lineEndings;
    se (!questo.aspetto) {
      const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
      const strokeAlpha = dict.get("CA");
      const interiorColor = getRgbColor(dict.getArray("IC"), null);
      const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
      const fillAlpha = fillColor ? strokeAlpha : null;
      const borderWidth = this.borderStyle.width || 1,
        borderAdjust = 2 * larghezza bordo;
      const bbox = [this.data.lineCoordinates[0] - borderAdjust, this.data.lineCoordinates[1] - borderAdjust, this.data.lineCoordinates[2] + borderAdjust, this.data.lineCoordinates[3] + borderAdjust];
      se (!_util.Util.intersect(this.rectangle, bbox)) {
        questo.rettangolo = bbox;
      }
      questo._setDefaultAppearance({
        riferimento esterno,
        extra: `${borderWidth} w`,
        Colore tratto,
        colore di riempimento,
        colpoAlfa,
        fillAlpha,
        pointsCallback: (buffer, punti) => {
          buffer.push(`${lineCoordinates[0]} ${lineCoordinates[1]} m`, `${lineCoordinates[2]} ${lineCoordinates[3]} l`, "S");
          restituisci [punti[0].x - larghezza bordo, punti[1].x + larghezza bordo, punti[3].y - larghezza bordo, punti[1].y + larghezza bordo];
        }
      });
    }
  }
}
classe SquareAnnotation estende MarkupAnnotation {
  costruttore(parametri) {
    super(parametri);
    costante {
      dizionario,
      riferimento esterno
    } = parametri;
    this.data.annotationType = _util.AnnotationType.SQUARE;
    this.data.hasOwnCanvas = this.data.noRotate;
    se (!questo.aspetto) {
      const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
      const strokeAlpha = dict.get("CA");
      const interiorColor = getRgbColor(dict.getArray("IC"), null);
      const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
      const fillAlpha = fillColor ? strokeAlpha : null;
      se (this.borderStyle.width === 0 && !fillColor) {
        ritorno;
      }
      questo._setDefaultAppearance({
        riferimento esterno,
        extra: `${this.borderStyle.width} w`,
        Colore tratto,
        colore di riempimento,
        colpoAlfa,
        fillAlpha,
        pointsCallback: (buffer, punti) => {
          const x = punti[2].x + this.borderStyle.width / 2;
          const y = punti[2].y + this.borderStyle.width / 2;
          const width = punti[3].x - punti[2].x - this.borderStyle.width;
          altezza costante = punti[1].y - punti[3].y - this.borderStyle.width;
          buffer.push(`${x} ${y} ${larghezza} ${altezza} re`);
          se (fillColor) {
            buffer.push("B");
          } altro {
            buffer.push("S");
          }
          restituisci [punti[0].x, punti[1].x, punti[3].y, punti[1].y];
        }
      });
    }
  }
}
classe CircleAnnotation estende MarkupAnnotation {
  costruttore(parametri) {
    super(parametri);
    costante {
      dizionario,
      riferimento esterno
    } = parametri;
    questo.data.annotationType = _util.AnnotationType.CIRCLE;
    se (!questo.aspetto) {
      const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
      const strokeAlpha = dict.get("CA");
      const interiorColor = getRgbColor(dict.getArray("IC"), null);
      const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
      const fillAlpha = fillColor ? strokeAlpha : null;
      se (this.borderStyle.width === 0 && !fillColor) {
        ritorno;
      }
      const controlPointsDistance = 4 / 3 * Math.tan(Math.PI / (2 * 4));
      questo._setDefaultAppearance({
        riferimento esterno,
        extra: `${this.borderStyle.width} w`,
        Colore tratto,
        colore di riempimento,
        colpoAlfa,
        fillAlpha,
        pointsCallback: (buffer, punti) => {
          const x0 = punti[0].x + this.borderStyle.width / 2;
          const y0 = punti[0].y - this.borderStyle.width / 2;
          const x1 = punti[3].x - this.borderStyle.width / 2;
          const y1 = punti[3].y + this.borderStyle.width / 2;
          costante xMid = x0 + (x1 - x0) / 2;
          costante yMid = y0 + (y1 - y0) / 2;
          const xOffset = (x1 - x0) / 2 * controlPointsDistance;
          const yOffset = (y1 - y0) / 2 * controlPointsDistance;
          buffer.push(`${xMid} ${y1} m`, `${xMid + xOffset} ${y1} ${x1} ${yMid + yOffset} ${x1} ${yMid} c`, `${x1} ${yMid - yOffset} ${xMid + xOffset} ${y0} ${xMid} ${y0} c`, `${xMid - xOffset} ${y0} ${x0} ${yMid - yOffset} ${x0} ${yMid} c`, `${x0} ${yMid + yOffset} ${xMid - xOffset} ${y1} ${xMid} ${y1} c`, "h");
          se (fillColor) {
            buffer.push("B");
          } altro {
            buffer.push("S");
          }
          restituisci [punti[0].x, punti[1].x, punti[3].y, punti[1].y];
        }
      });
    }
  }
}
classe PolylineAnnotation estende MarkupAnnotation {
  costruttore(parametri) {
    super(parametri);
    costante {
      dizionario,
      riferimento esterno
    } = parametri;
    this.data.annotationType = _util.AnnotationType.POLYLINE;
    this.data.hasOwnCanvas = this.data.noRotate;
    questo.dati.vertici = [];
    se (!(questa istanza di PolygonAnnotation)) {
      this.setLineEndings(dict.getArray("LE"));
      this.data.lineEndings = this.lineEndings;
    }
    const rawVertices = dict.getArray("Vertici");
    se (!Array.isArray(rawVertices)) {
      ritorno;
    }
    per (lascia che i = 0, ii = rawVertices.length; i < ii; i += 2) {
      questo.dati.vertici.push({
        x: vertici grezzi[i],
        y: vertici grezzi[i + 1]
      });
    }
    se (!questo.aspetto) {
      const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
      const strokeAlpha = dict.get("CA");
      const borderWidth = this.borderStyle.width || 1,
        borderAdjust = 2 * larghezza bordo;
      const bbox = [Infinito, Infinito, -Infinito, -Infinito];
      per (vertice costante di this.data.vertices) {
        bbox[0] = Math.min(bbox[0], vertex.x - borderAdjust);
        bbox[1] = Math.min(bbox[1], vertex.y - borderAdjust);
        bbox[2] = Math.max(bbox[2], vertex.x + borderAdjust);
        bbox[3] = Math.max(bbox[3], vertex.y + borderAdjust);
      }
      se (!_util.Util.intersect(this.rectangle, bbox)) {
        questo.rettangolo = bbox;
      }
      questo._setDefaultAppearance({
        riferimento esterno,
        extra: `${borderWidth} w`,
        Colore tratto,
        colpoAlfa,
        pointsCallback: (buffer, punti) => {
          vertici costanti = questo.dati.vertici;
          per (lascia che i = 0, ii = vertici.lunghezza; i < ii; i++) {
            buffer.push(`${vertici[i].x} ${vertici[i].y} ${i === 0 ? "m" : "l"}`);
          }
          buffer.push("S");
          restituisci [punti[0].x, punti[1].x, punti[3].y, punti[1].y];
        }
      });
    }
  }
}
classe PolygonAnnotation estende PolylineAnnotation {
  costruttore(parametri) {
    super(parametri);
    this.data.annotationType = _util.AnnotationType.POLYGON;
  }
}
classe CaretAnnotation estende MarkupAnnotation {
  costruttore(parametri) {
    super(parametri);
    this.data.annotationType = _util.AnnotationType.CARET;
  }
}
classe InkAnnotation estende MarkupAnnotation {
  costruttore(parametri) {
    super(parametri);
    this.data.hasOwnCanvas = this.data.noRotate;
    costante {
      dizionario,
      riferimento esterno
    } = parametri;
    questo.data.annotationType = _util.AnnotationType.INK;
    questo.data.inkLists = [];
    const rawInkLists = dict.getArray("InkList");
    se (!Array.isArray(rawInkLists)) {
      ritorno;
    }
    per (lascia che i = 0, ii = rawInkLists.length; i < ii; ++i) {
      questo.dati.inkLists.push([]);
      per (lascia che j = 0, jj = rawInkLists[i].length; j < jj; j += 2) {
        questo.data.inkLists[i].push({
          x: xref.fetchIfRef(rawInkLists[i][j]),
          y: xref.fetchIfRef(rawInkLists[i][j + 1])
        });
      }
    }
    se (!questo.aspetto) {
      const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
      const strokeAlpha = dict.get("CA");
      const borderWidth = this.borderStyle.width || 1,
        borderAdjust = 2 * larghezza bordo;
      const bbox = [Infinito, Infinito, -Infinito, -Infinito];
      per (const inkLists di this.data.inkLists) {
        per (vertice costante di inkLists) {
          bbox[0] = Math.min(bbox[0], vertex.x - borderAdjust);
          bbox[1] = Math.min(bbox[1], vertex.y - borderAdjust);
          bbox[2] = Math.max(bbox[2], vertex.x + borderAdjust);
          bbox[3] = Math.max(bbox[3], vertex.y + borderAdjust);
        }
      }
      se (!_util.Util.intersect(this.rectangle, bbox)) {
        questo.rettangolo = bbox;
      }
      questo._setDefaultAppearance({
        riferimento esterno,
        extra: `${borderWidth} w`,
        Colore tratto,
        colpoAlfa,
        pointsCallback: (buffer, punti) => {
          per (const inkList di this.data.inkLists) {
            per (lascia che i = 0, ii = inkList.length; i < ii; i++) {
              buffer.push(`${inkList[i].x} ${inkList[i].y} ${i === 0 ? "m" : "l"}`);
            }
            buffer.push("S");
          }
          restituisci [punti[0].x, punti[1].x, punti[3].y, punti[1].y];
        }
      });
    }
  }
  static createNewDict(annotazione, xrif, {
    apRef,
    una persona
  }) {
    costante {
      colore,
      opacità,
      percorsi,
      dritto,
      rotazione,
      spessore
    } = annotazione;
    const ink = new _primitives.Dict(xref);
    ink.set("Tipo", _primitives.Name.get("Annot"));
    ink.set("Sottotipo", _primitives.Name.get("Inchiostro"));
    ink.set("Data di creazione", `D:${(0, _util.getModificationDate)()}`);
    ink.set("Rettangolo", rettangolo);
    ink.set("InkList", paths.map(p => p.points));
    inchiostro.set("F", 4);
    ink.set("Ruota", rotazione);
    const bs = new _primitives.Dict(xref);
    inchiostro.set("BS", bs);
    bs.set("W", spessore);
    ink.set("C", Array.from(colore, c => c / 255));
    ink.set("CA", opacità);
    const n = new _primitives.Dict(xref);
    ink.set("AP", n);
    se (apRef) {
      n.set("N", apRef);
    } altro {
      n.set("N", ap);
    }
    restituire l'inchiostro;
  }
  static async createNewAppearanceStream(annotazione, xref, parametri) {
    costante {
      colore,
      dritto,
      percorsi,
      spessore,
      opacità
    } = annotazione;
    const appearanceBuffer = [`${spessore} w 1 J 1 j`, `${(0, _default_appearance.getPdfColor)(colore, false)}`];
    se (opacità !== 1) {
      appearanceBuffer.push("/R0 gs");
    }
    buffer costante = [];
    per (cost {
      Bézier
    } di percorsi) {
      buffer.lunghezza = 0;
      buffer.push(`${(0, _core_utils.numberToString)(bezier[0])} ${(0, _core_utils.numberToString)(bezier[1])} m`);
      per (lascia che i = 2, ii = lunghezza di bezier; i < ii; i += 6) {
        curva costante = bezier.slice(i, i + 6).map(_core_utils.numberToString).join(" ");
        buffer.push(`${curva} c`);
      }
      buffer.push("S");
      apparenzaBuffer.push(buffer.join("\n"));
    }
    const aspetto = appearanceBuffer.join("\n");
    const appearanceStreamDict = new _primitives.Dict(xref);
    appearanceStreamDict.set("FormType", 1);
    appearanceStreamDict.set("Sottotipo", _primitives.Name.get("Form"));
    appearanceStreamDict.set("Tipo", _primitives.Name.get("XObject"));
    appearanceStreamDict.set("BBox", rect);
    appearanceStreamDict.set("Lunghezza", appearance.length);
    se (opacità !== 1) {
      const resources = new _primitives.Dict(xref);
      const extGState = new _primitives.Dict(xref);
      const r0 = new _primitives.Dict(xref);
      r0.set("CA", opacità);
      r0.set("Tipo", _primitives.Name.get("ExtGState"));
      extGState.set("R0", r0);
      risorse.set("ExtGState", extGState);
      appearanceStreamDict.set("Risorse", risorse);
    }
    const ap = new _stream.StringStream(aspetto);
    ap.dict = appearanceStreamDict;
    ritorno ap;
  }
}
classe HighlightAnnotation estende MarkupAnnotation {
  costruttore(parametri) {
    super(parametri);
    costante {
      dizionario,
      riferimento esterno
    } = parametri;
    this.data.annotationType = _util.AnnotationType.HIGHLIGHT;
    const quadPoints = this.data.quadPoints = getQuadPoints(dict, null);
    se (quadPoints) {
      const risorse = this.appearance?.dict.get("Risorse");
      se (!this.appearance || !resources?.has("ExtGState")) {
        se (questo.aspetto) {
          (0, _util.warn)("HighlightAnnotation - ignora il flusso di aspetto incorporato.");
        }
        const fillColor = this.color ? getPdfColorArray(this.color) : [1, 1, 0];
        const fillAlpha = dict.get("CA");
        questo._setDefaultAppearance({
          riferimento esterno,
          colore di riempimento,
          blendMode: "Moltiplica",
          fillAlpha,
          pointsCallback: (buffer, punti) => {
            buffer.push(`${punti[0].x} ${punti[0].y} m`, `${punti[1].x} ${punti[1].y} l`, `${punti[3].x} ${punti[3].y} l`, `${punti[2].x} ${punti[2].y} l`, "f");
            restituisci [punti[0].x, punti[1].x, punti[3].y, punti[1].y];
          }
        });
      }
    } altro {
      questo.data.popupRef = null;
    }
  }
}
classe UnderlineAnnotation estende MarkupAnnotation {
  costruttore(parametri) {
    super(parametri);
    costante {
      dizionario,
      riferimento esterno
    } = parametri;
    this.data.annotationType = _util.AnnotationType.UNDERLINE;
    const quadPoints = this.data.quadPoints = getQuadPoints(dict, null);
    se (quadPoints) {
      se (!questo.aspetto) {
        const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
        const strokeAlpha = dict.get("CA");
        questo._setDefaultAppearance({
          riferimento esterno,
          extra: "[] 0 d 0,571 w",
          Colore tratto,
          colpoAlfa,
          pointsCallback: (buffer, punti) => {
            buffer.push(`${punti[2].x} ${punti[2].y + 1,3} m`, `${punti[3].x} ${punti[3].y + 1,3} l`, "S");
            restituisci [punti[0].x, punti[1].x, punti[3].y, punti[1].y];
          }
        });
      }
    } altro {
      questo.data.popupRef = null;
    }
  }
}
classe SquigglyAnnotation estende MarkupAnnotation {
  costruttore(parametri) {
    super(parametri);
    costante {
      dizionario,
      riferimento esterno
    } = parametri;
    this.data.annotationType = _util.AnnotationType.SQUIGGLY;
    const quadPoints = this.data.quadPoints = getQuadPoints(dict, null);
    se (quadPoints) {
      se (!questo.aspetto) {
        const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
        const strokeAlpha = dict.get("CA");
        questo._setDefaultAppearance({
          riferimento esterno,
          extra: "[] 0 d 1 w",
          Colore tratto,
          colpoAlfa,
          pointsCallback: (buffer, punti) => {
            const dy = (punti[0].y - punti[2].y) / 6;
            lascia shift = dy;
            lascia x = punti[2].x;
            const y = punti[2].y;
            const xEnd = punti[3].x;
            buffer.push(`${x} ${y + shift} m`);
            Fare {
              x += 2;
              spostamento = spostamento === 0 ? dy : 0;
              buffer.push(`${x} ${y + shift} l`);
            } mentre (x < xEnd);
            buffer.push("S");
            ritorna [punti[2].x, xEnd, y - 2 * dy, y + 2 * dy];
          }
        });
      }
    } altro {
      questo.data.popupRef = null;
    }
  }
}
classe StrikeOutAnnotation estende MarkupAnnotation {
  costruttore(parametri) {
    super(parametri);
    costante {
      dizionario,
      riferimento esterno
    } = parametri;
    this.data.annotationType = _util.AnnotationType.STRIKEOUT;
    const quadPoints = this.data.quadPoints = getQuadPoints(dict, null);
    se (quadPoints) {
      se (!questo.aspetto) {
        const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
        const strokeAlpha = dict.get("CA");
        questo._setDefaultAppearance({
          riferimento esterno,
          extra: "[] 0 d 1 w",
          Colore tratto,
          colpoAlfa,
          pointsCallback: (buffer, punti) => {
            buffer.push(`${(punti[0].x + punti[2].x) / 2} ` + `${(punti[0].y + punti[2].y) / 2} m`, `${(punti[1].x + punti[3].x) / 2} ` + `${(punti[1].y + punti[3].y) / 2} l`, "S");
            restituisci [punti[0].x, punti[1].x, punti[3].y, punti[1].y];
          }
        });
      }
    } altro {
      questo.data.popupRef = null;
    }
  }
}
classe StampAnnotation estende MarkupAnnotation {
  costruttore(parametri) {
    super(parametri);
    questo.data.annotationType = _util.AnnotationType.STAMP;
    this.data.hasOwnCanvas = this.data.noRotate;
  }
  statico asincrono createImage(bitmap, xref) {
    costante {
      larghezza,
      altezza
    } = bitmap;
    const canvas = new OffscreenCanvas(larghezza, altezza);
    const ctx = canvas.getContext("2d", {
      alfa: vero
    });
    ctx.drawImage(bitmap, 0, 0);
    const data = ctx.getImageData(0, 0, larghezza, altezza).data;
    const buf32 = new Uint32Array(data.buffer);
    const hasAlpha = buf32.some(_util.FeatureTest.isLittleEndian ? x => x >>> 24 !== 0xff : x => (x & 0xff) !== 0xff);
    se (haAlpha) {
      ctx.fillStyle = "bianco";
      ctx.fillRect(0, 0, larghezza, altezza);
      ctx.drawImage(bitmap, 0, 0);
    }
    const jpegBufferPromise = canvas.convertToBlob({
      tipo: "immagine/jpeg",
      qualità: 1
    }).then(blob => {
      restituisci blob.arrayBuffer();
    });
    const xobjectName = _primitives.Name.get("XObject");
    const imageName = _primitives.Name.get("Immagine");
    const image = new _primitives.Dict(xref);
    image.set("Tipo", xobjectName);
    image.set("Sottotipo", nomeimmagine);
    image.set("BitsPerComponent", 8);
    image.set("ColorSpace", _primitives.Name.get("DeviceRGB"));
    image.set("Filtro", _primitives.Name.get("DCTDecode"));
    image.set("BBox", [0, 0, larghezza, altezza]);
    image.set("Larghezza", larghezza);
    image.set("Altezza", altezza);
    lascia smaskStream = null;
    se (haAlpha) {
      const alphaBuffer = new Uint8Array(buf32.length);
      se (_util.FeatureTest.isLittleEndian) {
        per (lascia che i = 0, ii = buf32.length; i < ii; i++) {
          alphaBuffer[i] = buf32[i] >>> 24;
        }
      } altro {
        per (lascia che i = 0, ii = buf32.length; i < ii; i++) {
          alphaBuffer[i] = buf32[i] & 0xff;
        }
      }
      const smask = new _primitives.Dict(xref);
      smask.set("Tipo", xobjectName);
      smask.set("Sottotipo", nomeimmagine);
      smask.set("BitPerComponente", 8);
      smask.set("ColorSpace", _primitives.Name.get("DeviceGray"));
      smask.set("Larghezza", larghezza);
      smask.set("Altezza", altezza);
      smaskStream = new _stream.Stream(alphaBuffer, 0, 0, smask);
    }
    const imageStream = new _stream.Stream(await jpegBufferPromise, 0, 0, image);
    ritorno {
      flusso di immagini,
      smaskStream,
      larghezza,
      altezza
    };
  }
  static createNewDict(annotazione, xrif, {
    apRef,
    una persona
  }) {
    costante {
      dritto,
      rotazione,
      utente
    } = annotazione;
    const stamp = new _primitives.Dict(xref);
    stamp.set("Tipo", _primitives.Name.get("Annot"));
    stamp.set("Sottotipo", _primitives.Name.get("Timbro"));
    stamp.set("Data di creazione", `D:${(0, _util.getModificationDate)()}`);
    stamp.set("Rettangolo", rettangolo);
    timbro.set("F", 4);
    timbro.set("Bordo", [0, 0, 0]);
    stamp.set("Ruota", rotazione);
    se (utente) {
      stamp.set("T", (0, _core_utils.isAscii)(utente) ? utente : (0, _core_utils.stringToUTF16String)(utente, true));
    }
    se (apRef || ap) {
      const n = new _primitives.Dict(xref);
      timbro.set("AP", n);
      se (apRef) {
        n.set("N", apRef);
      } altro {
        n.set("N", ap);
      }
    }
    timbro di ritorno;
  }
  static async createNewAppearanceStream(annotazione, xref, parametri) {
    costante {
      rotazione
    } = annotazione;
    costante {
      imageRef,
      larghezza,
      altezza
    } = params.image;
    const resources = new _primitives.Dict(xref);
    const xobject = new _primitives.Dict(xref);
    risorse.set("XObject", xobject);
    xobject.set("Im0", imageRef);
    aspetto costante = `q ${larghezza} 0 0 ${altezza} 0 0 cm /Im0 Do Q`;
    const appearanceStreamDict = new _primitives.Dict(xref);
    appearanceStreamDict.set("FormType", 1);
    appearanceStreamDict.set("Sottotipo", _primitives.Name.get("Form"));
    appearanceStreamDict.set("Tipo", _primitives.Name.get("XObject"));
    appearanceStreamDict.set("BBox", [0, 0, larghezza, altezza]);
    appearanceStreamDict.set("Risorse", risorse);
    se (rotazione) {
      matrice costante = (0, _core_utils.getRotationMatrix)(rotazione, larghezza, altezza);
      appearanceStreamDict.set("Matrice", matrice);
    }
    const ap = new _stream.StringStream(aspetto);
    ap.dict = appearanceStreamDict;
    ritorno ap;
  }
}
classe FileAttachmentAnnotation estende MarkupAnnotation {
  costruttore(parametri) {
    super(parametri);
    costante {
      dizionario,
      riferimento esterno
    } = parametri;
    const file = new _file_spec.FileSpec(dict.get("FS"), xref);
    this.data.annotationType = _util.AnnotationType.FILEATTACHMENT;
    this.data.hasOwnCanvas = this.data.noRotate;
    questo.file.dati = file.serializzabile;
    const nome = dict.get("Nome");
    this.data.name = name instanceof _primitives.Name ? (0, _util.stringToPDFString)(name.name) : "PushPin";
    const fillAlpha = dict.get("ca");
    this.data.fillAlpha = typeof fillAlpha === "numero" && fillAlpha >= 0 && fillAlpha <= 1 ? fillAlpha : null;
  }
}

/***/ }),
/* 11 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.FakeUnicodeFont = void 0;
exports.createDefaultAppearance = createDefaultAppearance;
esportazioni.getPdfColor = getPdfColor;
esportazioni.parseAppearanceStream = parseAppearanceStream;
exports.parseDefaultAppearance = parseDefaultAppearance;
var _primitives = __w_pdfjs_require__(4);
var _core_utils = __w_pdfjs_require__(3);
var _util = __w_pdfjs_require__(2);
var _colorspace = __w_pdfjs_require__(12);
var _evaluator = __w_pdfjs_require__(13);
var _image_utils = __w_pdfjs_require__(59);
var _function = __w_pdfjs_require__(57);
var _stream = __w_pdfjs_require__(8);
classe DefaultAppearanceEvaluator estende _evaluator.EvaluatorPreprocessor {
  costruttore(str) {
    super(nuovo _stream.StringStream(str));
  }
  analizzare() {
    operazione costante = {
      nota: 0,
      argomenti: []
    };
    risultato costante = {
      dimensione carattere: 0,
      NomeFont: "",
      fontColor: nuovo Uint8ClampedArray(3)
    };
    Tentativo {
      mentre (vero) {
        lunghezza.argomenti.operazione = 0;
        se (!this.read(operazione)) {
          rottura;
        }
        se (this.savedStatesDepth !== 0) {
          continuare;
        }
        costante {
          fn,
          argomenti
        } = operazione;
        interruttore (fn | 0) {
          caso _util.OPS.setFont:
            const [nome_carattere, dimensione_carattere] = argomenti;
            se (fontName instanceof _primitives.Name) {
              risultato.nomefont = nomefont.nome;
            }
            se (tipo di fontSize === "numero" e fontSize > 0) {
              risultato.fontSize = fontSize;
            }
            rottura;
          caso _util.OPS.setFillRGBColor:
            _colorspace.ColorSpace.singletons.rgb.getRgbItem(args, 0, result.fontColor, 0);
            rottura;
          caso _util.OPS.setFillGray:
            _colorspace.ColorSpace.singletons.gray.getRgbItem(args, 0, result.fontColor, 0);
            rottura;
          caso _util.OPS.setFillCMYKColor:
            _colorspace.ColorSpace.singletons.cmyk.getRgbItem(args, 0, result.fontColor, 0);
            rottura;
        }
      }
    } cattura (motivo) {
      (0, _util.warn)(`parseDefaultAppearance - ignorando gli errori: "${reason}".`);
    }
    restituisci il risultato;
  }
}
funzione parseDefaultAppearance(str) {
  restituisci nuovo DefaultAppearanceEvaluator(str).parse();
}
classe AppearanceStreamEvaluator estende _evaluator.EvaluatorPreprocessor {
  costruttore(flusso, opzionivalutatore, riferimento incrociato) {
    super(flusso);
    questo.flusso = flusso;
    this.evaluatorOptions = evaluatorOptions;
    questo.xref = xref;
    this.resources = stream.dict?.get("Risorse");
  }
  analizzare() {
    operazione costante = {
      nota: 0,
      argomenti: []
    };
    lascia risultato = {
      fattore di scala: 1,
      dimensione carattere: 0,
      NomeFont: "",
      fontColor: nuovo Uint8ClampedArray(3),
      fillColorSpace: _colorspace.ColorSpace.singletons.gray
    };
    lascia breakLoop = false;
    pila costante = [];
    Tentativo {
      mentre (vero) {
        lunghezza.argomenti.operazione = 0;
        se (breakLoop || !this.read(operazione)) {
          rottura;
        }
        costante {
          fn,
          argomenti
        } = operazione;
        interruttore (fn | 0) {
          caso _util.OPS.save:
            pila.push({
              scaleFactor: risultato.scaleFactor,
              fontSize: risultato.fontSize,
              fontName: risultato.fontName,
              fontColor: risultato.fontColor.slice(),
              fillColorSpace: risultato.fillColorSpace
            });
            rottura;
          caso _util.OPS.restore:
            risultato = stack.pop() || risultato;
            rottura;
          caso _util.OPS.setTextMatrix:
            risultato.scaleFactor *= Math.hypot(args[0], args[1]);
            rottura;
          caso _util.OPS.setFont:
            const [nome_carattere, dimensione_carattere] = argomenti;
            se (fontName instanceof _primitives.Name) {
              risultato.nomefont = nomefont.nome;
            }
            se (tipo di fontSize === "numero" e fontSize > 0) {
              risultato.fontSize = fontSize * risultato.scaleFactor;
            }
            rottura;
          caso _util.OPS.setFillColorSpace:
            risultato.riempimentoSpazioColore = _spaziocolori.SpazioColore.parse({
              cs: argomenti[0],
              xrif: questo.xrif,
              risorse: questo.risorse,
              pdfFunctionFactory: questo._pdfFunctionFactory,
              localColorSpaceCache: this._localColorSpaceCache
            });
            rottura;
          caso _util.OPS.setFillColor:
            const cs = risultato.riempimentoSpazioColore;
            cs.getRgbItem(args, 0, result.fontColor, 0);
            rottura;
          caso _util.OPS.setFillRGBColor:
            _colorspace.ColorSpace.singletons.rgb.getRgbItem(args, 0, result.fontColor, 0);
            rottura;
          caso _util.OPS.setFillGray:
            _colorspace.ColorSpace.singletons.gray.getRgbItem(args, 0, result.fontColor, 0);
            rottura;
          caso _util.OPS.setFillCMYKColor:
            _colorspace.ColorSpace.singletons.cmyk.getRgbItem(args, 0, result.fontColor, 0);
            rottura;
          caso _util.OPS.showText:
          caso _util.OPS.showSpacedText:
          caso _util.OPS.nextLineShowText:
          caso _util.OPS.nextLineSetSpacingShowText:
            breakLoop = true;
            rottura;
        }
      }
    } cattura (motivo) {
      (0, _util.warn)(`parseAppearanceStream - ignorando gli errori: "${reason}".`);
    }
    questo.stream.reset();
    elimina result.scaleFactor;
    elimina risultato.fillColorSpace;
    restituisci il risultato;
  }
  ottieni _localColorSpaceCache() {
    return (0, _util.shadow)(this, "_localColorSpaceCache", new _image_utils.LocalColorSpaceCache());
  }
  ottieni _pdfFunctionFactory() {
    const pdfFunctionFactory = new _function.PDFFunctionFactory({
      xrif: questo.xrif,
      isEvalSupported: this.evaluatorOptions.isEvalSupported
    });
    return (0, _util.shadow)(this, "_pdfFunctionFactory", pdfFunctionFactory);
  }
}
funzione parseAppearanceStream(stream, evaluatorOptions, xref) {
  restituisce nuovo AppearanceStreamEvaluator(stream, evaluatorOptions, xref).parse();
}
funzione getPdfColor(colore, isFill) {
  se (colore[0] === colore[1] e colore[1] === colore[2]) {
    const grigio = colore[0] / 255;
    restituisci `${(0, _core_utils.numberToString)(gray)} ${isFill ? "g" : "G"}`;
  }
  restituisci Array.from(colore, c => (0, _core_utils.numberToString)(c / 255)).join(" ") + ` ${isFill ? "rg" : "RG"}`;
}
funzione createDefaultAppearance({
  dimensione del carattere,
  NomeFont,
  colore del carattere
}) {
  restituisci `/${(0, _core_utils.escapePDFName)(fontName)} ${fontSize} Tf ${getPdfColor(fontColor, true)}`;
}
classe FakeUnicodeFont {
  costruttore(xref, fontFamily) {
    questo.xref = xref;
    questo.larghezze = null;
    this.firstChar = Infinito;
    this.lastChar = -Infinity;
    this.fontFamily = fontFamily;
    const canvas = new OffscreenCanvas(1, 1);
    this.ctxMeasure = canvas.getContext("2d");
    se (!FakeUnicodeFont._fontNameId) {
      FakeUnicodeFont._fontNameId = 1;
    }
    this.fontName = _primitives.Name.get(`InvalidPDFjsFont_${fontFamily}_${FakeUnicodeFont._fontNameId++}`);
  }
  vai aUnicodeRef() {
    se (!FakeUnicodeFont._toUnicodeRef) {
      const toUnicode = `/CIDInit /ProcSet findresource begin
12 dict iniziano
mappa di inizio
/CIDSystemInfo
<< /Registro (Adobe)
/Ordinamento (UCS) /Supplemento 0 >> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000> <FFFF>
intervallo di spazio del codice finale
1 beginbfrange
<0000> <FFFF> <0000>
endbfrange
endcmap CMapName currentdict /CMap defineresource pop end end`;
      const toUnicodeStream = FakeUnicodeFont.toUnicodeStream = new _stream.StringStream(toUnicode);
      const toUnicodeDict = new _primitives.Dict(this.xref);
      toUnicodeStream.dict = toUnicodeDict;
      toUnicodeDict.set("Lunghezza", toUnicode.length);
      FakeUnicodeFont._toUnicodeRef = this.xref.getNewPersistentRef(toUnicodeStream);
    }
    restituisci FakeUnicodeFont._toUnicodeRef;
  }
  ottieni fontDescriptorRef() {
    if (!FakeUnicodeFont._fontDescriptorRef) {
      const fontDescriptor = new _primitives.Dict(this.xref);
      fontDescriptor.set("Tipo", _primitives.Name.get("FontDescriptor"));
      fontDescriptor.set("NomeFont", this.fontName);
      fontDescriptor.set("FontFamily", "MyriadPro Regular");
      fontDescriptor.set("FontBBox", [0, 0, 0, 0]);
      fontDescriptor.set("FontStretch", _primitives.Name.get("Normale"));
      fontDescriptor.set("PesoFont", 400);
      fontDescriptor.set("ItalicAngle", 0);
      FakeUnicodeFont._fontDescriptorRef = this.xref.getNewPersistentRef(fontDescriptor);
    }
    restituisci FakeUnicodeFont._fontDescriptorRef;
  }
  ottieni descendantFontRef() {
    const descendantFont = new _primitives.Dict(this.xref);
    descendantFont.set("BaseFont", this.fontName);
    descendantFont.set("Tipo", _primitives.Name.get("Carattere"));
    descendantFont.set("Sottotipo", _primitives.Name.get("CIDFontType0"));
    descendantFont.set("CIDToGIDMap", _primitives.Name.get("Identità"));
    descendantFont.set("FirstChar", this.firstChar);
    descendantFont.set("UltimoCarattere", this.ultimoCarattere);
    discendenteFont.set("FontDescriptor", this.fontDescriptorRef);
    descendantFont.set("DW", 1000);
    larghezze costanti = [];
    const chars = [...this.widths.entries()].sort();
    lascia che currentChar = null;
    lascia che currentWidths = null;
    per (const [char, larghezza] di caratteri) {
      se (!currentChar) {
        currentChar = char;
        larghezzecorrenti = [larghezza];
        continuare;
      }
      se (char === currentChar + currentWidths.length) {
        currentWidths.push(larghezza);
      } altro {
        larghezze.push(currentChar, currentWidths);
        currentChar = char;
        larghezzecorrenti = [larghezza];
      }
    }
    se (currentChar) {
      larghezze.push(currentChar, currentWidths);
    }
    descendantFont.set("W", larghezze);
    const cidSystemInfo = new _primitives.Dict(this.xref);
    cidSystemInfo.set("Ordinamento", "Identità");
    cidSystemInfo.set("Registro", "Adobe");
    cidSystemInfo.set("Supplemento", 0);
    descendantFont.set("CIDSystemInfo", cidSystemInfo);
    restituisci this.xref.getNewPersistentRef(descendantFont);
  }
  ottieni baseFontRef() {
    const baseFont = new _primitives.Dict(this.xref);
    baseFont.set("BaseFont", this.fontName);
    baseFont.set("Tipo", _primitives.Name.get("Carattere"));
    baseFont.set("Sottotipo", _primitives.Name.get("Type0"));
    baseFont.set("Codifica", _primitives.Name.get("Identità-H"));
    baseFont.set("Caratteri discendenti", [this.descendantFontRef]);
    baseFont.set("ToUnicode", this.toUnicodeRef);
    restituisci this.xref.getNewPersistentRef(baseFont);
  }
  ottenere risorse() {
    const resources = new _primitives.Dict(this.xref);
    const font = new _primitives.Dict(this.xref);
    font.set(this.fontName.name, this.baseFontRef);
    risorse.set("Carattere", font);
    restituire le risorse;
  }
  _creaContesto() {
    this.widths = new Map();
    this.ctxMeasure.font = `1000px ${this.fontFamily}`;
    restituisci this.ctxMeasure;
  }
  createFontResources(testo) {
    const ctx = this._createContext();
    per (const riga di testo.split(/\r\n?|\n/)) {
      per (const char di line.split("")) {
        codice costante = char.charCodeAt(0);
        se (this.widths.has(codice)) {
          continuare;
        }
        metriche costanti = ctx.measureText(char);
        larghezza costante = Math.ceil(metrics.width);
        this.widths.set(codice, larghezza);
        this.firstChar = Math.min(codice, this.firstChar);
        this.lastChar = Math.max(codice, this.lastChar);
      }
    }
    restituisci questo.risorse;
  }
  createAppearance(testo, rettangolo, rotazione, dimensione carattere, colore sfondo, strokeAlpha) {
    const ctx = this._createContext();
    linee costanti = [];
    lascia maxWidth = -Infinito;
    per (const riga di testo.split(/\r\n?|\n/)) {
      linee.push(linea);
      const lineWidth = ctx.measureText(line).width;
      maxWidth = Math.max(maxWidth, lineWidth);
      per (const char di line.split("")) {
        codice costante = char.charCodeAt(0);
        lascia larghezza = this.widths.get(codice);
        se (larghezza === indefinito) {
          metriche costanti = ctx.measureText(char);
          larghezza = Math.ceil(metrics.width);
          this.widths.set(codice, larghezza);
          this.firstChar = Math.min(codice, this.firstChar);
          this.lastChar = Math.max(codice, this.lastChar);
        }
      }
    }
    larghezza massima *= dimensione carattere / 1000;
    const [x1, y1, x2, y2] = rect;
    sia w = x2 - x1;
    sia h = y2 - y1;
    se (rotazione % 180 !== 0) {
      [l, a] = [a, l];
    }
    lascia hscale = 1;
    se (larghezza massima > w) {
      hscale = w / maxWidth;
    }
    lascia che vscale = 1;
    const lineHeight = _util.LINE_FACTOR * fontSize;
    const lineDescent = _util.LINE_DESCENT_FACTOR * fontSize;
    const maxHeight = lineHeight * lines.length;
    se (altezza massima > h) {
      scala verticale = h / altezza massima;
    }
    const fscale = Math.min(hscale, vscale);
    const newFontSize = fontSize * fscale;
    const buffer = ["q", `0 0 ${(0, _core_utils.numberToString)(w)} ${(0, _core_utils.numberToString)(h)} re W n`, `BT`, `1 0 0 1 0 ${(0, _core_utils.numberToString)(h + lineDescent)} Tm 0 Tc ${getPdfColor(bgColor, true)}`, `/${this.fontName.name} ${(0, _core_utils.numberToString)(newFontSize)} Tf`];
    costante {
      risorse
    } = questo;
    strokeAlpha = typeof strokeAlpha === "numero" && strokeAlpha >= 0 && strokeAlpha <= 1 ? strokeAlpha : 1;
    se (strokeAlpha !== 1) {
      buffer.push("/R0 gs");
      const extGState = new _primitives.Dict(this.xref);
      const r0 = new _primitives.Dict(this.xref);
      r0.set("ca", strokeAlpha);
      r0.set("CA", strokeAlpha);
      r0.set("Tipo", _primitives.Name.get("ExtGState"));
      extGState.set("R0", r0);
      risorsa s.set("ExtGState", extGState);
    }
    const vShift = (0, _core_utils.numberToString)(lineHeight);
    per (const riga di righe) {
      buffer.push(`0 -${vShift} Td <${(0, _core_utils.stringToUTF16HexString)(line)}> Tj`);
    }
    buffer.push("ET", "Q");
    aspetto costante = buffer.join("\n");
    const appearanceStreamDict = new _primitives.Dict(this.xref);
    appearanceStreamDict.set("Sottotipo", _primitives.Name.get("Form"));
    appearanceStreamDict.set("Tipo", _primitives.Name.get("XObject"));
    appearanceStreamDict.set("BBox", [0, 0, w, h]);
    appearanceStreamDict.set("Lunghezza", appearance.length);
    appearanceStreamDict.set("Risorse", risorse);
    se (rotazione) {
      matrice costante = (0, _core_utils.getRotationMatrix)(rotazione, w, h);
      appearanceStreamDict.set("Matrice", matrice);
    }
    const ap = new _stream.StringStream(aspetto);
    ap.dict = appearanceStreamDict;
    ritorno ap;
  }
}
esportazioni.FakeUnicodeFont = FakeUnicodeFont;

/***/ }),
/* 12 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.ColorSpace = void 0;
var _util = __w_pdfjs_require__(2);
var _primitives = __w_pdfjs_require__(4);
var _base_stream = __w_pdfjs_require__(5);
var _core_utils = __w_pdfjs_require__(3);
funzione resizeRgbImage(src, dest, w1, h1, w2, h2, alpha01) {
  const COMPONENTI = 3;
  alfa01 = alfa01 !== 1 ? 0: alfa01;
  costante xRatio = w1 / w2;
  costante yRatio = h1 / h2;
  lascia nuovoIndice = 0,
    vecchioIndice;
  const xScaled = new Uint16Array(w2);
  const w1Scanline = w1 * COMPONENTI;
  per (lascia che i = 0; i < w2; i++) {
    xScaled[i] = Math.floor(i * xRatio) * COMPONENTI;
  }
  per (lascia che i = 0; i < h2; i++) {
    const py = Math.floor(i * yRatio) * w1Scanline;
    per (lascia j = 0; j < w2; j++) {
      vecchioIndice = py + xScaled[j];
      dest[nuovoIndice++] = src[vecchioIndice++];
      dest[nuovoIndice++] = src[vecchioIndice++];
      dest[nuovoIndice++] = src[vecchioIndice++];
      nuovoIndice += alpha01;
    }
  }
}
classe ColorSpace {
  costruttore(nome, numComps) {
    se (questo.costruttore === ColorSpace) {
      (0, _util.unreachable)("Impossibile inizializzare ColorSpace.");
    }
    questo.nome = nome;
    questo.numComps = numComps;
  }
  getRgb(src, srcOffset) {
    const rgb = new Uint8ClampedArray(3);
    this.getRgbItem(src, srcOffset, rgb, 0);
    restituisci rgb;
  }
  getRgbItem(src, srcOffset, dest, destOffset) {
    (0, _util.unreachable)("Non dovrebbe chiamare ColorSpace.getRgbItem");
  }
  getRgbBuffer(src, srcOffset, conteggio, dest, destOffset, bit, alpha01) {
    (0, _util.unreachable)("Non dovrebbe chiamare ColorSpace.getRgbBuffer");
  }
  getOutputLength(lunghezzainput, alpha01) {
    (0, _util.unreachable)("Non dovrebbe chiamare ColorSpace.getOutputLength");
  }
  isPassthrough(bit) {
    restituisci falso;
  }
  isDefaultDecode(decodeMap, bpc) {
    restituisci ColorSpace.isDefaultDecode(decodeMap, this.numComps);
  }
  fillRgb(dest, originalWidth, originalHeight, width, height, actualHeight, bpc, comps, alpha01) {
    conteggio costante = larghezza originale * altezza originale;
    lascia rgbBuf = null;
    const numComponentColors = 1 << bpc;
    const needsResizing = originalHeight !== altezza || originalWidth !== larghezza;
    se (questo.èPassthrough(bpc)) {
      rgbBuf = comps;
    } else if (this.numComps === 1 && count > numComponentColors && this.name !== "DeviceGray" && this.name !== "DeviceRGB") {
      const allColors = bpc <= 8 ? new Uint8Array(numComponentColors) : new Uint16Array(numComponentColors);
      per (lascia che i = 0; i < numComponentColors; i++) {
        tutti i colori[i] = i;
      }
      const colorMap = new Uint8ClampedArray(numComponentColors * 3);
      this.getRgbBuffer(tutti i colori, 0, numComponentColors, mappa colori, 0, bpc, 0);
      se (!necessita di ridimensionamento) {
        lascia destPos = 0;
        per (lascia che i = 0; i < conta; ++i) {
          chiave costante = comps[i] * 3;
          dest[destPos++] = colorMap[chiave];
          dest[destPos++] = colorMap[key + 1];
          dest[destPos++] = colorMap[key + 2];
          destPos += alpha01;
        }
      } altro {
        rgbBuf = new Uint8Array(conteggio * 3);
        lascia rgbPos = 0;
        per (lascia che i = 0; i < conta; ++i) {
          chiave costante = comps[i] * 3;
          rgbBuf[rgbPos++] = colorMap[chiave];
          rgbBuf[rgbPos++] = colorMap[key + 1];
          rgbBuf[rgbPos++] = colorMap[key + 2];
        }
      }
    } altrimenti se (!needsResizing) {
      this.getRgbBuffer(comps, 0, width * actualHeight, dest, 0, bpc, alpha01);
    } altro {
      rgbBuf = new Uint8ClampedArray(conteggio * 3);
      this.getRgbBuffer(comps, 0, conteggio, rgbBuf, 0, bpc, 0);
    }
    se (rgbBuf) {
      se (necessita di ridimensionamento) {
        resizeRgbImage(rgbBuf, dest, originalWidth, originalHeight, width, height, alpha01);
      } altro {
        lascia destPos = 0,
          rgbPos = 0;
        per (lascia che i = 0, ii = larghezza * altezzaeffettiva; i < ii; i++) {
          dest[destPos++] = rgbBuf[rgbPos++];
          dest[destPos++] = rgbBuf[rgbPos++];
          dest[destPos++] = rgbBuf[rgbPos++];
          destPos += alpha01;
        }
      }
    }
  }
  ottenere usesZeroToOneRange() {
    return (0, _util.shadow)(this, "usesZeroToOneRange", true);
  }
  static _cache(cacheKey, xref, localColorSpaceCache, parsedColorSpace) {
    se (!localColorSpaceCache) {
      genera un nuovo errore('ColorSpace._cache - previsto argomento "localColorSpaceCache".');
    }
    se (!parsedColorSpace) {
      genera un nuovo errore('ColorSpace._cache - previsto argomento "parsedColorSpace".');
    }
    lascia csName, csRef;
    se (cacheKey instanceof _primitives.Ref) {
      csRef = cacheKey;
      cacheKey = xref.fetch(cacheKey);
    }
    se (cacheKey instanceof _primitives.Name) {
      csName = cacheKey.name;
    }
    se (csName || csRef) {
      localColorSpaceCache.set(csName, csRef, parsedColorSpace);
    }
  }
  getCached statico(cacheKey, xref, localColorSpaceCache) {
    se (!localColorSpaceCache) {
      genera un nuovo errore('ColorSpace.getCached - previsto argomento "localColorSpaceCache".');
    }
    se (cacheKey instanceof _primitives.Ref) {
      const localColorSpace = localColorSpaceCache.getByRef(cacheKey);
      se (spaziocolorelocale) {
        restituisci localColorSpace;
      }
      Tentativo {
        cacheKey = xref.fetch(cacheKey);
      } catturare (es.) {
        se (ad esempio instanceof _core_utils.MissingDataException) {
          lanciare ex;
        }
      }
    }
    se (cacheKey instanceof _primitives.Name) {
      const localColorSpace = localColorSpaceCache.getByName(cacheKey.name);
      se (spaziocolorelocale) {
        restituisci localColorSpace;
      }
    }
    restituisci null;
  }
  analisi asincrona statica parseAsync({
    cs,
    riferimento esterno,
    risorse = null,
    pdfFunctionFactory,
    localColorSpaceCache
  }) {
    const parsedColorSpace = this._parse(cs, xref, risorse, pdfFunctionFactory);
    this._cache(cs, xref, localColorSpaceCache, parsedColorSpace);
    restituisci parsedColorSpace;
  }
  analisi statica({
    cs,
    riferimento esterno,
    risorse = null,
    pdfFunctionFactory,
    localColorSpaceCache
  }) {
    const cachedColorSpace = this.getCached(cs, xref, localColorSpaceCache);
    se (cachedColorSpace) {
      restituisci cachedColorSpace;
    }
    const parsedColorSpace = this._parse(cs, xref, risorse, pdfFunctionFactory);
    this._cache(cs, xref, localColorSpaceCache, parsedColorSpace);
    restituisci parsedColorSpace;
  }
  static _parse(cs, xref, resources = null, pdfFunctionFactory) {
    cs = xref.fetchIfRef(cs);
    se (cs instanceof _primitives.Name) {
      switch (cs.name) {
        caso "G":
        caso "DeviceGray":
          restituisci questo.singletons.gray;
        caso "RGB":
        caso "DeviceRGB":
          restituisci questo.singletons.rgb;
        caso "CMYK":
        caso "DeviceCMYK":
          restituisci questo.singletons.cmyk;
        caso "Modello":
          restituisci nuovo PatternCS(null);
        predefinito:
          se (risorse instanceof _primitives.Dict) {
            const colorSpaces = resources.get("ColorSpace");
            se (colorSpaces instanceof _primitives.Dict) {
              const resourcesCS = colorSpaces.get(cs.name);
              se (risorseCS) {
                se (risorseCS istanza di _primitive.Nome) {
                  restituisci this._parse(resourcesCS, xref, resources, pdfFunctionFactory);
                }
                cs = risorseCS;
                rottura;
              }
            }
          }
          throw new _util.FormatError(`ColorSpace non riconosciuto: ${cs.name}`);
      }
    }
    se (Array.isArray(cs)) {
      modalità costante = xref.fetchIfRef(cs[0]).name;
      lascia parametri, numComps, baseCS, whitePoint, blackPoint, gamma;
      interruttore (modalità) {
        caso "G":
        caso "DeviceGray":
          restituisci questo.singletons.gray;
        caso "RGB":
        caso "DeviceRGB":
          restituisci questo.singletons.rgb;
        caso "CMYK":
        caso "DeviceCMYK":
          restituisci questo.singletons.cmyk;
        caso "CalGray":
          parametri = xref.fetchIfRef(cs[1]);
          Puntobianco = params.getArray("Puntobianco");
          Puntonero = params.getArray("Puntonero");
          gamma = params.get("Gamma");
          restituisci nuovo CalGrayCS(puntobianco, puntonero, gamma);
        caso "CalRGB":
          parametri = xref.fetchIfRef(cs[1]);
          Puntobianco = params.getArray("Puntobianco");
          Puntonero = params.getArray("Puntonero");
          gamma = params.getArray("Gamma");
          matrice costante = params.getArray("Matrice");
          restituisci nuovo CalRGBCS(punto bianco, punto nero, gamma, matrice);
        caso "ICCBased":
          flusso costante = xref.fetchIfRef(cs[1]);
          const dict = stream.dict;
          numComps = dict.get("N");
          const alt = dict.get("Alternativo");
          se (alt) {
            const altCS = this._parse(alt, xref, risorse, pdfFunctionFactory);
            se (altCS.numComps === numComps) {
              restituisci altCS;
            }
            (0, _util.warn)("Spazio colore basato su ICC: ignorata la voce errata /Alternate.");
          }
          se (numComps === 1) {
            restituisci questo.singletons.gray;
          } altrimenti se (numComps === 3) {
            restituisci questo.singletons.rgb;
          } altrimenti se (numComps === 4) {
            restituisci questo.singletons.cmyk;
          }
          rottura;
        caso "Modello":
          baseCS = cs[1] || null;
          se (baseCS) {
            baseCS = this._parse(baseCS, xref, risorse, pdfFunctionFactory);
          }
          restituisci nuovo PatternCS(baseCS);
        caso "I":
        caso "Indicizzato":
          baseCS = this._parse(cs[1], xref, risorse, pdfFunctionFactory);
          const hiVal = xref.fetchIfRef(cs[2]) + 1;
          ricerca costante = xref.fetchIfRef(cs[3]);
          restituisci nuovo IndexedCS(baseCS, hiVal, lookup);
        caso "Separazione":
        caso "DispositivoN":
          const nome = xref.fetchIfRef(cs[1]);
          numComps = Array.isArray(nome) ? nome.lunghezza : 1;
          baseCS = this._parse(cs[2], xref, risorse, pdfFunctionFactory);
          const tintFn = pdfFunctionFactory.create(cs[3]);
          restituisci nuovo AlternateCS(numComps, baseCS, tintFn);
        caso "Lab":
          parametri = xref.fetchIfRef(cs[1]);
          Puntobianco = params.getArray("Puntobianco");
          Puntonero = params.getArray("Puntonero");
          const range = params.getArray("Intervallo");
          restituisci nuovo LabCS(puntobianco, puntonero, intervallo);
        predefinito:
          throw new _util.FormatError(`Oggetto ColorSpace non implementato: ${mode}`);
      }
    }
    throw new _util.FormatError(`Oggetto ColorSpace non riconosciuto: ${cs}`);
  }
  static isDefaultDecode(decodifica, numComps) {
    se (!Array.isArray(decodifica)) {
      restituisci vero;
    }
    se (numComps * 2 !== lunghezza decodifica) {
      (0, _util.warn)("La mappa di decodifica non ha la lunghezza corretta");
      restituisci vero;
    }
    per (lascia che i = 0, ii = decode.length; i < ii; i += 2) {
      se (decodifica[i] !== 0 || decodifica[i + 1] !== 1) {
        restituisci falso;
      }
    }
    restituisci vero;
  }
  static get singletons() {
    return (0, _util.shadow)(this, "singleton", {
      ottieni grigio() {
        return (0, _util.shadow)(this, "gray", new DeviceGrayCS());
      },
      ottieni rgb() {
        return (0, _util.shadow)(this, "rgb", new DeviceRgbCS());
      },
      ottieni cmyk() {
        return (0, _util.shadow)(this, "cmyk", new DeviceCmykCS());
      }
    });
  }
}
esportazioni.ColorSpace = ColorSpace;
classe AlternateCS estende ColorSpace {
  costruttore(numComps, base, tintFn) {
    super("Alternativo", numComps);
    questa.base = base;
    this.tintFn = tintFn;
    this.tmpBuf = new Float32Array(base.numComps);
  }
  getRgbItem(src, srcOffset, dest, destOffset) {
    const tmpBuf = this.tmpBuf;
    this.tintFn(src, srcOffset, tmpBuf, 0);
    this.base.getRgbItem(tmpBuf, 0, dest, destOffset);
  }
  getRgbBuffer(src, srcOffset, conteggio, dest, destOffset, bit, alpha01) {
    const tintFn = this.tintFn;
    const base = this.base;
    scala costante = 1 / ((1 << bit) - 1);
    const baseNumComps = base.numComps;
    const usesZeroToOneRange = base.usesZeroToOneRange;
    const isPassthrough = (base.isPassthrough(8) || !usesZeroToOneRange) && alpha01 === 0;
    lascia pos = isPassthrough ? destOffset: 0;
    const baseBuf = isPassthrough ? dest : new Uint8ClampedArray(baseNumComps * count);
    const numComps = this.numComps;
    const scalato = nuovo Float32Array(numComps);
    const tinted = new Float32Array(baseNumComps);
    siano i, j;
    per (i = 0; i < conteggio; i++) {
      per (j = 0; j < numComps; j++) {
        scalato[j] = src[srcOffset++] * scala;
      }
      tintFn(scalato, 0, colorato, 0);
      se (usaZeroToOneRange) {
        for (j = 0; j < baseNumComps; j++) {
          baseBuf[pos++] = tinted[j] * 255;
        }
      } altro {
        base.getRgbItem(tinted, 0, baseBuf, pos);
        pos += baseNumComps;
      }
    }
    se (!isPassthrough) {
      base.getRgbBuffer(baseBuf, 0, conteggio, destinazione, destOffset, 8, alpha01);
    }
  }
  getOutputLength(lunghezzainput, alpha01) {
    restituisci this.base.getOutputLength(inputLength * this.base.numComps / this.numComps, alpha01);
  }
}
la classe PatternCS estende ColorSpace {
  costruttore(baseCS) {
    super("Modello", null);
    this.base = baseCS;
  }
  isDefaultDecode(decodeMap, bpc) {
    (0, _util.unreachable)("Non dovrebbe chiamare PatternCS.isDefaultDecode");
  }
}
classe IndexedCS estende ColorSpace {
  costruttore(base, highVal, ricerca) {
    super("Indicizzato", 1);
    questa.base = base;
    questo.highVal = highVal;
    lunghezza costante = base.numComps * highVal;
    this.lookup = new Uint8Array(lunghezza);
    se (cerca instanceof _base_stream.BaseStream) {
      const byte = lookup.getBytes(lunghezza);
      questo.lookup.set(byte);
    } altrimenti se (tipo di ricerca === "stringa") {
      per (lascia che i = 0; i < lunghezza; ++i) {
        questo.lookup[i] = lookup.charCodeAt(i) & 0xff;
      }
    } altro {
      throw new _util.FormatError(`IndexedCS - tabella di ricerca non riconosciuta: ${lookup}`);
    }
  }
  getRgbItem(src, srcOffset, dest, destOffset) {
    const numComps = this.base.numComps;
    const start = src[srcOffset] * numComps;
    this.base.getRgbBuffer(this.lookup, inizio, 1, destinazione, destOffset, 8, 0);
  }
  getRgbBuffer(src, srcOffset, conteggio, dest, destOffset, bit, alpha01) {
    const base = this.base;
    const numComps = base.numComps;
    const outputDelta = base.getOutputLength(numComps, alpha01);
    const lookup = this.lookup;
    per (lascia che i = 0; i < conta; ++i) {
      const lookupPos = src[srcOffset++] * numComps;
      base.getRgbBuffer(lookup, lookupPos, 1, dest, destOffset, 8, alpha01);
      destOffset += outputDelta;
    }
  }
  getOutputLength(lunghezzainput, alpha01) {
    restituisci this.base.getOutputLength(inputLength * this.base.numComps, alpha01);
  }
  isDefaultDecode(decodeMap, bpc) {
    se (!Array.isArray(decodeMap)) {
      restituisci vero;
    }
    se (decodeMap.length !== 2) {
      (0, _util.warn)("La lunghezza della mappa di decodifica non è corretta");
      restituisci vero;
    }
    se (!Numero.èIntero(bpc) || ​​bpc < 1) {
      (0, _util.warn)("I bit per componente non sono corretti");
      restituisci vero;
    }
    restituisci decodeMap[0] === 0 && decodeMap[1] === (1 << bpc) - 1;
  }
}
classe DeviceGrayCS estende ColorSpace {
  costruttore() {
    super("Dispositivo grigio", 1);
  }
  getRgbItem(src, srcOffset, dest, destOffset) {
    const c = src[srcOffset] * 255;
    dest[destOffset] = dest[destOffset + 1] = dest[destOffset + 2] = c;
  }
  getRgbBuffer(src, srcOffset, conteggio, dest, destOffset, bit, alpha01) {
    scala costante = 255 / ((1 << bit) - 1);
    lascia j = srcOffset,
      q = destOffset;
    per (lascia che i = 0; i < conta; ++i) {
      const c = scala * src[j++];
      dest[q++] = c;
      dest[q++] = c;
      dest[q++] = c;
      q += alfa01;
    }
  }
  getOutputLength(lunghezzainput, alpha01) {
    restituisci inputLength * (3 + alpha01);
  }
}
classe DeviceRgbCS estende ColorSpace {
  costruttore() {
    super("DispositivoRGB", 3);
  }
  getRgbItem(src, srcOffset, dest, destOffset) {
    dest[destOffset] = src[srcOffset] * 255;
    dest[destOffset + 1] = src[srcOffset + 1] * 255;
    dest[destOffset + 2] = src[srcOffset + 2] * 255;
  }
  getRgbBuffer(src, srcOffset, conteggio, dest, destOffset, bit, alpha01) {
    se (bit === 8 e alpha01 === 0) {
      dest.set(src.subarray(srcOffset, srcOffset + conteggio * 3), destOffset);
      ritorno;
    }
    scala costante = 255 / ((1 << bit) - 1);
    lascia j = srcOffset,
      q = destOffset;
    per (lascia che i = 0; i < conta; ++i) {
      dest[q++] = scala * src[j++];
      dest[q++] = scala * src[j++];
      dest[q++] = scala * src[j++];
      q += alfa01;
    }
  }
  getOutputLength(lunghezzainput, alpha01) {
    restituisci inputLength * (3 + alpha01) / 3 | 0;
  }
  isPassthrough(bit) {
    restituisci bit === 8;
  }
}
classe DeviceCmykCS estende ColorSpace {
  costruttore() {
    super("DispositivoCMYK", 4);
  }
  #toRgb(src, srcOffset, srcScale, dest, destOffset) {
    const c = src[srcOffset] * srcScale;
    const m = src[srcOffset + 1] * srcScale;
    const y = src[srcOffset + 2] * srcScale;
    const k = src[srcOffset + 3] * srcScale;
    dest[destOffset] = 255 + c * (-4,387332384609988 * c + 54,48615194189176 * m + 18,82290502165302 * y + 212,25662451639585 * k + -285,2331026137004) + m * (1,7149763477362134 * m - 5,6096736904047315 * y + -17,873870861415444 * k - 5,497006427196366) + y * (-2,5217340131683033 * y - 21.248923337353073 * k + 17.5119270841813) + k * (-21.86122147463605 * k - 189.48180835922747);
    dest[destOffset + 1] = 255 + c * (8,841041422036149 * c + 60,118027045597366 * m + 6,871425592049007 * y + 31,159100130055922 * k + -79,2970844816548) + m * (-15,310361306967817 * m + 17,575251261109482 * y + 131,35250912493976 * k - 190,9453302588951) + y * (4,444339102852739 * y + 9,8632861493405 * k - 24,86741582555878) + k * (-20,737325471181034 * k - 187,80453709719578);
    dest[destOffset + 2] = 255 + c * (0,8842522430003296 * c + 8,078677503112928 * m + 30,89978309703729 * y - 0,23883238689178934 * k + -14,183576799673286) + m * (10,49593273432072 * m + 63,02378494754052 * y + 50,606957656360734 * k - 112,23884253719248) + y * (0,03296041114873217 * y + 115,60384449646641 * k + -193,58209356861505) + k * (-22,33816807309886 * k - 180,12613974708367);
  }
  getRgbItem(src, srcOffset, dest, destOffset) {
    questo.#toRgb(src, srcOffset, 1, dest, destOffset);
  }
  getRgbBuffer(src, srcOffset, conteggio, dest, destOffset, bit, alpha01) {
    scala costante = 1 / ((1 << bit) - 1);
    per (lascia che i = 0; i < conta; i++) {
      questo.#toRgb(src, srcOffset, scala, dest, destOffset);
      srcOffset += 4;
      destOffset += 3 + alpha01;
    }
  }
  getOutputLength(lunghezzainput, alpha01) {
    restituisci inputLength / 4 * (3 + alpha01) | 0;
  }
}
classe CalGrayCS estende ColorSpace {
  costruttore(puntobianco, puntonero, gamma) {
    super("CalGray", 1);
    se (!puntobianco) {
      throw new _util.FormatError("Punto bianco mancante - richiesto per lo spazio colore CalGray");
    }
    [questo.XW, questo.YW, questo.ZW] = puntobianco;
    [questo.XB, questo.YB, questo.ZB] = blackPoint || [0, 0, 0];
    questo.G = gamma || 1;
    se (questo.XW < 0 || questo.ZW < 0 || questo.YW !== 1) {
      throw new _util.FormatError(`Componenti WhitePoint non validi per ${this.name}, nessun fallback disponibile`);
    }
    se (questo.XB < 0 || questo.YB < 0 || questo.ZB < 0) {
      (0, _util.info)(`BlackPoint non valido per ${this.name}, si torna al valore predefinito.`);
      questo.XB = questo.YB = questo.ZB = 0;
    }
    se (questo.XB !== 0 || questo.YB !== 0 || questo.ZB !== 0) {
      (0, _util.warn)(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ` + `ZB: ${this.ZB}, sono supportati solo i valori predefiniti.`);
    }
    se (questo.G < 1) {
      (0, _util.info)(`Gamma non valida: ${this.G} per ${this.name}, ritorno al valore predefinito.`);
      questo.G = 1;
    }
  }
  #toRgb(src, srcOffset, dest, destOffset, scala) {
    const A = src[srcOffset] * scala;
    const AG = A ** this.G;
    const L = this.YW * AG;
    const val = Math.max(295,8 * L ** 0,3333333333333333 - 40,8, 0);
    dest[destOffset] = val;
    dest[destOffset + 1] = val;
    dest[destOffset + 2] = val;
  }
  getRgbItem(src, srcOffset, dest, destOffset) {
    questo.#toRgb(src, srcOffset, dest, destOffset, 1);
  }
  getRgbBuffer(src, srcOffset, conteggio, dest, destOffset, bit, alpha01) {
    scala costante = 1 / ((1 << bit) - 1);
    per (lascia che i = 0; i < conta; ++i) {
      questo.#toRgb(src, srcOffset, dest, destOffset, scala);
      srcOffset += 1;
      destOffset += 3 + alpha01;
    }
  }
  getOutputLength(lunghezzainput, alpha01) {
    restituisci inputLength * (3 + alpha01);
  }
}
classe CalRGBCS estende ColorSpace {
  statico #BRADFORD_SCALE_MATRIX = new Float32Array([0,8951, 0,2664, -0,1614, -0,7502, 1,7135, 0,0367, 0,0389, -0,0685, 1,0296]);
  static #BRADFORD_SCALE_INVERSE_MATRIX = new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -0.0085287, 0.0400428, 0.9684867]);
  statico #SRGB_D65_XYZ_TO_RGB_MATRIX = new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.9692660, 1.8760108, 0.0415560, 0.0556434, -0.2040259, 1.0572252]);
  statico #FLAT_WHITEPOINT_MATRIX = new Float32Array([1, 1, 1]);
  statico #tempNormalizeMatrix = new Float32Array(3);
  statico #tempConvertMatrix1 = new Float32Array(3);
  statico #tempConvertMatrix2 = new Float32Array(3);
  statico #DECODE_L_CONSTANT = ((8 + 16) / 116) ** 3 / 8.0;
  costruttore(puntobianco, puntonero, gamma, matrice) {
    super("CalRGB", 3);
    se (!puntobianco) {
      throw new _util.FormatError("Punto bianco mancante - richiesto per lo spazio colore CalRGB");
    }
    const [XW, YW, ZW] = this.whitePoint = whitePoint;
    const [XB, YB, ZB] = this.blackPoint = blackPoint || new Float32Array(3);
    [questo.GR, questo.GG, questo.GB] = gamma || new Float32Array([1, 1, 1]);
    [this.MXA, this.MYA, this.MZA, this.MXB, this.MYB, this.MZB, this.MXC, this.MYC, this.MZC] = matrice || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    se (XW < 0 || ZW < 0 || YW !== 1) {
      throw new _util.FormatError(`Componenti WhitePoint non validi per ${this.name}, nessun fallback disponibile`);
    }
    se (XB < 0 || YB < 0 || ZB < 0) {
      (0, _util.info)(`BlackPoint non valido per ${this.name} [${XB}, ${YB}, ${ZB}], ` + "ritorno al valore predefinito.");
      this.blackPoint = new Float32Array(3);
    }
    se (questo.GR < 0 || questo.GG < 0 || questo.GB < 0) {
      (0, _util.info)(`Gamma non valida [${this.GR}, ${this.GG}, ${this.GB}] per ` + `${this.name}, ritorno al valore predefinito.`);
      questo.GR = questo.GG = questo.GB = 1;
    }
  }
  #matrixProduct(a, b, risultato) {
    risultato[0] = a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    risultato[1] = a[3] * b[0] + a[4] * b[1] + a[5] * b[2];
    risultato[2] = a[6] * b[0] + a[7] * b[1] + a[8] * b[2];
  }
  #toFlat(sourceWhitePoint, LMS, risultato) {
    risultato[0] = LMS[0] * 1 / sourceWhitePoint[0];
    risultato[1] = LMS[1] * 1 / sourceWhitePoint[1];
    risultato[2] = LMS[2] * 1 / sourceWhitePoint[2];
  }
  #toD65(sourceWhitePoint, LMS, risultato) {
    costante D65X = 0,95047;
    costante D65Y = 1;
    costante D65Z = 1,08883;
    risultato[0] = LMS[0] * D65X / sourceWhitePoint[0];
    risultato[1] = LMS[1] * D65Y / sourceWhitePoint[1];
    risultato[2] = LMS[2] * D65Z / sourceWhitePoint[2];
  }
  #sRGBTransferFunction(colore) {
    se (colore <= 0,0031308) {
      restituisci questo.#adjustToRange(0, 1, 12.92 * colore);
    }
    se (colore >= 0,99554525) {
      restituisci 1;
    }
    restituisci questo.#adjustToRange(0, 1, (1 + 0,055) * colore ** (1 / 2,4) - 0,055);
  }
  #adjustToRange(min, max, valore) {
    restituisci Math.max(min, Math.min(max, valore));
  }
  #decodificaL(L) {
    se (L < 0) {
      restituisci -questo.#decodeL(-L);
    }
    se (L > 8.0) {
      ritorno ((L + 16) / 116) ** 3;
    }
    restituisci L * CalRGBCS.#DECODE_L_CONSTANT;
  }
  #compensateBlackPoint(sourceBlackPoint, XYZ_Flat, risultato) {
    se (sourceBlackPoint[0] === 0 && sourceBlackPoint[1] === 0 && sourceBlackPoint[2] === 0) {
      risultato[0] = XYZ_Flat[0];
      risultato[1] = XYZ_Flat[1];
      risultato[2] = XYZ_Flat[2];
      ritorno;
    }
    const zeroDecodeL = this.#decodeL(0);
    const X_DST = zeroDecodeL;
    const X_SRC = this.#decodeL(sourceBlackPoint[0]);
    const Y_DST = zeroDecodeL;
    const Y_SRC = this.#decodeL(sourceBlackPoint[1]);
    const Z_DST = zeroDecodeL;
    const Z_SRC = this.#decodeL(sourceBlackPoint[2]);
    const X_Scale = (1 - X_DST) / (1 - X_SRC);
    const X_Offset = 1 - X_Scale;
    costante Y_Scala = (1 - Y_DST) / (1 - Y_SRC);
    const Y_Offset = 1 - Y_Scale;
    const Z_Scale = (1 - Z_DST) / (1 - Z_SRC);
    const Z_Offset = 1 - Z_Scala;
    risultato[0] = XYZ_Flat[0] * X_Scale + X_Offset;
    risultato[1] = XYZ_Flat[1] * Y_Scale + Y_Offset;
    risultato[2] = XYZ_Flat[2] * Z_Scale + Z_Offset;
  }
  #normalizeWhitePointToFlat(sourceWhitePoint, XYZ_In, result) {
    se (sourceWhitePoint[0] === 1 && sourceWhitePoint[2] === 1) {
      risultato[0] = XYZ_In[0];
      risultato[1] = XYZ_In[1];
      risultato[2] = XYZ_In[2];
      ritorno;
    }
    const LMS = risultato;
    questo.#matrixProduct(CalRGBCS.#BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
    const LMS_Flat = CalRGBCS.#tempNormalizeMatrix;
    questo.#toFlat(sourceWhitePoint, LMS, LMS_Flat);
    questo.#matrixProduct(CalRGBCS.#BRADFORD_SCALE_INVERSE_MATRIX, LMS_Flat, risultato);
  }
  #normalizeWhitePointToD65(sourceWhitePoint, XYZ_In, result) {
    const LMS = risultato;
    questo.#matrixProduct(CalRGBCS.#BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
    const LMS_D65 = CalRGBCS.#tempNormalizeMatrix;
    questo.#toD65(sourceWhitePoint, LMS, LMS_D65);
    questo.#matrixProduct(CalRGBCS.#BRADFORD_SCALE_INVERSE_MATRIX, LMS_D65, risultato);
  }
  #toRgb(src, srcOffset, dest, destOffset, scala) {
    const A = this.#adjustToRange(0, 1, src[srcOffset] * scale);
    const B = this.#adjustToRange(0, 1, src[srcOffset + 1] * scale);
    const C = this.#adjustToRange(0, 1, src[srcOffset + 2] * scale);
    const AGR = A === 1 ? 1 : A ** this.GR;
    const BGG = B === 1 ? 1 : B ** this.GG;
    const CGB = C === 1 ? 1 : C ** this.GB;
    const X = this.MXA * AGR + this.MXB * BGG + this.MXC * CGB;
    const Y = this.MYA * AGR + this.MYB * BGG + this.MYC * CGB;
    const Z = this.MZA * AGR + this.MZB * BGG + this.MZC * CGB;
    const XYZ = CalRGBCS.#tempConvertMatrix1;
    XYZ[0] = X;
    XYZ[1] = Y;
    XYZ[2] = Z;
    const XYZ_Flat = CalRGBCS.#tempConvertMatrix2;
    questo.#normalizeWhitePointToFlat(questo.whitePoint, XYZ, XYZ_Flat);
    const XYZ_Black = CalRGBCS.#tempConvertMatrix1;
    questo.#compensateBlackPoint(questo.blackPoint, XYZ_Flat, XYZ_Black);
    const XYZ_D65 = CalRGBCS.#tempConvertMatrix2;
    questo.#normalizeWhitePointToD65(CalRGBCS.#FLAT_WHITEPOINT_MATRIX, XYZ_Black, XYZ_D65);
    const SRGB = CalRGBCS.#tempConvertMatrix1;
    questo.#matrixProduct(CalRGBCS.#SRGB_D65_XYZ_TO_RGB_MATRIX, XYZ_D65, SRGB);
    dest[destOffset] = this.#sRGBTransferFunction(SRGB[0]) * 255;
    dest[destOffset + 1] = this.#sRGBTransferFunction(SRGB[1]) * 255;
    dest[destOffset + 2] = this.#sRGBTransferFunction(SRGB[2]) * 255;
  }
  getRgbItem(src, srcOffset, dest, destOffset) {
    questo.#toRgb(src, srcOffset, dest, destOffset, 1);
  }
  getRgbBuffer(src, srcOffset, conteggio, dest, destOffset, bit, alpha01) {
    scala costante = 1 / ((1 << bit) - 1);
    per (lascia che i = 0; i < conta; ++i) {
      questo.#toRgb(src, srcOffset, dest, destOffset, scala);
      srcOffset += 3;
      destOffset += 3 + alpha01;
    }
  }
  getOutputLength(lunghezzainput, alpha01) {
    restituisci inputLength * (3 + alpha01) / 3 | 0;
  }
}
classe LabCS estende ColorSpace {
  costruttore(puntobianco, puntonero, intervallo) {
    super("Laboratorio", 3);
    se (!puntobianco) {
      throw new _util.FormatError("Punto bianco mancante - richiesto per lo spazio colore Lab");
    }
    [questo.XW, questo.YW, questo.ZW] = puntobianco;
    [this.amin, this.amax, this.bmin, this.bmax] = intervallo || [-100, 100, -100, 100];
    [questo.XB, questo.YB, questo.ZB] = blackPoint || [0, 0, 0];
    se (questo.XW < 0 || questo.ZW < 0 || questo.YW !== 1) {
      throw new _util.FormatError("Componenti WhitePoint non validi, nessun fallback disponibile");
    }
    se (questo.XB < 0 || questo.YB < 0 || questo.ZB < 0) {
      (0, _util.info)("BlackPoint non valido, ritorno al valore predefinito");
      questo.XB = questo.YB = questo.ZB = 0;
    }
    se (questo.amin > questo.amax || questo.bmin > questo.bmax) {
      (0, _util.info)("Intervallo non valido, ritorno ai valori predefiniti");
      questo.amin = -100;
      questo.amax = 100;
      questo.bmin = -100;
      questo.bmax = 100;
    }
  }
  #fn_g(x) {
    restituisci x >= 6 / 29 ? x ** 3 : 108 / 841 * (x - 4 / 29);
  }
  #decode(valore, alto1, basso2, alto2) {
    restituisci low2 + valore * (high2 - low2) / high1;
  }
  #toRgb(src, srcOffset, maxVal, dest, destOffset) {
    lascia Ls = src[srcOffset];
    lascia come = src[srcOffset + 1];
    lascia bs = src[srcOffset + 2];
    se (maxVal !== falso) {
      Ls = questo.#decode(Ls, maxVal, 0, 100);
      come = questo.#decode(come, maxVal, questo.amin, questo.amax);
      bs = this.#decode(bs, maxVal, this.bmin, this.bmax);
    }
    se (come > questo.amax) {
      come = questo.amax;
    } altrimenti se (come < this.amin) {
      come = questo.amin;
    }
    se (bs > this.bmax) {
      bs = questo.bmax;
    } altrimenti se (bs < this.bmin) {
      bs = questo.bmin;
    }
    costante M = (Ls + 16) / 116;
    costante L = M + come / 500;
    costante N = M - bs / 200;
    const X = questo.XW * questo.#fn_g(L);
    const Y = questo.YW * questo.#fn_g(M);
    const Z = questo.ZW * questo.#fn_g(N);
    lascia r, g, b;
    se (questo.ZW < 1) {
      r = X * 3,1339 + Y * -1,617 + Z * -0,4906;
      g = X * -0,9785 + Y * 1,916 + Z * 0,0333;
      b = X * 0,072 + Y * -0,229 + Z * 1,4057;
    } altro {
      r = X * 3,2406 + Y * -1,5372 + Z * -0,4986;
      g = X * -0,9689 + Y * 1,8758 + Z * 0,0415;
      b = X * 0,0557 + Y * -0,204 + Z * 1,057;
    }
    dest[destOffset] = Math.sqrt(r) * 255;
    dest[destOffset + 1] = Math.sqrt(g) * 255;
    dest[destOffset + 2] = Math.sqrt(b) * 255;
  }
  getRgbItem(src, srcOffset, dest, destOffset) {
    questo.#toRgb(src, srcOffset, false, dest, destOffset);
  }
  getRgbBuffer(src, srcOffset, conteggio, dest, destOffset, bit, alpha01) {
    const maxVal = (1 << bit) - 1;
    per (lascia che i = 0; i < conta; i++) {
      questo.#toRgb(src, srcOffset, maxVal, dest, destOffset);
      srcOffset += 3;
      destOffset += 3 + alpha01;
    }
  }
  getOutputLength(lunghezzainput, alpha01) {
    restituisci inputLength * (3 + alpha01) / 3 | 0;
  }
  isDefaultDecode(decodeMap, bpc) {
    restituisci vero;
  }
  ottenere usesZeroToOneRange() {
    return (0, _util.shadow)(this, "usesZeroToOneRange", false);
  }
}

/***/ }),
/* 13 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.PartialEvaluator = esportazioni.EvaluatorPreprocessor = void 0;
var _util = __w_pdfjs_require__(2);
var _cmap = __w_pdfjs_require__(14);
var _primitives = __w_pdfjs_require__(4);
var _fonts = __w_pdfjs_require__(34);
var _encodings = __w_pdfjs_require__(37);
var _standard_fonts = __w_pdfjs_require__(41);
var _pattern = __w_pdfjs_require__(50);
var _xfa_fonts = __w_pdfjs_require__(51);
var _to_unicode_map = __w_pdfjs_require__(42);
var _function = __w_pdfjs_require__(57);
var _parser = __w_pdfjs_require__(16);
var _image_utils = __w_pdfjs_require__(59);
var _stream = __w_pdfjs_require__(8);
var _base_stream = __w_pdfjs_require__(5);
var _bidi = __w_pdfjs_require__(60);
var _colorspace = __w_pdfjs_require__(12);
var _decode_stream = __w_pdfjs_require__(18);
var _fonts_utils = __w_pdfjs_require__(38);
var _font_substitutions = __w_pdfjs_require__(61);
var _glyphlist = __w_pdfjs_require__(39);
var _metrics = __w_pdfjs_require__(45);
var _unicode = __w_pdfjs_require__(40);
var _image_resizer = __w_pdfjs_require__(62);
var _murmurhash = __w_pdfjs_require__(63);
var _operator_list = __w_pdfjs_require__(64);
var _immagine = __w_pdfjs_require__(65);
const DefaultPartialEvaluatorOptions = Object.freeze({
  dimensione massima dell'immagine: -1,
  disableFontFace: falso,
  ignoreErrors: falso,
  isEvalSupported: vero,
  isOffscreenCanvasSupported: falso,
  canvasMaxAreaInBytes: -1,
  fontExtraProperties: false,
  useSystemFonts: vero,
  cMapUrl: nullo,
  standardFontDataUrl: null
});
const Tipo di modello = {
  PIASTRELLATURA: 1,
  OMBREGGIATURA: 2
};
const TEXT_CHUNK_BATCH_SIZE = 10;
const differito = Promise.resolve();
funzione normalizeBlendMode(valore, parsingArray = false) {
  se (Array.isArray(valore)) {
    per (valore costante del valore) {
      const maybeBM = normalizeBlendMode(val, true);
      se (forseBM) {
        restituisci forseBM;
      }
    }
    (0, _util.warn)(`Modalità di fusione non supportata Array: ${value}`);
    restituisci "source-over";
  }
  se (!(valore instanceof _primitives.Name)) {
    se (parsingArray) {
      restituisci null;
    }
    restituisci "source-over";
  }
  switch (valore.nome) {
    caso "Normale":
    caso "Compatibile":
      restituisci "source-over";
    caso "Moltiplica":
      restituisci "moltiplica";
    caso "Schermo":
      restituisci "schermo";
    caso "Sovrapposizione":
      restituisci "sovrapposizione";
    caso "Oscurare":
      restituisci "oscurare";
    caso "Schiarisci":
      restituisci "schiarisci";
    caso "ColorDodge":
      restituisci "color-dodge";
    caso "ColorBurn":
      restituisci "colore-brucia";
    caso "HardLight":
      restituisci "luce-dura";
    caso "SoftLight":
      restituisci "luce soffusa";
    caso "Differenza":
      restituisci "differenza";
    caso "Esclusione":
      restituisci "esclusione";
    caso "Tonalità":
      restituisci "tonalità";
    caso "Saturazione":
      restituisci "saturazione";
    caso "Colore":
      restituisci "colore";
    caso "Luminosità":
      restituisci "luminosità";
  }
  se (parsingArray) {
    restituisci null;
  }
  (0, _util.warn)(`Modalità di fusione non supportata: ${value.name}`);
  restituisci "source-over";
}
funzione incrementCachedImageMaskCount(dati) {
  se (data.fn === _util.OPS.paintImageMaskXObject && data.args[0]?.count > 0) {
    dati.args[0].count++;
  }
}
classe TimeSlotManager {
  statico TIME_SLOT_DURATION_MS = 20;
  statico CHECK_TIME_EVERY = 100;
  costruttore() {
    questo.reset();
  }
  controllo() {
    se (++questo.controllato < TimeSlotManager.CHECK_TIME_EVERY) {
      restituisci falso;
    }
    questo.controllato = 0;
    restituisci this.endTime <= Date.now();
  }
  reimposta() {
    this.endTime = Date.now() + TimeSlotManager.TIME_SLOT_DURATION_MS;
    questo.controllato = 0;
  }
}
classe PartialEvaluator {
  costruttore({
    riferimento esterno,
    gestore,
    indice della pagina,
    idFactory,
    fontCache,
    builtInCMapCache,
    standardFontDataCache,
    globalImageCache,
    systemFontCache,
    opzioni = null
  }) {
    questo.xref = xref;
    this.handler = gestore;
    this.pageIndex = pageIndex;
    this.idFactory = idFactory;
    this.fontCache = fontCache;
    this.builtInCMapCache = builtInCMapCache;
    this.standardFontDataCache = standardFontDataCache;
    this.globalImageCache = globalImageCache;
    this.systemFontCache = systemFontCache;
    this.options = opzioni || DefaultPartialEvaluatorOptions;
    this.parsingType3Font = false;
    this._regionalImageCache = new _image_utils.RegionalImageCache();
    this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
    _image_resizer.ImageResizer.setMaxArea(this.options.canvasMaxAreaInBytes);
  }
  ottieni _pdfFunctionFactory() {
    const pdfFunctionFactory = new _function.PDFFunctionFactory({
      xrif: questo.xrif,
      isEvalSupported: this.options.isEvalSupported
    });
    return (0, _util.shadow)(this, "_pdfFunctionFactory", pdfFunctionFactory);
  }
  clone(nuoveOpzioni = null) {
    const newEvaluator = Object.create(this);
    newEvaluator.options = Object.assign(Object.create(null), this.options, newOptions);
    restituisci nuovo Valutatore;
  }
  hasBlendModes(risorse, nonBlendModesSet) {
    se (!(risorse instanceof _primitives.Dict)) {
      restituisci falso;
    }
    se (resources.objId && nonBlendModesSet.has(resources.objId)) {
      restituisci falso;
    }
    const elaborato = new _primitives.RefSet(nonBlendModesSet);
    se (risorse.objId) {
      elaborato.put(risorse.objId);
    }
    nodi costanti = [risorse],
      xrif = questo.xrif;
    mentre (nodi.lunghezza) {
      const node = nodes.shift();
      const graphicStates = node.get("ExtGState");
      se (graphicStates instanceof _primitives.Dict) {
        per (lascia graphicState di graphicStates.getRawValues()) {
          se (graphicState instanceof _primitives.Ref) {
            se (processed.has(graphicState)) {
              continuare;
            }
            Tentativo {
              Statografico = xref.fetch(Statografico);
            } catturare (es.) {
              elaborato.put(graphicState);
              (0, _util.info)(`hasBlendModes - ignorando ExtGState: "${ex}".`);
              continuare;
            }
          }
          se (!(graphicState instanceof _primitives.Dict)) {
            continuare;
          }
          se (graphicState.objId) {
            elaborato.put(graphicState.objId);
          }
          const bm = graphicState.get("BM");
          se (bm instanceof _primitives.Name) {
            se (bm.name !== "Normale") {
              restituisci vero;
            }
            continuare;
          }
          se (bm !== indefinito && Array.isArray(bm)) {
            per (elemento costante di bm) {
              if (element instanceof _primitives.Name && element.name !== "Normale") {
                restituisci vero;
              }
            }
          }
        }
      }
      const xObjects = node.get("XObject");
      se (!(xObjects instanceof _primitives.Dict)) {
        continuare;
      }
      per (lascia xObject di xObjects.getRawValues()) {
        se (xObject instanceof _primitives.Ref) {
          se (processed.has(xObject)) {
            continuare;
          }
          Tentativo {
            xObject = xref.fetch(xObject);
          } catturare (es.) {
            elaborato.put(xObject);
            (0, _util.info)(`hasBlendModes - ignorando XObject: "${ex}".`);
            continuare;
          }
        }
        se (!(xObject instanceof _base_stream.BaseStream)) {
          continuare;
        }
        se (xObject.dict.objId) {
          elaborato.put(xObject.dict.objId);
        }
        const xResources = xObject.dict.get("Risorse");
        se (!(xResources instanceof _primitives.Dict)) {
          continuare;
        }
        se (xResources.objId && elaborato.has(xResources.objId)) {
          continuare;
        }
        nodi.push(xRisorse);
        se (xResources.objId) {
          elaborato.put(xResources.objId);
        }
      }
    }
    per (const ref di elaborato) {
      nonBlendModesSet.put(ref);
    }
    restituisci falso;
  }
  fetchBuiltInCMap asincrono(nome) {
    const cachedData = this.builtInCMapCache.get(nome);
    se (cachedData) {
      restituisci dati memorizzati nella cache;
    }
    lascia i dati;
    se (this.options.cMapUrl !== null) {
      const url = `${this.options.cMapUrl}${name}.bcmap`;
      risposta costante = attendi fetch(url);
      se (!risposta.ok) {
        throw new Error(`fetchBuiltInCMap: impossibile recuperare il file "${url}" con "${response.statusText}".`);
      }
      dati = {
        cMapData: nuovo Uint8Array(attendi risposta.arrayBuffer()),
        compressionType: _util.CMapCompressionType.BINARY
      };
    } altro {
      dati = attendi this.handler.sendWithPromise("FetchBuiltInCMap", {
        nome
      });
    }
    se (data.compressionType !== _util.CMapCompressionType.NONE) {
      this.builtInCMapCache.set(nome, dati);
    }
    restituire i dati;
  }
  fetchStandardFontData asincrono(nome) {
    const cachedData = this.standardFontDataCache.get(name);
    se (cachedData) {
      restituisci nuovo _stream.Stream(cachedData);
    }
    if (this.options.useSystemFonts && name !== "Simbolo" && name !== "ZapfDingbats") {
      restituisci null;
    }
    const standardFontNameToFileName = (0, _standard_fonts.getFontNameToFileMap)(),
      nome file = standardFontNameToFileName[nome];
    lascia i dati;
    se (this.options.standardFontDataUrl !== null) {
      const url = `${this.options.standardFontDataUrl}${filename}`;
      risposta costante = attendi fetch(url);
      se (!risposta.ok) {
        (0, _util.warn)(`fetchStandardFontData: impossibile recuperare il file "${url}" con "${response.statusText}".`);
      } altro {
        dati = attendi risposta.arrayBuffer();
      }
    } altro {
      Tentativo {
        dati = attendi this.handler.sendWithPromise("FetchStandardFontData", {
          nome del file
        });
      } cattura (e) {
        (0, _util.warn)(`fetchStandardFontData: impossibile recuperare il file "${filename}" con "${e}".`);
      }
    }
    se (!dati) {
      restituisci null;
    }
    this.standardFontDataCache.set(nome, dati);
    restituisci nuovo _stream.Stream(dati);
  }
  async buildFormXObject(risorse, xobj, smask, operatorList, task, initialState, localColorSpaceCache) {
    const dict = xobj.dict;
    matrice costante = dict.getArray("Matrice");
    lascia bbox = dict.getArray("BBox");
    bbox = Array.isArray(bbox) && bbox.length === 4 ? _util.Util.normalizeRect(bbox): null;
    lascia optionalContent, groupOptions;
    se (dict.has("OC")) {
      optionalContent = attendi this.parseMarkedContentProps(dict.get("OC"), resources);
    }
    se (optionalContent !== indefinito) {
      operatorList.addOp(_util.OPS.beginMarkedContentProps, ["OC", optionalContent]);
    }
    const group = dict.get("Gruppo");
    se (gruppo) {
      Opzionigruppo = {
        matrice,
        scatola di cartone,
        maschera,
        isolato: falso,
        knockout: falso
      };
      const groupSubtype = group.get("S");
      lascia che colorSpace = null;
      se ((0, _primitives.isName)(groupSubtype, "Trasparenza")) {
        groupOptions.isolated = group.get("I") || false;
        groupOptions.knockout = group.get("K") || falso;
        se (gruppo.has("CS")) {
          const cs = group.getRaw("CS");
          const cachedColorSpace = _colorspace.ColorSpace.getCached(cs, this.xref, localColorSpaceCache);
          se (cachedColorSpace) {
            colorSpace = cachedColorSpace;
          } altro {
            colorSpace = attendi questo.parseColorSpace({
              cs,
              risorse,
              localColorSpaceCache
            });
          }
        }
      }
      se (smask?.backdrop) {
        colorSpace ||= _colorspace.ColorSpace.singletons.rgb;
        smask.backdrop = colorSpace.getRgb(smask.backdrop, 0);
      }
      operatorList.addOp(_util.OPS.beginGroup, [groupOptions]);
    }
    const args = group ? [matrice, null] : [matrice, bbox];
    operatorList.addOp(_util.OPS.paintFormXObjectBegin, args);
    restituisci questo.getOperatorList({
      flusso: xobj,
      compito,
      risorse: dict.get("Risorse") || risorse,
      elenco degli operatori,
      statoiniziale
    }).then(funzione () {
      operatorList.addOp(_util.OPS.paintFormXObjectEnd, []);
      se (gruppo) {
        operatorList.addOp(_util.OPS.endGroup, [groupOptions]);
      }
      se (optionalContent !== indefinito) {
        operatorList.addOp(_util.OPS.endMarkedContent, []);
      }
    });
  }
  _sendImgData(objId, imgData, cacheGlobally = false) {
    trasferimenti costanti = imgData ? [imgData.bitmap || imgData.data.buffer] : null;
    se (this.parsingType3Font || cacheGlobally) {
      restituisci this.handler.send("commonobj", [objId, "Immagine", imgData], trasferimenti);
    }
    restituisci this.handler.send("obj", [objId, this.pageIndex, "Immagine", imgData], trasferimenti);
  }
  buildPaintImageXObject asincrono({
    risorse,
    immagine,
    isInline = falso,
    elenco degli operatori,
    chiave della cache,
    localImageCache,
    localColorSpaceCache
  }) {
    const dict = image.dict;
    const imageRef = dict.objId;
    const w = dict.get("W", "Larghezza");
    const h = dict.get("H", "Altezza");
    se (!(w && tipo di w === "numero") || !(h && tipo di h === "numero")) {
      (0, _util.warn)("Mancano le dimensioni dell'immagine o non sono numeri.");
      ritorno;
    }
    const maxImageSize = this.options.maxImageSize;
    se (maxImageSize !== -1 && w * h > maxImageSize) {
      const msg = "L'immagine ha superato la dimensione massima consentita ed è stata rimossa.";
      se (this.options.ignoreErrors) {
        (0, _util.warn)(msg);
        ritorno;
      }
      lancia un nuovo errore (msg);
    }
    lascia optionalContent;
    se (dict.has("OC")) {
      optionalContent = attendi this.parseMarkedContentProps(dict.get("OC"), resources);
    }
    const imageMask = dict.get("IM", "ImageMask") || falso;
    lascia imgData, argomenti;
    se (immagineMaschera) {
      const interpolate = dict.get("I", "Interpola");
      const bitStrideLength = w + 7 >> 3;
      const imgArray = image.getBytes(bitStrideLength * h);
      const decode = dict.getArray("D", "Decodifica");
      se (this.parsingType3Font) {
        imgData = _image.PDFImage.createRawMask({
          imgArray,
          larghezza: w,
          altezza: h,
          imageIsFromDecodeStream: istanza dell'immagine di _decode_stream.DecodeStream,
          inverseDecode: decodifica?.[0] > 0,
          interpolare
        });
        imgData.cached = !!cacheKey;
        argomenti = [imgData];
        operatorList.addImageOps(_util.OPS.paintImageMaskXObject, argomenti, optionalContent);
        se (cacheKey) {
          const cacheData = {
            funzione: _util.OPS.paintImageMaskXObject,
            argomenti,
            Contenuto facoltativo
          };
          localImageCache.set(cacheKey, imageRef, cacheData);
          se (imageRef) {
            this._regionalImageCache.set(null, imageRef, cacheData);
          }
        }
        ritorno;
      }
      imgData = attendi _image.PDFImage.createMask({
        imgArray,
        larghezza: w,
        altezza: h,
        imageIsFromDecodeStream: istanza dell'immagine di _decode_stream.DecodeStream,
        inverseDecode: decodifica?.[0] > 0,
        interpolare,
        isOffscreenCanvasSupported: this.options.isOffscreenCanvasSupported
      });
      se (imgData.isSingleOpaquePixel) {
        operatorList.addImageOps(_util.OPS.paintSolidColorImageMask, [], optionalContent);
        se (cacheKey) {
          const cacheData = {
            fn: _util.OPS.paintSolidColorImageMask,
            argomenti: [],
            Contenuto facoltativo
          };
          localImageCache.set(cacheKey, imageRef, cacheData);
          se (imageRef) {
            this._regionalImageCache.set(null, imageRef, cacheData);
          }
        }
        ritorno;
      }
      const objId = `mask_${this.idFactory.createObjId()}`;
      operatorList.addDependency(objId);
      this._sendImgData(objId, imgData);
      argomenti = [{
        dati: objId,
        larghezza: imgData.width,
        altezza: imgData.height,
        interpolare: imgData.interpolate,
        conteggio: 1
      }];
      operatorList.addImageOps(_util.OPS.paintImageMaskXObject, argomenti, optionalContent);
      se (cacheKey) {
        const cacheData = {
          funzione: _util.OPS.paintImageMaskXObject,
          argomenti,
          Contenuto facoltativo
        };
        localImageCache.set(cacheKey, imageRef, cacheData);
        se (imageRef) {
          this._regionalImageCache.set(null, imageRef, cacheData);
        }
      }
      ritorno;
    }
    const PICCOLE_DIMENSIONI_IMMAGINE = 200;
    se (isInline && !dict.has("SMask") && !dict.has("Mask") && w + h < SMALL_IMAGE_DIMENSIONS) {
      const imageObj = new _image.PDFImage({
        xrif: questo.xrif,
        res: risorse,
        immagine,
        è in linea,
        pdfFunctionFactory: questo._pdfFunctionFactory,
        localColorSpaceCache
      });
      imgData = attendi imageObj.createImageData(true, false);
      operatorList.isOffscreenCanvasSupported = this.options.isOffscreenCanvasSupported;
      operatorList.addImageOps(_util.OPS.paintInlineImageXObject, [imgData], optionalContent);
      ritorno;
    }
    lascia objId = `img_${this.idFactory.createObjId()}`,
      cacheGlobally = false;
    se (this.parsingType3Font) {
      objId = `${this.idFactory.getDocId()}_type3_${objId}`;
    } altrimenti se (imageRef) {
      cacheGlobally = this.globalImageCache.shouldCache(imageRef, this.pageIndex);
      se (cacheGlobally) {
        objId = `${this.idFactory.getDocId()}_${objId}`;
      }
    }
    operatorList.addDependency(objId);
    argomenti = [objId, w, h];
    _immagine.PDFImage.buildImage({
      xrif: questo.xrif,
      res: risorse,
      immagine,
      è in linea,
      pdfFunctionFactory: questo._pdfFunctionFactory,
      localColorSpaceCache
    }).then(async imageObj => {
      imgData = attendi imageObj.createImageData(false, this.options.isOffscreenCanvasSupported);
      se (cacheKey && imageRef && cacheGlobally) {
        lunghezza costante = imgData.bitmap ? imgData.larghezza * imgData.altezza * 4 : imgData.lunghezza dati;
        this.globalImageCache.addByteSize(imageRef, lunghezza);
      }
      restituisce this._sendImgData(objId, imgData, cacheGlobally);
    }).catch(motivo => {
      (0, _util.warn)(`Impossibile decodificare l'immagine "${objId}": "${reason}".`);
      restituisci questo._sendImgData(objId, null, cacheGlobally);
    });
    operatorList.addImageOps(_util.OPS.paintImageXObject, argomenti, optionalContent);
    se (cacheKey) {
      const cacheData = {
        funzione: _util.OPS.paintImageXObject,
        argomenti,
        Contenuto facoltativo
      };
      localImageCache.set(cacheKey, imageRef, cacheData);
      se (imageRef) {
        this._regionalImageCache.set(null, imageRef, cacheData);
        se (cacheGlobally) {
          (0, _util.assert)(!isInline, "Impossibile memorizzare nella cache un'immagine in linea a livello globale.");
          this.globalImageCache.setData(imageRef, {
            objId,
            funzione: _util.OPS.paintImageXObject,
            argomenti,
            Contenuto facoltativo,
            Dimensione byte: 0
          });
        }
      }
    }
  }
  handleSMask(smask, risorse, operatorList, attività, stateManager, localColorSpaceCache) {
    const smaskContent = smask.get("G");
    const smaskOptions = {
      sottotipo: smask.get("S").name,
      sfondo: smask.get("BC")
    };
    const transferObj = smask.get("TR");
    se ((0, _function.isPDFFunction)(transferObj)) {
      const transferFn = this._pdfFunctionFactory.create(transferObj);
      const transferMap = new Uint8Array(256);
      const tmp = new Float32Array(1);
      per (lascia che i = 0; i < 256; i++) {
        tmp[0] = i / 255;
        transferFn(tmp, 0, tmp, 0);
        transferMap[i] = tmp[0] * 255 | 0;
      }
      smaskOptions.transferMap = transferMap;
    }
    restituisci this.buildFormXObject(risorse, smaskContent, smaskOptions, operatorList, attività, stateManager.state.clone(), localColorSpaceCache);
  }
  handleTransferFunction(tr) {
    lascia trasferireArray;
    se (Array.isArray(tr)) {
      trasferimentoArray = tr;
    } altrimenti se ((0, _function.isPDFFunction)(tr)) {
      trasferimentoArray = [tr];
    } altro {
      restituisci null;
    }
    const transferMaps = [];
    lascia numFns = 0,
      numEffectfulFns = 0;
    per (voce costante di transferArray) {
      const transferObj = this.xref.fetchIfRef(entry);
      numFns++;
      se ((0, _primitives.isName)(transferObj, "Identità")) {
        transferMaps.push(null);
        continuare;
      } altrimenti se (!(0, _function.isPDFFunction)(transferObj)) {
        restituisci null;
      }
      const transferFn = this._pdfFunctionFactory.create(transferObj);
      const transferMap = new Uint8Array(256),
        tmp = nuovo Float32Array(1);
      per (sia j = 0; j < 256; j++) {
        tmp[0] = j / 255;
        transferFn(tmp, 0, tmp, 0);
        transferMap[j] = tmp[0] * 255 | 0;
      }
      transferMaps.push(transferMap);
      numEffectfulFns++;
    }
    se (!(numFns === 1 || numFns === 4)) {
      restituisci null;
    }
    se (numEffectfulFns === 0) {
      restituisci null;
    }
    trasferimento di ritornoMappe;
  }
  handleTilingType(fn, colore, risorse, modello, patternDict, operatorList, attività, localTilingPatternCache) {
    const tilingOpList = new _operator_list.OperatorList();
    const patternResources = _primitives.Dict.merge({
      xrif: questo.xrif,
      dictArray: [patternDict.get("Risorse"), risorse]
    });
    restituisci questo.getOperatorList({
      flusso: modello,
      compito,
      risorse: patternResources,
      operatorList: tilingOpList
    }).then(funzione () {
      const operatorListIR = tilingOpList.getIR();
      const tilingPatternIR = (0, _pattern.getTilingPatternIR)(operatorListIR, patternDict, color);
      operatorList.addDependencies(tilingOpList.dependencies);
      operatorList.addOp(fn, tilingPatternIR);
      se (patternDict.objId) {
        localTilingPatternCache.set(null, patternDict.objId, {
          operatorListIR,
          dizionario: patternDict
        });
      }
    }).catch(motivo => {
      se (motivo instanceof _util.AbortException) {
        ritorno;
      }
      se (this.options.ignoreErrors) {
        (0, _util.warn)(`handleTilingType - ignorando il modello: "${reason}".`);
        ritorno;
      }
      gettare la ragione;
    });
  }
  handleSetFont(risorse, fontArgs, fontRef, operatorList, attività, stato, fallbackFontDict = null, cssFontInfo = null) {
    const fontName = fontArgs?.[0] instanceof _primitives.Name ? fontArgs[0].name : null;
    restituisci questo.loadFont(fontName, fontRef, risorse, fallbackFontDict, cssFontInfo).then(tradotto => {
      se (!tradotto.font.isType3Font) {
        ritorno tradotto;
      }
      restituisci translated.loadType3Data(this, resources, task).then(function () {
        operatorList.addDependencies(tradotto.type3Dependencies);
        ritorno tradotto;
      }).catch(motivo => {
        restituisci nuovo TranslatedFont({
          Nome caricato: "g_font_error",
          font: new _fonts.ErrorFont(`Errore di caricamento del font Type3: ${reason}`),
          dizionario: tradotto.font,
          evaluatorOptions: this.options
        });
      });
    }).then(tradotto => {
      state.font = translated.font;
      tradotto.invia(questo.gestore);
      restituisci translated.loadedName;
    });
  }
  handleText(caratteri, stato) {
    const font = stato.font;
    const glifi = font.charsToGlyphs(caratteri);
    se (font.data) {
      const isAddToPathSet = !!(state.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);
      if (isAddToPathSet || state.fillColorSpace.name === "Pattern" || font.disableFontFace || this.options.disableFontFace) {
        PartialEvaluator.buildFontPaths(font, glifi, this.handler, this.options);
      }
    }
    restituisci glifi;
  }
  ensureStateFont(stato) {
    se (stato.font) {
      ritorno;
    }
    const reason = new _util.FormatError("Manca l'operatore setFont (Tf) prima dell'operatore di rendering del testo.");
    se (this.options.ignoreErrors) {
      (0, _util.warn)(`ensureStateFont: "${reason}".`);
      ritorno;
    }
    gettare la ragione;
  }
  setGState asincrono({
    risorse,
    gState,
    elenco degli operatori,
    chiave della cache,
    compito,
    Direttore dello Stato,
    localGStateCache,
    localColorSpaceCache
  }) {
    const gStateRef = gState.objId;
    lascia che isSimpleGState = true;
    const gStateObj = [];
    lascia promessa = Promessa.risolvi();
    per (const chiave di gState.getKeys()) {
      valore costante = gState.get(chiave);
      interruttore (chiave) {
        caso "Tipo":
          rottura;
        caso "LW":
        caso "LC":
        caso "LJ":
        caso "ML":
        caso "D":
        caso "RI":
        caso "FL":
        caso "CA":
        caso "ca":
          gStateObj.push([chiave, valore]);
          rottura;
        caso "Font":
          isSimpleGState = false;
          promessa = promessa.allora(() => {
            restituisci this.handleSetFont(risorse, null, valore[0], operatorList, attività, stateManager.state).then(funzione (loadedName) {
              operatorList.addDependency(loadedName);
              gStateObj.push([chiave, [nomecaricato, valore[1]]]);
            });
          });
          rottura;
        caso "BM":
          gStateObj.push([chiave, normalizeBlendMode(valore)]);
          rottura;
        caso "SMask":
          se ((0, _primitives.isName)(valore, "Nessuno")) {
            gStateObj.push([chiave, falso]);
            rottura;
          }
          se (valore instanceof _primitives.Dict) {
            isSimpleGState = false;
            promessa = promessa.allora(() => {
              restituisci this.handleSMask(valore, risorse, operatorList, attività, stateManager, localColorSpaceCache);
            });
            gStateObj.push([chiave, vero]);
          } altro {
            (0, _util.warn)("Tipo SMask non supportato");
          }
          rottura;
        caso "TR":
          const transferMaps = this.handleTransferFunction(value);
          gStateObj.push([chiave, transferMaps]);
          rottura;
        caso "OP":
        caso "op":
        caso "OPM":
        caso "BG":
        caso "BG2":
        caso "UCR":
        caso "UCR2":
        caso "TR2":
        caso "HT":
        caso "SM":
        caso "SA":
        caso "AIS":
        caso "TK":
          (0, _util.info)("operatore di stato grafico " + tasto);
          rottura;
        predefinito:
          (0, _util.info)("Operatore di stato grafico sconosciuto " + tasto);
          rottura;
      }
    }
    restituisci promessa.quindi(funzione () {
      se (gStateObj.length > 0) {
        operatorList.addOp(_util.OPS.setGState, [gStateObj]);
      }
      se (isSimpleGState) {
        localGStateCache.set(cacheKey, gStateRef, gStateObj);
      }
    });
  }
  loadFont(fontName, font, risorse, fallbackFontDict = null, cssFontInfo = null) {
    const errorFont = async () => {
      restituisci nuovo TranslatedFont({
        Nome caricato: "g_font_error",
        font: new _fonts.ErrorFont(`Il font "${fontName}" non è disponibile.`),
        dizionario: font,
        evaluatorOptions: this.options
      });
    };
    lascia fontRef;
    se (carattere) {
      se (font instanceof _primitives.Ref) {
        fontRef = font;
      }
    } altro {
      const fontRes = resources.get("Font");
      se (fontRes) {
        fontRef = fontRes.getRaw(fontName);
      }
    }
    se (fontRef) {
      se (this.parsingType3Font && this.type3FontRefs.has(fontRef)) {
        restituisci erroreFont();
      }
      se (this.fontCache.has(fontRef)) {
        restituisce this.fontCache.get(fontRef);
      }
      font = this.xref.fetchIfRef(fontRef);
    }
    se (!(font instanceof _primitives.Dict)) {
      se (!this.options.ignoreErrors && !this.parsingType3Font) {
        (0, _util.warn)(`Il carattere "${fontName}" non è disponibile.`);
        restituisci erroreFont();
      }
      (0, _util.warn)(`Il font "${fontName}" non è disponibile. Si sta tentando di tornare a un font predefinito.`);
      font = fallbackFontDict || PartialEvaluator.fallbackFontDict;
    }
    se (font.cacheKey && this.fontCache.has(font.cacheKey)) {
      restituisci this.fontCache.get(font.cacheKey);
    }
    const fontCapability = new _util.PromiseCapability();
    lascia preEvaluatedFont;
    Tentativo {
      preEvaluatedFont = this.preEvaluateFont(font);
      preEvaluatedFont.cssFontInfo = cssFontInfo;
    } cattura (motivo) {
      (0, _util.warn)(`loadFont - preEvaluateFont fallito: "${reason}".`);
      restituisci erroreFont();
    }
    costante {
      descrittore,
      hash
    } = preEvaluatedFont;
    const fontRefIsRef = fontRef instanceof _primitives.Ref;
    lascia fontID;
    se (hash && descrittore instanceof _primitives.Dict) {
      const fontAliases = descriptor.fontAliases ||= Object.create(null);
      se (fontAliases[hash]) {
        const aliasFontRef = fontAliases[hash].aliasRef;
        if (fontRefIsRef && aliasFontRef && this.fontCache.has(aliasFontRef)) {
          this.fontCache.putAlias(fontRef, aliasFontRef);
          restituisce this.fontCache.get(fontRef);
        }
      } altro {
        fontAliases[hash] = {
          fontID: this.idFactory.createFontId()
        };
      }
      se (fontRefIsRef) {
        fontAliases[hash].aliasRef = fontRef;
      }
      fontID = fontAliases[hash].fontID;
    } altro {
      fontID = this.idFactory.createFontId();
    }
    (0, _util.assert)(fontID?.startsWith("f"), 'Il "fontID" deve essere definito (correttamente).');
    se (fontRefIsRef) {
      this.fontCache.put(fontRef, fontCapability.promise);
    } altro {
      font.cacheKey = `cacheKey_${fontID}`;
      this.fontCache.put(font.cacheKey, fontCapability.promise);
    }
    font.loadedName = `${this.idFactory.getDocId()}_${fontID}`;
    this.translateFont(preEvaluatedFont).then(translatedFont => {
      fontCapability.resolve(new TranslatedFont({
        Nome caricato: font.Nome caricato,
        font: tradottoFont,
        dizionario: font,
        evaluatorOptions: this.options
      }));
    }).catch(motivo => {
      (0, _util.warn)(`loadFont - translateFont fallito: "${reason}".`);
      fontCapability.resolve(new TranslatedFont({
        Nome caricato: font.Nome caricato,
        font: new _fonts.ErrorFont(motivo instanceof Error ? motivo.messaggio : motivo),
        dizionario: font,
        evaluatorOptions: this.options
      }));
    });
    restituisci fontCapability.promise;
  }
  buildPath(operatorList, fn, args, parsingText = false) {
    const lastIndex = operatorList.length - 1;
    se (!arg) {
      argomenti = [];
    }
    se (ultimoIndice < 0 || operatorList.fnArray[ultimoIndice] !== _util.OPS.constructPath) {
      se (parsingText) {
        (0, _util.warn)(`È stato rilevato l'operatore di percorso "${fn}" all'interno di un oggetto di testo.`);
        operatorList.addOp(_util.OPS.save, null);
      }
      lascia minMax;
      interruttore (fn) {
        caso _util.OPS.rectangle:
          const x = argomenti[0] + argomenti[2];
          costante y = argomenti[1] + argomenti[3];
          minMax = [Math.min(args[0], x), Math.max(args[0], x), Math.min(args[1], y), Math.max(args[1], y)];
          rottura;
        caso _util.OPS.moveTo:
        caso _util.OPS.lineTo:
          minMax = [argomenti[0], argomenti[0], argomenti[1], argomenti[1]];
          rottura;
        predefinito:
          minMax = [Infinito, -Infinito, Infinito, -Infinito];
          rottura;
      }
      operatorList.addOp(_util.OPS.constructPath, [[fn], args, minMax]);
      se (parsingText) {
        operatorList.addOp(_util.OPS.restore, null);
      }
    } altro {
      const opArgs = operatorList.argsArray[lastIndex];
      opArgs[0].push(fn);
      opArgs[1].push(...args);
      const minMax = opArgs[2];
      interruttore (fn) {
        caso _util.OPS.rectangle:
          const x = argomenti[0] + argomenti[2];
          costante y = argomenti[1] + argomenti[3];
          minMax[0] = Math.min(minMax[0], argomenti[0], x);
          minMax[1] = Math.max(minMax[1], argomenti[0], x);
          minMax[2] = Math.min(minMax[2], argomenti[1], y);
          minMax[3] = Math.max(minMax[3], argomenti[1], y);
          rottura;
        caso _util.OPS.moveTo:
        caso _util.OPS.lineTo:
          minMax[0] = Math.min(minMax[0], args[0]);
          minMax[1] = Math.max(minMax[1], argomenti[0]);
          minMax[2] = Math.min(minMax[2], args[1]);
          minMax[3] = Math.max(minMax[3], argomenti[1]);
          rottura;
      }
    }
  }
  parseColorSpace({
    cs,
    risorse,
    localColorSpaceCache
  }) {
    restituisci _colorspace.ColorSpace.parseAsync({
      cs,
      xrif: questo.xrif,
      risorse,
      pdfFunctionFactory: questo._pdfFunctionFactory,
      localColorSpaceCache
    }).catch(motivo => {
      se (motivo instanceof _util.AbortException) {
        restituisci null;
      }
      se (this.options.ignoreErrors) {
        (0, _util.warn)(`parseColorSpace - ignorando ColorSpace: "${reason}".`);
        restituisci null;
      }
      gettare la ragione;
    });
  }
  parseShading({
    ombreggiatura,
    risorse,
    localColorSpaceCache,
    cache modello di ombreggiatura locale
  }) {
    lascia id = localShadingPatternCache.get(ombreggiatura);
    se (!id) {
      var shadingFill = _pattern.Pattern.parseShading(ombreggiatura, this.xref, risorse, this._pdfFunctionFactory, localColorSpaceCache);
      const patternIR = shadingFill.getIR();
      id = `pattern_${this.idFactory.createObjId()}`;
      se (this.parsingType3Font) {
        id = `${this.idFactory.getDocId()}_type3_${id}`;
      }
      localShadingPatternCache.set(ombreggiatura, id);
      se (this.parsingType3Font) {
        this.handler.send("commonobj", [id, "Modello", patternIR]);
      } altro {
        this.handler.send("obj", [id, this.pageIndex, "Modello", patternIR]);
      }
    }
    ID di ritorno;
  }
  handleColorN(operatorList, fn, args, cs, patterns, resources, task, localColorSpaceCache, localTilingPatternCache, localShadingPatternCache) {
    const patternName = args.pop();
    se (nomemodello instanceof _primitives.Name) {
      const rawPattern = patterns.getRaw(patternName.name);
      const localTilingPattern = rawPattern instanceof _primitives.Ref && localTilingPatternCache.getByRef(rawPattern);
      se (localTilingPattern) {
        Tentativo {
          const color = cs.base ? cs.base.getRgb(args, 0) : null;
          const tilingPatternIR = (0, _pattern.getTilingPatternIR)(localTilingPattern.operatorListIR, localTilingPattern.dict, color);
          operatorList.addOp(fn, tilingPatternIR);
          restituisci indefinito;
        } presa {}
      }
      modello costante = this.xref.fetchIfRef(rawPattern);
      se (modello) {
        const dict = pattern instanceof _base_stream.BaseStream ? pattern.dict : pattern;
        const typeNum = dict.get("PatternType");
        if (typeNum === PatternType.TILING) {
          const color = cs.base ? cs.base.getRgb(args, 0) : null;
          restituisci this.handleTilingType(fn, colore, risorse, modello, dizionario, operatorList, attività, localTilingPatternCache);
        } altrimenti se (typeNum === PatternType.SHADING) {
          const shading = dict.get("Ombreggiatura");
          matrice costante = dict.getArray("Matrice");
          const objId = this.parseShading({
            ombreggiatura,
            risorse,
            localColorSpaceCache,
            cache modello di ombreggiatura locale
          });
          operatorList.addOp(fn, ["Ombreggiatura", objId, matrice]);
          restituisci indefinito;
        }
        lancia nuovo _util.FormatError(`Tipo di modello sconosciuto: ${typeNum}`);
      }
    }
    lancia nuovo _util.FormatError(`Nome modello sconosciuto: ${nomemodello}`);
  }
  _parseVisibilityExpression(array, nestingCounter, currentResult) {
    const MAX_NESTING = 10;
    se (++contatoreannidamento > MAX_ANNIDAMENTO) {
      (0, _util.warn)("L'espressione di visibilità è troppo annidata");
      ritorno;
    }
    lunghezza costante = array.lunghezza;
    operatore costante = this.xref.fetchIfRef(array[0]);
    se (lunghezza < 2 || !(operatore instanceof _primitives.Name)) {
      (0, _util.warn)("Espressione di visibilità non valida");
      ritorno;
    }
    switch (nome.operatore) {
      caso "E":
      caso "O":
      caso "Non":
        currentResult.push(operatore.nome);
        rottura;
      predefinito:
        (0, _util.warn)(`Operatore non valido ${operator.name} nell'espressione di visibilità`);
        ritorno;
    }
    per (lascia che i = 1; i < lunghezza; i++) {
      const raw = array[i];
      oggetto costante = this.xref.fetchIfRef(raw);
      se (Array.isArray(oggetto)) {
        const nestedResult = [];
        currentResult.push(nestedResult);
        this._parseVisibilityExpression(oggetto, nestingCounter, nestedResult);
      } altrimenti se (istanza grezza di _primitives.Ref) {
        currentResult.push(raw.toString());
      }
    }
  }
  async parseMarkedContentProps(contentProperties, resources) {
    lascia optionalContent;
    se (contentProperties instanceof _primitives.Name) {
      const properties = resources.get("Proprietà");
      optionalContent = properties.get(contentProperties.name);
    } altrimenti se (contentProperties instanceof _primitives.Dict) {
      optionalContent = contentProperties;
    } altro {
      throw new _util.FormatError("Proprietà del contenuto facoltative non valide.");
    }
    const optionalContentType = optionalContent.get("Tipo")?.name;
    se (optionalContentType === "OCG") {
      ritorno {
        tipo: optionalContentType,
        id: optionalContent.objId
      };
    } altrimenti se (optionalContentType === "OCMD") {
      espressione costante = optionalContent.get("VE");
      se (Array.isArray(espressione)) {
        risultato costante = [];
        this._parseVisibilityExpression(espressione, 0, risultato);
        se (lunghezza del risultato > 0) {
          ritorno {
            tipo: "OCMD",
            espressione: risultato
          };
        }
      }
      const optionalContentGroups = optionalContent.get("OCG");
      se (Array.isArray(optionalContentGroups) || optionalContentGroups instanceof _primitives.Dict) {
        const groupIds = [];
        se (Array.isArray(optionalContentGroups)) {
          per (const ocg di optionalContentGroups) {
            groupIds.push(ocg.toString());
          }
        } altro {
          groupIds.push(optionalContentGroups.objId);
        }
        ritorno {
          tipo: optionalContentType,
          ID: ID gruppo,
          policy: optionalContent.get("P") instanceof _primitives.Name ? optionalContent.get("P").name : null,
          espressione: null
        };
      } altrimenti se (optionalContentGroups instanceof _primitives.Ref) {
        ritorno {
          tipo: optionalContentType,
          id: optionalContentGroups.toString()
        };
      }
    }
    restituisci null;
  }
  getOperatorList({
    flusso,
    compito,
    risorse,
    elenco degli operatori,
    statoiniziale = null,
    fallbackFontDict = null
  }) {
    risorse ||= _primitives.Dict.empty;
    statoiniziale ||= nuovo stato di valutazione();
    se (!elencooperatori) {
      throw new Error('getOperatorList: parametro "operatorList" mancante');
    }
    const self = questo;
    const xref = this.xref;
    lascia che parsingText = false;
    const localImageCache = new _image_utils.LocalImageCache();
    const localColorSpaceCache = new _image_utils.LocalColorSpaceCache();
    const localGStateCache = new _image_utils.LocalGStateCache();
    const localTilingPatternCache = new _image_utils.LocalTilingPatternCache();
    const localShadingPatternCache = new Map();
    const xobjs = resources.get("XObject") || _primitives.Dict.empty;
    const patterns = resources.get("Pattern") || _primitives.Dict.empty;
    const stateManager = new StateManager(initialState);
    const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
    const timeSlotManager = new TimeSlotManager();
    funzione closePendingRestoreOPS(argomento) {
      per (lascia che i = 0, ii = preprocessor.savedStatesDepth; i < ii; i++) {
        operatorList.addOp(_util.OPS.restore, []);
      }
    }
    restituisci nuova Promessa(funzione promiseBody(risolvi, rifiuta) {
      const next = funzione (promessa) {
        Promessa.all([promessa, operatorList.ready]).then(funzione () {
          Tentativo {
            promiseBody(risolvi, rifiuta);
          } catturare (es.) {
            rifiutare(es.);
          }
        }, rifiutare);
      };
      task.ensureNotTerminated();
      timeSlotManager.reset();
      operazione costante = {};
      lascia ferma, i, ii, cs, nome, isValidName;
      mentre (!(stop = timeSlotManager.check())) {
        argomenti operazione = null;
        se (!preprocessor.read(operazione)) {
          rottura;
        }
        lascia che args = operation.args;
        lascia fn = operazione.fn;
        interruttore (fn | 0) {
          caso _util.OPS.paintXObject:
            isValidName = args[0] instanceof _primitives.Name;
            nome = argomenti[0].nome;
            se (isValidName) {
              const localImage = localImageCache.getByName(nome);
              se (immaginelocale) {
                operatorList.addImageOps(localImage.fn, localImage.args, localImage.optionalContent);
                incrementCachedImageMaskCount(localImage);
                argomenti = null;
                continuare;
              }
            }
            next(new Promise(function (resolveXObject, rejectXObject) {
              se (!isValidName) {
                throw new _util.FormatError("È necessario fare riferimento a XObject tramite il nome.");
              }
              lascia xobj = xobjs.getRaw(nome);
              se (xobj instanceof _primitives.Ref) {
                const localImage = localImageCache.getByRef(xobj) || self._regionalImageCache.getByRef(xobj);
                se (immaginelocale) {
                  operatorList.addImageOps(localImage.fn, localImage.args, localImage.optionalContent);
                  incrementCachedImageMaskCount(localImage);
                  resolveXObject();
                  ritorno;
                }
                const globalImage = self.globalImageCache.getData(xobj, self.pageIndex);
                se (immagineglobale) {
                  operatorList.addDependency(globalImage.objId);
                  operatorList.addImageOps(globalImage.fn, globalImage.args, globalImage.optionalContent);
                  resolveXObject();
                  ritorno;
                }
                xobj = xref.fetch(xobj);
              }
              se (!(xobj instanceof _base_stream.BaseStream)) {
                throw new _util.FormatError("XObject dovrebbe essere un flusso");
              }
              const type = xobj.dict.get("Sottotipo");
              se (!(tipo instanceof _primitives.Name)) {
                throw new _util.FormatError("XObject dovrebbe avere un sottotipo Name");
              }
              se (tipo.nome === "Form") {
                stateManager.save();
                self.buildFormXObject(risorse, xobj, null, operatorList, attività, stateManager.state.clone(), localColorSpaceCache).then(funzione () {
                  stateManager.restore();
                  resolveXObject();
                }, rifiutaXObject);
                ritorno;
              } else if (type.name === "Immagine") {
                self.buildPaintImageXObject({
                  risorse,
                  immagine: xobj,
                  elenco degli operatori,
                  cacheKey: nome,
                  localImageCache,
                  localColorSpaceCache
                }).then(resolveXObject, rejectXObject);
                ritorno;
              } altrimenti se (tipo.nome === "PS") {
                (0, _util.info)("Sottotipo XObject ignorato PS");
              } altro {
                throw new _util.FormatError(`Sottotipo XObject non gestito ${type.name}`);
              }
              resolveXObject();
            }).catch(funzione (motivo) {
              se (motivo instanceof _util.AbortException) {
                ritorno;
              }
              se (self.options.ignoreErrors) {
                (0, _util.warn)(`getOperatorList - ignorando XObject: "${reason}".`);
                ritorno;
              }
              gettare la ragione;
            }));
            ritorno;
          caso _util.OPS.setFont:
            var fontSize = args[1];
            next(self.handleSetFont(risorse, argomenti, null, operatorList, attività, stateManager.state, fallbackFontDict).then(funzione (loadedName) {
              operatorList.addDependency(loadedName);
              operatorList.addOp(_util.OPS.setFont, [loadedName, fontSize]);
            }));
            ritorno;
          caso _util.OPS.beginText:
            parsingText = true;
            rottura;
          caso _util.OPS.endText:
            parsingText = falso;
            rottura;
          caso _util.OPS.endInlineImage:
            var cacheKey = args[0].cacheKey;
            se (cacheKey) {
              const localImage = localImageCache.getByName(cacheKey);
              se (immaginelocale) {
                operatorList.addImageOps(localImage.fn, localImage.args, localImage.optionalContent);
                incrementCachedImageMaskCount(localImage);
                argomenti = null;
                continuare;
              }
            }
            next(self.buildPaintImageXObject({
              risorse,
              immagine: argomenti[0],
              isInline: vero,
              elenco degli operatori,
              chiave della cache,
              localImageCache,
              localColorSpaceCache
            }));
            ritorno;
          caso _util.OPS.showText:
            se (!stateManager.state.font) {
              self.ensureStateFont(stateManager.state);
              continuare;
            }
            argomenti[0] = self.handleText(argomenti[0], stateManager.state);
            rottura;
          caso _util.OPS.showSpacedText:
            se (!stateManager.state.font) {
              self.ensureStateFont(stateManager.state);
              continuare;
            }
            var combinedGlyphs = [];
            var stato = stateManager.state;
            per (const arrItem di args[0]) {
              se (tipo di arrItem === "stringa") {
                combinedGlyphs.push(...self.handleText(arrItem, state));
              } else if (typeof arrItem === "numero") {
                combinedGlyphs.push(arrItem);
              }
            }
            args[0] = glifi combinati;
            fn = _util.OPS.showText;
            rottura;
          caso _util.OPS.nextLineShowText:
            se (!stateManager.state.font) {
              self.ensureStateFont(stateManager.state);
              continuare;
            }
            operatorList.addOp(_util.OPS.nextLine);
            argomenti[0] = self.handleText(argomenti[0], stateManager.state);
            fn = _util.OPS.showText;
            rottura;
          caso _util.OPS.nextLineSetSpacingShowText:
            se (!stateManager.state.font) {
              self.ensureStateFont(stateManager.state);
              continuare;
            }
            operatorList.addOp(_util.OPS.nextLine);
            operatorList.addOp(_util.OPS.setWordSpacing, [args.shift()]);
            operatorList.addOp(_util.OPS.setCharSpacing, [args.shift()]);
            argomenti[0] = self.handleText(argomenti[0], stateManager.state);
            fn = _util.OPS.showText;
            rottura;
          caso _util.OPS.setTextRenderingMode:
            stateManager.state.textRenderingMode = argomenti[0];
            rottura;
          caso _util.OPS.setFillColorSpace:
            {
              const cachedColorSpace = _colorspace.ColorSpace.getCached(args[0], xref, localColorSpaceCache);
              se (cachedColorSpace) {
                stateManager.state.fillColorSpace = cachedColorSpace;
                continuare;
              }
              next(self.parseColorSpace({
                cs: argomenti[0],
                risorse,
                localColorSpaceCache
              }).then(funzione (spaziocolore) {
                se (spaziocolore) {
                  stateManager.state.fillColorSpace = colorSpace;
                }
              }));
              ritorno;
            }
          caso _util.OPS.setStrokeColorSpace:
            {
              const cachedColorSpace = _colorspace.ColorSpace.getCached(args[0], xref, localColorSpaceCache);
              se (cachedColorSpace) {
                stateManager.state.strokeColorSpace = cachedColorSpace;
                continuare;
              }
              next(self.parseColorSpace({
                cs: argomenti[0],
                risorse,
                localColorSpaceCache
              }).then(funzione (spaziocolore) {
                se (spaziocolore) {
                  stateManager.state.strokeColorSpace = colorSpace;
                }
              }));
              ritorno;
            }
          caso _util.OPS.setFillColor:
            cs = stateManager.state.fillColorSpace;
            argomenti = cs.getRgb(argomenti, 0);
            fn = _util.OPS.setFillRGBColor;
            rottura;
          caso _util.OPS.setStrokeColor:
            cs = stateManager.state.strokeColorSpace;
            argomenti = cs.getRgb(argomenti, 0);
            fn = _util.OPS.setStrokeRGBColor;
            rottura;
          caso _util.OPS.setFillGray:
            stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.gray;
            argomenti = _colorspace.ColorSpace.singletons.gray.getRgb(argomenti, 0);
            fn = _util.OPS.setFillRGBColor;
            rottura;
          caso _util.OPS.setStrokeGray:
            stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.gray;
            argomenti = _colorspace.ColorSpace.singletons.gray.getRgb(argomenti, 0);
            fn = _util.OPS.setStrokeRGBColor;
            rottura;
          caso _util.OPS.setFillCMYKColor:
            stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.cmyk;
            argomenti = _colorspace.ColorSpace.singletons.cmyk.getRgb(argomenti, 0);
            fn = _util.OPS.setFillRGBColor;
            rottura;
          caso _util.OPS.setStrokeCMYKColor:
            stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.cmyk;
            argomenti = _colorspace.ColorSpace.singletons.cmyk.getRgb(argomenti, 0);
            fn = _util.OPS.setStrokeRGBColor;
            rottura;
          caso _util.OPS.setFillRGBColor:
            stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.rgb;
            argomenti = _colorspace.ColorSpace.singletons.rgb.getRgb(argomenti, 0);
            rottura;
          caso _util.OPS.setStrokeRGBColor:
            stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.rgb;
            argomenti = _colorspace.ColorSpace.singletons.rgb.getRgb(argomenti, 0);
            rottura;
          caso _util.OPS.setFillColorN:
            cs = stateManager.state.fillColorSpace;
            se (cs.name === "Modello") {
              next(self.handleColorN(operatorList, _util.OPS.setFillColorN, argomenti, cs, modelli, risorse, attività, localColorSpaceCache, localTilingPatternCache, localShadingPatternCache));
              ritorno;
            }
            argomenti = cs.getRgb(argomenti, 0);
            fn = _util.OPS.setFillRGBColor;
            rottura;
          caso _util.OPS.setStrokeColorN:
            cs = stateManager.state.strokeColorSpace;
            se (cs.name === "Modello") {
              next(self.handleColorN(operatorList, _util.OPS.setStrokeColorN, argomenti, cs, modelli, risorse, attività, localColorSpaceCache, localTilingPatternCache, localShadingPatternCache));
              ritorno;
            }
            argomenti = cs.getRgb(argomenti, 0);
            fn = _util.OPS.setStrokeRGBColor;
            rottura;
          caso _util.OPS.shadingFill:
            var shadingRes = resources.get("Ombreggiatura");
            se (!shadingRes) {
              throw new _util.FormatError("Nessuna risorsa di ombreggiatura trovata");
            }
            var shading = shadingRes.get(args[0].name);
            se (!ombreggiatura) {
              throw new _util.FormatError("Nessun oggetto di ombreggiatura trovato");
            }
            const patternId = self.parseShading({
              ombreggiatura,
              risorse,
              localColorSpaceCache,
              cache modello di ombreggiatura locale
            });
            argomenti = [IDmodello];
            fn = _util.OPS.shadingFill;
            rottura;
          caso _util.OPS.setGState:
            isValidName = args[0] instanceof _primitives.Name;
            nome = argomenti[0].nome;
            se (isValidName) {
              const localGStateObj = localGStateCache.getByName(nome);
              se (localGStateObj) {
                se (localGStateObj.length > 0) {
                  operatorList.addOp(_util.OPS.setGState, [localGStateObj]);
                }
                argomenti = null;
                continuare;
              }
            }
            next(new Promise(function (resolveGState, rejectGState) {
              se (!isValidName) {
                throw new _util.FormatError("È necessario fare riferimento a GState tramite il nome.");
              }
              const extGState = resources.get("ExtGState");
              se (!(extGState instanceof _primitives.Dict)) {
                throw new _util.FormatError("ExtGState dovrebbe essere un dizionario.");
              }
              const gState = extGState.get(nome);
              se (!(gState instanceof _primitives.Dict)) {
                throw new _util.FormatError("GState dovrebbe essere un dizionario.");
              }
              self.setGState({
                risorse,
                gState,
                elenco degli operatori,
                cacheKey: nome,
                compito,
                Direttore dello Stato,
                localGStateCache,
                localColorSpaceCache
              }).then(resolveGState, rejectGState);
            }).catch(funzione (motivo) {
              se (motivo instanceof _util.AbortException) {
                ritorno;
              }
              se (self.options.ignoreErrors) {
                (0, _util.warn)(`getOperatorList - ignorando ExtGState: "${reason}".`);
                ritorno;
              }
              gettare la ragione;
            }));
            ritorno;
          caso _util.OPS.moveTo:
          caso _util.OPS.lineTo:
          caso _util.OPS.curveTo:
          caso _util.OPS.curveTo2:
          caso _util.OPS.curveTo3:
          caso _util.OPS.closePath:
          caso _util.OPS.rectangle:
            self.buildPath(operatorList, fn, args, parsingText);
            continuare;
          caso _util.OPS.markPoint:
          caso _util.OPS.markPointProps:
          caso _util.OPS.beginCompat:
          caso _util.OPS.endCompat:
            continuare;
          caso _util.OPS.beginMarkedContentProps:
            se (!(args[0] instanceof _primitives.Name)) {
              (0, _util.warn)(`Nome previsto per beginMarkedContentProps arg0=${args[0]}`);
              continuare;
            }
            se (args[0].name === "OC") {
              next(self.parseMarkedContentProps(args[1], risorse).then(dati => {
                operatorList.addOp(_util.OPS.beginMarkedContentProps, ["OC", data]);
              }).catch(motivo => {
                se (motivo instanceof _util.AbortException) {
                  ritorno;
                }
                se (self.options.ignoreErrors) {
                  (0, _util.warn)(`getOperatorList - ignorando beginMarkedContentProps: "${reason}".`);
                  ritorno;
                }
                gettare la ragione;
              }));
              ritorno;
            }
            argomenti = [args[0].nome, args[1] istanza di _primitives.Dict ? args[1].get("MCID") : null];
            rottura;
          caso _util.OPS.beginMarkedContent:
          caso _util.OPS.endMarkedContent:
          predefinito:
            se (argomenti !== null) {
              per (i = 0, ii = lunghezza argomenti; i < ii; i++) {
                se (args[i] instanceof _primitives.Dict) {
                  rottura;
                }
              }
              se (i < ii) {
                (0, _util.warn)("getOperatorList - ignorando l'operatore: " + fn);
                continuare;
              }
            }
        }
        operatorList.addOp(fn, args);
      }
      se (fermati) {
        successivo(differito);
        ritorno;
      }
      closePendingRestoreOPS();
      risolvere();
    }).catch(motivo => {
      se (motivo instanceof _util.AbortException) {
        ritorno;
      }
      se (this.options.ignoreErrors) {
        (0, _util.warn)(`getOperatorList - ignora gli errori durante "${task.name}" ` + `task: "${reason}".`);
        closePendingRestoreOPS();
        ritorno;
      }
      gettare la ragione;
    });
  }
  getTextContent({
    flusso,
    compito,
    risorse,
    stateManager = null,
    includeMarkedContent = false,
    lavello,
    stili visti = nuovo Set(),
    viewBox,
    markedContentData = null,
    disableNormalization = false
  }) {
    risorse ||= _primitives.Dict.empty;
    stateManager ||= nuovo StateManager(nuovo TextState());
    se (includeMarkedContent) {
      markedContentData ||= {
        livello: 0
      };
    }
    const textContent = {
      elementi: [],
      stili: Object.create(null)
    };
    const textContentItem = {
      inizializzato: falso,
      str: [],
      Larghezza totale: 0,
      altezza totale: 0,
      larghezza: 0,
      altezza: 0,
      verticale: falso,
      prevTrasforma: null,
      textAdvanceScale: 0,
      spaceInFlowMin: 0,
      spaceInFlowMax: 0,
      trackingSpaceMin: Infinito,
      negativeSpaceMax: -Infinito,
      notASpace: -Infinito,
      trasformare: nullo,
      fontName: null,
      hasEOL: falso
    };
    const twoLastChars = [" ", " "];
    lascia twoLastCharsPos = 0;
    funzione saveLastChar(char) {
      const nextPos = (twoLastCharsPos + 1) % 2;
      const ret = twoLastChars[twoLastCharsPos] !== " " && twoLastChars[nextPos] === " ";
      twoLastChars[twoLastCharsPos] = char;
      twoLastCharsPos = nextPos;
      ritorno ret;
    }
    funzione shouldAddWhitepsace() {
      restituisci dueUltimiCaratteri[PosizioneUltimiCaratteri] !== " " && dueUltimiCaratteri[(PosizioneUltimiCaratteri + 1) % 2] === " ";
    }
    funzione resetLastChars() {
      dueUltimiCaratteri[0] = dueUltimiCaratteri[1] = " ";
      twoLastCharsPos = 0;
    }
    const TRACKING_SPACE_FACTOR = 0,102;
    const NOT_A_SPACE_FACTOR = 0.03;
    const NEGATIVE_SPACE_FACTOR = -0.2;
    const SPACE_IN_FLOW_MIN_FACTOR = 0,102;
    const SPACE_IN_FLOW_MAX_FACTOR = 0.6;
    const RAPPORTO_SPOSTAMENTO_VERTICALE = 0,25;
    const self = questo;
    const xref = this.xref;
    const showSpacedTextBuffer = [];
    lascia xobjs = null;
    const emptyXObjectCache = new _image_utils.LocalImageCache();
    const emptyGStateCache = new _image_utils.LocalGStateCache();
    const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
    lascia testoStato;
    funzione pushWhitespace({
      larghezza = 0,
      altezza = 0,
      trasformazione = textContentItem.prevTransform,
      fontName = textContentItem.fontName
    }) {
      testoContenuto.elementi.push({
        str: " ",
        dir: "ltr",
        larghezza,
        altezza,
        trasformare,
        NomeFont,
        hasEOL: falso
      });
    }
    funzione getCurrentTextTransform() {
      const font = textState.font;
      const tsm = [textState.fontSize * textState.textHScale, 0, 0, textState.fontSize, 0, textState.textRise];
      se (font.isType3Font && (textState.fontSize <= 1 || font.isCharBBox) && !(0, _util.isArrayEqual)(textState.fontMatrix, _util.FONT_IDENTITY_MATRIX)) {
        const glyphHeight = font.bbox[3] - font.bbox[1];
        se (glyphHeight > 0) {
          tsm[3] *= glyphHeight * textState.fontMatrix[3];
        }
      }
      restituisci _util.Util.transform(textState.ctm, _util.Util.transform(textState.textMatrix, tsm));
    }
    funzione ensureTextContentItem() {
      se (textContentItem.initializzato) {
        restituisci textContentItem;
      }
      costante {
        font,
        Nome caricato
      } = stato del testo;
      se (!seenStyles.has(loadedName)) {
        seenStyles.add(loadedName);
        textContent.styles[loadedName] = {
          fontFamily: font.fallbackName,
          salita: font.ascent,
          discesa: font.descent,
          verticale: font.vertical
        };
      }
      textContentItem.fontName = loadedName;
      const trm = textContentItem.transform = getCurrentTextTransform();
      se (!font.vertical) {
        textContentItem.width = textContentItem.totalWidth = 0;
        textContentItem.height = textContentItem.totalHeight = Math.hypot(trm[2], trm[3]);
        textContentItem.vertical = false;
      } altro {
        textContentItem.width = textContentItem.totalWidth = Math.hypot(trm[0], trm[1]);
        textContentItem.height = textContentItem.totalHeight = 0;
        textContentItem.vertical = true;
      }
      const scaleLineX = Math.hypot(textState.textLineMatrix[0], textState.textLineMatrix[1]);
      const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
      textContentItem.textAdvanceScale = scaleCtmX * scaleLineX;
      costante {
        dimensione del carattere
      } = stato del testo;
      textContentItem.trackingSpaceMin = fontSize * TRACKING_SPACE_FACTOR;
      textContentItem.notASpace = fontSize * NOT_A_SPACE_FACTOR;
      textContentItem.negativeSpaceMax = fontSize * NEGATIVE_SPACE_FACTOR;
      textContentItem.spaceInFlowMin = fontSize * SPACE_IN_FLOW_MIN_FACTOR;
      textContentItem.spaceInFlowMax = fontSize * SPACE_IN_FLOW_MAX_FACTOR;
      textContentItem.hasEOL = falso;
      textContentItem.initialized = true;
      restituisci textContentItem;
    }
    funzione updateAdvanceScale() {
      se (!textContentItem.initialized) {
        ritorno;
      }
      const scaleLineX = Math.hypot(textState.textLineMatrix[0], textState.textLineMatrix[1]);
      const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
      const scaleFactor = scaleCtmX * scaleLineX;
      if (scaleFactor === textContentItem.textAdvanceScale) {
        ritorno;
      }
      se (!textContentItem.vertical) {
        textContentItem.totalWidth += textContentItem.width * textContentItem.textAdvanceScale;
        textContentItem.width = 0;
      } altro {
        textContentItem.totalHeight += textContentItem.height * textContentItem.textAdvanceScale;
        textContentItem.height = 0;
      }
      textContentItem.textAdvanceScale = scaleFactor;
    }
    funzione runBidiTransform(textChunk) {
      lascia testo = textChunk.str.join("");
      se (!disableNormalization) {
        testo = (0, _util.normalizeUnicode)(testo);
      }
      const bidiResult = (0, _bidi.bidi)(testo, -1, textChunk.vertical);
      ritorno {
        str: bidiResult.str,
        dir: bidiResult.dir,
        larghezza: Math.abs(textChunk.totalWidth),
        altezza: Math.abs(textChunk.totalHeight),
        trasforma: textChunk.transform,
        fontName: textChunk.fontName,
        hasEOL: textChunk.hasEOL
      };
    }
    funzione handleSetFont(fontName, fontRef) {
      restituisci self.loadFont(fontName, fontRef, resources).then(function (tradotto) {
        se (!tradotto.font.isType3Font) {
          ritorno tradotto;
        }
        restituisci tradotto.loadType3Data(self, risorse, attività).catch(funzione () {}).then(funzione () {
          ritorno tradotto;
        });
      }).then(funzione (tradotta) {
        textState.loadedName = translated.loadedName;
        textState.font = translated.font;
        textState.fontMatrix = translated.font.fontMatrix || _util.FONT_IDENTITY_MATRIX;
      });
    }
    funzione applyInverseRotation(x, y, matrice) {
      scala costante = Math.hypot(matrice[0], matrice[1]);
      ritorna [(matrice[0] * x + matrice[1] * y) / scala, (matrice[2] * x + matrice[3] * y) / scala];
    }
    funzione compareWithLastPosition(glyphWidth) {
      const currentTransform = getCurrentTextTransform();
      lascia posX = currentTransform[4];
      lascia posY = currentTransform[5];
      se (textState.font?.vertical) {
        se (posX < viewBox[0] || posX > viewBox[2] || posY + glyphWidth < viewBox[1] || posY > viewBox[3]) {
          restituisci falso;
        }
      } altrimenti se (posX + glyphWidth < viewBox[0] || posX > viewBox[2] || posY < viewBox[1] || posY > viewBox[3]) {
        restituisci falso;
      }
      if (!textState.font || !textContentItem.prevTransform) {
        restituisci vero;
      }
      let lastPosX = textContentItem.prevTransform[4];
      let lastPosY = textContentItem.prevTransform[5];
      if (lastPosX === posX && lastPosY === posY) {
        restituisci vero;
      }
      lascia ruotare = -1;
      se (trasformazionecorrente[0] e trasformazionecorrente[1] === 0 e trasformazionecorrente[2] === 0) {
        ruota = currentTransform[0] > 0 ? 0 : 180;
      } altrimenti se (trasformazionecorrente[1] e trasformazionecorrente[0] === 0 e trasformazionecorrente[3] === 0) {
        ruota = currentTransform[1] > 0 ? 90 : 270;
      }
      cambiare (ruotare) {
        caso 0:
          rottura;
        caso 90:
          [posX, posY] = [posY, posX];
          [ultimaPosX, ultimaPosY] = [ultimaPosY, ultimaPosX];
          rottura;
        caso 180:
          [posX, posY, lastPosX, lastPosY] = [-posX, -posY, -lastPosX, -lastPosY];
          rottura;
        caso 270:
          [posX, posY] = [-posY, -posX];
          [ultimaPosX, ultimaPosY] = [-ultimaPosY, -ultimaPosX];
          rottura;
        predefinito:
          [posX, posY] = applyInverseRotation(posX, posY, currentTransform);
          [lastPosX, lastPosY] = applyInverseRotation(lastPosX, lastPosY, textContentItem.prevTransform);
      }
      se (textState.font.vertical) {
        const advanceY = (lastPosY - posY) / textContentItem.textAdvanceScale;
        const advanceX = posX - lastPosX;
        const textOrientation = Math.sign(textContentItem.height);
        se (advanceY < textOrientation * textContentItem.negativeSpaceMax) {
          se (Math.abs(advanceX) > 0,5 * textContentItem.width) {
            appendEOL();
            restituisci vero;
          }
          resetLastChars();
          flushTextContentItem();
          restituisci vero;
        }
        se (Math.abs(advanceX) > textContentItem.width) {
          appendEOL();
          restituisci vero;
        }
        se (advanceY <= textOrientation * textContentItem.notASpace) {
          resetLastChars();
        }
        se (advanceY <= textOrientation * textContentItem.trackingSpaceMin) {
          se (dovrebbeAggiungerePsaceBianco()) {
            resetLastChars();
            flushTextContentItem();
            pushWhitespace({
              altezza: Math.abs(advanceY)
            });
          } altro {
            textContentItem.height += advanceY;
          }
        } altrimenti se (!addFakeSpaces(advanceY, textContentItem.prevTransform, textOrientation)) {
          se (textContentItem.str.length === 0) {
            resetLastChars();
            pushWhitespace({
              altezza: Math.abs(advanceY)
            });
          } altro {
            textContentItem.height += advanceY;
          }
        }
        se (Math.abs(advanceX) > textContentItem.width * VERTICAL_SHIFT_RATIO) {
          flushTextContentItem();
        }
        restituisci vero;
      }
      const advanceX = (posX - lastPosX) / textContentItem.textAdvanceScale;
      const anticipoY = posY - lastPosY;
      const textOrientation = Math.sign(textContentItem.width);
      se (advanceX < textOrientation * textContentItem.negativeSpaceMax) {
        se (Math.abs(advanceY) > 0,5 * textContentItem.height) {
          appendEOL();
          restituisci vero;
        }
        resetLastChars();
        flushTextContentItem();
        restituisci vero;
      }
      se (Math.abs(advanceY) > textContentItem.height) {
        appendEOL();
        restituisci vero;
      }
      se (advanceX <= textOrientation * textContentItem.notASpace) {
        resetLastChars();
      }
      se (advanceX <= textOrientation * textContentItem.trackingSpaceMin) {
        se (dovrebbeAggiungerePsaceBianco()) {
          resetLastChars();
          flushTextContentItem();
          pushWhitespace({
            larghezza: Math.abs(advanceX)
          });
        } altro {
          textContentItem.width += advanceX;
        }
      } altrimenti se (!addFakeSpaces(advanceX, textContentItem.prevTransform, textOrientation)) {
        se (textContentItem.str.length === 0) {
          resetLastChars();
          pushWhitespace({
            larghezza: Math.abs(advanceX)
          });
        } altro {
          textContentItem.width += advanceX;
        }
      }
      se (Math.abs(advanceY) > textContentItem.height * VERTICAL_SHIFT_RATIO) {
        flushTextContentItem();
      }
      restituisci vero;
    }
    funzione buildTextContentItem({
      caratteri,
      extraSpacing
    }) {
      const font = textState.font;
      se (!caratteri) {
        const charSpacing = textState.charSpacing + extraSpacing;
        se (spaziatura caratteri) {
          se (!font.vertical) {
            textState.translateTextMatrix(charSpacing * textState.textHScale, 0);
          } altro {
            textState.translateTextMatrix(0, -charSpacing);
          }
        }
        ritorno;
      }
      const glifi = font.charsToGlyphs(caratteri);
      const scale = textState.fontMatrix[0] * textState.fontSize;
      per (lascia che i = 0, ii = glyphs.length; i < ii; i++) {
        const glyph = glyphs[i];
        costante {
          categoria
        } = glifo;
        se (categoria.isInvisibleFormatMark) {
          continuare;
        }
        lascia charSpacing = textState.charSpacing + (i + 1 === ii ? extraSpacing : 0);
        lascia glyphWidth = glyph.width;
        se (font.vertical) {
          Larghezza del glifo = glifo.vmetric ? glifo.vmetric[0] : -larghezza del glifo;
        }
        lascia scaledDim = glyphWidth * scala;
        se (categoria.èSpazio) {
          se (!font.vertical) {
            charSpacing += scaledDim + textState.wordSpacing;
            textState.translateTextMatrix(charSpacing * textState.textHScale, 0);
          } altro {
            charSpacing += -scaledDim + textState.wordSpacing;
            textState.translateTextMatrix(0, -charSpacing);
          }
          salvaUltimoCarattere(" ");
          continuare;
        }
        se (!category.isZeroWidthDiacritic && !compareWithLastPosition(scaledDim)) {
          se (!font.vertical) {
            textState.translateTextMatrix(scaledDim * textState.textHScale, 0);
          } altro {
            textState.translateTextMatrix(0, scaledDim);
          }
          continuare;
        }
        const textChunk = ensureTextContentItem();
        se (categoria.èZeroWidthDiacritico) {
          scalataDim = 0;
        }
        se (!font.vertical) {
          scaledDim *= textState.textHScale;
          textState.translateTextMatrix(scaledDim, 0);
          textChunk.width += scaledDim;
        } altro {
          textState.translateTextMatrix(0, scaledDim);
          scalataDim = Math.abs(scalataDim);
          textChunk.height += scaledDim;
        }
        se (dimensionescalata) {
          textChunk.prevTransform = getCurrentTextTransform();
        }
        const glyphUnicode = glyph.unicode;
        se (saveLastChar(glyphUnicode)) {
          textChunk.str.push(" ");
        }
        textChunk.str.push(glyphUnicode);
        se (spaziatura caratteri) {
          se (!font.vertical) {
            textState.translateTextMatrix(charSpacing * textState.textHScale, 0);
          } altro {
            textState.translateTextMatrix(0, -charSpacing);
          }
        }
      }
    }
    funzione appendEOL() {
      resetLastChars();
      se (textContentItem.initializzato) {
        textContentItem.hasEOL = vero;
        flushTextContentItem();
      } altro {
        testoContenuto.elementi.push({
          str: "",
          dir: "ltr",
          larghezza: 0,
          altezza: 0,
          trasforma: getCurrentTextTransform(),
          fontName: textState.loadedName,
          hasEOL: vero
        });
      }
    }
    funzione addFakeSpaces(larghezza, transf, textOrientation) {
      se (textOrientation * textContentItem.spaceInFlowMin <= larghezza e larghezza <= textOrientation * textContentItem.spaceInFlowMax) {
        se (textContentItem.initializzato) {
          resetLastChars();
          textContentItem.str.push(" ");
        }
        restituisci falso;
      }
      const fontName = textContentItem.fontName;
      lascia altezza = 0;
      se (textContentItem.vertical) {
        altezza = larghezza;
        larghezza = 0;
      }
      flushTextContentItem();
      resetLastChars();
      pushWhitespace({
        larghezza: Math.abs(larghezza),
        altezza: Math.abs(altezza),
        trasformazione: trasf || getCurrentTextTransform(),
        NomeFont
      });
      restituisci vero;
    }
    funzione flushTextContentItem() {
      se (!textContentItem.inizializzato || !textContentItem.str) {
        ritorno;
      }
      se (!textContentItem.vertical) {
        textContentItem.totalWidth += textContentItem.width * textContentItem.textAdvanceScale;
      } altro {
        textContentItem.totalHeight += textContentItem.height * textContentItem.textAdvanceScale;
      }
      textContent.items.push(runBidiTransform(textContentItem));
      textContentItem.initialized = false;
      textContentItem.str.length = 0;
    }
    funzione enqueueChunk(batch = false) {
      lunghezza costante = lunghezza del contenuto del testo.elementi;
      se (lunghezza === 0) {
        ritorno;
      }
      se (batch && lunghezza < TEXT_CHUNK_BATCH_SIZE) {
        ritorno;
      }
      sink.enqueue(textContent, lunghezza);
      textContent.items = [];
      textContent.styles = Object.create(null);
    }
    const timeSlotManager = new TimeSlotManager();
    restituisci nuova Promessa(funzione promiseBody(risolvi, rifiuta) {
      const next = funzione (promessa) {
        enqueueChunk(true);
        Promessa.tutto([promessa, lavandino.pronto]).quindi(funzione () {
          Tentativo {
            promiseBody(risolvi, rifiuta);
          } catturare (es.) {
            rifiutare(es.);
          }
        }, rifiutare);
      };
      task.ensureNotTerminated();
      timeSlotManager.reset();
      operazione costante = {};
      lasciamo fermarci,
        argomenti = [];
      mentre (!(stop = timeSlotManager.check())) {
        lunghezza argomenti = 0;
        operazione.args = args;
        se (!preprocessor.read(operazione)) {
          rottura;
        }
        const previousState = textState;
        textState = stateManager.stato;
        const fn = operazione.fn;
        argomenti = operazione.args;
        interruttore (fn | 0) {
          caso _util.OPS.setFont:
            var fontNameArg = args[0].nome,
              fontSizeArg = argomenti[1];
            se (textState.font && fontNameArg === textState.fontName && fontSizeArg === textState.fontSize) {
              rottura;
            }
            flushTextContentItem();
            textState.fontName = fontNameArg;
            textState.fontSize = fontSizeArg;
            next(handleSetFont(fontNameArg, null));
            ritorno;
          caso _util.OPS.setTextRise:
            textState.textRise = args[0];
            rottura;
          caso _util.OPS.setHScale:
            textState.textHScale = args[0] / 100;
            rottura;
          caso _util.OPS.setLeading:
            textState.leading = args[0];
            rottura;
          caso _util.OPS.moveText:
            textState.translateTextLineMatrix(args[0], args[1]);
            textState.textMatrix = textState.textLineMatrix.slice();
            rottura;
          caso _util.OPS.setLeadingMoveText:
            textState.leading = -args[1];
            textState.translateTextLineMatrix(args[0], args[1]);
            textState.textMatrix = textState.textLineMatrix.slice();
            rottura;
          caso _util.OPS.nextLine:
            textState.carriageReturn();
            rottura;
          caso _util.OPS.setTextMatrix:
            textState.setTextMatrix(argomenti[0], argomenti[1], argomenti[2], argomenti[3], argomenti[4], argomenti[5]);
            textState.setTextLineMatrix(argomenti[0], argomenti[1], argomenti[2], argomenti[3], argomenti[4], argomenti[5]);
            aggiornaAdvanceScale();
            rottura;
          caso _util.OPS.setCharSpacing:
            textState.charSpacing = args[0];
            rottura;
          caso _util.OPS.setWordSpacing:
            textState.wordSpacing = args[0];
            rottura;
          caso _util.OPS.beginText:
            textState.textMatrix = _util.IDENTITY_MATRIX.slice();
            textState.textLineMatrix = _util.IDENTITY_MATRIX.slice();
            rottura;
          caso _util.OPS.showSpacedText:
            se (!stateManager.state.font) {
              self.ensureStateFont(stateManager.state);
              continuare;
            }
            const spaceFactor = (textState.font.vertical ? 1 : -1) * textState.fontSize / 1000;
            elementi costanti = argomenti[0];
            per (lascia che i = 0, ii = elementi.lunghezza; i < ii; i++) {
              const elemento = elementi[i];
              se (tipo di elemento === "stringa") {
                showSpacedTextBuffer.push(elemento);
              } else if (typeof item === "number" && item !== 0) {
                const str = showSpacedTextBuffer.join("");
                mostraSpacedTextBuffer.length = 0;
                buildTextContentItem({
                  caratteri: str,
                  extraSpacing: elemento * spaceFactor
                });
              }
            }
            se (mostraSpacedTextBuffer.length > 0) {
              const str = showSpacedTextBuffer.join("");
              mostraSpacedTextBuffer.length = 0;
              buildTextContentItem({
                caratteri: str,
                Spaziatura extra: 0
              });
            }
            rottura;
          caso _util.OPS.showText:
            se (!stateManager.state.font) {
              self.ensureStateFont(stateManager.state);
              continuare;
            }
            buildTextContentItem({
              caratteri: argomenti[0],
              Spaziatura extra: 0
            });
            rottura;
          caso _util.OPS.nextLineShowText:
            se (!stateManager.state.font) {
              self.ensureStateFont(stateManager.state);
              continuare;
            }
            textState.carriageReturn();
            buildTextContentItem({
              caratteri: argomenti[0],
              Spaziatura extra: 0
            });
            rottura;
          caso _util.OPS.nextLineSetSpacingShowText:
            se (!stateManager.state.font) {
              self.ensureStateFont(stateManager.state);
              continuare;
            }
            textState.wordSpacing = args[0];
            textState.charSpacing = args[1];
            textState.carriageReturn();
            buildTextContentItem({
              caratteri: argomenti[2],
              Spaziatura extra: 0
            });
            rottura;
          caso _util.OPS.paintXObject:
            flushTextContentItem();
            se (!xobjs) {
              xobjs = resources.get("XObject") || _primitives.Dict.empty;
            }
            var isValidName = args[0] istanza di _primitives.Name;
            var nome = args[0].name;
            se (isValidName && emptyXObjectCache.getByName(nome)) {
              rottura;
            }
            next(new Promise(function (resolveXObject, rejectXObject) {
              se (!isValidName) {
                throw new _util.FormatError("È necessario fare riferimento a XObject tramite il nome.");
              }
              lascia xobj = xobjs.getRaw(nome);
              se (xobj instanceof _primitives.Ref) {
                se (emptyXObjectCache.getByRef(xobj)) {
                  resolveXObject();
                  ritorno;
                }
                const globalImage = self.globalImageCache.getData(xobj, self.pageIndex);
                se (immagineglobale) {
                  resolveXObject();
                  ritorno;
                }
                xobj = xref.fetch(xobj);
              }
              se (!(xobj instanceof _base_stream.BaseStream)) {
                throw new _util.FormatError("XObject dovrebbe essere un flusso");
              }
              const type = xobj.dict.get("Sottotipo");
              se (!(tipo instanceof _primitives.Name)) {
                throw new _util.FormatError("XObject dovrebbe avere un sottotipo Name");
              }
              se (tipo.nome !== "Form") {
                emptyXObjectCache.set(nome, xobj.dict.objId, true);
                resolveXObject();
                ritorno;
              }
              const currentState = stateManager.state.clone();
              const xObjStateManager = new StateManager(currentState);
              matrice costante = xobj.dict.getArray("Matrice");
              se (Array.isArray(matrice) && lunghezza matrice === 6) {
                xObjStateManager.transform(matrice);
              }
              accodaChunk();
              const sinkWrapper = {
                enqueueInvoked: false,
                accoda(pezzo, dimensione) {
                  this.enqueueInvoked = true;
                  sink.enqueue(pezzo, dimensione);
                },
                ottieni la dimensione desiderata() {
                  restituisci sink.desiredSize;
                },
                preparati() {
                  restituisci sink.ready;
                }
              };
              self.getTextContent({
                flusso: xobj,
                compito,
                risorse: xobj.dict.get("Risorse") || risorse,
                stateManager: xObjStateManager,
                includeMarkedContent,
                lavandino: sinkWrapper,
                Stili visti,
                viewBox,
                markedContentData,
                Disabilita la normalizzazione
              }).then(funzione () {
                se (!sinkWrapper.enqueueInvoked) {
                  emptyXObjectCache.set(nome, xobj.dict.objId, true);
                }
                resolveXObject();
              }, rifiutaXObject);
            }).catch(funzione (motivo) {
              se (motivo instanceof _util.AbortException) {
                ritorno;
              }
              se (self.options.ignoreErrors) {
                (0, _util.warn)(`getTextContent - ignorando XObject: "${reason}".`);
                ritorno;
              }
              gettare la ragione;
            }));
            ritorno;
          caso _util.OPS.setGState:
            isValidName = args[0] instanceof _primitives.Name;
            nome = argomenti[0].nome;
            se (isValidName && emptyGStateCache.getByName(nome)) {
              rottura;
            }
            next(new Promise(function (resolveGState, rejectGState) {
              se (!isValidName) {
                throw new _util.FormatError("È necessario fare riferimento a GState tramite il nome.");
              }
              const extGState = resources.get("ExtGState");
              se (!(extGState instanceof _primitives.Dict)) {
                throw new _util.FormatError("ExtGState dovrebbe essere un dizionario.");
              }
              const gState = extGState.get(nome);
              se (!(gState instanceof _primitives.Dict)) {
                throw new _util.FormatError("GState dovrebbe essere un dizionario.");
              }
              const gStateFont = gState.get("Carattere");
              se (!gStateFont) {
                emptyGStateCache.set(nome, gState.objId, vero);
                resolveGState();
                ritorno;
              }
              flushTextContentItem();
              textState.fontName = null;
              textState.fontSize = gStateFont[1];
              handleSetFont(null, gStateFont[0]).then(resolveGState, rejectGState);
            }).catch(funzione (motivo) {
              se (motivo instanceof _util.AbortException) {
                ritorno;
              }
              se (self.options.ignoreErrors) {
                (0, _util.warn)(`getTextContent - ignorando ExtGState: "${reason}".`);
                ritorno;
              }
              gettare la ragione;
            }));
            ritorno;
          caso _util.OPS.beginMarkedContent:
            flushTextContentItem();
            se (includeMarkedContent) {
              markedContentData.level++;
              testoContenuto.elementi.push({
                tipo: "beginMarkedContent",
                tag: args[0] instanceof _primitives.Name ? args[0].name : null
              });
            }
            rottura;
          caso _util.OPS.beginMarkedContentProps:
            flushTextContentItem();
            se (includeMarkedContent) {
              markedContentData.level++;
              lascia mcid = null;
              se (args[1] instanceof _primitives.Dict) {
                mcid = args[1].get("MCID");
              }
              testoContenuto.elementi.push({
                tipo: "beginMarkedContentProps",
                id: Number.isInteger(mcid) ? `${self.idFactory.getPageObjId()}_mc${mcid}` : null,
                tag: args[0] instanceof _primitives.Name ? args[0].name : null
              });
            }
            rottura;
          caso _util.OPS.endMarkedContent:
            flushTextContentItem();
            se (includeMarkedContent) {
              se (markedContentData.level === 0) {
                rottura;
              }
              markedContentData.level--;
              testoContenuto.elementi.push({
                tipo: "endMarkedContent"
              });
            }
            rottura;
          caso _util.OPS.restore:
            se (statoprecedente && (statoprecedente.font !== statotesto.font || statoprecedente.dimensionefont !== statotesto.dimensionefont || statoprecedente.nomefont !== statotesto.nomefont)) {
              flushTextContentItem();
            }
            rottura;
        }
        se (textContent.items.length >= sink.desiredSize) {
          stop = vero;
          rottura;
        }
      }
      se (fermati) {
        successivo(differito);
        ritorno;
      }
      flushTextContentItem();
      accodaChunk();
      risolvere();
    }).catch(motivo => {
      se (motivo instanceof _util.AbortException) {
        ritorno;
      }
      se (this.options.ignoreErrors) {
        (0, _util.warn)(`getTextContent - ignora gli errori durante "${task.name}" ` + `task: "${reason}".`);
        flushTextContentItem();
        accodaChunk();
        ritorno;
      }
      gettare la ragione;
    });
  }
  extractDataStructures(dict, baseDict, proprietà) {
    const xref = this.xref;
    lascia cidToGidBytes;
    const toUnicodePromise = this.readToUnicode(properties.toUnicode || dict.get("ToUnicode") || baseDict.get("ToUnicode"));
    se (proprietà.composito) {
      const cidSystemInfo = dict.get("CIDSystemInfo");
      se (cidSystemInfo instanceof _primitives.Dict) {
        proprietà.cidSystemInfo = {
          registro: (0, _util.stringToPDFString)(cidSystemInfo.get("Registro")),
          ordinamento: (0, _util.stringToPDFString)(cidSystemInfo.get("Ordinamento")),
          supplemento: cidSystemInfo.get("Supplemento")
        };
      }
      Tentativo {
        const cidToGidMap = dict.get("CIDToGIDMap");
        se (cidToGidMap instanceof _base_stream.BaseStream) {
          cidToGidBytes = cidToGidMap.getBytes();
        }
      } catturare (es.) {
        se (!this.options.ignoreErrors) {
          lanciare ex;
        }
        (0, _util.warn)(`extractDataStructures - ignorando i dati CIDToGIDMap: "${ex}".`);
      }
    }
    differenze costanti = [];
    lascia baseEncodingName = null;
    lascia codifica;
    se (dict.has("Codifica")) {
      codifica = dict.get("Codifica");
      se (codifica instanceof _primitives.Dict) {
        baseEncodingName = encoding.get("BaseEncoding");
        baseEncodingName = baseEncodingName instanceof _primitives.Name ? baseEncodingName.name : null;
        se (encoding.has("Differenze")) {
          const diffEncoding = encoding.get("Differenze");
          lascia indice = 0;
          per (voce costante di diffEncoding) {
            dati costanti = xref.fetchIfRef(voce);
            se (tipo di dati === "numero") {
              indice = dati;
            } altrimenti se (istanza di dati _primitives.Name) {
              differenze[indice++] = dati.nome;
            } altro {
              throw new _util.FormatError(`Voce non valida nell'array 'Differenze': ${data}`);
            }
          }
        }
      } altrimenti se (codifica instanceof _primitives.Name) {
        baseEncodingName = codifica.nome;
      } altro {
        const msg = "La codifica non è un nome né un dizionario";
        se (!this.options.ignoreErrors) {
          lancia nuovo _util.FormatError(msg);
        }
        (0, _util.warn)(msg);
      }
      se (baseEncodingName !== "MacRomanEncoding" && baseEncodingName !== "MacExpertEncoding" && baseEncodingName !== "WinAnsiEncoding") {
        baseEncodingName = null;
      }
    }
    const nonEmbeddedFont = !properties.file || properties.isInternalFont,
      isSymbolsFontName = (0, _standard_fonts.getSymbolsFonts)()[properties.name];
    se (baseEncodingName && nonEmbeddedFont && isSymbolsFontName) {
      baseEncodingName = null;
    }
    se (baseEncodingName) {
      proprietà.defaultEncoding = (0, _encodings.getEncoding)(baseEncodingName);
    } altro {
      const isSymbolicFont = !!(properties.flags & _fonts_utils.FontFlags.Symbolic);
      const isNonsymbolicFont = !!(properties.flags & _fonts_utils.FontFlags.Nonsymbolic);
      codifica = _encodings.StandardEncoding;
      se (properties.type === "TrueType" && !isNonsymbolicFont) {
        codifica = _encodings.WinAnsiEncoding;
      }
      se (isSymbolicFont || isSymbolsFontName) {
        codifica = _encodings.MacRomanEncoding;
        se (nonEmbeddedFont) {
          se (/Symbol/i.test(nome.proprietà)) {
            codifica = _encodings.SymbolSetEncoding;
          } altrimenti se (/Dingbats/i.test(nome.proprietà)) {
            codifica = _encodings.ZapfDingbatsEncoding;
          } altrimenti se (/Wingdings/i.test(nome.proprietà)) {
            codifica = _encodings.WinAnsiEncoding;
          }
        }
      }
      properties.defaultEncoding = codifica;
    }
    proprietà.differenze = differenze;
    proprietà.baseEncodingName = baseEncodingName;
    properties.hasEncoding = !!baseEncodingName || differences.length > 0;
    proprietà.dict = dict;
    ritorna aUnicodePromise.then(readToUnicode => {
      proprietà.toUnicode = readToUnicode;
      restituisci this.buildToUnicode(proprietà);
    }).then(builtToUnicode => {
      proprietà.toUnicode = builtToUnicode;
      se (cidToGidBytes) {
        proprietà.cidToGidMap = this.readCidToGidMap(cidToGidBytes, builtToUnicode);
      }
      restituire proprietà;
    });
  }
  _simpleFontToUnicode(proprietà, forceGlyphs = false) {
    (0, _util.assert)(!properties.composite, "Deve essere un font semplice.");
    const toUnicode = [];
    codifica costante = proprietà.defaultEncoding.slice();
    const baseEncodingName = proprietà.baseEncodingName;
    differenze costanti = proprietà.differenze;
    per (codice carattere costante nelle differenze) {
      const glyphName = differences[charcode];
      se (glyphName === ".notdef") {
        continuare;
      }
      encoding[charcode] = glyphName;
    }
    const glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
    per (codice carattere costante nella codifica) {
      lascia glyphName = encoding[charcode];
      se (glifoName === "") {
        continuare;
      }
      lascia unicode = glyphsUnicodeMap[glyphName];
      se (unicode !== indefinito) {
        toUnicode[charcode] = String.fromCharCode(unicode);
        continuare;
      }
      lascia codice = 0;
      switch (glyphName[0]) {
        caso "G":
          se (glyphName.length === 3) {
            codice = parseInt(glyphName.substring(1), 16);
          }
          rottura;
        caso "g":
          se (glyphName.length === 5) {
            codice = parseInt(glyphName.substring(1), 16);
          }
          rottura;
        caso "C":
        caso "c":
          se (glyphName.length >= 3 && glyphName.length <= 4) {
            const codeStr = glyphName.substring(1);
            se (forceGlyphs) {
              codice = parseInt(codeStr, 16);
              rottura;
            }
            codice = +codiceStr;
            se (Numero.isNaN(codice) && Numero.isInteger(parseInt(codiceStr, 16))) {
              restituisci questo._simpleFontToUnicode(proprietà, vero);
            }
          }
          rottura;
        caso "u":
          unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap);
          se (unicode !== -1) {
            codice = unicode;
          }
          rottura;
        predefinito:
          switch (glyphName) {
            caso "f_h":
            caso "f_t":
            caso "T_h":
              toUnicode[charcode] = glyphName.replaceAll("_", "");
              continuare;
          }
          rottura;
      }
      se (codice > 0 e codice <= 0x10ffff e Number.isInteger(codice)) {
        se (baseEncodingName && codice === +charcode) {
          const baseEncoding = (0, _encodings.getEncoding)(baseEncodingName);
          se (baseEncoding && (glyphName = baseEncoding[charcode])) {
            toUnicode[charcode] = String.fromCharCode(glyphsUnicodeMap[glyphName]);
            continuare;
          }
        }
        toUnicode[charcode] = String.fromCodePoint(codice);
      }
    }
    torna aUnicode;
  }
  async buildToUnicode(proprietà) {
    proprietà.hasIncludedToUnicodeMap = proprietà.toUnicode?.length > 0;
    se (properties.hasIncludedToUnicodeMap) {
      se (!properties.composite && properties.hasEncoding) {
        proprietà.fallbackToUnicode = this._simpleFontToUnicode(proprietà);
      }
      restituisci proprietà.inUnicode;
    }
    se (!proprietà.composito) {
      restituisci nuovo _to_unicode_map.ToUnicodeMap(this._simpleFontToUnicode(properties));
    }
    if (properties.composite && (properties.cMap.builtInCMap && !(properties.cMap instanceof _cmap.IdentityCMap) || properties.cidSystemInfo.registry === "Adobe" && (properties.cidSystemInfo.ordering === "GB1" || properties.cidSystemInfo.ordering === "CNS1" || properties.cidSystemInfo.ordering === "Giappone1" || properties.cidSystemInfo.ordering === "Corea1"))) {
      costante {
        registro,
        ordinazione
      } = proprietà.cidSystemInfo;
      const ucs2CMapName = _primitives.Name.get(`${registry}-${ordering}-UCS2`);
      const ucs2CMap = await _cmap.CMapFactory.create({
        codifica: ucs2CMapName,
        fetchBuiltInCMap: this._fetchBuiltInCMapBound,
        useCMap: null
      });
      const toUnicode = [],
        buf = [];
      properties.cMap.forEach(funzione (codice carattere, cid) {
        se (cid > 0xffff) {
          throw new _util.FormatError("La dimensione massima del CID è 65.535");
        }
        const ucs2 = ucs2CMap.lookup(cid);
        se (ucs2) {
          lunghezza buf = 0;
          per (lascia che i = 0, ii = ucs2.length; i < ii; i += 2) {
            buf.push((ucs2.charCodeAt(i) << 8) + ucs2.charCodeAt(i + 1));
          }
          toUnicode[charcode] = String.fromCharCode(...buf);
        }
      });
      restituisci nuovo _to_unicode_map.ToUnicodeMap(toUnicode);
    }
    restituisci nuovo _to_unicode_map.IdentityToUnicodeMap(properties.firstChar, properties.lastChar);
  }
  leggi in Unicode (cmapObj) {
    se (!cmapObj) {
      restituisci Promise.resolve(null);
    }
    se (cmapObj instanceof _primitives.Name) {
      restituisci _cmap.CMapFactory.create({
        codifica: cmapObj,
        fetchBuiltInCMap: this._fetchBuiltInCMapBound,
        useCMap: null
      }).then(funzione (cmap) {
        se (istanza di cmap _cmap.IdentityCMap) {
          restituisci nuovo _to_unicode_map.IdentityToUnicodeMap(0, 0xffff);
        }
        restituisci nuovo _to_unicode_map.ToUnicodeMap(cmap.getMap());
      });
    } altrimenti se (cmapObj instanceof _base_stream.BaseStream) {
      restituisci _cmap.CMapFactory.create({
        codifica: cmapObj,
        fetchBuiltInCMap: this._fetchBuiltInCMapBound,
        useCMap: null
      }).then(funzione (cmap) {
        se (istanza di cmap _cmap.IdentityCMap) {
          restituisci nuovo _to_unicode_map.IdentityToUnicodeMap(0, 0xffff);
        }
        const map = new Array(cmap.length);
        cmap.forEach(funzione (charCode, token) {
          se (tipo di token === "numero") {
            mappa[charCode] = String.fromCodePoint(token);
            ritorno;
          }
          costante str = [];
          per (lascia che k = 0; k < lunghezza del token; k += 2) {
            const w1 = token.charCodeAt(k) << 8 | token.charCodeAt(k + 1);
            se ((w1 & 0xf800) !== 0xd800) {
              str.push(w1);
              continuare;
            }
            k += 2;
            const w2 = token.charCodeAt(k) << 8 | token.charCodeAt(k + 1);
            str.push(((w1 & 0x3ff) << 10) + (w2 & 0x3ff) + 0x10000);
          }
          mappa[charCode] = String.fromCodePoint(...str);
        });
        restituisci nuovo _to_unicode_map.ToUnicodeMap(map);
      }, motivo => {
        se (motivo instanceof _util.AbortException) {
          restituisci null;
        }
        se (this.options.ignoreErrors) {
          (0, _util.warn)(`readToUnicode - ignorando i dati ToUnicode: "${reason}".`);
          restituisci null;
        }
        gettare la ragione;
      });
    }
    restituisci Promise.resolve(null);
  }
  readCidToGidMap(glyphsData, toUnicode) {
    risultato costante = [];
    per (lascia che j = 0, jj = glyphsData.length; j < jj; j++) {
      const glyphID = glyphsData[j++] << 8 | glyphsData[j];
      codice costante = j >> 1;
      se (glyphID === 0 && !toUnicode.has(codice)) {
        continuare;
      }
      risultato[codice] = glyphID;
    }
    restituisci il risultato;
  }
  extractWidths(dict, descrittore, proprietà) {
    const xref = this.xref;
    lascia che glyphsWidths = [];
    lascia defaultWidth = 0;
    const glyphsVMetrics = [];
    lascia defaultVMetrics;
    lascia i, ii, j, jj, inizio, codice, larghezze;
    se (proprietà.composito) {
      defaultWidth = dict.has("DW") ? dict.get("DW") : 1000;
      larghezze = dict.get("W");
      se (larghezze) {
        per (i = 0, ii = larghezze.lunghezza; i < ii; i++) {
          inizio = xref.fetchIfRef(larghezze[i++]);
          codice = xref.fetchIfRef(larghezze[i]);
          se (Array.isArray(codice)) {
            per (j = 0, jj = lunghezza del codice; j < jj; j++) {
              glyphsWidths[start++] = xref.fetchIfRef(code[j]);
            }
          } altro {
            const width = xref.fetchIfRef(larghezze[++i]);
            per (j = inizio; j <= codice; j++) {
              glyphsWidths[j] = larghezza;
            }
          }
        }
      }
      se (proprietà.verticale) {
        lascia vmetrics = dict.getArray("DW2") || [880, -1000];
        defaultVMetrics = [vmetrics[1], defaultWidth * 0.5, vmetrics[0]];
        vmetrics = dict.get("W2");
        se (vmetrics) {
          per (i = 0, ii = vmetrics.length; i < ii; i++) {
            inizio = xref.fetchIfRef(vmetrics[i++]);
            codice = xref.fetchIfRef(vmetrics[i]);
            se (Array.isArray(codice)) {
              per (j = 0, jj = lunghezza del codice; j < jj; j++) {
                glifiVMetrics[start++] = [xref.fetchIfRef(codice[j++]), xref.fetchIfRef(codice[j++]), xref.fetchIfRef(codice[j])];
              }
            } altro {
              const vmetric = [xref.fetchIfRef(vmetrics[++i]), xref.fetchIfRef(vmetrics[++i]), xref.fetchIfRef(vmetrics[++i])];
              per (j = inizio; j <= codice; j++) {
                glifiVMetrics[j] = vmetrica;
              }
            }
          }
        }
      }
    } altro {
      const firstChar = proprietà.firstChar;
      larghezze = dict.get("Larghezze");
      se (larghezze) {
        j = primoCarattere;
        per (i = 0, ii = larghezze.lunghezza; i < ii; i++) {
          glifiLarghezze[j++] = xref.fetchIfRef(larghezze[i]);
        }
        defaultWidth = parseFloat(descriptor.get("MissingWidth")) || 0;
      } altro {
        const baseFontName = dict.get("BaseFont");
        se (baseFontName instanceof _primitives.Name) {
          metriche costanti = this.getBaseFontMetrics(baseFontName.name);
          glyphsWidths = this.buildCharCodeToWidth(metrics.widths, properties);
          defaultWidth = metriche.defaultWidth;
        }
      }
    }
    lascia che isMonospace = true;
    lascia primaLarghezza = larghezzapredefinita;
    per (glifo costante in glifiLarghezze) {
      const glyphWidth = glyphsWidths[glyph];
      se (!glifoLarghezza) {
        continuare;
      }
      se (!primaLarghezza) {
        firstWidth = glyphWidth;
        continuare;
      }
      if (firstWidth!== glyphWidth) {
        isMonospace = false;
        rottura;
      }
    }
    se (èMonospace) {
      proprietà.flags |= _fonts_utils.FontFlags.FixedPitch;
    } altro {
      proprietà.flags &= ~_fonts_utils.FontFlags.FixedPitch;
    }
    proprietà.defaultWidth = defaultWidth;
    proprietà.larghezze = glifiLarghezze;
    proprietà.defaultVMetrics = defaultVMetrics;
    proprietà.vmetrics = glifiVMetrics;
  }
  isSerifFont(baseFontName) {
    const fontNameWoStyle = baseFontName.split("-")[0];
    restituisci fontNameWoStyle in (0, _standard_fonts.getSerifFonts)() || /serif/gi.test(fontNameWoStyle);
  }
  getBaseFontMetrics(nome) {
    lascia defaultWidth = 0;
    lascia larghezze = Object.create(null);
    lascia monospazio = falso;
    const stdFontMap = (0, _standard_fonts.getStdFontMap)();
    lascia lookupName = stdFontMap[nome] || nome;
    const Metriche = (0, _metrics.getMetrics)();
    se (!(lookupName in Metriche)) {
      lookupName = this.isSerifFont(name) ? "Times-Roman" : "Helvetica";
    }
    const glyphWidths = Metrics[lookupName];
    se (tipo di glifoLarghezze === "numero") {
      defaultWidth = glyphWidths;
      monospazio = vero;
    } altro {
      larghezze = glyphWidths();
    }
    ritorno {
      Larghezza predefinita,
      monospaziato,
      larghezze
    };
  }
  buildCharCodeToWidth(larghezzePerNomeGlyph, proprietà) {
    const larghezze = Object.create(null);
    differenze costanti = proprietà.differenze;
    codifica costante = proprietà.codificapredefinita;
    per (lascia che charCode = 0; charCode < 256; charCode++) {
      se (charCode in differenze && widthsByGlyphName[differenze[charCode]]) {
        larghezze[codicecarattere] = larghezzePerNomeGlifo[differenze[codicecarattere]];
        continuare;
      }
      se (charCode nella codifica && widthsByGlyphName[encoding[charCode]]) {
        larghezze[codicecarattere] = larghezzePerNomeGlifo[codifica[codicecarattere]];
        continuare;
      }
    }
    larghezze di ritorno;
  }
  preEvaluateFont(dict) {
    const baseDict = dizionario;
    lascia tipo = dict.get("Sottotipo");
    se (!(tipo instanceof _primitives.Name)) {
      throw new _util.FormatError("sottotipo di font non valido");
    }
    lascia composito = falso;
    lascia hash, inUnicode;
    se (tipo.nome === "Tipo0") {
      const df = dict.get("DescendantFonts");
      se (!df) {
        throw new _util.FormatError("I font discendenti non sono specificati");
      }
      dizionario = Array.isArray(df) ? this.xref.fetchIfRef(df[0]) : df;
      se (!(dict instanceof _primitives.Dict)) {
        throw new _util.FormatError("Il font discendente non è un dizionario.");
      }
      tipo = dict.get("Sottotipo");
      se (!(tipo instanceof _primitives.Name)) {
        throw new _util.FormatError("sottotipo di font non valido");
      }
      composito = vero;
    }
    const firstChar = dict.get("FirstChar") || 0,
      lastChar = dict.get("LastChar") || (composito ? 0xffff : 0xff);
    const descrittore = dict.get("FontDescriptor");
    se (descrittore) {
      hash = nuovo _murmurhash.MurmurHash3_64();
      const codifica = baseDict.getRaw("Codifica");
      se (codifica instanceof _primitives.Name) {
        hash.update(codifica.nome);
      } altrimenti se (codifica instanceof _primitives.Ref) {
        hash.update(encoding.toString());
      } altrimenti se (codifica instanceof _primitives.Dict) {
        per (voce costante di encoding.getRawValues()) {
          se (istanza di voce _primitives.Name) {
            hash.update(nome voce);
          } altrimenti se (istanza di voce _primitives.Ref) {
            hash.update(entry.toString());
          } altrimenti se (Array.isArray(voce)) {
            const diffLength = entry.length,
              diffBuf = nuovo Array(diffLength);
            per (lascia che j = 0; j < diffLength; j++) {
              const diffEntry = entry[j];
              se (diffEntry instanceof _primitives.Name) {
                diffBuf[j] = diffEntry.name;
              } else if (typeof diffEntry === "numero" || diffEntry instanceof _primitives.Ref) {
                diffBuf[j] = diffEntry.toString();
              }
            }
            hash.update(diffBuf.join());
          }
        }
      }
      hash.update(`${primoCarattere}-${ultimoCarattere}`);
      toUnicode = dict.get("ToUnicode") || baseDict.get("ToUnicode");
      se (istanza Unicode di _base_stream.BaseStream) {
        const stream = toUnicode.str || toUnicode;
        const uint8array = stream.buffer ? new Uint8Array(stream.buffer.buffer, 0, stream.bufferLength) : new Uint8Array(stream.bytes.buffer, stream.start, stream.end - stream.start);
        hash.update(uint8array);
      } altrimenti se (inUnicode instanceof _primitives.Name) {
        hash.update(toUnicode.name);
      }
      const widths = dict.get("Larghezze") || baseDict.get("Larghezze");
      se (Array.isArray(larghezze)) {
        const widthsBuf = [];
        per (immissione costante di larghezze) {
          se (tipo di voce === "numero" || voce instanceof _primitives.Ref) {
            widthsBuf.push(entry.toString());
          }
        }
        hash.update(larghezzeBuf.join());
      }
      se (composto) {
        hash.update("compositeFont");
        const compositeWidths = dict.get("W") || baseDict.get("W");
        se (Array.isArray(larghezzecomposte)) {
          const widthsBuf = [];
          per (voce costante di compositeWidths) {
            se (tipo di voce === "numero" || voce instanceof _primitives.Ref) {
              widthsBuf.push(entry.toString());
            } altrimenti se (Array.isArray(voce)) {
              const subWidthsBuf = [];
              per (elemento costante della voce) {
                se (tipo di elemento === "numero" || elemento istanza di _primitives.Ref) {
                  subWidthsBuf.push(element.toString());
                }
              }
              larghezzeBuf.push(`[${subWidthsBuf.join()}]`);
            }
          }
          hash.update(larghezzeBuf.join());
        }
        const cidToGidMap = dict.getRaw("CIDToGIDMap") || baseDict.getRaw("CIDToGIDMap");
        se (cidToGidMap instanceof _primitives.Name) {
          hash.update(cidToGidMap.name);
        } altrimenti se (cidToGidMap instanceof _primitives.Ref) {
          hash.update(cidToGidMap.toString());
        } altrimenti se (cidToGidMap instanceof _base_stream.BaseStream) {
          hash.update(cidToGidMap.peekBytes());
        }
      }
    }
    ritorno {
      descrittore,
      dizionario,
      baseDict,
      composito,
      tipo: tipo.nome,
      primoCarnevale,
      ultimoCartone,
      in Unicode,
      hash: hash ? hash.hexdigest() : ""
    };
  }
  traduzione asincronaFont({
    descrittore,
    dizionario,
    baseDict,
    composito,
    tipo,
    primoCarnevale,
    ultimoCartone,
    in Unicode,
    cssFontInfo
  }) {
    const isType3Font = tipo === "Tipo3";
    lasciare proprietà;
    se (!descrittore) {
      se (isType3Font) {
        descrittore = new _primitives.Dict(null);
        descriptor.set("NomeFont", _primitives.Name.get(tipo));
        descrittore.set("FontBBox", dict.getArray("FontBBox") || [0, 0, 0, 0]);
      } altro {
        lascia baseFontName = dict.get("BaseFont");
        se (!(baseFontName instanceof _primitives.Name)) {
          throw new _util.FormatError("Il font di base non è specificato");
        }
        baseFontName = baseFontName.name.replaceAll(/[,_]/g, "-");
        metriche costanti = this.getBaseFontMetrics(baseFontName);
        const fontNameWoStyle = baseFontName.split("-")[0];
        const flags = (this.isSerifFont(fontNameWoStyle) ? _fonts_utils.FontFlags.Serif : 0) | (metrics.monospace ? _fonts_utils.FontFlags.FixedPitch : 0) | ((0, _standard_fonts.getSymbolsFonts)()[fontNameWoStyle] ? _fonts_utils.FontFlags.Symbolic : _fonts_utils.FontFlags.Nonsymbolic);
        proprietà = {
          tipo,
          nome: baseFontName,
          Nome caricato: baseDict.Nome caricato,
          systemFontInfo: null,
          larghezze: metriche.larghezze,
          defaultWidth: metriche.defaultWidth,
          isSimulatedFlags: vero,
          bandiere,
          primoCarnevale,
          ultimoCartone,
          in Unicode,
          xAltezza: 0,
          altezza del cappuccio: 0,
          Angolo corsivo: 0,
          isType3Font
        };
        const widths = dict.get("Larghezze");
        const standardFontName = (0, _standard_fonts.getStandardFontName)(baseFontName);
        lascia file = null;
        se (nomeCaratterestandard) {
          file = attendi questo.fetchStandardFontData(standardFontName);
          proprietà.isInternalFont = !!file;
        }
        se (!properties.isInternalFont && this.options.useSystemFonts) {
          properties.systemFontInfo = (0, _font_substitutions.getFontSubstitution)(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, baseFontName, standardFontName);
        }
        restituisci this.extractDataStructures(dict, dict, properties).then(newProperties => {
          se (larghezze) {
            const glyphWidths = [];
            lascia j = primoCarattere;
            per (const larghezza delle larghezze) {
              glyphWidths[j++] = this.xref.fetchIfRef(larghezza);
            }
            newProperties.widths = glyphWidths;
          } altro {
            newProperties.widths = this.buildCharCodeToWidth(metrics.widths, newProperties);
          }
          restituisci nuovi _fonts.Font(baseFontName, file, newProperties);
        });
      }
    }
    lascia fontName = descriptor.get("FontName");
    lascia baseFont = dict.get("BaseFont");
    se (tipo di fontName === "stringa") {
      fontName = _primitives.Name.get(fontName);
    }
    se (tipo di baseFont === "stringa") {
      baseFont = _primitives.Name.get(baseFont);
    }
    const fontNameStr = fontName?.name;
    const baseFontStr = baseFont?.name;
    se (!isType3Font && fontNameStr !== baseFontStr) {
      (0, _util.info)(`Il FontName del FontDescriptor è "${fontNameStr}" ma ` + `dovrebbe essere lo stesso del BaseFont del Font "${baseFontStr}".`);
      se (fontNameStr && baseFontStr && (baseFontStr.startsWith(fontNameStr) || !(0, _standard_fonts.isKnownFontName)(fontNameStr) && (0, _standard_fonts.isKnownFontName)(baseFontStr))) {
        fontName = null;
      }
    }
    fontName ||= baseFont;
    se (!(fontName instanceof _primitives.Name)) {
      throw new _util.FormatError("nome del font non valido");
    }
    lascia fontFile, sottotipo, lunghezza1, lunghezza2, lunghezza3;
    Tentativo {
      fontFile = descriptor.get("FontFile", "FontFile2", "FontFile3");
    } catturare (es.) {
      se (!this.options.ignoreErrors) {
        lanciare ex;
      }
      (0, _util.warn)(`translateFont - recupero del file del font "${fontName.name}": "${ex}".`);
      fontFile = new _stream.NullStream();
    }
    lascia che isInternalFont = false;
    lascia glyphScaleFactors = null;
    lascia systemFontInfo = null;
    se (filecarattere) {
      se (fontFile.dict) {
        const subtypeEntry = fontFile.dict.get("Sottotipo");
        se (subtypeEntry instanceof _primitives.Name) {
          sottotipo = sottotipoEntry.name;
        }
        lunghezza1 = fontFile.dict.get("Lunghezza1");
        lunghezza2 = fontFile.dict.get("Lunghezza2");
        lunghezza3 = fontFile.dict.get("Lunghezza3");
      }
    } altrimenti se (cssFontInfo) {
      const standardFontName = (0, _xfa_fonts.getXfaFontName)(fontName.name);
      se (nomeCaratterestandard) {
        cssFontInfo.fontFamily = `${cssFontInfo.fontFamily}-PdfJS-XFA`;
        cssFontInfo.metrics = standardFontName.metrics || null;
        glyphScaleFactors = standardFontName.factors || null;
        fontFile = attendi questo.fetchStandardFontData(standardFontName.name);
        isInternalFont = !!fontFile;
        baseDict = dict = (0, _xfa_fonts.getXfaFontDict)(fontName.name);
        composito = vero;
      }
    } altrimenti se (!isType3Font) {
      const standardFontName = (0, _standard_fonts.getStandardFontName)(fontName.name);
      se (nomeCaratterestandard) {
        fontFile = attendi questo.fetchStandardFontData(standardFontName);
        isInternalFont = !!fontFile;
      }
      se (!isInternalFont && this.options.useSystemFonts) {
        systemFontInfo = (0, _font_substitutions.getFontSubstitution)(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, fontName.name, standardFontName);
      }
    }
    proprietà = {
      tipo,
      nome: fontName.name,
      sottotipo,
      file: fontFile,
      lunghezza1,
      lunghezza2,
      lunghezza3,
      èInternalFont,
      Nome caricato: baseDict.Nome caricato,
      composito,
      fixedPitch: falso,
      fontMatrix: dict.getArray("FontMatrix") || _util.FONT_IDENTITY_MATRIX,
      primoCarnevale,
      ultimoCartone,
      in Unicode,
      bbox: descrittore.getArray("FontBBox") || dict.getArray("FontBBox"),
      salita: descriptor.get("Salita"),
      discesa: descriptor.get("Discesa"),
      xAltezza: descrittore.get("XAltezza") || 0,
      altezza del cappuccio: descriptor.get("Altezza del cappuccio") || 0,
      flag: descriptor.get("Flag"),
      Angolo corsivo: descriptor.get("Angolo corsivo") || 0,
      èType3Font,
      cssFontInfo,
      scaleFactors: glyphScaleFactors,
      systemFontInfo
    };
    se (composto) {
      const cidEncoding = baseDict.get("Codifica");
      se (cidEncoding instanceof _primitives.Name) {
        proprietà.cidEncoding = cidEncoding.name;
      }
      const cMap = await _cmap.CMapFactory.create({
        codifica: cidEncoding,
        fetchBuiltInCMap: this._fetchBuiltInCMapBound,
        useCMap: null
      });
      proprietà.cMap = cMap;
      proprietà.verticale = proprietà.cMap.verticale;
    }
    restituisci this.extractDataStructures(dict, baseDict, properties).then(newProperties => {
      this.extractWidths(dict, descriptor, newProperties);
      restituisci nuovi _fonts.Font(fontName.name, fontFile, newProperties);
    });
  }
  static buildFontPaths(font, glifi, gestore, evaluatorOptions) {
    funzione buildPath(fontChar) {
      const glyphName = `${font.loadedName}_path_${fontChar}`;
      Tentativo {
        se (font.renderer.hasBuiltPath(fontChar)) {
          ritorno;
        }
        handler.send("commonobj", [glyphName, "FontPath", font.renderer.getPathJs(fontChar)]);
      } cattura (motivo) {
        se (evaluatorOptions.ignoreErrors) {
          (0, _util.warn)(`buildFontPaths - ignorando il glifo ${glyphName}: "${reason}".`);
          ritorno;
        }
        gettare la ragione;
      }
    }
    per (glifo costante di glifi) {
      buildPath(glyph.fontChar);
      const accent = glyph.accent;
      se (accento?.fontChar) {
        buildPath(accent.fontChar);
      }
    }
  }
  statico ottieni fallbackFontDict() {
    const dict = new _primitives.Dict();
    dict.set("BaseFont", _primitives.Name.get("Helvetica"));
    dict.set("Tipo", _primitives.Name.get("FallbackType"));
    dict.set("Sottotipo", _primitives.Name.get("FallbackType"));
    dict.set("Codifica", _primitives.Name.get("WinAnsiEncoding"));
    return (0, _util.shadow)(this, "fallbackFontDict", dict);
  }
}
esportazioni.PartialEvaluator = PartialEvaluator;
classe TranslatedFont {
  costruttore({
    Nome caricato,
    font,
    dizionario,
    Opzioni di valutazione
  }) {
    this.loadedName = loadedName;
    questo.font = font;
    questo.dizionario = dizionario;
    this._evaluatorOptions = evaluatorOptions || DefaultPartialEvaluatorOptions;
    this.type3Loaded = null;
    this.type3Dependencies = font.isType3Font ? new Set() : null;
    this.sent = false;
  }
  invia(gestore) {
    se (questo.inviato) {
      ritorno;
    }
    questo.inviato = vero;
    handler.send("commonobj", [this.loadedName, "Carattere", this.font.exportData(this._evaluatorOptions.fontExtraProperties)]);
  }
  fallback(gestore) {
    se (!this.font.data) {
      ritorno;
    }
    this.font.disableFontFace = true;
    PartialEvaluator.buildFontPaths(this.font, this.font.glyphCacheValues, handler, this._evaluatorOptions);
  }
  loadType3Data(valutatore, risorse, attività) {
    se (this.type3Loaded) {
      restituisci questo.tipo3Caricato;
    }
    se (!this.font.isType3Font) {
      throw new Error("Deve essere un font Type3.");
    }
    const type3Evaluator = evaluator.clone({
      ignoreErrors: falso
    });
    type3Evaluator.parsingType3Font = true;
    const type3FontRefs = new _primitives.RefSet(evaluator.type3FontRefs);
    se (this.dict.objId && !type3FontRefs.has(this.dict.objId)) {
      type3FontRefs.put(this.dict.objId);
    }
    type3Evaluator.type3FontRefs = type3FontRefs;
    const translatedFont = this.font,
      tipo3Dipendenze = questo.tipo3Dipendenze;
    lascia che loadCharProcsPromise = Promise.resolve();
    const charProcs = this.dict.get("CharProcs");
    const fontResources = this.dict.get("Risorse") || risorse;
    const charProcOperatorList = Object.create(null);
    const fontBBox = _util.Util.normalizeRect(translatedFont.bbox || [0, 0, 0, 0]),
      larghezza = fontBBox[2] - fontBBox[0],
      altezza = fontBBox[3] - fontBBox[1];
    const fontBBoxSize = Math.hypot(larghezza, altezza);
    per (const chiave di charProcs.getKeys()) {
      loadCharProcsPromise = loadCharProcsPromise.then(() => {
        const glyphStream = charProcs.get(chiave);
        const operatorList = new _operator_list.OperatorList();
        restituisci type3Evaluator.getOperatorList({
          flusso: glyphStream,
          compito,
          risorse: fontResources,
          lista degli operatori
        }).poi(() => {
          se (operatorList.fnArray[0] === _util.OPS.setCharWidthAndBounds) {
            this._removeType3ColorOperators(operatorList, fontBBoxSize);
          }
          charProcOperatorList[chiave] = operatorList.getIR();
          per (dipendenza costante di operatorList.dependencies) {
            type3Dependencies.add(dipendenza);
          }
        }).catch(funzione (motivo) {
          (0, _util.warn)(`La risorsa font Type3 "${key}" non è disponibile.`);
          const dummyOperatorList = new _operator_list.OperatorList();
          charProcOperatorList[chiave] = dummyOperatorList.getIR();
        });
      });
    }
    this.type3Loaded = loadCharProcsPromise.then(() => {
      translatedFont.charProcOperatorList = charProcOperatorList;
      se (this._bbox) {
        translatedFont.isCharBBox = true;
        translatedFont.bbox = this._bbox;
      }
    });
    restituisci questo.tipo3Caricato;
  }
  _removeType3ColorOperators(operatorList, fontBBoxSize = NaN) {
    const charBBox = _util.Util.normalizeRect(operatorList.argsArray[0].slice(2)),
      larghezza = charBBox[2] - charBBox[0],
      altezza = charBBox[3] - charBBox[1];
    const charBBoxSize = Math.hypot(larghezza, altezza);
    se (larghezza === 0 || altezza === 0) {
      operatorList.fnArray.splice(0, 1);
      operatorList.argsArray.splice(0, 1);
    } altrimenti se (fontBBoxSize === 0 || Math.round(charBBoxSize / fontBBoxSize) >= 10) {
      se (!this._bbox) {
        this._bbox = [Infinito, Infinito, -Infinito, -Infinito];
      }
      this._bbox[0] = Math.min(this._bbox[0], charBBox[0]);
      this._bbox[1] = Math.min(this._bbox[1], charBBox[1]);
      this._bbox[2] = Math.max(this._bbox[2], charBBox[2]);
      this._bbox[3] = Math.max(this._bbox[3], charBBox[3]);
    }
    sia i = 0,
      ii = operatorList.length;
    mentre (i < ii) {
      interruttore (operatorList.fnArray[i]) {
        caso _util.OPS.setCharWidthAndBounds:
          rottura;
        caso _util.OPS.setStrokeColorSpace:
        caso _util.OPS.setFillColorSpace:
        caso _util.OPS.setStrokeColor:
        caso _util.OPS.setStrokeColorN:
        caso _util.OPS.setFillColor:
        caso _util.OPS.setFillColorN:
        caso _util.OPS.setStrokeGray:
        caso _util.OPS.setFillGray:
        caso _util.OPS.setStrokeRGBColor:
        caso _util.OPS.setFillRGBColor:
        caso _util.OPS.setStrokeCMYKColor:
        caso _util.OPS.setFillCMYKColor:
        caso _util.OPS.shadingFill:
        case _util.OPS.setRenderingIntent:
          operatorList.fnArray.splice(i, 1);
          operatorList.argsArray.splice(i, 1);
          ii--;
          continuare;
        caso _util.OPS.setGState:
          const [gStateObj] = operatorList.argsArray[i];
          sia j = 0,
            jj = gStateObj.length;
          mentre (j < jj) {
            const [gStateKey] = gStateObj[j];
            interruttore (gStateKey) {
              caso "TR":
              caso "TR2":
              caso "HT":
              caso "BG":
              caso "BG2":
              caso "UCR":
              caso "UCR2":
                gStateObj.splice(j, 1);
                jj--;
                continuare;
            }
            j++;
          }
          rottura;
      }
      i++;
    }
  }
}
classe StateManager {
  costruttore(statoiniziale = nuovo stato di valutazione()) {
    questo.stato = statoiniziale;
    questo.stateStack = [];
  }
  salva() {
    const vecchio = questo.stato;
    questo.statoStack.push(questo.stato);
    questo.stato = vecchio.clone();
  }
  ripristinare() {
    const prev = this.stateStack.pop();
    se (precedente) {
      questo.stato = prec;
    }
  }
  trasforma(argomenti) {
    questo.stato.ctm = _util.Util.transform(questo.stato.ctm, argomenti);
  }
}
classe TextState {
  costruttore() {
    this.ctm = new Float32Array(_util.IDENTITY_MATRIX);
    this.fontName = null;
    this.fontSize = 0;
    this.loadedName = null;
    questo.font = null;
    this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
    this.textMatrix = _util.IDENTITY_MATRIX.slice();
    this.textLineMatrix = _util.IDENTITY_MATRIX.slice();
    this.charSpacing = 0;
    this.wordSpacing = 0;
    questo.principale = 0;
    this.textHScale = 1;
    this.textRise = 0;
  }
  impostaMatriceTesto(a, b, c, d, e, f) {
    const m = this.textMatrix;
    m[0] = a;
    m[1] = b;
    m[2] = c;
    m[3] = d;
    m[4] = e;
    m[5] = f;
  }
  impostaTextLineMatrix(a, b, c, d, e, f) {
    const m = this.textLineMatrix;
    m[0] = a;
    m[1] = b;
    m[2] = c;
    m[3] = d;
    m[4] = e;
    m[5] = f;
  }
  traduciTextMatrix(x, y) {
    const m = this.textMatrix;
    m[4] = m[0] * x + m[2] * y + m[4];
    m[5] = m[1] * x + m[3] * y + m[5];
  }
  traduciTextLineMatrix(x, y) {
    const m = this.textLineMatrix;
    m[4] = m[0] * x + m[2] * y + m[4];
    m[5] = m[1] * x + m[3] * y + m[5];
  }
  ritorno a capo() {
    this.translateTextLineMatrix(0, -this.leading);
    this.textMatrix = this.textLineMatrix.slice();
  }
  clona() {
    const clone = Object.create(this);
    clone.textMatrix = this.textMatrix.slice();
    clone.textLineMatrix = this.textLineMatrix.slice();
    clone.fontMatrix = this.fontMatrix.slice();
    restituisci clone;
  }
}
classe EvalState {
  costruttore() {
    this.ctm = new Float32Array(_util.IDENTITY_MATRIX);
    questo.font = null;
    this.textRenderingMode = _util.TextRenderingMode.FILL;
    this.fillColorSpace = _colorspace.ColorSpace.singletons.gray;
    this.strokeColorSpace = _colorspace.ColorSpace.singletons.gray;
  }
  clona() {
    restituisci Object.create(this);
  }
}
classe EvaluatorPreprocessor {
  static get opMap() {
    restituisci (0, _util.shadow)(questo, "opMap", {
      in: {
        ID: _util.OPS.setLineWidth,
        numArg: 1,
        variableArgs: false
      },
      J: {
        ID: _util.OPS.setLineCap,
        numArg: 1,
        variableArgs: false
      },
      J: {
        ID: _util.OPS.setLineJoin,
        numArg: 1,
        variableArgs: false
      },
      M: {
        ID: _util.OPS.setMiterLimit,
        numArg: 1,
        variableArgs: false
      },
      D: {
        ID: _util.OPS.setDash,
        numArgs: 2,
        variableArgs: false
      },
      ri: {
        ID: _util.OPS.setRenderingIntent,
        numArg: 1,
        variableArgs: false
      },
      io: {
        ID: _util.OPS.setFlatness,
        numArg: 1,
        variableArgs: false
      },
      gs: {
        ID: _util.OPS.setGState,
        numArg: 1,
        variableArgs: false
      },
      Q: {
        ID: _util.OPS.save,
        numArgs: 0,
        variableArgs: false
      },
      Q: {
        ID: _util.OPS.restore,
        numArgs: 0,
        variableArgs: false
      },
      cm: {
        ID: _util.OPS.transform,
        numArgs: 6,
        variableArgs: false
      },
      M: {
        ID: _util.OPS.moveTo,
        numArgs: 2,
        variableArgs: false
      },
      l: {
        ID: _util.OPS.lineTo,
        numArgs: 2,
        variableArgs: false
      },
      C: {
        ID: _util.OPS.curveTo,
        numArgs: 6,
        variableArgs: false
      },
      v: {
        ID: _util.OPS.curveTo2,
        numArgs: 4,
        variableArgs: false
      },
      e: {
        ID: _util.OPS.curveTo3,
        numArgs: 4,
        variableArgs: false
      },
      H: {
        ID: _util.OPS.closePath,
        numArgs: 0,
        variableArgs: false
      },
      Rif: {
        id: _util.OPS.rectangle,
        numArgs: 4,
        variableArgs: false
      },
      S: {
        ID: _util.OPS.stroke,
        numArgs: 0,
        variableArgs: false
      },
      S: {
        ID: _util.OPS.closeStroke,
        numArgs: 0,
        variableArgs: false
      },
      F: {
        ID: _util.OPS.fill,
        numArgs: 0,
        variableArgs: false
      },
      F: {
        ID: _util.OPS.fill,
        numArgs: 0,
        variableArgs: false
      },
      "F*": {
        ID: _util.OPS.eoFill,
        numArgs: 0,
        variableArgs: false
      },
      B: {
        ID: _util.OPS.fillStroke,
        numArgs: 0,
        variableArgs: false
      },
      "B*": {
        ID: _util.OPS.eoFillStroke,
        numArgs: 0,
        variableArgs: false
      },
      B: {
        ID: _util.OPS.closeFillStroke,
        numArgs: 0,
        variableArgs: false
      },
      "B*": {
        ID: _util.OPS.closeEOFillStroke,
        numArgs: 0,
        variableArgs: false
      },
      N: {
        ID: _util.OPS.endPath,
        numArgs: 0,
        variableArgs: false
      },
      O: {
        ID: _util.OPS.clip,
        numArgs: 0,
        variableArgs: false
      },
      "W*": {
        ID: _util.OPS.eoClip,
        numArgs: 0,
        variableArgs: false
      },
      BT: {
        ID: _util.OPS.beginText,
        numArgs: 0,
        variableArgs: false
      },
      ET: {
        ID: _util.OPS.endText,
        numArgs: 0,
        variableArgs: false
      },
      Tc: {
        ID: _util.OPS.setCharSpacing,
        numArg: 1,
        variableArgs: false
      },
      Due: {
        ID: _util.OPS.setWordSpacing,
        numArg: 1,
        variableArgs: false
      },
      Tz: {
        ID: _util.OPS.setHScale,
        numArg: 1,
        variableArgs: false
      },
      TL: {
        ID: _util.OPS.setLeading,
        numArg: 1,
        variableArgs: false
      },
      Tf: {
        ID: _util.OPS.setFont,
        numArgs: 2,
        variableArgs: false
      },
      Tradotto: {
        ID: _util.OPS.setTextRenderingMode,
        numArg: 1,
        variableArgs: false
      },
      Ts: {
        ID: _util.OPS.setTextRise,
        numArg: 1,
        variableArgs: false
      },
      Td: {
        ID: _util.OPS.moveText,
        numArgs: 2,
        variableArgs: false
      },
      TD: {
        ID: _util.OPS.setLeadingMoveText,
        numArgs: 2,
        variableArgs: false
      },
      Marchio: {
        ID: _util.OPS.setTextMatrix,
        numArgs: 6,
        variableArgs: false
      },
      "T*": {
        ID: _util.OPS.nextLine,
        numArgs: 0,
        variableArgs: false
      },
      Tj: {
        ID: _util.OPS.showText,
        numArg: 1,
        variableArgs: false
      },
      TJ: {
        ID: _util.OPS.showSpacedText,
        numArg: 1,
        variableArgs: false
      },
      "'": {
        ID: _util.OPS.nextLineShowText,
        numArg: 1,
        variableArgs: false
      },
      '"': {
        ID: _util.OPS.nextLineSetSpacingShowText,
        numArgs: 3,
        variableArgs: false
      },
      d0: {
        ID: _util.OPS.setCharWidth,
        numArgs: 2,
        variableArgs: false
      },
      d1: {
        ID: _util.OPS.setCharWidthAndBounds,
        numArgs: 6,
        variableArgs: false
      },
      CS: {
        ID: _util.OPS.setStrokeColorSpace,
        numArg: 1,
        variableArgs: false
      },
      cs: {
        ID: _util.OPS.setFillColorSpace,
        numArg: 1,
        variableArgs: false
      },
      SC: {
        ID: _util.OPS.setStrokeColor,
        numArgs: 4,
        variableArgs: true
      },
      SCN: {
        ID: _util.OPS.setStrokeColorN,
        numArgs: 33,
        variableArgs: true
      },
      sc: {
        ID: _util.OPS.setFillColor,
        numArgs: 4,
        variableArgs: true
      },
      scansione: {
        ID: _util.OPS.setFillColorN,
        numArgs: 33,
        variableArgs: true
      },
      G: {
        ID: _util.OPS.setStrokeGray,
        numArg: 1,
        variableArgs: false
      },
      G: {
        ID: _util.OPS.setFillGray,
        numArg: 1,
        variableArgs: false
      },
      RG: {
        ID: _util.OPS.setStrokeRGBColor,
        numArgs: 3,
        variableArgs: false
      },
      rg: {
        ID: _util.OPS.setFillRGBColor,
        numArgs: 3,
        variableArgs: false
      },
      K: {
        ID: _util.OPS.setStrokeCMYKColor,
        numArgs: 4,
        variableArgs: false
      },
      k: {
        ID: _util.OPS.setFillCMYKColor,
        numArgs: 4,
        variableArgs: false
      },
      sh: {
        ID: _util.OPS.shadingFill,
        numArg: 1,
        variableArgs: false
      },
      BI: {
        ID: _util.OPS.beginInlineImage,
        numArgs: 0,
        variableArgs: false
      },
      ID: {
        ID: _util.OPS.beginImageData,
        numArgs: 0,
        variableArgs: false
      },
      EI: {
        ID: _util.OPS.endInlineImage,
        numArg: 1,
        variableArgs: false
      },
      Fare: {
        ID: _util.OPS.paintXObject,
        numArg: 1,
        variableArgs: false
      },
      Deputato: {
        ID: _util.OPS.markPoint,
        numArg: 1,
        variableArgs: false
      },
      DP: {
        ID: _util.OPS.markPointProps,
        numArgs: 2,
        variableArgs: false
      },
      BMC: {
        ID: _util.OPS.beginMarkedContent,
        numArg: 1,
        variableArgs: false
      },
      BDC: {
        ID: _util.OPS.beginMarkedContentProps,
        numArgs: 2,
        variableArgs: false
      },
      EMC: {
        ID: _util.OPS.endMarkedContent,
        numArgs: 0,
        variableArgs: false
      },
      BX: {
        ID: _util.OPS.beginCompat,
        numArgs: 0,
        variableArgs: false
      },
      ES: {
        ID: _util.OPS.endCompat,
        numArgs: 0,
        variableArgs: false
      },
      BM: nullo,
      BD: nullo,
      vero: nullo,
      fa: nullo,
      fal: nullo,
      falsi: nullo,
      falso: nullo,
      nu: nullo,
      nullo: nullo,
      nullo: nullo
    });
  }
  statico MAX_INVALID_PATH_OPS = 10;
  costruttore(flusso, riferimento esterno, stateManager = nuovo StateManager()) {
    questo.parser = nuovo _parser.Parser({
      lexer: nuovo _parser.Lexer(stream, EvaluatorPreprocessor.opMap),
      riferimento esterno
    });
    questo.stateManager = stateManager;
    questo.nonProcessedArgs = [];
    this._isPathOp = false;
    this._numInvalidPathOPS = 0;
  }
  ottieni savedStatesDepth() {
    restituisci this.stateManager.stateStack.length;
  }
  lettura(operazione) {
    lascia che args = operation.args;
    mentre (vero) {
      const obj = this.parser.getObj();
      se (oggetto istanza di _primitives.Cmd) {
        const cmd = obj.cmd;
        const opSpec = EvaluatorPreprocessor.opMap[cmd];
        se (!opSpec) {
          (0, _util.warn)(`Comando sconosciuto "${cmd}".`);
          continuare;
        }
        const fn = opSpec.id;
        const numArgs = opSpec.numArgs;
        lascia che argsLength = args !== null ? args.length : 0;
        se (!this._isPathOp) {
          this._numInvalidPathOPS = 0;
        }
        this._isPathOp = fn >= _util.OPS.moveTo && fn <= _util.OPS.endPath;
        se (!opSpec.variableArgs) {
          se (lunghezzaarg!== numArgs) {
            const nonProcessedArgs = this.nonProcessedArgs;
            while (lunghezzaarg > numArg) {
              nonProcessedArgs.push(args.shift());
              lunghezzaargs--;
            }
            while (argsLength < numArgs && nonProcessedArgs.length !== 0) {
              se (argomenti === null) {
                argomenti = [];
              }
              args.unshift(nonProcessedArgs.pop());
              lunghezzaargs++;
            }
          }
          se (lunghezzaarg < numArg) {
            const partialMsg = `comando ${cmd}: previsti ${numArgs} argomenti, ` + `ma ricevuti ${argsLength} argomenti.`;
            se (this._isPathOp && ++this._numInvalidPathOPS > EvaluatorPreprocessor.MAX_INVALID_PATH_OPS) {
              lancia nuovo _util.FormatError(`${partialMsg} non valido`);
            }
            (0, _util.warn)(`Salta ${partialMsg}`);
            se (argomenti !== null) {
              lunghezza argomenti = 0;
            }
            continuare;
          }
        } altrimenti se (lunghezzaarg > numArgs) {
          (0, _util.info)(`Comando ${cmd}: previsti [0, ${numArgs}] argomenti, ` + `ma ricevuti ${argsLength} argomenti.`);
        }
        this.preprocessCommand(fn, args);
        operazione.fn = fn;
        operazione.args = args;
        restituisci vero;
      }
      se (oggetto === _primitives.EOF) {
        restituisci falso;
      }
      se (oggetto !== null) {
        se (argomenti === null) {
          argomenti = [];
        }
        argomenti.push(oggetto);
        se (lunghezza argomenti > 33) {
          throw new _util.FormatError("Troppi argomenti");
        }
      }
    }
  }
  preprocessCommand(fn, argomenti) {
    interruttore (fn | 0) {
      caso _util.OPS.save:
        questo.gestore.salva();
        rottura;
      caso _util.OPS.restore:
        this.stateManager.restore();
        rottura;
      caso _util.OPS.transform:
        this.stateManager.transform(args);
        rottura;
    }
  }
}
esportazioni.EvaluatorPreprocessor = EvaluatorPreprocessor;

/***/ }),
/* 14 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.IdentityCMap = esportazioni.CMapFactory = esportazioni.CMap = void 0;
var _util = __w_pdfjs_require__(2);
var _primitives = __w_pdfjs_require__(4);
var _base_stream = __w_pdfjs_require__(5);
var _binary_cmap = __w_pdfjs_require__(15);
var _parser = __w_pdfjs_require__(16);
var _core_utils = __w_pdfjs_require__(3);
var _stream = __w_pdfjs_require__(8);
const BUILT_IN_CMAPS = ["Adobe-GB1-UCS2", "Adobe-CNS1-UCS2", "Adobe-Japan1-UCS2", "Adobe-Korea1-UCS2", "78-EUC-H", "78-EUC-V", "78-H", "78-RKSJ-H", "78-RKSJ-V", "78-V", "78ms-RKSJ-H", "78ms-RKSJ-V", "83pv-RKSJ-H", "90ms-RKSJ-H", "90ms-RKSJ-V", "90msp-RKSJ-H", "90msp-RKSJ-V", "90pv-RKSJ-H", "90pv-RKSJ-V", "Add-H", "Add-RKSJ-H", "Aggiungi-RKSJ-V", "Add-V", "Adobe-CNS1-0", "Adobe-CNS1-1", "Adobe-CNS1-2", "Adobe-CNS1-3", "Adobe-CNS1-4", "Adobe-CNS1-5", "Adobe-CNS1-6", "Adobe-GB1-0", "Adobe-GB1-1", "Adobe-GB1-2", "Adobe-GB1-3", "Adobe-GB1-4", "Adobe-GB1-5", "Adobe-Japan1-0", "Adobe-Japan1-1", "Adobe-Japan1-2", "Adobe-Japan1-3", "Adobe-Japan1-4", "Adobe-Japan1-5", "Adobe-Japan1-6", "Adobe-Corea1-0", "Adobe-Corea1-1", "Adobe-Korea1-2", "B5-H", "B5-V", "B5pc-H", "B5pc-V", "CNS-EUC-H", "CNS-EUC-V", "CNS1-H", "CNS1-V", "CNS2-H", "CNS2-V", "ETHK-B5-H", "ETHK-B5-V", "ETen-B5-H", "ETen-B5-V", "ETenms-B5-H", "ETenms-B5-V", "EUC-H", "EUC-V", "Ext-H", "Ext-RKSJ-H", "Ext-RKSJ-V", "Ext-V", "GB-EUC-H", "GB-EUC-V", "GB-H", "GB-V", "GBK-EUC-H", "GBK-EUC-V", "GBK2K-H", "GBK2K-V", "GBKp-EUC-H", "GBKp-EUC-V", "GBT-EUC-H", "GBT-EUC-V", "GBT-H", "GBT-V", "GBTpc-EUC-H", "GBTpc-EUC-V", "GBpc-EUC-H", "GBpc-EUC-V", "H", "HKdla-B5-H", "HKdla-B5-V", "HKdlb-B5-H", "HKdlb-B5-V", "HKgccs-B5-H", "HKgccs-B5-V", "HKm314-B5-H", "HKm314-B5-V", "HKm471-B5-H", "HKm471-B5-V", "HKscs-B5-H", "HKscs-B5-V", "Hankaku", "Hiragana", "KSC-EUC-H", "KSC-EUC-V", "KSC-H", "KSC-Johab-H", "KSC-Johab-V", "KSC-V", "KSCms-UHC-H", "KSCms-UHC-HW-H", "KSCms-UHC-HW-V", "KSCms-UHC-V", "KSCpc-EUC-H", "KSCpc-EUC-V", "Katakana", "NWP-H", "NWP-V", "RKSJ-H", "RKSJ-V", "Roman", "UniCNS-UCS2-H", "UniCNS-UCS2-V", "UniCNS-UTF16-H", "UniCNS-UTF16-V", "UniCNS-UTF32-H", "UniCNS-UTF32-V","UniCNS-UTF8-H", "UniCNS-UTF8-V", "UniGB-UCS2-H", "UniGB-UCS2-V", "UniGB-UTF16-H", "UniGB-UTF16-V", "UniGB-UTF32-H", "UniGB-UTF32-V", "UniGB-UTF8-H", "UniGB-UTF8-V", "UniJIS-UCS2-H", "UniJIS-UCS2-HW-H", "UniJIS-UCS2-HW-V", "UniJIS-UCS2-V", "UniJIS-UTF16-H", "UniJIS-UTF16-V", "UniJIS-UTF32-H", "UniJIS-UTF32-V", "UniJIS-UTF8-H", "UniJIS-UTF8-V", "UniJIS2004-UTF16-H", "UniJIS2004-UTF16-V", "UniJIS2004-UTF32-H", "UniJIS2004-UTF32-V", "UniJIS2004-UTF8-H", "UniJIS2004-UTF8-V", "UniJISPro-UCS2-HW-V", "UniJISPro-UCS2-V", "UniJISPro-UTF8-V", "UniJISX0213-UTF32-H", "UniJISX0213-UTF32-V", "UniJISX02132004-UTF32-H", "UniJISX02132004-UTF32-V", "UniKS-UCS2-H", "UniKS-UCS2-V", "UniKS-UTF16-H", "UniKS-UTF16-V", "UniKS-UTF32-H", "UniKS-UTF32-V", "UniKS-UTF8-H", "UniKS-UTF8-V", "V", "WP-Symbol"];
const MAX_MAP_RANGE = 2 ** 24 - 1;
classe CMap {
  costruttore(builtInCMap = false) {
    this.codespaceRanges = [[], [], [], []];
    this.numCodespaceRanges = 0;
    questa._mappa = [];
    questo.nome = "";
    questo.verticale = falso;
    this.useCMap = null;
    this.builtInCMap = builtInCMap;
  }
  addCodespaceRange(n, basso, alto) {
    this.codespaceRanges[n - 1].push(basso, alto);
    questo.numCodespaceRanges++;
  }
  mapCidRange(basso, alto, dstLow) {
    se (alto - basso > MAX_MAP_RANGE) {
      throw new Error("mapCidRange - ignorati i dati superiori a MAX_MAP_RANGE.");
    }
    mentre (basso <= alto) {
      this._map[low++] = dstLow++;
    }
  }
  mapBfRange(basso, alto, dstLow) {
    se (alto - basso > MAX_MAP_RANGE) {
      throw new Error("mapBfRange - ignorati i dati superiori a MAX_MAP_RANGE.");
    }
    const lastByte = dstLow.length - 1;
    mentre (basso <= alto) {
      this._map[low++] = dstLow;
      const nextCharCode = dstLow.charCodeAt(lastByte) + 1;
      se (nextCharCode > 0xff) {
        dstLow = dstLow.substring(0, lastByte - 1) + String.fromCharCode(dstLow.charCodeAt(lastByte - 1) + 1) + "\x00";
        continuare;
      }
      dstLow = dstLow.substring(0, lastByte) + String.fromCharCode(nextCharCode);
    }
  }
  mapBfRangeToArray(basso, alto, array) {
    se (alto - basso > MAX_MAP_RANGE) {
      throw new Error("mapBfRangeToArray - ignorati i dati superiori a MAX_MAP_RANGE.");
    }
    const ii = array.length;
    sia i = 0;
    mentre (basso <= alto && i < ii) {
      this._map[low] = array[i++];
      ++basso;
    }
  }
  mapOne(src, dst) {
    this._map[src] = dst;
  }
  ricerca(codice) {
    restituisci questo._map[codice];
  }
  contiene(codice) {
    restituisci questo._map[codice] !== indefinito;
  }
  perOgni(richiamata) {
    const map = this._map;
    lunghezza costante = lunghezza mappa;
    se (lunghezza <= 0x10000) {
      per (lascia che i = 0; i < lunghezza; i++) {
        se (map[i] !== indefinito) {
          callback(i, mappa[i]);
        }
      }
    } altro {
      per (const i nella mappa) {
        callback(i, mappa[i]);
      }
    }
  }
  charCodeOf(valore) {
    const map = this._map;
    se (lunghezza mappa <= 0x10000) {
      restituisci map.indexOf(valore);
    }
    per (codicecarattere costante nella mappa) {
      se (map[charCode] === valore) {
        restituisci charCode | 0;
      }
    }
    restituisci -1;
  }
  ottieniMap() {
    restituisci questo._map;
  }
  readCharCode(str, offset, out) {
    sia c = 0;
    const codespaceRanges = this.codespaceRanges;
    per (lascia che n = 0, nn = codespaceRanges.length; n < nn; n++) {
      c = (c << 8 | str.charCodeAt(offset + n)) >>> 0;
      const codespaceRange = codespaceRanges[n];
      per (lascia che k = 0, kk = codespaceRange.length; k < kk;) {
        const low = codespaceRange[k++];
        const high = codespaceRange[k++];
        se (c >= basso e c <= alto) {
          out.charcode = c;
          lunghezza in uscita = n + 1;
          ritorno;
        }
      }
    }
    out.charcode = 0;
    lunghezza in uscita = 1;
  }
  getCharCodeLength(charCode) {
    const codespaceRanges = this.codespaceRanges;
    per (lascia che n = 0, nn = codespaceRanges.length; n < nn; n++) {
      const codespaceRange = codespaceRanges[n];
      per (lascia che k = 0, kk = codespaceRange.length; k < kk;) {
        const low = codespaceRange[k++];
        const high = codespaceRange[k++];
        se (charCode >= basso e charCode <= alto) {
          restituisci n + 1;
        }
      }
    }
    restituisci 1;
  }
  ottieni lunghezza() {
    restituisci questa._lunghezza della mappa;
  }
  ottieni isIdentityCMap() {
    se (!(this.name === "Identità-H" || this.name === "Identità-V")) {
      restituisci falso;
    }
    se (questa._lunghezza.mappa !== 0x10000) {
      restituisci falso;
    }
    per (lascia che i = 0; i < 0x10000; i++) {
      se (this._map[i] !== i) {
        restituisci falso;
      }
    }
    restituisci vero;
  }
}
esportazioni.CMap = CMap;
classe IdentityCMap estende CMap {
  costruttore(verticale, n) {
    super();
    this.vertical = verticale;
    this.addCodespaceRange(n, 0, 0xffff);
  }
  mapCidRange(basso, alto, dstLow) {
    (0, _util.unreachable)("non dovrebbe chiamare mapCidRange");
  }
  mapBfRange(basso, alto, dstLow) {
    (0, _util.unreachable)("non dovrebbe chiamare mapBfRange");
  }
  mapBfRangeToArray(basso, alto, array) {
    (0, _util.unreachable)("non dovrebbe chiamare mapBfRangeToArray");
  }
  mapOne(src, dst) {
    (0, _util.unreachable)("non dovrebbe chiamare mapCidOne");
  }
  ricerca(codice) {
    restituisci Number.isInteger(codice) && codice <= 0xffff ? codice : indefinito;
  }
  contiene(codice) {
    restituisci Number.isInteger(codice) && codice <= 0xffff;
  }
  perOgni(richiamata) {
    per (lascia che i = 0; i <= 0xffff; i++) {
      callback(i, i);
    }
  }
  charCodeOf(valore) {
    restituisci Number.isInteger(valore) && valore <= 0xffff ? valore : -1;
  }
  ottieniMap() {
    const map = new Array(0x10000);
    per (lascia che i = 0; i <= 0xffff; i++) {
      mappa[i] = i;
    }
    mappa di ritorno;
  }
  ottieni lunghezza() {
    restituisci 0x10000;
  }
  ottieni isIdentityCMap() {
    (0, _util.unreachable)("non dovrebbe accedere a .isIdentityCMap");
  }
}
esportazioni.IdentityCMap = IdentityCMap;
funzione strToInt(str) {
  sia a = 0;
  per (lascia che i = 0; i < str.length; i++) {
    a = a << 8 | str.charCodeAt(i);
  }
  restituisci un >>> 0;
}
funzione expectString(obj) {
  se (tipo di oggetto !== "stringa") {
    throw new _util.FormatError("CMap non valido: stringa prevista.");
  }
}
funzione expectInt(obj) {
  se (!Numero.èIntero(oggetto)) {
    throw new _util.FormatError("CMap non valido: previsto int.");
  }
}
funzione parseBfChar(cMap, lexer) {
  mentre (vero) {
    lascia che obj = lexer.getObj();
    se (oggetto === _primitives.EOF) {
      rottura;
    }
    se ((0, _primitives.isCmd)(obj, "endbfchar")) {
      ritorno;
    }
    aspettaString(oggetto);
    const src = strToInt(obj);
    obj = lexer.getObj();
    aspettaString(oggetto);
    const dst = obj;
    cMap.mapOne(src, dst);
  }
}
funzione parseBfRange(cMap, lexer) {
  mentre (vero) {
    lascia che obj = lexer.getObj();
    se (oggetto === _primitives.EOF) {
      rottura;
    }
    se ((0, _primitives.isCmd)(obj, "endbfrange")) {
      ritorno;
    }
    aspettaString(oggetto);
    const low = strToInt(obj);
    obj = lexer.getObj();
    aspettaString(oggetto);
    const high = strToInt(obj);
    obj = lexer.getObj();
    se (Number.isInteger(obj) || tipo di obj === "stringa") {
      const dstLow = Number.isInteger(obj) ? String.fromCharCode(obj) : obj;
      cMap.mapBfRange(basso, alto, dstLow);
    } altrimenti se ((0, _primitives.isCmd)(obj, "[")) {
      obj = lexer.getObj();
      matrice costante = [];
      while (!(0, _primitives.isCmd)(obj, "]") && obj !== _primitives.EOF) {
        array.push(oggetto);
        obj = lexer.getObj();
      }
      cMap.mapBfRangeToArray(basso, alto, array);
    } altro {
      rottura;
    }
  }
  throw new _util.FormatError("Intervallo bf non valido.");
}
funzione parseCidChar(cMap, lexer) {
  mentre (vero) {
    lascia che obj = lexer.getObj();
    se (oggetto === _primitives.EOF) {
      rottura;
    }
    se ((0, _primitives.isCmd)(obj, "endcidchar")) {
      ritorno;
    }
    aspettaString(oggetto);
    const src = strToInt(obj);
    obj = lexer.getObj();
    aspettaInt(oggetto);
    const dst = obj;
    cMap.mapOne(src, dst);
  }
}
funzione parseCidRange(cMap, lexer) {
  mentre (vero) {
    lascia che obj = lexer.getObj();
    se (oggetto === _primitives.EOF) {
      rottura;
    }
    se ((0, _primitives.isCmd)(obj, "endcidrange")) {
      ritorno;
    }
    aspettaString(oggetto);
    const low = strToInt(obj);
    obj = lexer.getObj();
    aspettaString(oggetto);
    const high = strToInt(obj);
    obj = lexer.getObj();
    aspettaInt(oggetto);
    const dstLow = obj;
    cMap.mapCidRange(basso, alto, dstLow);
  }
}
funzione parseCodespaceRange(cMap, lexer) {
  mentre (vero) {
    lascia che obj = lexer.getObj();
    se (oggetto === _primitives.EOF) {
      rottura;
    }
    se ((0, _primitives.isCmd)(obj, "endcodespacerange")) {
      ritorno;
    }
    se (tipo di oggetto !== "stringa") {
      rottura;
    }
    const low = strToInt(obj);
    obj = lexer.getObj();
    se (tipo di oggetto !== "stringa") {
      rottura;
    }
    const high = strToInt(obj);
    cMap.addCodespaceRange(obj.length, low, high);
  }
  throw new _util.FormatError("Intervallo di codespace non valido.");
}
funzione parseWMode(cMap, lexer) {
  const obj = lexer.getObj();
  se (Numero.èIntero(oggetto)) {
    cMap.vertical = !!obj;
  }
}
funzione parseCMapName(cMap, lexer) {
  const obj = lexer.getObj();
  se (oggetto istanza di _primitives.Nome) {
    cMap.name = obj.name;
  }
}
funzione asincrona parseCMap(cMap, lexer, fetchBuiltInCMap, useCMap) {
  lascia precedente, embeddedUseCMap;
  objLoop: while (true) {
    Tentativo {
      const obj = lexer.getObj();
      se (oggetto === _primitives.EOF) {
        rottura;
      } altrimenti se (oggetto istanza di _primitives.Nome) {
        se (nome_oggetto === "WMode") {
          parseWMode(cMap, analizzatore lessicale);
        } altrimenti se (nome oggetto === "NomeCMap") {
          parseCMapName(cMap, lexer);
        }
        precedente = obj;
      } altrimenti se (oggetto istanza di _primitives.Cmd) {
        switch (obj.cmd) {
          caso "endcmap":
            interruzione objLoop;
          caso "usecmap":
            se (istanza precedente di _primitives.Name) {
              embeddedUseCMap = previous.name;
            }
            rottura;
          caso "begincodespacerange":
            parseCodespaceRange(cMap, lexer);
            rottura;
          caso "beginbfchar":
            parseBfChar(cMap, analizzatore lessicale);
            rottura;
          caso "begincidchar":
            parseCidChar(cMap, analizzatore lessicale);
            rottura;
          caso "beginbfrange":
            parseBfRange(cMap, analizzatore lessicale);
            rottura;
          caso "begincidrange":
            parseCidRange(cMap, analizzatore lessicale);
            rottura;
        }
      }
    } catturare (es.) {
      se (ad esempio instanceof _core_utils.MissingDataException) {
        lanciare ex;
      }
      (0, _util.warn)("Dati cMap non validi: " + ex);
      continuare;
    }
  }
  se (!useCMap && embeddedUseCMap) {
    useCMap = embeddedUseCMap;
  }
  se (usaCMap) {
    restituisci extendCMap(cMap, fetchBuiltInCMap, useCMap);
  }
  restituisci cMap;
}
funzione asincrona extendCMap(cMap, fetchBuiltInCMap, useCMap) {
  cMap.useCMap = attendi createBuiltInCMap(useCMap, fetchBuiltInCMap);
  se (cMap.numCodespaceRanges === 0) {
    const useCodespaceRanges = cMap.useCMap.codespaceRanges;
    per (lascia che i = 0; i < usaCodespaceRanges.length; i++) {
      cMap.codespaceRanges[i] = useCodespaceRanges[i].slice();
    }
    cMap.numCodespaceRanges = cMap.useCMap.numCodespaceRanges;
  }
  cMap.useCMap.forEach(funzione (chiave, valore) {
    se (!cMap.contains(chiave)) {
      cMap.mapOne(chiave, cMap.useCMap.lookup(chiave));
    }
  });
  restituisci cMap;
}
funzione asincrona createBuiltInCMap(nome, fetchBuiltInCMap) {
  se (nome === "Identità-H") {
    restituisci nuova IdentityCMap(false, 2);
  } else if (name === "Identity-V") {
    restituisci nuova IdentityCMap(true, 2);
  }
  se (!BUILT_IN_CMAPS.includes(nome)) {
    genera un nuovo errore("Nome CMap sconosciuto: " + nome);
  }
  se (!fetchBuiltInCMap) {
    throw new Error("I parametri CMap incorporati non sono forniti.");
  }
  costante {
    cMapData,
    tipo di compressione
  } = attendi fetchBuiltInCMap(nome);
  const cMap = new CMap(true);
  se (compressionType === _util.CMapCompressionType.BINARY) {
    restituisce nuovo _binary_cmap.BinaryCMapReader().process(cMapData, cMap, useCMap => {
      restituisci extendCMap(cMap, fetchBuiltInCMap, useCMap);
    });
  }
  se (compressionType === _util.CMapCompressionType.NONE) {
    const lexer = new _parser.Lexer(new _stream.Stream(cMapData));
    restituisci parseCMap(cMap, lexer, fetchBuiltInCMap, null);
  }
  genera un nuovo errore(`Valore "compressionType" CMap non valido: ${compressionType}`);
}
classe CMapFactory {
  statico asincrono crea({
    codifica,
    fetchBuiltInCMap,
    usaCMap
  }) {
    se (codifica instanceof _primitives.Name) {
      restituisci createBuiltInCMap(encoding.name, fetchBuiltInCMap);
    } altrimenti se (codifica instanceof _base_stream.BaseStream) {
      const parsedCMap = await parseCMap(new CMap(), new _parser.Lexer(encoding), fetchBuiltInCMap, useCMap);
      se (parsedCMap.isIdentityCMap) {
        restituisci createBuiltInCMap(parsedCMap.name, fetchBuiltInCMap);
      }
      restituisci parsedCMap;
    }
    throw new Error("Codifica richiesta.");
  }
}
esportazioni.CMapFactory = CMapFactory;

/***/ }),
/* 15 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.BinaryCMapReader = void 0;
var _util = __w_pdfjs_require__(2);
funzione hexToInt(a, dimensione) {
  sia n = 0;
  per (lascia che i = 0; i <= dimensione; i++) {
    n = n << 8 | a[i];
  }
  restituisci n >>> 0;
}
funzione hexToStr(a, dimensione) {
  se (dimensione === 1) {
    restituisci String.fromCharCode(a[0], a[1]);
  }
  se (dimensione === 3) {
    restituisci String.fromCharCode(a[0], a[1], a[2], a[3]);
  }
  restituisci String.fromCharCode(...a.subarray(0, dimensione + 1));
}
funzione addHex(a, b, dimensione) {
  sia c = 0;
  per (lascia che i = dimensione; i >= 0; i--) {
    c += a[i] + b[i];
    a[i] = c & 255;
    c >>= 8;
  }
}
funzione incHex(a, dimensione) {
  sia c = 1;
  per (lascia che i = dimensione; i >= 0 && c > 0; i--) {
    c += a[i];
    a[i] = c & 255;
    c >>= 8;
  }
}
const MAX_NUM_SIZE = 16;
const MAX_ENCODED_NUM_SIZE = 19;
classe BinaryCMapStream {
  costruttore(dati) {
    questo.buffer = dati;
    questo.pos = 0;
    this.end = data.length;
    this.tmpBuf = new Uint8Array(MAX_ENCODED_NUM_SIZE);
  }
  leggiByte() {
    se (this.pos >= this.end) {
      restituisci -1;
    }
    restituisci questo.buffer[questo.pos++];
  }
  leggiNumero() {
    sia n = 0;
    lasciare durare;
    Fare {
      const b = this.readByte();
      se (b < 0) {
        throw new _util.FormatError("EOF imprevisto in bcmap");
      }
      ultimo = !(b & 0x80);
      n = n << 7 | b & 0x7f;
    } while (!last);
    restituisci n;
  }
  leggiFirmato() {
    const n = this.readNumber();
    restituisci n & 1 ? ~(n >>> 1) : n >>> 1;
  }
  readHex(num, dimensione) {
    num.set(this.buffer.subarray(this.pos, this.pos + size + 1));
    this.pos += dimensione + 1;
  }
  readHexNumber(num, dimensione) {
    lasciare durare;
    const stack = this.tmpBuf;
    lascia sp = 0;
    Fare {
      const b = this.readByte();
      se (b < 0) {
        throw new _util.FormatError("EOF imprevisto in bcmap");
      }
      ultimo = !(b & 0x80);
      pila[sp++] = b & 0x7f;
    } while (!last);
    sia i = dimensione,
      buffer = 0,
      bufferSize = 0;
    mentre (i >= 0) {
      while (bufferSize < 8 && stack.length > 0) {
        buffer |= stack[--sp] << dimensionebuffer;
        bufferSize += 7;
      }
      num[i] = buffer & 255;
      io--;
      buffer >>= 8;
      bufferSize -= 8;
    }
  }
  readHexSigned(num, dimensione) {
    this.readHexNumber(num, dimensione);
    const sign = num[size] & 1 ? 255 : 0;
    sia c = 0;
    per (lascia che i = 0; i <= dimensione; i++) {
      c = (c & 1) << 8 | num[i];
      num[i] = c >> 1 segno ^;
    }
  }
  leggiString() {
    const len ​​= this.readNumber(),
      buf = nuovo Array(len);
    per (lascia che i = 0; i < len; i++) {
      buf[i] = this.readNumber();
    }
    restituisci String.fromCharCode(...buf);
  }
}
classe BinaryCMapReader {
  processo asincrono (dati, cMap, estensione) {
    flusso costante = nuovo BinaryCMapStream(dati);
    const header = stream.readByte();
    cMap.vertical = !!(intestazione & 1);
    lascia che useCMap = null;
    const start = new Uint8Array(MAX_NUM_SIZE);
    const end = new Uint8Array(MAX_NUM_SIZE);
    const char = new Uint8Array(MAX_NUM_SIZE);
    const charCode = new Uint8Array(MAX_NUM_SIZE);
    const tmp = new Uint8Array(MAX_NUM_SIZE);
    lascia il codice;
    lascia b;
    mentre ((b = stream.readByte()) >= 0) {
      tipo costante = b >> 5;
      se (tipo === 7) {
        interruttore (b & 0x1f) {
          caso 0:
            stream.readString();
            rottura;
          caso 1:
            useCMap = stream.readString();
            rottura;
        }
        continuare;
      }
      sequenza costante = !!(b & 0x10);
      const dataSize = b & 15;
      se (dataSize + 1 > MAX_NUM_SIZE) {
        genera un nuovo errore("BinaryCMapReader.process: dataSize non valido.");
      }
      const ucs2DataSize = 1;
      const subitemsCount = stream.readNumber();
      interruttore (tipo) {
        caso 0:
          stream.readHex(inizio, dataSize);
          stream.readHexNumber(fine, dimensione dati);
          addHex(fine, inizio, dimensione dati);
          cMap.addCodespaceRange(dataSize + 1, hexToInt(inizio, dataSize), hexToInt(fine, dataSize));
          per (lascia che i = 1; i < subitemsCount; i++) {
            incHex(fine, dimensione dati);
            stream.readHexNumber(inizio, dataSize);
            addHex(inizio, fine, dimensione dati);
            stream.readHexNumber(fine, dimensione dati);
            addHex(fine, inizio, dimensione dati);
            cMap.addCodespaceRange(dataSize + 1, hexToInt(inizio, dataSize), hexToInt(fine, dataSize));
          }
          rottura;
        caso 1:
          stream.readHex(inizio, dataSize);
          stream.readHexNumber(fine, dimensione dati);
          addHex(fine, inizio, dimensione dati);
          stream.readNumber();
          per (lascia che i = 1; i < subitemsCount; i++) {
            incHex(fine, dimensione dati);
            stream.readHexNumber(inizio, dataSize);
            addHex(inizio, fine, dimensione dati);
            stream.readHexNumber(fine, dimensione dati);
            addHex(fine, inizio, dimensione dati);
            stream.readNumber();
          }
          rottura;
        caso 2:
          stream.readHex(char, dataSize);
          codice = stream.readNumber();
          cMap.mapOne(hexToInt(char, dataSize), codice);
          per (lascia che i = 1; i < subitemsCount; i++) {
            incHex(char, dataSize);
            se (!sequenza) {
              stream.readHexNumber(tmp, dataSize);
              addHex(char, tmp, dataSize);
            }
            codice = stream.readSigned() + (codice + 1);
            cMap.mapOne(hexToInt(char, dataSize), codice);
          }
          rottura;
        caso 3:
          stream.readHex(inizio, dataSize);
          stream.readHexNumber(fine, dimensione dati);
          addHex(fine, inizio, dimensione dati);
          codice = stream.readNumber();
          cMap.mapCidRange(hexToInt(inizio, dimensione dati), hexToInt(fine, dimensione dati), codice);
          per (lascia che i = 1; i < subitemsCount; i++) {
            incHex(fine, dimensione dati);
            se (!sequenza) {
              stream.readHexNumber(inizio, dataSize);
              addHex(inizio, fine, dimensione dati);
            } altro {
              inizio.imposta(fine);
            }
            stream.readHexNumber(fine, dimensione dati);
            addHex(fine, inizio, dimensione dati);
            codice = stream.readNumber();
            cMap.mapCidRange(hexToInt(inizio, dimensione dati), hexToInt(fine, dimensione dati), codice);
          }
          rottura;
        caso 4:
          stream.readHex(char, ucs2DataSize);
          stream.readHex(charCode, dataSize);
          cMap.mapOne(hexToInt(char, ucs2DataSize), hexToStr(charCode, dataSize));
          per (lascia che i = 1; i < subitemsCount; i++) {
            incHex(char, ucs2DataSize);
            se (!sequenza) {
              stream.readHexNumber(tmp, ucs2DataSize);
              addHex(char, tmp, ucs2DataSize);
            }
            incHex(charCode, dataSize);
            stream.readHexSigned(tmp, dataSize);
            addHex(charCode, tmp, dataSize);
            cMap.mapOne(hexToInt(char, ucs2DataSize), hexToStr(charCode, dataSize));
          }
          rottura;
        caso 5:
          stream.readHex(inizio, ucs2DataSize);
          stream.readHexNumber(fine, ucs2DataSize);
          addHex(fine, inizio, ucs2DataSize);
          stream.readHex(charCode, dataSize);
          cMap.mapBfRange(hexToInt(inizio, ucs2DataSize), hexToInt(fine, ucs2DataSize), hexToStr(charCode, dataSize));
          per (lascia che i = 1; i < subitemsCount; i++) {
            incHex(fine, ucs2DataSize);
            se (!sequenza) {
              stream.readHexNumber(inizio, ucs2DataSize);
              addHex(inizio, fine, ucs2DataSize);
            } altro {
              inizio.imposta(fine);
            }
            stream.readHexNumber(fine, ucs2DataSize);
            addHex(fine, inizio, ucs2DataSize);
            stream.readHex(charCode, dataSize);
            cMap.mapBfRange(hexToInt(inizio, ucs2DataSize), hexToInt(fine, ucs2DataSize), hexToStr(charCode, dataSize));
          }
          rottura;
        predefinito:
          genera un nuovo errore (`BinaryCMapReader.process - tipo sconosciuto: ${type}`);
      }
    }
    se (usaCMap) {
      restituisci estendi(usaCMap);
    }
    restituisci cMap;
  }
}
esportazioni.BinaryCMapReader = BinaryCMapReader;

/***/ }),
/* 16 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.Parser = esportazioni.Linearizzazione = esportazioni.Lexer = void 0;
var _util = __w_pdfjs_require__(2);
var _primitives = __w_pdfjs_require__(4);
var _core_utils = __w_pdfjs_require__(3);
var _stream = __w_pdfjs_require__(8);
variabile _ascii_85_stream = __w_pdfjs_require__(17);
var _ascii_hex_stream = __w_pdfjs_require__(19);
var _ccitt_stream = __w_pdfjs_require__(20);
var _flate_stream = __w_pdfjs_require__(22);
variabile _jbig2_stream = __w_pdfjs_require__(23);
var _jpeg_stream = __w_pdfjs_require__(26);
variabile _jpx_stream = __w_pdfjs_require__(29);
var _lzw_stream = __w_pdfjs_require__(31);
var _predictor_stream = __w_pdfjs_require__(32);
var _run_length_stream = __w_pdfjs_require__(33);
const MAX_LENGTH_TO_CACHE = 1000;
funzione getInlineImageCacheKey(byte) {
  costante strBuf = [],
    ii = byte.lunghezza;
  sia i = 0;
  mentre (i < ii - 1) {
    strBuf.push(byte[i++] << 8 | byte[i++]);
  }
  se (i < ii) {
    strBuf.push(byte[i]);
  }
  restituisci ii + "_" + String.fromCharCode.apply(null, strBuf);
}
classe Parser {
  costruttore({
    lessicografo,
    riferimento esterno,
    allowStreams = falso,
    recoveryMode = falso
  }) {
    questo.lexer = lexer;
    questo.xref = xref;
    questo.allowStreams = allowStreams;
    this.recoveryMode = recoveryMode;
    this.imageCache = Object.create(null);
    questo._imageId = 0;
    questo.ricarica();
  }
  ricarica() {
    questo.buf1 = questo.lexer.getObj();
    questo.buf2 = questo.lexer.getObj();
  }
  spostare() {
    se (this.buf2 instanceof _primitives.Cmd && this.buf2.cmd === "ID") {
      questo.buf1 = questo.buf2;
      this.buf2 = null;
    } altro {
      questo.buf1 = questo.buf2;
      questo.buf2 = questo.lexer.getObj();
    }
  }
  provaShift() {
    Tentativo {
      questo.shift();
      restituisci vero;
    } cattura (e) {
      se (e instanceof _core_utils.MissingDataException) {
        lanciare e;
      }
      restituisci falso;
    }
  }
  getObj(cipherTransform = null) {
    const buf1 = this.buf1;
    questo.shift();
    se (buf1 instanceof _primitives.Cmd) {
      interruttore (buf1.cmd) {
        caso "BI":
          restituisci this.makeInlineImage(cipherTransform);
        caso "[":
          matrice costante = [];
          while (!(0, _primitives.isCmd)(this.buf1, "]") && this.buf1 !== _primitives.EOF) {
            array.push(this.getObj(cipherTransform));
          }
          se (this.buf1 === _primitives.EOF) {
            se (this.recoveryMode) {
              restituisci array;
            }
            throw new _core_utils.ParserEOFException("Fine del file all'interno dell'array.");
          }
          questo.shift();
          restituisci array;
        caso "<<":
          const dict = new _primitives.Dict(this.xref);
          while (!(0, _primitives.isCmd)(this.buf1, ">>") && this.buf1 !== _primitives.EOF) {
            se (!(this.buf1 instanceof _primitives.Name)) {
              (0, _util.info)("Dizionario non valido: la chiave deve essere un oggetto nome");
              questo.shift();
              continuare;
            }
            const key = this.buf1.name;
            questo.shift();
            se (this.buf1 === _primitives.EOF) {
              rottura;
            }
            dict.set(chiave, this.getObj(cipherTransform));
          }
          se (this.buf1 === _primitives.EOF) {
            se (this.recoveryMode) {
              restituisci dizionario;
            }
            throw new _core_utils.ParserEOFException("Fine del file all'interno del dizionario.");
          }
          se ((0, _primitives.isCmd)(this.buf2, "flusso")) {
            restituisci this.allowStreams ? this.makeStream(dict, cipherTransform) : dict;
          }
          questo.shift();
          restituisci dizionario;
        predefinito:
          restituisci buf1;
      }
    }
    se (Numero.èIntero(buf1)) {
      se (Number.isInteger(this.buf1) && (0, _primitives.isCmd)(this.buf2, "R")) {
        const ref = _primitives.Ref.get(buf1, this.buf1);
        questo.shift();
        questo.shift();
        restituisci ref;
      }
      restituisci buf1;
    }
    se (tipo di buf1 === "stringa") {
      se (cipherTransform) {
        restituisci cipherTransform.decryptString(buf1);
      }
      restituisci buf1;
    }
    restituisci buf1;
  }
  findDefaultInlineStreamEnd(flusso) {
    costante E = 0x45,
      Io = 0x49,
      SPAZIO = 0x20,
      LF = 0xa,
      CR = 0xd,
      NULLO = 0x0;
    costante {
        comandi noti
      } = questo.analizzatore lessicale,
      startPos = stream.pos,
      n = 15;
    lascia che lo stato = 0,
      che,
      forseEIPos;
    mentre ((ch = stream.getByte()) !== -1) {
      se (stato === 0) {
        stato = ch === E ? 1 : 0;
      } altrimenti se (stato === 1) {
        stato = ch === I ? 2 : 0;
      } altro {
        se (ch === SPAZIO || ch === LF || ch === CR) {
          forseEIPos = stream.pos;
          const followingBytes = stream.peekBytes(n);
          const ii = followingBytes.length;
          se (ii === 0) {
            rottura;
          }
          per (lascia che i = 0; i < ii; i++) {
            ch = followingBytes[i];
            se (ch === NUL && followingBytes[i + 1] !== NUL) {
              continuare;
            }
            se (ch !== LF && ch !== CR && (ch < SPAZIO || ch > 0x7f)) {
              stato = 0;
              rottura;
            }
          }
          se (stato !== 2) {
            continuare;
          }
          se (!comandinoti) {
            (0, _util.warn)("findDefaultInlineStreamEnd - `lexer.knownCommands` non è definito.");
            continuare;
          }
          const tmpLexer = new Lexer(new _stream.Stream(followingBytes.slice()), knownCommands);
          tmpLexer._hexStringWarn = () => {};
          lascia numArgs = 0;
          mentre (vero) {
            const nextObj = tmpLexer.getObj();
            se (nextObj === _primitives.EOF) {
              stato = 0;
              rottura;
            }
            se (nextObj instanceof _primitives.Cmd) {
              const knownCommand = knownCommands[nextObj.cmd];
              se (!comandonoto) {
                stato = 0;
                rottura;
              } altrimenti se (knownCommand.variableArgs ? numArgs <= knownCommand.numArgs : numArgs === knownCommand.numArgs) {
                rottura;
              }
              numArgs = 0;
              continuare;
            }
            numArgs++;
          }
          se (stato === 2) {
            rottura;
          }
        } altro {
          stato = 0;
        }
      }
    }
    se (ch === -1) {
      (0, _util.warn)("findDefaultInlineStreamEnd: " + "Raggiunta la fine del flusso senza trovare un marcatore EI valido");
      se (forseEIPos) {
        (0, _util.warn)('... tentativo di ripristino utilizzando l'ultima occorrenza "EI".');
        stream.skip(-(stream.pos - maybeEIPos));
      }
    }
    lascia endOffset = 4;
    stream.skip(-endOffset);
    ch = stream.peekByte();
    stream.skip(endOffset);
    se (!(0, _core_utils.isWhiteSpace)(ch)) {
      endOffset--;
    }
    restituisci stream.pos - endOffset - startPos;
  }
  findDCTDecodeInlineStreamEnd(flusso) {
    const startPos = stream.pos;
    lascia foundEOI = false,
      B,
      lunghezza del marcatore;
    mentre ((b = stream.getByte()) !== -1) {
      se (b !== 0xff) {
        continuare;
      }
      cambia (stream.getByte()) {
        caso 0x00:
          rottura;
        caso 0xff:
          flusso.salta(-1);
          rottura;
        caso 0xd9:
          foundEOI = true;
          rottura;
        caso 0xc0:
        caso 0xc1:
        caso 0xc2:
        caso 0xc3:
        caso 0xc5:
        caso 0xc6:
        caso 0xc7:
        caso 0xc9:
        caso 0xca:
        caso 0xcb:
        caso 0xcd:
        caso 0xce:
        caso 0xcf:
        caso 0xc4:
        caso 0xcc:
        caso 0xda:
        caso 0xdb:
        caso 0xdc:
        caso 0xdd:
        caso 0xde:
        caso 0xdf:
        caso 0xe0:
        caso 0xe1:
        caso 0xe2:
        caso 0xe3:
        caso 0xe4:
        caso 0xe5:
        caso 0xe6:
        caso 0xe7:
        caso 0xe8:
        caso 0xe9:
        caso 0xea:
        caso 0xeb:
        caso 0xec:
        caso 0xed:
        caso 0xee:
        caso 0xef:
        caso 0xfe:
          lunghezza del marcatore = stream.getUint16();
          se (lunghezza del marcatore > 2) {
            stream.skip(lunghezza del marcatore - 2);
          } altro {
            flusso.salta(-2);
          }
          rottura;
      }
      se (foundEOI) {
        rottura;
      }
    }
    lunghezza costante = stream.pos - startPos;
    se (b === -1) {
      (0, _util.warn)("Flusso di immagini DCTDecode in linea: " + "marcatore EOI non trovato, si sta cercando /EI/.");
      stream.skip(-lunghezza);
      restituisci questo.findDefaultInlineStreamEnd(stream);
    }
    this.inlineStreamSkipEI(flusso);
    lunghezza di ritorno;
  }
  findASCII85DecodeInlineStreamEnd(flusso) {
    costante TILDE = 0x7e,
      GT = 0x3e;
    const startPos = stream.pos;
    lascia ch;
    mentre ((ch = stream.getByte()) !== -1) {
      se (ch === TILDE) {
        const tildePos = stream.pos;
        ch = stream.peekByte();
        mentre ((0, _core_utils.isWhiteSpace)(ch)) {
          flusso.salta();
          ch = stream.peekByte();
        }
        se (ch === GT) {
          flusso.salta();
          rottura;
        }
        se (stream.pos > tildePos) {
          const maybeEI = stream.peekBytes(2);
          se (forseEI[0] === 0x45 e forseEI[1] === 0x49) {
            rottura;
          }
        }
      }
    }
    lunghezza costante = stream.pos - startPos;
    se (ch === -1) {
      (0, _util.warn)("Flusso di immagini ASCII85Decode in linea: " + "marcatore EOD non trovato, si sta cercando /EI/.");
      stream.skip(-lunghezza);
      restituisci questo.findDefaultInlineStreamEnd(stream);
    }
    this.inlineStreamSkipEI(flusso);
    lunghezza di ritorno;
  }
  findASCIIHexDecodeInlineStreamEnd(flusso) {
    costante GT = 0x3e;
    const start Pos = stream.pos;
    lascia ch;
    mentre ((ch = stream.getByte()) !== -1) {
      se (ch === GT) {
        rottura;
      }
    }
    lunghezza costante = stream.pos - startPos;
    se (ch === -1) {
      (0, _util.warn)("Flusso di immagini ASCIIHexDecode in linea: " + "marcatore EOD non trovato, ricerca di /EI/.");
      stream.skip(-lunghezza);
      restituisci questo.findDefaultInlineStreamEnd(stream);
    }
    this.inlineStreamSkipEI(flusso);
    lunghezza di ritorno;
  }
  inlineStreamSkipEI(flusso) {
    costante E = 0x45,
      Io = 0x49;
    lascia che lo stato = 0,
      cap;
    mentre ((ch = stream.getByte()) !== -1) {
      se (stato === 0) {
        stato = ch === E ? 1 : 0;
      } altrimenti se (stato === 1) {
        stato = ch === I ? 2 : 0;
      } altrimenti se (stato === 2) {
        rottura;
      }
    }
  }
  makeInlineImage(cipherTransform) {
    const lexer = this.lexer;
    const stream = lexer.stream;
    const dictMap = Object.create(null);
    lascia dictLength;
    while (!(0, _primitives.isCmd)(this.buf1, "ID") && this.buf1 !== _primitives.EOF) {
      se (!(this.buf1 instanceof _primitives.Name)) {
        throw new _util.FormatError("La chiave del dizionario deve essere un oggetto nome");
      }
      const key = this.buf1.name;
      questo.shift();
      se (this.buf1 === _primitives.EOF) {
        rottura;
      }
      dictMap[chiave] = this.getObj(cipherTransform);
    }
    se (lexer.beginInlineImagePos !== -1) {
      dictLength = stream.pos - lexer.beginInlineImagePos;
    }
    const filter = this.xref.fetchIfRef(dictMap.F || dictMap.Filter);
    lascia filterName;
    se (filtro instanceof _primitives.Name) {
      filterName = filter.name;
    } altrimenti se (Array.isArray(filtro)) {
      const filterZero = this.xref.fetchIfRef(filter[0]);
      se (filtroZero istanza di _primitives.Nome) {
        filterName = filterZero.name;
      }
    }
    const startPos = stream.pos;
    lascia la lunghezza;
    switch (filterName) {
      caso "DCT":
      caso "DCTDecode":
        lunghezza = this.findDCTDecodeInlineStreamEnd(stream);
        rottura;
      caso "A85":
      caso "ASCII85Decode":
        lunghezza = this.findASCII85DecodeInlineStreamEnd(stream);
        rottura;
      caso "AHx":
      caso "ASCIIHexDecode":
        lunghezza = this.findASCIIHexDecodeInlineStreamEnd(stream);
        rottura;
      predefinito:
        lunghezza = this.findDefaultInlineStreamEnd(stream);
    }
    lascia cacheKey;
    se (lunghezza < MAX_LENGTH_TO_CACHE && dictLength > 0) {
      const initialStreamPos = stream.pos;
      stream.pos = lexer.beginInlineImagePos;
      cacheKey = getInlineImageCacheKey(stream.getBytes(dictLength + lunghezza));
      stream.pos = initialStreamPos;
      const cacheEntry = this.imageCache[cacheKey];
      se (cacheEntry !== non definito) {
        this.buf2 = _primitives.Cmd.get("EI");
        questo.shift();
        cacheEntry.reset();
        restituisci cacheEntry;
      }
    }
    const dict = new _primitives.Dict(this.xref);
    per (chiave costante in dictMap) {
      dict.set(chiave, dictMap[chiave]);
    }
    lascia imageStream = stream.makeSubStream(startPos, lunghezza, dizionario);
    se (cipherTransform) {
      imageStream = cipherTransform.createStream(imageStream, lunghezza);
    }
    imageStream = this.filter(imageStream, dict, lunghezza);
    imageStream.dict = dizionario;
    se (cacheKey !== non definito) {
      imageStream.cacheKey = `inline_img_${++this._imageId}`;
      this.imageCache[cacheKey] = imageStream;
    }
    this.buf2 = _primitives.Cmd.get("EI");
    questo.shift();
    restituisci imageStream;
  }
  _findStreamLength(startPos, firma) {
    costante {
      flusso
    } = this.lexer;
    stream.pos = startPos;
    const SCAN_BLOCK_LENGTH = 2048;
    const signatureLength = signature.length;
    mentre (stream.pos < stream.end) {
      const scanBytes = stream.peekBytes(SCAN_BLOCK_LENGTH);
      const scanLength = scanBytes.length - signatureLength;
      se (lunghezza scansione <= 0) {
        rottura;
      }
      lascia pos = 0;
      while (pos < lunghezza scansione) {
        sia j = 0;
        while (j < signatureLength && scanBytes[pos + j] === signature[j]) {
          j++;
        }
        se (j >= lunghezzafirma) {
          flusso.pos += pos;
          restituisci stream.pos - startPos;
        }
        posizione++;
      }
      stream.pos += lunghezza scansione;
    }
    restituisci -1;
  }
  makeStream(dict, cipherTransform) {
    const lexer = this.lexer;
    lascia flusso = lexer.stream;
    lexer.skipToNextLine();
    const startPos = stream.pos - 1;
    lascia lunghezza = dict.get("Lunghezza");
    se (!Number.isInteger(length)) {
      (0, _util.info)(`Lunghezza errata "${length && length.toString()}" nel flusso.`);
      lunghezza = 0;
    }
    stream.pos = startPos + lunghezza;
    lexer.nextChar();
    se (this.tryShift() && (0, _primitives.isCmd)(this.buf2, "endstream")) {
      questo.shift();
    } altro {
      const ENDSTREAM_SIGNATURE = new Uint8Array([0x65, 0x6e, 0x64, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d]);
      lascia actualLength = this._findStreamLength(startPos, ENDSTREAM_SIGNATURE);
      se (lunghezzaeffettiva < 0) {
        const MAX_TRUNCATION = 1;
        per (lascia che i = 1; i <= MAX_TRUNCATION; i++) {
          const end = ENDSTREAM_SIGNATURE.length - i;
          const TRUNCATED_SIGNATURE = ENDSTREAM_SIGNATURE.slice(0, fine);
          const maybeLength = this._findStreamLength(startPos, TRUNCATED_SIGNATURE);
          se (forseLunghezza >= 0) {
            const lastByte = stream.peekBytes(end + 1)[end];
            se (!(0, _core_utils.isWhiteSpace)(lastByte)) {
              rottura;
            }
            (0, _util.info)(`Trovato "${(0, _util.bytesToString)(TRUNCATED_SIGNATURE)}" durante la ricerca del comando endstream. ` + ");
            lunghezzaeffettiva = lunghezzaforse;
            rottura;
          }
        }
        se (lunghezzaeffettiva < 0) {
          throw new _util.FormatError("Comando endstream mancante.");
        }
      }
      lunghezza = lunghezzaeffettiva;
      lexer.nextChar();
      questo.shift();
      questo.shift();
    }
    questo.shift();
    flusso = stream.makeSubStream(startPos, lunghezza, dizionario);
    se (cipherTransform) {
      flusso = cipherTransform.createStream(flusso, lunghezza);
    }
    flusso = this.filter(flusso, dizionario, lunghezza);
    stream.dict = dizionario;
    flusso di ritorno;
  }
  filtro(flusso, dizionario, lunghezza) {
    lascia filtro = dict.get("F", "Filtro");
    lascia parametri = dict.get("DP", "DecodeParms");
    se (filtro instanceof _primitives.Name) {
      se (Array.isArray(parametri)) {
        (0, _util.warn)("/DecodeParms non dovrebbe essere un Array, quando /Filter è un Name.");
      }
      restituisci this.makeFilter(stream, filter.name, length, params);
    }
    lascia che forseLunghezza = lunghezza;
    se (Array.isArray(filtro)) {
      const filterArray = filtro;
      const paramsArray = params;
      per (lascia che i = 0, ii = filterArray.length; i < ii; ++i) {
        filtro = this.xref.fetchIfRef(filterArray[i]);
        se (!(filtro instanceof _primitives.Name)) {
          throw new _util.FormatError(`Nome del filtro non valido "${filter}"`);
        }
        parametri = null;
        se (Array.isArray(paramsArray) && i in paramsArray) {
          parametri = this.xref.fetchIfRef(paramsArray[i]);
        }
        flusso = this.makeFilter(flusso, nome filtro, forse lunghezza, parametri);
        forseLunghezza = null;
      }
    }
    flusso di ritorno;
  }
  makeFilter(stream, nome, maybeLength, parametri) {
    se (forseLunghezza === 0) {
      (0, _util.warn)(`Flusso "${name}" vuoto.`);
      restituisci nuovo _stream.NullStream();
    }
    Tentativo {
      interruttore (nome) {
        caso "Fl":
        caso "FlateDecode":
          se (parametri) {
            restituisci nuovo _predictor_stream.PredictorStream(nuovo _flate_stream.FlateStream(stream, maybeLength), maybeLength, parametri);
          }
          restituisci nuovo _flate_stream.FlateStream(stream, maybeLength);
        caso "LZW":
        caso "LZWDecode":
          lascia earlyChange = 1;
          se (parametri) {
            se (params.has("EarlyChange")) {
              earlyChange = params.get("EarlyChange");
            }
            restituisci nuovo _predictor_stream.PredictorStream(nuovo _lzw_stream.LZWStream(stream, maybeLength, earlyChange), maybeLength, params);
          }
          restituisci nuovo _lzw_stream.LZWStream(stream, maybeLength, earlyChange);
        caso "DCT":
        caso "DCTDecode":
          restituisci nuovo _jpeg_stream.JpegStream(stream, maybeLength, params);
        caso "JPX":
        caso "JPXDecode":
          restituisci nuovo _jpx_stream.JpxStream(stream, maybeLength, params);
        caso "A85":
        caso "ASCII85Decode":
          restituisci nuovo _ascii_85_stream.Ascii85Stream(stream, maybeLength);
        caso "AHx":
        caso "ASCIIHexDecode":
          restituisci nuovo _ascii_hex_stream.AsciiHexStream(stream, maybeLength);
        caso "CCF":
        caso "CCITTFaxDecode":
          restituisci nuovo _ccitt_stream.CCITTFaxStream(stream, maybeLength, params);
        caso "RL":
        caso "RunLengthDecode":
          restituisci nuovo _run_length_stream.RunLengthStream(stream, maybeLength);
        caso "JBIG2Decode":
          restituisci nuovo _jbig2_stream.Jbig2Stream(stream, maybeLength, params);
      }
      (0, _util.warn)(`Il filtro "${name}" non è supportato.`);
      flusso di ritorno;
    } catturare (es.) {
      se (ad esempio instanceof _core_utils.MissingDataException) {
        lanciare ex;
      }
      (0, _util.warn)(`Flusso non valido: "${ex}"`);
      restituisci nuovo _stream.NullStream();
    }
  }
}
esportazioni.Parser = Parser;
const specialChars = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2 ... 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
funzione toHexDigit(ch) {
  se (ch >= 0x30 e ch <= 0x39) {
    restituisci ch & 0x0f;
  }
  se (ch >= 0x41 e ch <= 0x46 || ch >= 0x61 e ch <= 0x66) {
    ritorno (ch & 0x0f) + 9;
  }
  restituisci -1;
}
classe Lexer {
  costruttore(flusso, comandi noti = null) {
    questo.flusso = flusso;
    questo.nextChar();
    questo.strBuf = [];
    questo.comandinoti = comandinoti;
    this._hexStringNumWarn = 0;
    this.beginInlineImagePos = -1;
  }
  nextChar() {
    restituisci this.currentChar = this.stream.getByte();
  }
  peekChar() {
    restituisci this.stream.peekByte();
  }
  ottieniNumero() {
    lascia ch = this.currentChar;
    lascia eNotation = false;
    lascia divideBy = 0;
    lascia segno = 1;
    se (ch === 0x2d) {
      segno = -1;
      ch = this.nextChar();
      se (ch === 0x2d) {
        ch = this.nextChar();
      }
    } altrimenti se (ch === 0x2b) {
      ch = this.nextChar();
    }
    se (ch === 0x0a || ch === 0x0d) {
      Fare {
        ch = this.nextChar();
      } while (ch === 0x0a || ch === 0x0d);
    }
    se (ch === 0x2e) {
      divideBy = 10;
      ch = this.nextChar();
    }
    se (ch < 0x30 || ch > 0x39) {
      const msg = `Numero non valido: ${String.fromCharCode(ch)} (charCode ${ch})`;
      se ((0, _core_utils.isWhiteSpace)(ch) || ch === -1) {
        (0, _util.info)(`Lexer.getNumber - "${msg}".`);
        restituisci 0;
      }
      lancia nuovo _util.FormatError(msg);
    }
    lascia baseValue = ch - 0x30;
    lascia che powerValue = 0;
    lascia che powerValueSign = 1;
    mentre ((ch = this.nextChar()) >= 0) {
      se (ch >= 0x30 e ch <= 0x39) {
        const currentDigit = ch - 0x30;
        se (eNotazione) {
          powerValue = powerValue * 10 + currentDigit;
        } altro {
          se (divideBy !== 0) {
            divideBy *= 10;
          }
          baseValue = baseValue * 10 + currentDigit;
        }
      } altrimenti se (ch === 0x2e) {
        se (divideBy === 0) {
          divideBy = 1;
        } altro {
          rottura;
        }
      } altrimenti se (ch === 0x2d) {
        (0, _util.warn)("Numero formattato male: segno meno al centro");
      } altrimenti se (ch === 0x45 || ch === 0x65) {
        ch = this.peekChar();
        se (ch === 0x2b || ch === 0x2d) {
          powerValueSign = ch === 0x2d ? -1 : 1;
          questo.nextChar();
        } altrimenti se (ch < 0x30 || ch > 0x39) {
          rottura;
        }
        eNotazione = vero;
      } altro {
        rottura;
      }
    }
    se (divideBy !== 0) {
      baseValue /= divideBy;
    }
    se (eNotazione) {
      baseValue *= 10 ** (powerValueSign * powerValue);
    }
    segno di ritorno * baseValue;
  }
  ottieniStringa() {
    lascia numParen = 1;
    lascia fatto = falso;
    const strBuf = this.strBuf;
    strBuf.length = 0;
    lascia ch = this.nextChar();
    mentre (vero) {
      lascia che charBuffered = false;
      interruttore (ch | 0) {
        caso -1:
          (0, _util.warn)("Stringa non terminata");
          fatto = vero;
          rottura;
        caso 0x28:
          ++numParen;
          strBuf.push("(");
          rottura;
        caso 0x29:
          se (--numParen === 0) {
            questo.nextChar();
            fatto = vero;
          } altro {
            strBuf.push(")");
          }
          rottura;
        caso 0x5c:
          ch = this.nextChar();
          interruttore (ch) {
            caso -1:
              (0, _util.warn)("Stringa non terminata");
              fatto = vero;
              rottura;
            caso 0x6e:
              strBuf.push("\n");
              rottura;
            caso 0x72:
              strBuf.push("\r");
              rottura;
            caso 0x74:
              strBuf.push("\t");
              rottura;
            caso 0x62:
              strBuf.push("\b");
              rottura;
            caso 0x66:
              strBuf.push("\f");
              rottura;
            caso 0x5c:
            caso 0x28:
            caso 0x29:
              strBuf.push(String.fromCharCode(ch));
              rottura;
            caso 0x30:
            caso 0x31:
            caso 0x32:
            caso 0x33:
            caso 0x34:
            caso 0x35:
            caso 0x36:
            caso 0x37:
              lascia x = ch & 0x0f;
              ch = this.nextChar();
              charBuffered = true;
              se (ch >= 0x30 e ch <= 0x37) {
                x = (x << 3) + (ch & 0x0f);
                ch = this.nextChar();
                se (ch >= 0x30 e ch <= 0x37) {
                  charBuffered = false;
                  x = (x << 3) + (ch & 0x0f);
                }
              }
              strBuf.push(String.fromCharCode(x));
              rottura;
            caso 0x0d:
              se (this.peekChar() === 0x0a) {
                questo.nextChar();
              }
              rottura;
            caso 0x0a:
              rottura;
            predefinito:
              strBuf.push(String.fromCharCode(ch));
              rottura;
          }
          rottura;
        predefinito:
          strBuf.push(String.fromCharCode(ch));
          rottura;
      }
      se (fatto) {
        rottura;
      }
      se (!charBuffered) {
        ch = this.nextChar();
      }
    }
    restituisci strBuf.join("");
  }
  getName() {
    lascia ch, previousCh;
    const strBuf = this.strBuf;
    strBuf.length = 0;
    while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
      se (ch === 0x23) {
        ch = this.nextChar();
        se (specialChars[ch]) {
          (0, _util.warn)("Lexer_getName: " + "IL SEGNO DI CANCELLAZIONE (#) deve essere seguito da un numero esadecimale.");
          strBuf.push("#");
          rottura;
        }
        const x = toHexDigit(ch);
        se (x !== -1) {
          precedenteCh = ch;
          ch = this.nextChar();
          const x2 = toHexDigit(ch);
          se (x2 === -1) {
            (0, _util.warn)(`Lexer_getName: cifra illegale (${String.fromCharCode(ch)}) ` + "in numero esadecimale.");
            strBuf.push("#", String.fromCharCode(previousCh));
            se (specialChars[ch]) {
              rottura;
            }
            strBuf.push(String.fromCharCode(ch));
            continuare;
          }
          strBuf.push(String.fromCharCode(x << 4 | x2));
        } altro {
          strBuf.push("#", String.fromCharCode(ch));
        }
      } altro {
        strBuf.push(String.fromCharCode(ch));
      }
    }
    se (strBuf.length > 127) {
      (0, _util.warn)(`Il token del nome è più lungo di quanto consentito dalla specifica: ${strBuf.length}`);
    }
    restituisci _primitives.Name.get(strBuf.join(""));
  }
  _hexStringWarn(ch) {
    const MAX_HEX_STRING_NUM_WARN = 5;
    se (this._hexStringNumWarn++ === MAX_HEX_STRING_NUM_WARN) {
      (0, _util.warn)("getHexString - ignora i caratteri non validi aggiuntivi.");
      ritorno;
    }
    se (this._hexStringNumWarn > MAX_HEX_STRING_NUM_WARN) {
      ritorno;
    }
    (0, _util.warn)(`getHexString - ignorare il carattere non valido: ${ch}`);
  }
  getHexString() {
    const strBuf = this.strBuf;
    strBuf.length = 0;
    lascia ch = this.currentChar;
    lascia che isFirstHex = true;
    lascia primaCifra, secondaCifra;
    this._hexStringNumWarn = 0;
    mentre (vero) {
      se (ch < 0) {
        (0, _util.warn)("Stringa esadecimale non terminata");
        rottura;
      } altrimenti se (ch === 0x3e) {
        questo.nextChar();
        rottura;
      } altrimenti se (specialChars[ch] === 1) {
        ch = this.nextChar();
        continuare;
      } altro {
        se (èFirstHex) {
          firstDigit = toHexDigit(ch);
          se (primacifra === -1) {
            this._hexStringWarn(ch);
            ch = this.nextChar();
            continuare;
          }
        } altro {
          secondDigit = toHexDigit(ch);
          se (secondacifra === -1) {
            this._hexStringWarn(ch);
            ch = this.nextChar();
            continuare;
          }
          strBuf.push(String.fromCharCode(firstDigit << 4 | secondDigit));
        }
        èPrimoEsadecimale = !èPrimoEsadecimale;
        ch = this.nextChar();
      }
    }
    restituisci strBuf.join("");
  }
  getObj() {
    lascia commento = falso;
    lascia ch = this.currentChar;
    mentre (vero) {
      se (ch < 0) {
        restituisci _primitives.EOF;
      }
      se (commento) {
        se (ch === 0x0a || ch === 0x0d) {
          commento = falso;
        }
      } altrimenti se (ch === 0x25) {
        commento = vero;
      } altrimenti se (specialChars[ch] !== 1) {
        rottura;
      }
      ch = this.nextChar();
    }
    interruttore (ch | 0) {
      caso 0x30:
      caso 0x31:
      caso 0x32:
      caso 0x33:
      caso 0x34:
      caso 0x35:
      caso 0x36:
      caso 0x37:
      caso 0x38:
      caso 0x39:
      caso 0x2b:
      caso 0x2d:
      caso 0x2e:
        restituisci questo.getNumber();
      caso 0x28:
        restituisci questo.getString();
      caso 0x2f:
        restituisci questo.getName();
      caso 0x5b:
        questo.nextChar();
        restituisci _primitives.Cmd.get("[");
      caso 0x5d:
        questo.nextChar();
        restituisci _primitives.Cmd.get("]");
      caso 0x3c:
        ch = this.nextChar();
        se (ch === 0x3c) {
          questo.nextChar();
          restituisci _primitives.Cmd.get("<<");
        }
        restituisci questo.getHexString();
      caso 0x3e:
        ch = this.nextChar();
        se (ch === 0x3e) {
          questo.nextChar();
          restituisci _primitives.Cmd.get(">>");
        }
        restituisci _primitives.Cmd.get(">");
      caso 0x7b:
        questo.nextChar();
        restituisci _primitives.Cmd.get("{");
      caso 0x7d:
        questo.nextChar();
        restituisci _primitives.Cmd.get("}");
      caso 0x29:
        questo.nextChar();
        throw new _util.FormatError(`Carattere non valido: ${ch}`);
    }
    lascia str = String.fromCharCode(ch);
    se (ch < 0x20 || ch > 0x7f) {
      const nextCh = this.peekChar();
      se (nextCh >= 0x20 e nextCh <= 0x7f) {
        questo.nextChar();
        restituisci _primitives.Cmd.get(str);
      }
    }
    const knownCommands = this.knownCommands;
    lascia knownCommandFound = knownCommands?.[str] !== indefinito;
    while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
      const possibleCommand = str + String.fromCharCode(ch);
      se (comandonototrovato e comandinoti[comandopossibile] === indefinito) {
        rottura;
      }
      se (str.length === 128) {
        throw new _util.FormatError(`Token di comando troppo lungo: ${str.length}`);
      }
      str = possibileComando;
      knownCommandFound = knownCommands?.[str] !== indefinito;
    }
    se (str === "vero") {
      restituisci vero;
    }
    se (str === "falso") {
      restituisci falso;
    }
    se (str === "null") {
      restituisci null;
    }
    se (str === "BI") {
      this.beginInlineImagePos = this.stream.pos;
    }
    restituisci _primitives.Cmd.get(str);
  }
  salta alla riga successiva() {
    lascia ch = this.currentChar;
    mentre (ch >= 0) {
      se (ch === 0x0d) {
        ch = this.nextChar();
        se (ch === 0x0a) {
          questo.nextChar();
        }
        rottura;
      } altrimenti se (ch === 0x0a) {
        questo.nextChar();
        rottura;
      }
      ch = this.nextChar();
    }
  }
}
esportazioni.Lexer = Lexer;
classe Linearizzazione {
  statico crea(flusso) {
    funzione getInt(linDict, nome, consentZeroValue = false) {
      const obj = linDict.get(nome);
      se (Number.isInteger(obj) && (allowZeroValue ? obj >= 0 : obj > 0)) {
        restituisci oggetto;
      }
      throw new Error(`Il parametro "${name}" nel dizionario di linearizzazione ` + "non è valido.");
    }
    funzione getHints(linDict) {
      suggerimenti costanti = linDict.get("H");
      lascia suggerimentiLunghezza;
      se (Array.isArray(suggerimenti) && ((lunghezzasuggerimenti = lunghezzasuggerimenti) === 2 || lunghezzasuggerimenti === 4)) {
        per (let index = 0; index < hintsLength; index++) {
          const suggerimento = suggerimenti[indice];
          se (!(Number.isInteger(suggerimento) && suggerimento > 0)) {
            throw new Error(`Il suggerimento (${index}) nel dizionario di linearizzazione non è valido.`);
          }
        }
        restituire suggerimenti;
      }
      throw new Error("L'array di suggerimenti nel dizionario di linearizzazione non è valido.");
    }
    const parser = nuovo Parser({
      lexer: nuovo Lexer(flusso),
      riferimento esterno: nullo
    });
    const obj1 = parser.getObj();
    const obj2 = parser.getObj();
    const obj3 = parser.getObj();
    const linDict = parser.getObj();
    lascia obj, lunghezza;
    se (!(Number.isInteger(obj1) && Number.isInteger(obj2) && (0, _primitives.isCmd)(obj3, "obj") && linDict instanceof _primitives.Dict && typeof (obj = linDict.get("Linearizzato")) === "numero" && obj > 0)) {
      restituisci null;
    } altrimenti se ((lunghezza = getInt(linDict, "L")) !== stream.length) {
      throw new Error('Il parametro "L" nel dizionario di linearizzazione ' + "non è uguale alla lunghezza del flusso.");
    }
    ritorno {
      lunghezza,
      suggerimenti: getHints(linDict),
      objectNumberFirst: getInt(linDict, "O"),
      endFirst: getInt(linDict, "E"),
      numPagine: getInt(linDict, "N"),
      mainXRefEntriesOffset: getInt(linDict, "T"),
      pageFirst: linDict.has("P") ? getInt(linDict, "P", true) : 0
    };
  }
}
esportazioni.Linearizzazione = Linearizzazione;

/***/ }),
/* 17 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.Ascii85Stream = void 0;
var _decode_stream = __w_pdfjs_require__(18);
var _core_utils = __w_pdfjs_require__(3);
classe Ascii85Stream estende _decode_stream.DecodeStream {
  costruttore(str, forseLunghezza) {
    se (forseLunghezza) {
      forseLunghezza *= 0,8;
    }
    super(forseLunghezza);
    questo.str = str;
    questo.dizionario = str.dizionario;
    questo.input = nuovo Uint8Array(5);
  }
  readBlock() {
    const TILDA_CHAR = 0x7e;
    const Z_LOWER_CHAR = 0x7a;
    costante EOF = -1;
    const str = this.str;
    lascia c = str.getByte();
    mentre ((0, _core_utils.isWhiteSpace)(c)) {
      c = str.getByte();
    }
    se (c === EOF || c === TILDA_CHAR) {
      this.eof = true;
      ritorno;
    }
    const bufferLength = this.bufferLength;
    lascia buffer, i;
    se (c === Z_LOWER_CHAR) {
      buffer = this.ensureBuffer(lunghezzabuffer + 4);
      per (i = 0; i < 4; ++i) {
        buffer[lunghezzabuffer + i] = 0;
      }
      questo.bufferLength += 4;
    } altro {
      const input = this.input;
      ingresso[0] = c;
      per (i = 1; i < 5; ++i) {
        c = str.getByte();
        mentre ((0, _core_utils.isWhiteSpace)(c)) {
          c = str.getByte();
        }
        input[i] = c;
        se (c === EOF || c === TILDA_CHAR) {
          rottura;
        }
      }
      buffer = this.ensureBuffer(bufferLength + i - 1);
      this.bufferLength += i - 1;
      se (i < 5) {
        per (; i < 5; ++i) {
          input[i] = 0x21 + 84;
        }
        this.eof = true;
      }
      sia t = 0;
      per (i = 0; i < 5; ++i) {
        t = t * 85 + (input[i] - 0x21);
      }
      per (i = 3; i >= 0; --i) {
        buffer[lunghezzabuffer + i] = t & 0xff;
        t >>= 8;
      }
    }
  }
}
esportazioni.Ascii85Stream = Ascii85Stream;

/***/ }),
/* 18 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.StreamsSequenceStream = esportazioni.DecodeStream = void 0;
var _base_stream = __w_pdfjs_require__(5);
var _stream = __w_pdfjs_require__(8);
const emptyBuffer = new Uint8Array(0);
classe DecodeStream estende _base_stream.BaseStream {
  costruttore(forseMinBufferLength) {
    super();
    this._rawMinBufferLength = maybeMinBufferLength || 0;
    questo.pos = 0;
    questo.bufferLength = 0;
    this.eof = false;
    questo.buffer = buffervuoto;
    this.minBufferLength = 512;
    se (forseMinBufferLength) {
      while (this.minBufferLength < maybeMinBufferLength) {
        this.minBufferLength *= 2;
      }
    }
  }
  ottieni isEmpty() {
    while (!this.eof && this.bufferLength === 0) {
      questo.readBlock();
    }
    restituisci questo.bufferLength === 0;
  }
  ensureBuffer(richiesto) {
    const buffer = this.buffer;
    se (richiesto <= buffer.byteLength) {
      buffer di ritorno;
    }
    lascia dimensione = this.minBufferLength;
    mentre (dimensione < richiesta) {
      dimensione *= 2;
    }
    const buffer2 = new Uint8Array(dimensione);
    buffer2.set(buffer);
    restituisci questo.buffer = buffer2;
  }
  getByte() {
    const pos = this.pos;
    while (this.bufferLength <= pos) {
      se (questo.eof) {
        restituisci -1;
      }
      questo.readBlock();
    }
    restituisci questo.buffer[questo.pos++];
  }
  getBytes(lunghezza) {
    const pos = this.pos;
    lascia finire;
    se (lunghezza) {
      this.ensureBuffer(pos + lunghezza);
      fine = pos + lunghezza;
      while (!this.eof && this.bufferLength < end) {
        questo.readBlock();
      }
      const bufEnd = this.bufferLength;
      se (fine > bufEnd) {
        fine = bufEnd;
      }
    } altro {
      mentre (!this.eof) {
        questo.readBlock();
      }
      fine = questo.bufferLength;
    }
    questo.pos = fine;
    restituisci questo.buffer.subarray(pos, fine);
  }
  reimposta() {
    questo.pos = 0;
  }
  makeSubStream(inizio, lunghezza, dizionario = null) {
    se (lunghezza === indefinito) {
      mentre (!this.eof) {
        questo.readBlock();
      }
    } altro {
      const fine = inizio + lunghezza;
      while (this.bufferLength <= end && !this.eof) {
        questo.readBlock();
      }
    }
    restituisci nuovo _stream.Stream(this.buffer, inizio, lunghezza, dizionario);
  }
  getBaseStreams() {
    restituisci this.str ? this.str.getBaseStreams() : null;
  }
}
esportazioni.DecodeStream = DecodeStream;
classe StreamsSequenceStream estende DecodeStream {
  costruttore(flussi, onError = null) {
    lascia che forseLunghezza = 0;
    per (flusso costante di flussi) {
      maybeLength += stream instanceof DecodeStream ? stream._rawMinBufferLength : stream.length;
    }
    super(forseLunghezza);
    this.streams = flussi;
    this._onError = onError;
  }
  readBlock() {
    const streams = this.streams;
    se (lunghezza flussi === 0) {
      this.eof = true;
      ritorno;
    }
    const stream = streams.shift();
    lasciare il pezzo;
    Tentativo {
      pezzo = stream.getBytes();
    } cattura (motivo) {
      se (this._onError) {
        this._onError(motivo, stream.dict?.objId);
        ritorno;
      }
      gettare la ragione;
    }
    const bufferLength = this.bufferLength;
    const newLength = bufferLength + chunk.length;
    const buffer = this.ensureBuffer(newLength);
    buffer.set(chunk, lunghezza del buffer);
    this.bufferLength = newLength;
  }
  getBaseStreams() {
    const baseStreamsBuf = [];
    per (flusso costante di this.streams) {
      const baseStreams = stream.getBaseStreams();
      se (baseStreams) {
        baseStreamsBuf.push(...baseStreams);
      }
    }
    restituisci baseStreamsBuf.length > 0 ? baseStreamsBuf : null;
  }
}
esportazioni.StreamsSequenceStream = StreamsSequenceStream;

/***/ }),
/* 19 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.AsciiHexStream = void 0;
var _decode_stream = __w_pdfjs_require__(18);
classe AsciiHexStream estende _decode_stream.DecodeStream {
  costruttore(str, forseLunghezza) {
    se (forseLunghezza) {
      forseLunghezza *= 0,5;
    }
    super(forseLunghezza);
    questo.str = str;
    questo.dizionario = str.dizionario;
    this.firstDigit = -1;
  }
  readBlock() {
    const UPSTREAM_BLOCK_SIZE = 8000;
    const byte = this.str.getBytes(UPSTREAM_BLOCK_SIZE);
    se (!byte.lunghezza) {
      this.eof = true;
      ritorno;
    }
    const maxDecodeLength = byte.lunghezza + 1 >> 1;
    const buffer = this.ensureBuffer(this.bufferLength + maxDecodeLength);
    lascia che bufferLength = this.bufferLength;
    lascia primaCifra = this.primaCifra;
    per (const ch di byte) {
      lascia la cifra;
      se (ch >= 0x30 e ch <= 0x39) {
        cifra = ch & 0x0f;
      } altrimenti se (ch >= 0x41 e ch <= 0x46 || ch >= 0x61 e ch <= 0x66) {
        cifra = (ch & 0x0f) + 9;
      } altrimenti se (ch === 0x3e) {
        this.eof = true;
        rottura;
      } altro {
        continuare;
      }
      se (primacifra < 0) {
        firstDigit = cifra;
      } altro {
        buffer[bufferLength++] = firstDigit << 4 | cifra;
        primaCifra = -1;
      }
    }
    se (firstDigit >= 0 && this.eof) {
      buffer[bufferLength++] = primaCifra << 4;
      primaCifra = -1;
    }
    this.firstDigit = firstDigit;
    this.bufferLength = bufferLength;
  }
}
esportazioni.AsciiHexStream = AsciiHexStream;

/***/ }),
/* 20 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.CCITTFaxStream = void 0;
var _ccitt = __w_pdfjs_require__(21);
var _decode_stream = __w_pdfjs_require__(18);
var _primitives = __w_pdfjs_require__(4);
classe CCITTFaxStream estende _decode_stream.DecodeStream {
  costruttore(str, forseLunghezza, parametri) {
    super(forseLunghezza);
    questo.str = str;
    questo.dizionario = str.dizionario;
    se (!(parametri instanceof _primitives.Dict)) {
      parametri = _primitives.Dict.empty;
    }
    sorgente costante = {
      Prossimo() {
        restituisci str.getByte();
      }
    };
    this.ccittFaxDecoder = new _ccitt.CCITTFaxDecoder(source, {
      K: params.get("K"),
      Fine riga: params.get("Fine riga"),
      Allineamento Byte Codificato: params.get("Allineamento Byte Codificato"),
      Colonne: params.get("Colonne"),
      Righe: params.get("Righe"),
      Fine del blocco: params.get("Fine del blocco"),
      NeroIs1: params.get("NeroIs1")
    });
  }
  readBlock() {
    mentre (!this.eof) {
      const c = this.ccittFaxDecoder.readNextChar();
      se (c === -1) {
        this.eof = true;
        ritorno;
      }
      this.ensureBuffer(this.bufferLength + 1);
      questo.buffer[questo.bufferLength++] = c;
    }
  }
}
esportazioni.CCITTFaxStream = CCITTFaxStream;

/***/ }),
/* 21 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.CCITTFaxDecoder = void 0;
var _util = __w_pdfjs_require__(2);
const ccittEOL = -2;
const ccittEOF = -1;
const twoDimPass = 0;
const twoDimHoriz = 1;
const twoDimVert0 = 2;
const twoDimVertR1 = 3;
const twoDimVertL1 = 4;
const twoDimVertR2 = 5;
const twoDimVertL2 = 6;
const twoDimVertR3 = 7;
const twoDimVertL3 = 8;
const twoDimTable = [[-1, -1], [-1, -1], [7, twoDimVertL3], [7, twoDimVertR3], [6, twoDimVertL2], [6, twoDimVertL2], [6, twoDimVertR2], [6, twoDimVertR2], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0];
const whiteTable1 = [[-1, -1], [12, ccittEOL], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]];
const whiteTable2 = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3 ... 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5,9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5 ... 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6 ... 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7 ... 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]];
const blackTable1 = [[-1, -1], [-1, -1], [12, ccittEOL], [12, ccittEOL], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]];
const blackTable2 = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]];
const blackTable3 = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2];
classe CCITTFaxDecoder {
  costruttore(sorgente, opzioni = {}) {
    se (!source || tipo di source.next !== "funzione") {
      genera un nuovo errore('CCITTFaxDecoder - parametro "sorgente" non valido.');
    }
    this.source = sorgente;
    this.eof = false;
    this.encoding = options.K || 0;
    this.eoline = options.EndOfLine || false;
    this.byteAlign = options.EncodedByteAlign || false;
    this.columns = options.Columns || 1728;
    questo.righe = opzioni.Righe || 0;
    this.eoblock = options.EndOfBlock ?? true;
    questo.nero = opzioni.NeroIs1 || falso;
    this.codingLine = new Uint32Array(this.columns + 1);
    this.refLine = new Uint32Array(this.columns + 2);
    this.codingLine[0] = this.columns;
    this.codingPos = 0;
    questa.riga = 0;
    this.nextLine2D = this.encoding < 0;
    questo.inputBits = 0;
    questo.inputBuf = 0;
    questo.outputBits = 0;
    this.rowsDone = false;
    lascia codice1;
    mentre ((code1 = this._lookBits(12)) === 0) {
      questo._eatBits(1);
    }
    se (codice1 === 1) {
      questo._eatBits(12);
    }
    se (questa codifica > 0) {
      this.nextLine2D = !this._lookBits(1);
      questo._eatBits(1);
    }
  }
  leggiNextChar() {
    se (questo.eof) {
      restituisci -1;
    }
    const refLine = this.refLine;
    const codingLine = this.codingLine;
    const colonne = this.columns;
    lascia refPos, blackPixels, bit, i;
    se (this.outputBits === 0) {
      se (this.rowsDone) {
        this.eof = true;
      }
      se (questo.eof) {
        restituisci -1;
      }
      questo.err = falso;
      lascia codice1, codice2, codice3;
      se (this.nextLine2D) {
        per (i = 0; codingLine[i] < colonne; ++i) {
          refLine[i] = codingLine[i];
        }
        refLine[i++] = colonne;
        refLine[i] = colonne;
        codificaLine[0] = 0;
        this.codingPos = 0;
        rifPos = 0;
        Pixel neri = 0;
        while (codingLine[this.codingPos] < colonne) {
          codice1 = this._getTwoDimCode();
          interruttore (codice1) {
            caso dueDimPass:
              this._addPixels(refLine[refPos + 1], blackPixels);
              se (refLine[refPos + 1] < colonne) {
                rifPos += 2;
              }
              rottura;
            caso dueDimHoriz:
              codice1 = codice2 = 0;
              se (pixel neri) {
                Fare {
                  codice1 += codice3 = this._getBlackCode();
                } while (codice3 >= 64);
                Fare {
                  codice2 += codice3 = this._getWhiteCode();
                } while (codice3 >= 64);
              } altro {
                Fare {
                  codice1 += codice3 = this._getWhiteCode();
                } while (codice3 >= 64);
                Fare {
                  codice2 += codice3 = this._getBlackCode();
                } while (codice3 >= 64);
              }
              this._addPixels(codingLine[this.codingPos] + code1, blackPixels);
              se (codingLine[this.codingPos] < colonne) {
                this._addPixels(codingLine[this.codingPos] + code2, blackPixels ^ 1);
              }
              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                rifPos += 2;
              }
              rottura;
            caso dueDimVertR3:
              this._addPixels(refLine[refPos] + 3, blackPixels);
              pixel neri ^= 1;
              se (codingLine[this.codingPos] < colonne) {
                ++rifPos;
                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  rifPos += 2;
                }
              }
              rottura;
            caso dueDimVertR2:
              this._addPixels(refLine[refPos] + 2, blackPixels);
              pixel neri ^= 1;
              se (codingLine[this.codingPos] < colonne) {
                ++rifPos;
                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  rifPos += 2;
                }
              }
              rottura;
            caso dueDimVertR1:
              this._addPixels(refLine[refPos] + 1, blackPixels);
              pixel neri ^= 1;
              se (codingLine[this.codingPos] < colonne) {
                ++rifPos;
                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  rifPos += 2;
                }
              }
              rottura;
            caso dueDimVert0:
              this._addPixels(refLine[refPos], blackPixels);
              pixel neri ^= 1;
              se (codingLine[this.codingPos] < colonne) {
                ++rifPos;
                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  rifPos += 2;
                }
              }
              rottura;
            caso dueDimVertL3:
              this._addPixelsNeg(refLine[refPos] - 3, blackPixels);
              pixel neri ^= 1;
              se (codingLine[this.codingPos] < colonne) {
                se (rifPos > 0) {
                  --refPos;
                } altro {
                  ++rifPos;
                }
                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  rifPos += 2;
                }
              }
              rottura;
            caso dueDimVertL2:
              this._addPixelsNeg(refLine[refPos] - 2, blackPixels);
              pixel neri ^= 1;
              se (codingLine[this.codingPos] < colonne) {
                se (rifPos > 0) {
                  --refPos;
                } altro {
                  ++rifPos;
                }
                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  rifPos += 2;
                }
              }
              rottura;
            caso dueDimVertL1:
              this._addPixelsNeg(refLine[refPos] - 1, blackPixels);
              pixel neri ^= 1;
              se (codingLine[this.codingPos] < colonne) {
                se (rifPos > 0) {
                  --refPos;
                } altro {
                  ++rifPos;
                }
                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  rifPos += 2;
                }
              }
              rottura;
            caso ccittEOF:
              this._addPixels(colonne, 0);
              this.eof = true;
              rottura;
            predefinito:
              (0, _util.info)("codice 2d non valido");
              this._addPixels(colonne, 0);
              questo.err = vero;
          }
        }
      } altro {
        codificaLine[0] = 0;
        this.codingPos = 0;
        Pixel neri = 0;
        while (codingLine[this.codingPos] < colonne) {
          codice1 = 0;
          se (pixel neri) {
            Fare {
              codice1 += codice3 = this._getBlackCode();
            } while (codice3 >= 64);
          } altro {
            Fare {
              codice1 += codice3 = this._getWhiteCode();
            } while (codice3 >= 64);
          }
          this._addPixels(codingLine[this.codingPos] + code1, blackPixels);
          pixel neri ^= 1;
        }
      }
      lascia gotEOL = false;
      se (this.byteAlign) {
        questo.inputBits &= ~7;
      }
      se (!this.eoblock && this.row === this.rows - 1) {
        this.rowsDone = true;
      } altro {
        codice1 = this._lookBits(12);
        se (this.eoline) {
          while (code1 !== ccittEOF && code1 !== 1) {
            questo._eatBits(1);
            codice1 = this._lookBits(12);
          }
        } altro {
          mentre (codice1 === 0) {
            questo._eatBits(1);
            codice1 = this._lookBits(12);
          }
        }
        se (codice1 === 1) {
          questo._eatBits(12);
          gotEOL = true;
        } altrimenti se (codice1 === ccittEOF) {
          this.eof = true;
        }
      }
      se (!this.eof && this.encoding > 0 && !this.rowsDone) {
        this.nextLine2D = !this._lookBits(1);
        questo._eatBits(1);
      }
      se (this.eoblock && gotEOL && this.byteAlign) {
        codice1 = this._lookBits(12);
        se (codice1 === 1) {
          questo._eatBits(12);
          se (questa codifica > 0) {
            questo._lookBits(1);
            questo._eatBits(1);
          }
          se (questa codifica >= 0) {
            per (i = 0; i < 4; ++i) {
              codice1 = this._lookBits(12);
              se (codice1 !== 1) {
                (0, _util.info)("codice rtc non valido: " + code1);
              }
              questo._eatBits(12);
              se (questa codifica > 0) {
                questo._lookBits(1);
                questo._eatBits(1);
              }
            }
          }
          this.eof = true;
        }
      } altrimenti se (this.err && this.eoline) {
        mentre (vero) {
          codice1 = this._lookBits(13);
          se (codice1 === ccittEOF) {
            this.eof = true;
            restituisci -1;
          }
          se (codice1 >> 1 === 1) {
            rottura;
          }
          questo._eatBits(1);
        }
        questo._eatBits(12);
        se (questa codifica > 0) {
          questo._eatBits(1);
          this.nextLine2D = !(code1 & 1);
        }
      }
      this.outputBits = codingLine[0] > 0 ? codingLine[this.codingPos = 0] : codingLine[this.codingPos = 1];
      questa.riga++;
    }
    lascia c;
    se (this.outputBits >= 8) {
      c = this.codingPos & 1 ? 0 : 0xff;
      questo.outputBits -= 8;
      se (this.outputBits === 0 && codingLine[this.codingPos] < colonne) {
        questo.codingPos++;
        this.outputBits = codingLine[this.codingPos] - codingLine[this.codingPos - 1];
      }
    } altro {
      bit = 8;
      c = 0;
      Fare {
        se (tipo di this.outputBits !== "numero") {
          throw new _util.FormatError('Dati /CCITTFaxDecode non validi, "outputBits" deve essere un numero.');
        }
        se (this.outputBits > bit) {
          c <<= bit;
          se (!(this.codingPos & 1)) {
            c |= 0xff >> 8 - bit;
          }
          this.outputBits -= bit;
          bit = 0;
        } altro {
          c <<= this.outputBits;
          se (!(this.codingPos & 1)) {
            c |= 0xff >> 8 - this.outputBits;
          }
          bit -= this.outputBits;
          questo.outputBits = 0;
          se (codingLine[this.codingPos] < colonne) {
            questo.codingPos++;
            this.outputBits = codingLine[this.codingPos] - codingLine[this.codingPos - 1];
          } altrimenti se (bit > 0) {
            c <<= bit;
            bit = 0;
          }
        }
      } while (bit);
    }
    se (questo.nero) {
      c ^= 0xff;
    }
    ritorno c;
  }
  _addPixels(a1, pixel neri) {
    const codingLine = this.codingLine;
    lascia che codingPos = this.codingPos;
    se (a1 > codingLine[codingPos]) {
      se (a1 > this.columns) {
        (0, _util.info)("la riga ha una lunghezza errata");
        questo.err = vero;
        a1 = this.columns;
      }
      se (codingPos & 1 ^ pixel neri) {
        ++codingPos;
      }
      codificaLine[codingPos] = a1;
    }
    this.codingPos = codingPos;
  }
  _addPixelsNeg(a1, pixel neri) {
    const codingLine = this.codingLine;
    lascia che codingPos = this.codingPos;
    se (a1 > codingLine[codingPos]) {
      se (a1 > this.columns) {
        (0, _util.info)("la riga ha una lunghezza errata");
        questo.err = vero;
        a1 = this.columns;
      }
      se (codingPos & 1 ^ pixel neri) {
        ++codingPos;
      }
      codificaLine[codingPos] = a1;
    } altrimenti se (a1 < codingLine[codingPos]) {
      se (a1 < 0) {
        (0, _util.info)("codice non valido");
        questo.err = vero;
        a1 = 0;
      }
      while (codingPos > 0 && a1 < codingLine[codingPos - 1]) {
        --codingPos;
      }
      codificaLine[codingPos] = a1;
    }
    this.codingPos = codingPos;
  }
  _findTableCode(inizio, fine, tabella, limite) {
    const limitValue = limite || 0;
    per (lascia che i = inizio; i <= fine; ++i) {
      lascia codice = this._lookBits(i);
      se (codice === ccittEOF) {
        restituisci [vero, 1, falso];
      }
      se (i < fine) {
        codice <<= fine - i;
      }
      se (!limitValue || codice >= limitValue) {
        const p = table[codice - limitValue];
        se (p[0] === i) {
          questo._eatBits(i);
          restituisci [vero, p[1], vero];
        }
      }
    }
    restituisci [falso, 0, falso];
  }
  _getTwoDimCode() {
    lascia codice = 0;
    lascia p;
    se (questo.eoblock) {
      codice = this._lookBits(7);
      p = twoDimTable[codice];
      se (p?.[0] > 0) {
        questo._eatBits(p[0]);
        restituisci p[1];
      }
    } altro {
      risultato costante = this._findTableCode(1, 7, twoDimTable);
      se (risultato[0] e risultato[2]) {
        restituisci risultato[1];
      }
    }
    (0, _util.info)("Codice two dim errato");
    restituisci ccittEOF;
  }
  _getWhiteCode() {
    lascia codice = 0;
    lascia p;
    se (questo.eoblock) {
      codice = this._lookBits(12);
      se (codice === ccittEOF) {
        restituisci 1;
      }
      p = codice >> 5 === 0 ? whiteTable1[codice] : whiteTable2[codice >> 3];
      se (p[0] > 0) {
        questo._eatBits(p[0]);
        restituisci p[1];
      }
    } altro {
      lascia risultato = this._findTableCode(1, 9, whiteTable2);
      se (risultato[0]) {
        restituisci risultato[1];
      }
      risultato = this._findTableCode(11, 12, whiteTable1);
      se (risultato[0]) {
        restituisci risultato[1];
      }
    }
    (0, _util.info)("codice bianco errato");
    questo._eatBits(1);
    restituisci 1;
  }
  _getBlackCode() {
    lascia codice, p;
    se (questo.eoblock) {
      codice = this._lookBits(13);
      se (codice === ccittEOF) {
        restituisci 1;
      }
      se (codice >> 7 === 0) {
        p = blackTable1[codice];
      } else if (codice >> 9 === 0 && codice >> 7 !== 0) {
        p = blackTable2[(codice >> 1) - 64];
      } altro {
        p = blackTable3[codice >> 7];
      }
      se (p[0] > 0) {
        questo._eatBits(p[0]);
        restituisci p[1];
      }
    } altro {
      lascia risultato = this._findTableCode(2, 6, blackTable3);
      se (risultato[0]) {
        restituisci risultato[1];
      }
      risultato = this._findTableCode(7, 12, blackTable2, 64);
      se (risultato[0]) {
        restituisci risultato[1];
      }
      risultato = this._findTableCode(10, 13, blackTable1);
      se (risultato[0]) {
        restituisci risultato[1];
      }
    }
    (0, _util.info)("codice nero errato");
    questo._eatBits(1);
    restituisci 1;
  }
  _lookBits(n) {
    lascia c;
    mentre (this.inputBits < n) {
      se ((c = this.source.next()) === -1) {
        se (questo.inputBits === 0) {
          restituisci ccittEOF;
        }
        restituisci questo.inputBuf << n - questo.inputBits & 0xffff >> 16 - n;
      }
      questo.inputBuf = questo.inputBuf << 8 | c;
      questo.inputBits += 8;
    }
    restituisci this.inputBuf >> this.inputBits - n & 0xffff >> 16 - n;
  }
  _eatBits(n) {
    se ((this.inputBits -= n) < 0) {
      questo.inputBits = 0;
    }
  }
}
esportazioni.CCITTFaxDecoder = CCITTFaxDecoder;

/***/ }),
/* 22 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.FlateStream = void 0;
var _decode_stream = __w_pdfjs_require__(18);
var _util = __w_pdfjs_require__(2);
const codeLenCodeMap = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
const lengthDecode = new Int32Array([0x00003, 0x00004, 0x00005, 0x00006, 0x00007, 0x00008, 0x00009, 0x0000a, 0x1000b, 0x1000d, 0x1000f, 0x10011, 0x20013, 0x20017, 0x2001b, 0x2001f, 0x30023, 0x3002b, 0x30033, 0x3003b, 0x40043, 0x40053, 0x40063, 0x40073, 0x50083, 0x500a3, 0x500c3, 0x500e3, 0x00102, 0x00102, 0x00102]);
const distDecode = new Int32Array([0x00001, 0x00002, 0x00003, 0x00004, 0x10005, 0x10007, 0x20009, 0x2000d, 0x30011, 0x30019, 0x40021, 0x40031, 0x50041, 0x50061, 0x60081, 0x600c1, 0x70101, 0x70181, 0x80201, 0x80301, 0x90401, 0x90601, 0xa0801, 0xa0c01, 0xb1001, 0xb1801, 0xc2001, 0xc3001, 0xd4001, 0xd6001]);
const fixedLitCodeTab = [new Int32Array([0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c0, 0x70108, 0x80060, 0x80020, 0x900a0, 0x80000, 0x80080, 0x80040, 0x900e0, 0x70104, 0x80058, 0x80018, 0x90090, 0x70114, 0x80078, 0x80038, 0x900d0, 0x7010c, 0x80068, 0x80028, 0x900b0, 0x80008, 0x80088, 0x80048, 0x900f0, 0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c8, 0x7010a, 0x80064, 0x80024, 0x900a8, 0x80004, 0x80084, 0x80044, 0x900e8, 0x70106, 0x8005c, 0x8001c, 0x90098, 0x70116, 0x8007c, 0x8003c, 0x900d8, 0x7010e, 0x8006c, 0x8002c, 0x900b8, 0x8000c, 0x8008c, 0x8004c, 0x900f8, 0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c4, 0x70109, 0x80062, 0x80022, 0x900a4, 0x80002, 0x80082, 0x80042, 0x900e4, 0x70105, 0x8005a, 0x8001a, 0x90094, 0x70115, 0x8007a, 0x8003a, 0x900d4, 0x7010d, 0x8006a, 0x8002a, 0x900b4, 0x8000a, 0x8008a, 0x8004a, 0x900f4, 0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cc, 0x7010b, 0x80066, 0x80026, 0x900ac, 0x80006, 0x80086, 0x80046, 0x900ec, 0x70107, 0x8005e, 0x8001e, 0x9009c, 0x70117, 0x8007e, 0x8003e, 0x900dc, 0x7010f, 0x8006e, 0x8002e, 0x900bc, 0x8000e, 0x8008e, 0x8004e, 0x900fc, 0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c2, 0x70108, 0x80061, 0x80021, 0x900a2, 0x80001, 0x80081, 0x80041, 0x900e2, 0x70104, 0x80059, 0x80019, 0x90092, 0x70114, 0x80079, 0x80039, 0x900d2, 0x7010c, 0x80069, 0x80029, 0x900b2, 0x80009, 0x80089, 0x80049, 0x900f2, 0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900ca, 0x7010a, 0x80065, 0x80025, 0x900aa, 0x80005, 0x80085, 0x80045, 0x900ea, 0x70106, 0x8005d, 0x8001d, 0x9009a, 0x70116, 0x8007d, 0x8003d, 0x900da, 0x7010e, 0x8006d, 0x8002d, 0x900ba, 0x8000d, 0x8008d, 0x8004d, 0x900fa, 0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c6, 0x70109, 0x80063, 0x80023, 0x900a6, 0x80003, 0x80083, 0x80043, 0x900e6, 0x70105, 0x8005b, 0x8001b, 0x90096, 0x70115, 0x8007b, 0x8003b, 0x900d6, 0x7010d, 0x8006b, 0x8002b, 0x900b6, 0x8000b, 0x8008b, 0x8004b, 0x900f6, 0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900ce, 0x7010b, 0x80067, 0x80027, 0x900ae, 0x80007, 0x80087, 0x80047, 0x900ee, 0x70107, 0x8005f, 0x8001f, 0x9009e, 0x70117, 0x8007f, 0x8003f, 0x900de, 0x7010f, 0x8006f, 0x8002f, 0x900be, 0x8000f, 0x8008f, 0x8004f, 0x900fe, 0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c1, 0x70108, 0x80060, 0x80020, 0x900a1, 0x80000, 0x80080, 0x80040, 0x900e1, 0x70104, 0x80058, 0x80018, 0x90091, 0x70114, 0x80078, 0x80038, 0x900d1, 0x7010c, 0x80068, 0x80028, 0x900b1, 0x80008, 0x80088, 0x80048, 0x900f1, 0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c9, 0x7010a, 0x80064, 0x80024, 0x900a9, 0x80004, 0x80084, 0x80044, 0x900e9, 0x70106, 0x8005c, 0x8001c, 0x90099, 0x70116, 0x8007c, 0x8003c, 0x900d9, 0x7010e, 0x8006c, 0x8002c, 0x900b9, 0x8000c, 0x8008c, 0x8004c, 0x900f9, 0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c5,0x70109, 0x80062, 0x80022, 0x900a5, 0x80002, 0x80082, 0x80042, 0x900e5, 0x70105, 0x8005a, 0x8001a, 0x90095, 0x70115, 0x8007a, 0x8003a, 0x900d5, 0x7010d, 0x8006a, 0x8002a, 0x900b5, 0x8000a, 0x8008a, 0x8004a, 0x900f5, 0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cd, 0x7010b, 0x80066, 0x80026, 0x900ad, 0x80006, 0x80086, 0x80046, 0x900ed, 0x70107, 0x8005e, 0x8001e, 0x9009d, 0x70117, 0x8007e, 0x8003e, 0x900dd, 0x7010f, 0x8006e, 0x8002e, 0x900bd, 0x8000e, 0x8008e, 0x8004e, 0x900fd, 0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c3, 0x70108, 0x80061, 0x80021, 0x900a3, 0x80001, 0x80081, 0x80041, 0x900e3, 0x70104, 0x80059, 0x80019, 0x90093, 0x70114, 0x80079, 0x80039, 0x900d3, 0x7010c, 0x80069, 0x80029, 0x900b3, 0x80009, 0x80089, 0x80049, 0x900f3, 0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900cb, 0x7010a, 0x80065, 0x80025, 0x900ab, 0x80005, 0x80085, 0x80045, 0x900eb, 0x70106, 0x8005d, 0x8001d, 0x9009b, 0x70116, 0x8007d, 0x8003d, 0x900db, 0x7010e, 0x8006d, 0x8002d, 0x900bb, 0x8000d, 0x8008d, 0x8004d, 0x900fb, 0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c7, 0x70109, 0x80063, 0x80023, 0x900a7, 0x80003, 0x80083, 0x80043, 0x900e7, 0x70105, 0x8005b, 0x8001b, 0x90097, 0x70115, 0x8007b, 0x8003b, 0x900d7, 0x7010d, 0x8006b, 0x8002b, 0x900b7, 0x8000b, 0x8008b, 0x8004b, 0x900f7, 0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900cf, 0x7010b, 0x80067, 0x80027, 0x900af, 0x80007, 0x80087, 0x80047, 0x900ef, 0x70107, 0x8005f, 0x8001f, 0x9009f, 0x70117, 0x8007f, 0x8003f, 0x900df, 0x7010f, 0x8006f, 0x8002f, 0x900bf, 0x8000f, 0x8008f, 0x8004f, 0x900ff]), 9];0x8008b, 0x8004b, 0x900f7, 0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900cf, 0x7010b, 0x80067, 0x80027, 0x900af, 0x80007, 0x80087, 0x80047, 0x900ef, 0x70107, 0x8005f, 0x8001f, 0x9009f, 0x70117, 0x8007f, 0x8003f, 0x900df, 0x7010f, 0x8006f, 0x8002f, 0x900bf, 0x8000f, 0x8008f, 0x8004f, 0x900ff]), 9];0x8008b, 0x8004b, 0x900f7, 0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900cf, 0x7010b, 0x80067, 0x80027, 0x900af, 0x80007, 0x80087, 0x80047, 0x900ef, 0x70107, 0x8005f, 0x8001f, 0x9009f, 0x70117, 0x8007f, 0x8003f, 0x900df, 0x7010f, 0x8006f, 0x8002f, 0x900bf, 0x8000f, 0x8008f, 0x8004f, 0x900ff]), 9];
const fixedDistCodeTab = [new Int32Array([0x50000, 0x50010, 0x50008, 0x50018, 0x50004, 0x50014, 0x5000c, 0x5001c, 0x50002, 0x50012, 0x5000a, 0x5001a, 0x50006, 0x50016, 0x5000e, 0x00000, 0x50001, 0x50011, 0x50009, 0x50019, 0x50005, 0x50015, 0x5000d, 0x5001d, 0x50003, 0x50013, 0x5000b, 0x5001b, 0x50007, 0x50017, 0x5000f, 0x00000]), 5];
classe FlateStream estende _decode_stream.DecodeStream {
  costruttore(str, forseLunghezza) {
    super(forseLunghezza);
    questo.str = str;
    questo.dizionario = str.dizionario;
    const cmf = str.getByte();
    const flg = str.getByte();
    se (cmf === -1 || flg === -1) {
      throw new _util.FormatError(`Intestazione non valida nel flusso flate: ${cmf}, ${flg}`);
    }
    se ((cmf & 0x0f) !== 0x08) {
      throw new _util.FormatError(`Metodo di compressione sconosciuto nel flusso flate: ${cmf}, ${flg}`);
    }
    se (((cmf << 8) + flg) % 31 !== 0) {
      throw new _util.FormatError(`FCHECK non valido nel flusso flate: ${cmf}, ${flg}`);
    }
    se (flg & 0x20) {
      throw new _util.FormatError(`Bit FDICT impostato nel flusso flate: ${cmf}, ${flg}`);
    }
    this.codeSize = 0;
    questo.codeBuf = 0;
  }
  getBits(bit) {
    const str = this.str;
    lascia codeSize = this.codeSize;
    lascia che codeBuf = this.codeBuf;
    lascia b;
    while (codeSize < bit) {
      se ((b = str.getByte()) === -1) {
        throw new _util.FormatError("Codifica errata nel flusso flate");
      }
      codeBuf |= b << codeSize;
      dimensione del codice += 8;
    }
    b = codeBuf & (1 << bit) - 1;
    this.codeBuf = codeBuf >> bit;
    this.codeSize = codeSize -= bit;
    restituisci b;
  }
  getCode(tabella) {
    const str = this.str;
    codici costanti = tabella[0];
    const maxLen = tabella[1];
    lascia codeSize = this.codeSize;
    lascia che codeBuf = this.codeBuf;
    lascia b;
    mentre (codeSize < maxLen) {
      se ((b = str.getByte()) === -1) {
        rottura;
      }
      codeBuf |= b << codeSize;
      dimensione del codice += 8;
    }
    codice costante = codici[codeBuf & (1 << maxLen) - 1];
    const codeLen = codice >> 16;
    const codeVal = codice & 0xffff;
    se (codiceLen < 1 || dimensionecodice < codiceLen) {
      throw new _util.FormatError("Codifica errata nel flusso flate");
    }
    this.codeBuf = codeBuf >> codeLen;
    this.codeSize = codeSize - codeLen;
    codice di ritornoVal;
  }
  generateHuffmanTable(lunghezze) {
    const n = lunghezze.lunghezza;
    lascia maxLen = 0;
    lascia che io;
    per (i = 0; i < n; ++i) {
      se (lunghezze[i] > maxLen) {
        maxLen = lunghezze[i];
      }
    }
    dimensione costante = 1 << maxLen;
    codici costanti = nuovo Int32Array(dimensione);
    per (let len ​​= 1, code = 0, skip = 2; len <= maxLen; ++len, code <<= 1, skip <<= 1) {
      for (let val = 0; val < n; ++val) {
        se (lunghezze[val] === len) {
          lascia codice2 = 0;
          lascia t = codice;
          per (i = 0; i < len; ++i) {
            codice2 = codice2 << 1 | t & 1;
            t >>= 1;
          }
          per (i = codice2; i < dimensione; i += salta) {
            codici[i] = len << 16 | val;
          }
          ++codice;
        }
      }
    }
    ritorno [codici, maxLen];
  }
  readBlock() {
    lascia buffer, len;
    const str = this.str;
    lascia hdr = this.getBits(3);
    se (hdr & 1) {
      this.eof = true;
    }
    hdr >>= 1;
    se (hdr === 0) {
      lascia b;
      se ((b = str.getByte()) === -1) {
        throw new _util.FormatError("Intestazione del blocco errata nel flusso flate");
      }
      lascia bloccoLen = b;
      se ((b = str.getByte()) === -1) {
        throw new _util.FormatError("Intestazione del blocco errata nel flusso flate");
      }
      bloccoLen |= b << 8;
      se ((b = str.getByte()) === -1) {
        throw new _util.FormatError("Intestazione del blocco errata nel flusso flate");
      }
      lascia che controlli = b;
      se ((b = str.getByte()) === -1) {
        throw new _util.FormatError("Intestazione del blocco errata nel flusso flate");
      }
      controlla |= b << 8;
      se (controlla !== (~blockLen & 0xffff) && (blockLen !== 0 || controlla !== 0)) {
        throw new _util.FormatError("Lunghezza del blocco non compresso errata nel flusso flate");
      }
      questo.codeBuf = 0;
      this.codeSize = 0;
      const bufferLength = this.bufferLength,
        fine = lunghezza buffer + lunghezza blocco;
      buffer = this.ensureBuffer(end);
      this.bufferLength = fine;
      se (lunghezzablocco === 0) {
        se (str.peekByte() === -1) {
          this.eof = true;
        }
      } altro {
        blocco costante = str.getBytes(blockLen);
        buffer.set(blocco, lunghezza buffer);
        se (lunghezza blocco < lunghezza blocco) {
          this.eof = true;
        }
      }
      ritorno;
    }
    lascia litCodeTable;
    lascia distCodeTable;
    se (hdr === 1) {
      litCodeTable = fixedLitCodeTab;
      distCodeTable = fixedDistCodeTab;
    } altrimenti se (hdr === 2) {
      const numLitCodes = this.getBits(5) + 257;
      const numDistCodes = this.getBits(5) + 1;
      const numCodeLenCodes = this.getBits(4) + 4;
      const codeLenCodeLengths = new Uint8Array(codeLenCodeMap.length);
      lascia che io;
      per (i = 0; i < numCodeLenCodes; ++i) {
        codeLenCodeLengths[codeLenCodeMap[i]] = this.getBits(3);
      }
      const codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);
      lunghezza = 0;
      io = 0;
      codici costanti = numLitCodes + numDistCodes;
      const codeLengths = new Uint8Array(codici);
      lascia bitsLength, bitsOffset, cosa;
      while (i < codici) {
        codice costante = this.getCode(codeLenCodeTab);
        se (codice === 16) {
          lunghezzabit = 2;
          bitOffset = 3;
          cosa = len;
        } altrimenti se (codice === 17) {
          lunghezzabit = 3;
          bitOffset = 3;
          cosa = len = 0;
        } altrimenti se (codice === 18) {
          lunghezzabit = 7;
          bitOffset = 11;
          cosa = len = 0;
        } altro {
          codeLunghezza[i++] = len = codice;
          continuare;
        }
        lascia repeatLength = this.getBits(bitsLength) + bitsOffset;
        while (repeatLength-- > 0) {
          codeLengths[i++] = cosa;
        }
      }
      litCodeTable = this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes));
      distCodeTable = this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes));
    } altro {
      throw new _util.FormatError("Tipo di blocco sconosciuto nel flusso flate");
    }
    buffer = questo.buffer;
    lascia limite = buffer ? buffer.length : 0;
    lascia pos = this.bufferLength;
    mentre (vero) {
      lascia codice1 = this.getCode(litCodeTable);
      se (codice1 < 256) {
        se (pos + 1 >= limite) {
          buffer = this.ensureBuffer(pos + 1);
          limite = buffer.lunghezza;
        }
        buffer[pos++] = codice1;
        continuare;
      }
      se (codice1 === 256) {
        this.bufferLength = pos;
        ritorno;
      }
      codice1 -= 257;
      codice1 = lunghezzaDecode[codice1];
      lascia codice2 = codice1 >> 16;
      se (codice2 > 0) {
        codice2 = this.getBits(codice2);
      }
      len = (codice1 & 0xffff) + codice2;
      codice1 = this.getCode(distCodeTable);
      codice1 = distDecode[codice1];
      codice2 = codice1 >> 16;
      se (codice2 > 0) {
        codice2 = this.getBits(codice2);
      }
      const dist = (code1 & 0xffff) + code2;
      se (pos + len >= limite) {
        buffer = this.ensureBuffer(pos + len);
        limite = buffer.lunghezza;
      }
      per (lascia che k = 0; k < len; ++k, ++pos) {
        buffer[pos] = buffer[pos - dist];
      }
    }
  }
}
esportazioni.FlateStream = FlateStream;

/***/ }),
/* 23 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.Jbig2Stream = void 0;
var _base_stream = __w_pdfjs_require__(5);
var _decode_stream = __w_pdfjs_require__(18);
var _primitives = __w_pdfjs_require__(4);
var _jbig = __w_pdfjs_require__(24);
var _util = __w_pdfjs_require__(2);
classe Jbig2Stream estende _decode_stream.DecodeStream {
  costruttore(flusso, forseLunghezza, parametri) {
    super(forseLunghezza);
    questo.flusso = flusso;
    questo.dict = stream.dict;
    this.maybeLength = maybeLength;
    questo.parametri = parametri;
  }
  ottieni byte() {
    return (0, _util.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(richiesto) {}
  readBlock() {
    se (questo.eof) {
      ritorno;
    }
    const jbig2Image = new _jbig.Jbig2Image();
    const blocchi = [];
    se (this.params instanceof _primitives.Dict) {
      const globalsStream = this.params.get("JBIG2Globals");
      se (globalsStream instanceof _base_stream.BaseStream) {
        const globali = globalsStream.getBytes();
        pezzi.push({
          dati: globali,
          inizio: 0,
          fine: globals.length
        });
      }
    }
    pezzi.push({
      dati: this.bytes,
      inizio: 0,
      fine: questa lunghezza di byte
    });
    dati costanti = jbig2Image.parseChunks(chunks);
    const dataLength = data.length;
    per (lascia che i = 0; i < lunghezzadati; i++) {
      dati[i] ^= 0xff;
    }
    questo.buffer = dati;
    this.bufferLength = dataLength;
    this.eof = true;
  }
}
esportazioni.Jbig2Stream = Jbig2Stream;

/***/ }),
/* 24 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.Jbig2Image = void 0;
var _util = __w_pdfjs_require__(2);
var _core_utils = __w_pdfjs_require__(3);
var _arithmetic_decoder = __w_pdfjs_require__(25);
var _ccitt = __w_pdfjs_require__(21);
classe Jbig2Error estende _util.BaseException {
  costruttore(msg) {
    super(`Errore JBIG2: ${msg}`, "Jbig2Error");
  }
}
classe ContextCache {
  ottieniContesti(id) {
    se (id in questo) {
      restituisci questo[id];
    }
    restituisci questo[id] = nuovo Int8Array(1 << 16);
  }
}
classe DecodingContext {
  costruttore(dati, inizio, fine) {
    questo.dati = dati;
    questo.inizio = inizio;
    questo.fine = fine;
  }
  ottieni decodificatore() {
    const decoder = new _arithmetic_decoder.ArithmeticDecoder(this.data, this.start, this.end);
    return (0, _util.shadow)(this, "decoder", decoder);
  }
  ottieni contextCache() {
    const cache = new ContextCache();
    return (0, _util.shadow)(this, "contextCache", cache);
  }
}
costante MAX_INT_32 = 2 ** 31 - 1;
costante MIN_INT_32 = -(2 ** 31);
funzione decodeInteger(contextCache, procedura, decoder) {
  const contexts = contextCache.getContexts(procedura);
  lascia prev = 1;
  funzione readBits(lunghezza) {
    sia v = 0;
    per (lascia che i = 0; i < lunghezza; i++) {
      const bit = decoder.readBit(contesti, prev);
      precedente = precedente < 256 ? precedente << 1 | bit : (precedente << 1 | bit) & 511 | 256;
      v = v << 1 | bit;
    }
    ritorno v >>> 0;
  }
  segno costante = readBits(1);
  valore costante = readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(32) + 4436 : readBits(12) + 340 : readBits(8) + 84 : readBits(6) + 20 : readBits(4) + 4 : readBits(2);
  lascia valorefirmato;
  se (segno === 0) {
    signedValue = valore;
  } altrimenti se (valore > 0) {
    signedValue = -valore;
  }
  se (signedValue >= MIN_INT_32 e valore firmato <= MAX_INT_32) {
    restituisci valorefirmato;
  }
  restituisci null;
}
funzione decodeIAID(contextCache, decoder, codeLength) {
  const contesti = contextCache.getContexts("IAID");
  lascia prev = 1;
  per (lascia che i = 0; i < lunghezzacodice; i++) {
    const bit = decoder.readBit(contesti, prev);
    precedente = precedente << 1 | bit;
  }
  se (lunghezzacodice < 31) {
    return precedente & (1 <<codiceLunghezza) - 1;
  }
  ritorna prec & 0x7fffffff;
}
const SegmentTypes = ["SymbolDictionary", null, null, null, "IntermediateTextRegion", null, "ImmediateTextRegion", "ImmediateLosslessTextRegion", null, null, null, null, null, null, null, null, null, "PatternDictionary", null, null, null, null, "IntermediateHalftoneRegion", null, "ImmediateHalftoneRegion", "ImmediateLosslessHalftoneRegion", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "IntermediateGenericRegion", null, "ImmediateGenericRegion", "ImmediateLosslessGenericRefinementRegion", null, "ImmediateGenericRefinementRegion", "ImmediateLosslessGenericRefinementRegion", null, null, null, null, "PageInformation", "EndOfPage", "EndOfStripe", "EndOfFile", "Profiles", "Tabelle", null, null, null, null, null, null, null, null, "Estensione"];
const CodingTemplates = [[{
  x: -1,
  e: -2
}, {
  x: 0,
  e: -2
}, {
  x: 1,
  e: -2
}, {
  x: -2,
  e: -1
}, {
  x: -1,
  e: -1
}, {
  x: 0,
  e: -1
}, {
  x: 1,
  e: -1
}, {
  x: 2,
  e: -1
}, {
  x: -4,
  e: 0
}, {
  x: -3,
  e: 0
}, {
  x: -2,
  e: 0
}, {
  x: -1,
  e: 0
}], [{
  x: -1,
  e: -2
}, {
  x: 0,
  e: -2
}, {
  x: 1,
  e: -2
}, {
  x: 2,
  e: -2
}, {
  x: -2,
  e: -1
}, {
  x: -1,
  e: -1
}, {
  x: 0,
  e: -1
}, {
  x: 1,
  e: -1
}, {
  x: 2,
  e: -1
}, {
  x: -3,
  e: 0
}, {
  x: -2,
  e: 0
}, {
  x: -1,
  e: 0
}], [{
  x: -1,
  e: -2
}, {
  x: 0,
  e: -2
}, {
  x: 1,
  e: -2
}, {
  x: -2,
  e: -1
}, {
  x: -1,
  e: -1
}, {
  x: 0,
  e: -1
}, {
  x: 1,
  e: -1
}, {
  x: -2,
  e: 0
}, {
  x: -1,
  e: 0
}], [{
  x: -3,
  e: -1
}, {
  x: -2,
  e: -1
}, {
  x: -1,
  e: -1
}, {
  x: 0,
  e: -1
}, {
  x: 1,
  e: -1
}, {
  x: -4,
  e: 0
}, {
  x: -3,
  e: 0
}, {
  x: -2,
  e: 0
}, {
  x: -1,
  e: 0
}]];
const RefinementTemplates = [{
  codifica: [{
    x: 0,
    e: -1
  }, {
    x: 1,
    e: -1
  }, {
    x: -1,
    e: 0
  }],
  riferimento: [{
    x: 0,
    e: -1
  }, {
    x: 1,
    e: -1
  }, {
    x: -1,
    e: 0
  }, {
    x: 0,
    e: 0
  }, {
    x: 1,
    e: 0
  }, {
    x: -1,
    e: 1
  }, {
    x: 0,
    e: 1
  }, {
    x: 1,
    e: 1
  }]
}, {
  codifica: [{
    x: -1,
    e: -1
  }, {
    x: 0,
    e: -1
  }, {
    x: 1,
    e: -1
  }, {
    x: -1,
    e: 0
  }],
  riferimento: [{
    x: 0,
    e: -1
  }, {
    x: -1,
    e: 0
  }, {
    x: 0,
    e: 0
  }, {
    x: 1,
    e: 0
  }, {
    x: 0,
    e: 1
  }, {
    x: 1,
    e: 1
  }]
}];
const ReusedContexts = [0x9b25, 0x0795, 0x00e5, 0x0195];
const RefinementReusedContexts = [0x0020, 0x0008];
funzione decodeBitmapTemplate0(larghezza, altezza, decodingContext) {
  const decoder = decodingContext.decoder;
  contesti costanti = decodingContext.contextCache.getContexts("GB");
  bitmap costante = [];
  lascia contextLabel, i, j, pixel, riga, riga1, riga2;
  const OLD_PIXEL_MASK = 0x7bf7;
  per (i = 0; i < altezza; i++) {
    riga = bitmap[i] = new Uint8Array(larghezza);
    riga1 = i < 1 ? riga : bitmap[i - 1];
    riga2 = i < 2 ? riga : bitmap[i - 2];
    etichetta di contesto = riga2[0] << 13 | riga2[1] << 12 | riga2[2] << 11 | riga1[0] << 7 | riga1[1] << 6 | riga1[2] << 5 | riga1[3] << 4;
    per (j = 0; j < larghezza; j++) {
      row[j] = pixel = decoder.readBit(contesti, contextLabel);
      contextLabel = (contextLabel & OLD_PIXEL_MASK) << 1 | (j + 3 < larghezza ? riga2[j + 3] << 11 : 0) | (j + 4 < larghezza ? riga1[j + 4] << 4 : 0) | pixel;
    }
  }
  restituisci bitmap;
}
funzione decodeBitmap(mmr, larghezza, altezza, templateIndex, previsione, salta, a, decodingContext) {
  se (mmr) {
    const input = new Reader(decodingContext.data, decodingContext.start, decodingContext.end);
    restituisci decodeMMRBitmap(input, larghezza, altezza, false);
  }
  se (templateIndex === 0 && !salta && !previsione && at.length === 4 && at[0].x === 3 && at[0].y === -1 && at[1].x === -3 && at[1].y === -1 && at[2].x === 2 && at[2].y === -2 && at[3].x === -2 && at[3].y === -2) {
    restituisci decodeBitmapTemplate0(larghezza, altezza, decodingContext);
  }
  const useskip = !!skip;
  const template = CodingTemplates[templateIndex].concat(at);
  template.sort(funzione (a, b) {
    ritorno ay - di || ax - bx;
  });
  const templateLength = template.length;
  const templateX = new Int8Array(templateLength);
  const templateY = new Int8Array(templateLength);
  const changingTemplateEntries = [];
  lascia reuseMask = 0,
    minX = 0,
    maxX = 0,
    minY = 0;
  lascia c, k;
  per (k = 0; k < lunghezzamodello; k++) {
    modelloX[k] = modello[k].x;
    modelloY[k] = modello[k].y;
    minX = Math.min(minX, template[k].x);
    maxX = Math.max(maxX, template[k].x);
    minY = Math.min(minY, template[k].y);
    se (k < lunghezzamodello - 1 e modello[k].y === modello[k + 1].y e modello[k].x === modello[k + 1].x - 1) {
      reuseMask |= 1 << templateLength - 1 - k;
    } altro {
      changingTemplateEntries.push(k);
    }
  }
  const changingEntriesLength = changingTemplateEntries.length;
  const changingTemplateX = new Int8Array(changingEntriesLength);
  const changingTemplateY = new Int8Array(changingEntriesLength);
  const changingTemplateBit = new Uint16Array(changingEntriesLength);
  per (c = 0; c < lunghezzaVocimodifica; c++) {
    k = changingTemplateEntries[c];
    changingTemplateX[c] = template[k].x;
    changingTemplateY[c] = template[k].y;
    changingTemplateBit[c] = 1 << templateLength - 1 - k;
  }
  const sbb_left = -minX;
  const sbb_top = -minY;
  const sbb_right = larghezza - maxX;
  const pseudoPixelContext = ReusedContexts[templateIndex];
  lascia riga = nuovo Uint8Array(larghezza);
  bitmap costante = [];
  const decoder = decodingContext.decoder;
  contesti costanti = decodingContext.contextCache.getContexts("GB");
  sia ltp = 0,
    J,
    io0,
    j0,
    etichetta di contesto = 0,
    morso,
    spostare;
  per (lascia che i = 0; i < altezza; i++) {
    se (previsione) {
      const sltp = decoder.readBit(contesti, pseudoPixelContext);
      ltp ^= sltp;
      se (ltp) {
        bitmap.push(riga);
        continuare;
      }
    }
    riga = nuovo Uint8Array(riga);
    bitmap.push(riga);
    per (j = 0; j < larghezza; j++) {
      se (usa salta && salta[i][j]) {
        riga[j] = 0;
        continuare;
      }
      se (j >= sbb_sinistra e j < sbb_destra e i >= sbb_top) {
        contextLabel = contextLabel << 1 & reuseMask;
        per (k = 0; k < lunghezzaVociModifica; k++) {
          i0 = i + changingTemplateY[k];
          j0 = j + changingTemplateX[k];
          bit = bitmap[i0][j0];
          se (bit) {
            bit = changingTemplateBit[k];
            etichetta di contesto |= bit;
          }
        }
      } altro {
        etichetta di contesto = 0;
        shift = templateLength - 1;
        per (k = 0; k < lunghezzamodello; k++, shift--) {
          j0 = j + templateX[k];
          se (j0 >= 0 && j0 < larghezza) {
            i0 = i + modelloY[k];
            se (i0 >= 0) {
              bit = bitmap[i0][j0];
              se (bit) {
                contextLabel |= bit << shift;
              }
            }
          }
        }
      }
      const pixel = decoder.readBit(contesti, contextLabel);
      riga[j] = pixel;
    }
  }
  restituisci bitmap;
}
funzione decodeRefinement(larghezza, altezza, templateIndex, referenceBitmap, offsetX, offsetY, previsione, a, decodingContext) {
  lascia codingTemplate = RefinementTemplates[templateIndex].coding;
  se (templateIndex === 0) {
    codingTemplate = codingTemplate.concat([at[0]]);
  }
  const codingTemplateLength = codingTemplate.length;
  const codingTemplateX = new Int32Array(codingTemplateLength);
  const codingTemplateY = new Int32Array(codingTemplateLength);
  lascia k;
  per (k = 0; k < codingTemplateLength; k++) {
    codingTemplateX[k] = codingTemplate[k].x;
    codingTemplateY[k] = codingTemplate[k].y;
  }
  lascia referenceTemplate = RefinementTemplates[templateIndex].reference;
  se (templateIndex === 0) {
    modello di riferimento = modello di riferimento.concat([at[1]]);
  }
  const referenceTemplateLength = referenceTemplate.length;
  const referenceTemplateX = new Int32Array(referenceTemplateLength);
  const referenceTemplateY = new Int32Array(referenceTemplateLength);
  per (k = 0; k < lunghezzamodelloriferimento; k++) {
    modello di riferimentoX[k] = modello di riferimento[k].x;
    modello di riferimentoY[k] = modello di riferimento[k].y;
  }
  const referenceWidth = referenceBitmap[0].length;
  const referenceHeight = referenceBitmap.length;
  const pseudoPixelContext = RefinementReusedContexts[templateIndex];
  bitmap costante = [];
  const decoder = decodingContext.decoder;
  contesti costanti = decodingContext.contextCache.getContexts("GR");
  lascia ltp = 0;
  per (lascia che i = 0; i < altezza; i++) {
    se (previsione) {
      const sltp = decoder.readBit(contesti, pseudoPixelContext);
      ltp ^= sltp;
      se (ltp) {
        throw new Jbig2Error("la previsione non è supportata");
      }
    }
    const row = new Uint8Array(larghezza);
    bitmap.push(riga);
    per (lascia che j = 0; j < larghezza; j++) {
      lascia i0, j0;
      lascia contextLabel = 0;
      per (k = 0; k < codingTemplateLength; k++) {
        i0 = i + codingTemplateY[k];
        j0 = j + codingTemplateX[k];
        se (i0 < 0 || j0 < 0 || j0 >= larghezza) {
          etichetta di contesto <<= 1;
        } altro {
          etichetta di contesto = etichetta di contesto << 1 | bitmap[i0][j0];
        }
      }
      per (k = 0; k < lunghezzamodelloriferimento; k++) {
        i0 = i + referenceTemplateY[k] - offsetY;
        j0 = j + referenceTemplateX[k] - offsetX;
        se (i0 < 0 || i0 >= altezzariferimento || j0 < 0 || j0 >= larghezzariferimento) {
          etichetta di contesto <<= 1;
        } altro {
          contextLabel = contextLabel << 1 | referenceBitmap[i0][j0];
        }
      }
      const pixel = decoder.readBit(contesti, contextLabel);
      riga[j] = pixel;
    }
  }
  restituisci bitmap;
}
funzione decodeSymbolDictionary(huffman, raffinamento, simboli, numero di nuovi simboli, numero di simboli esportati, huffmanTables, templateIndex, a, refinementTemplateIndex, refinementAt, decodingContext, huffmanInput) {
  se (huffman && raffinamento) {
    throw new Jbig2Error("il perfezionamento dei simboli con Huffman non è supportato");
  }
  const nuoviSimboli = [];
  lascia altezzacorrente = 0;
  lascia symbolCodeLength = (0, _core_utils.log2)(symbols.length + numberOfNewSymbols);
  const decoder = decodingContext.decoder;
  const contextCache = decodingContext.contextCache;
  lascia tableB1, symbolWidths;
  se (huffman) {
    tabellaB1 = getStandardTable(1);
    simboliLarghezze = [];
    LunghezzaCodiceSimbolo = Math.max(LunghezzaCodiceSimbolo, 1);
  }
  while (nuoviSimboli.lunghezza < numeroNuoviSimboli) {
    const deltaHeight = huffman ? huffmanTables.tableDeltaHeight.decode(huffmanInput) : decodeInteger(contextCache, "IADH", decoder);
    altezzacorrente += altezzadelta;
    lascia che currentWidth = 0,
      larghezza totale = 0;
    const firstSymbol = huffman ? symbolWidths.length : 0;
    mentre (vero) {
      const deltaWidth = huffman? huffmanTables.tableDeltaWidth.decode(huffmanInput) : decodeInteger(contextCache, "IADW", decoder);
      se (deltaWidth === null) {
        rottura;
      }
      larghezzacorrente += larghezzadelta;
      larghezza totale += larghezza corrente;
      lascia bitmap;
      se (raffinamento) {
        const numberOfInstances = decodeInteger(contextCache, "IAAI", decoder);
        se (numeroIstanze > 1) {
          bitmap = decodeTextRegion(huffman, refinement, currentWidth, currentHeight, 0, numberOfInstances, 1, symbols.concat(newSymbols), symbolCodeLength, 0, 0, 1, 0, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext, 0, huffmanInput);
        } altro {
          const symbolId = decodeIAID(contextCache, decoder, symbolCodeLength);
          const rdx = decodeInteger(contextCache, "IARDX", decoder);
          const rdy = decodeInteger(contextCache, "IARDY", decoder);
          const symbol = symbolId < symbols.length ? symbols[symbolId] : newSymbols[symbolId - symbols.length];
          bitmap = decodeRefinement(currentWidth, currentHeight, refinementTemplateIndex, symbol, rdx, rdy, false, refinementAt, decodingContext);
        }
        nuoviSimboli.push(bitmap);
      } altrimenti se (huffman) {
        symbolWidths.push(currentWidth);
      } altro {
        bitmap = decodeBitmap(false, currentWidth, currentHeight, templateIndex, false, null, at, decodingContext);
        nuoviSimboli.push(bitmap);
      }
    }
    se (huffman && !raffinamento) {
      const bitmapSize = huffmanTables.tableBitmapSize.decode(huffmanInput);
      huffmanInput.byteAlign();
      lascia che collectiveBitmap;
      se (bitmapSize === 0) {
        collectiveBitmap = readUncompressedBitmap(huffmanInput, totalWidth, currentHeight);
      } altro {
        const originalEnd = huffmanInput.end;
        const bitmapEnd = huffmanInput.position + bitmapSize;
        huffmanInput.end = bitmapEnd;
        collectiveBitmap = decodeMMRBitmap(huffmanInput, totalWidth, currentHeight, false);
        huffmanInput.end = originalEnd;
        huffmanInput.position = bitmapEnd;
      }
      const numberOfSymbolsDecoded = symbolWidths.length;
      se (primoSimbolo === numeroSimboliDecodificati - 1) {
        nuoviSimboli.push(collectiveBitmap);
      } altro {
        lasciami,
          e,
          xMin = 0,
          xMax,
          larghezza bitmap,
          simboloBitmap;
        per (i = primoSimbolo; i < numeroSimboliDecodificati; i++) {
          bitmapWidth = symbolWidths[i];
          xMax = xMin + larghezza bitmap;
          simboloBitmap = [];
          per (y = 0; y < altezzacorrente; y++) {
            symbolBitmap.push(collectiveBitmap[y].subarray(xMin, xMax));
          }
          nuoviSimboli.push(simboloBitmap);
          xMin = xMax;
        }
      }
    }
  }
  const exportedSymbols = [],
    bandiere = [];
  lascia currentFlag = false,
    io,
    ii;
  const totalSymbolsLength = symbols.length + numberOfNewSymbols;
  while (flags.length < totalSymbolsLength) {
    lascia runLength = huffman ? tableB1.decode(huffmanInput) : decodeInteger(contextCache, "IAEX", decoder);
    while (runLength--) {
      flags.push(currentFlag);
    }
    currentFlag = !currentFlag;
  }
  per (i = 0, ii = simboli.lunghezza; i < ii; i++) {
    se (flags[i]) {
      exportedSymbols.push(simboli[i]);
    }
  }
  per (lascia che j = 0; j < numeroDiNuoviSimboli; i++, j++) {
    se (flags[i]) {
      simboliesportati.push(nuovisimboli[j]);
    }
  }
  restituisci exportedSymbols;
}
funzione decodeTextRegion(huffman, raffinamento, larghezza, altezza, defaultPixelValue, numberOfSymbolInstances, stripSize, inputSymbols, symbolCodeLength, trasposto, dsOffset, referenceCorner, combinationOperator, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext, logStripSize, huffmanInput) {
  se (huffman && raffinamento) {
    throw new Jbig2Error("il raffinamento con Huffman non è supportato");
  }
  bitmap costante = [];
  lasciami, riga;
  per (i = 0; i < altezza; i++) {
    riga = nuovo Uint8Array(larghezza);
    se (valorePixelpredefinito) {
      per (lascia che j = 0; j < larghezza; j++) {
        riga[j] = valorePixelpredefinito;
      }
    }
    bitmap.push(riga);
  }
  const decoder = decodingContext.decoder;
  const contextCache = decodingContext.contextCache;
  lascia stripT = huffman ? -huffmanTables.tableDeltaT.decode(huffmanInput) : -decodeInteger(contextCache, "IADT", decoder);
  lascia firstS = 0;
  io = 0;
  while (i < numeroIstanzeSimbolo) {
    const deltaT = Huffman ? huffmanTables.tableDeltaT.decode(huffmanInput) : decodeInteger(contextCache, "IADT", decoder);
    stripT += deltaT;
    const deltaFirstS = huffman ? huffmanTables.tableFirstS.decode(huffmanInput) : decodeInteger(contextCache, "IAFS", decoder);
    primoS += deltaPrimoS;
    lascia che currentS = firstS;
    Fare {
      lascia che correnteT = 0;
      se (dimensionestriscia > 1) {
        currentT = huffman ? huffmanInput.readBits(logStripSize) : decodeInteger(contextCache, "IAIT", decoder);
      }
      const t = stripSize * stripT + currentT;
      const symbolId = huffman ? huffmanTables.symbolIDTable.decode(huffmanInput) : decodeIAID(contextCache, decoder, symbolCodeLength);
      const applyRefinement = refinement && (huffman ? huffmanInput.readBit() : decodeInteger(contextCache, "IARI", decoder));
      lascia symbolBitmap = inputSymbols[symbolId];
      lascia symbolWidth = symbolBitmap[0].length;
      lascia symbolHeight = symbolBitmap.length;
      se (applicaRefinement) {
        const rdw = decodeInteger(contextCache, "IARDW", decoder);
        const rdh = decodeInteger(contextCache, "IARDH", decoder);
        const rdx = decodeInteger(contextCache, "IARDX", decoder);
        const rdy = decodeInteger(contextCache, "IARDY", decoder);
        symbolWidth += rdw;
        altezzasimbolo += rdh;
        symbolBitmap = decodeRefinement(symbolWidth, symbolHeight, refinementTemplateIndex, symbolBitmap, (rdw >> 1) + rdx, (rdh >> 1) + rdy, false, refinementAt, decodingContext);
      }
      const offsetT = t - (referenceCorner & 1 ? 0 : symbolHeight - 1);
      const offsetS = currentS - (referenceCorner & 2 ? symbolWidth - 1 : 0);
      lascia s2, t2, symbolRow;
      se (trasposto) {
        per (s2 = 0; s2 < altezzasimbolo; s2++) {
          riga = bitmap[offsetS + s2];
          se (! riga) {
            continuare;
          }
          symbolRow = symbolBitmap[s2];
          const maxWidth = Math.min(larghezza - offsetT, symbolWidth);
          switch (operatore di combinazione) {
            caso 0:
              per (t2 = 0; t2 < larghezza massima; t2++) {
                riga[offsetT + t2] |= simboloRiga[t2];
              }
              rottura;
            caso 2:
              per (t2 = 0; t2 < larghezza massima; t2++) {
                riga[offsetT + t2] ^= simboloRiga[t2];
              }
              rottura;
            predefinito:
              throw new Jbig2Error(`l'operatore ${combinationOperator} non è supportato`);
          }
        }
        currentS += symbolHeight - 1;
      } altro {
        per (t2 = 0; t2 < altezzasimbolo; t2++) {
          riga = bitmap[offsetT + t2];
          se (! riga) {
            continuare;
          }
          symbolRow = symbolBitmap[t2];
          switch (operatore di combinazione) {
            caso 0:
              for (s2 = 0; s2 < larghezzasimbolo; s2++) {
                riga[offsetS + s2] |= simboloRiga[s2];
              }
              rottura;
            caso 2:
              for (s2 = 0; s2 < larghezzasimbolo; s2++) {
                riga[offsetS + s2] ^= simboloRiga[s2];
              }
              rottura;
            predefinito:
              throw new Jbig2Error(`l'operatore ${combinationOperator} non è supportato`);
          }
        }
        currentS += symbolWidth - 1;
      }
      i++;
      const deltaS = Huffman? huffmanTables.tableDeltaS.decode(huffmanInput) : decodeInteger(contextCache, "IADS", decoder);
      se (deltaS === null) {
        rottura;
      }
      currentS += deltaS + dsOffset;
    } mentre (vero);
  }
  restituisci bitmap;
}
funzione decodePatternDictionary(mmr, patternWidth, patternHeight, maxPatternIndex, template, decodingContext) {
  costante a = [];
  se (!mmr) {
    at.push({
      x: -larghezza del modello,
      e: 0
    });
    se (modello === 0) {
      at.push({
        x: -3,
        e: -1
      }, {
        x: 2,
        e: -2
      }, {
        x: -2,
        e: -2
      });
    }
  }
  const collectiveWidth = (maxPatternIndex + 1) * patternWidth;
  const collectiveBitmap = decodeBitmap(mmr, collectiveWidth, patternHeight, template, false, null, at, decodingContext);
  modelli costanti = [];
  per (lascia che i = 0; i <= maxPatternIndex; i++) {
    const patternBitmap = [];
    const xMin = patternWidth * i;
    const xMax = xMin + patternWidth;
    per (lascia che y = 0; y < patternHeight; y++) {
      patternBitmap.push(collectiveBitmap[y].subarray(xMin, xMax));
    }
    modelli.push(patternBitmap);
  }
  modelli di ritorno;
}
funzione decodeHalftoneRegion(mmr, modelli, modello, regionWidth, regionHeight, defaultPixelValue, enableSkip, combinationOperator, gridWidth, gridHeight, gridOffsetX, gridOffsetY, gridVectorX, gridVectorY, decodingContext) {
  const salta = null;
  se (abilitaSalta) {
    throw new Jbig2Error("skip non è supportato");
  }
  se (operatore di combinazione !== 0) {
    throw new Jbig2Error(`l'operatore "${combinationOperator}" non è supportato nella regione dei mezzitoni`);
  }
  const regionBitmap = [];
  lascia i, j, riga;
  per (i = 0; i < altezzaregione; i++) {
    riga = nuovo Uint8Array(larghezzaregione);
    se (valorePixelpredefinito) {
      per (j = 0; j < larghezzaregione; j++) {
        riga[j] = valorePixelpredefinito;
      }
    }
    regionBitmap.push(riga);
  }
  const numeroDiModelli = modelli.lunghezza;
  const pattern0 = patterns[0];
  const patternWidth = pattern0[0].length,
    patternHeight = pattern0.length;
  const bitsPerValue = (0, _core_utils.log2)(numberOfPatterns);
  costante a = [];
  se (!mmr) {
    at.push({
      x: modello <= 1 ? 3 : 2,
      e: -1
    });
    se (modello === 0) {
      at.push({
        x: -3,
        e: -1
      }, {
        x: 2,
        e: -2
      }, {
        x: -2,
        e: -2
      });
    }
  }
  const grayScaleBitPlanes = [];
  lascia mmrInput, bitmap;
  se (mmr) {
    mmrInput = new Reader(decodingContext.data, decodingContext.start, decodingContext.end);
  }
  per (i = bitPerValore - 1; i >= 0; i--) {
    se (mmr) {
      bitmap = decodeMMRBitmap(mmrInput, gridWidth, gridHeight, true);
    } altro {
      bitmap = decodeBitmap(false, gridWidth, gridHeight, template, false, skip, at, decodingContext);
    }
    grayScaleBitPlanes[i] = bitmap;
  }
  lascia mg, ng, bit, patternIndex, patternBitmap, x, y, patternRow, regionRow;
  per (mg = 0; mg < altezzagriglia; mg++) {
    for (ng = 0; ng < larghezzagriglia; ng++) {
      bit = 0;
      indice del modello = 0;
      per (j = bitPerValore - 1; j >= 0; j--) {
        bit ^= GrayScaleBitPlanes[j][mg][ng];
        patternIndex |= bit << j;
      }
      patternBitmap = patterns[patternIndex];
      x = gridOffsetX + mg * gridVectorY + ng * gridVectorX >> 8;
      y = gridOffsetY + mg * gridVectorX - ng * gridVectorY >> 8;
      se (x >= 0 e x + larghezza modello <= larghezza regione e y >= 0 e y + altezza modello <= altezza regione) {
        per (i = 0; i < altezzamodello; i++) {
          regionRow = regionBitmap[y + i];
          patternRow = patternBitmap[i];
          per (j = 0; j < larghezza del modello; j++) {
            rigaregione[x + j] |= rigamodello[j];
          }
        }
      } altro {
        lascia regioneX, regioneY;
        per (i = 0; i < altezzamodello; i++) {
          regioneY = y + i;
          if (regioneY < 0 || regioneY >= regioneAltezza) {
            continuare;
          }
          regioneRiga = regioneBitmap[regioneY];
          patternRow = patternBitmap[i];
          per (j = 0; j < larghezza del modello; j++) {
            regioneX = x + j;
            se (regioneX >= 0 e regioneX < larghezzaregione) {
              rigaregione[regioneX] |= rigamodello[j];
            }
          }
        }
      }
    }
  }
  restituisci regionBitmap;
}
funzione readSegmentHeader(dati, inizio) {
  const segmentHeader = {};
  segmentHeader.number = (0, _core_utils.readUint32)(data, start);
  const flags = data[start + 4];
  const segmentType = flags & 0x3f;
  if (!SegmentTypes[segmentType]) {
    throw new Jbig2Error("tipo di segmento non valido: " + segmentType);
  }
  segmentHeader.type = segmentType;
  segmentHeader.typeName = SegmentTypes[segmentType];
  segmentHeader.deferredNonRetain = !!(flags & 0x80);
  const pageAssociationFieldSize = !!(flags & 0x40);
  const referredFlags = data[start + 5];
  lascia che referredToCount = referredFlags >> 5 & 7;
  const retainBits = [referredFlags & 31];
  lascia posizione = inizio + 6;
  se (referredFlags === 7) {
    referredToCount = (0, _core_utils.readUint32)(dati, posizione - 1) & 0x1fffffff;
    posizione += 3;
    lascia byte = referredToCount + 7 >> 3;
    retainBits[0] = data[position++];
    mentre (--byte > 0) {
      retainBits.push(dati[posizione++]);
    }
  } altrimenti se (referredFlags === 5 || referenceFlags === 6) {
    throw new Jbig2Error("flag di riferimento non validi");
  }
  segmentHeader.retainBits = retainBits;
  lascia che referredToSegmentNumberSize = 4;
  se (segmentHeader.numero <= 256) {
    referenziatoADimensioneNumeroSegmento = 1;
  } altrimenti se (segmentHeader.numero <= 65536) {
    referenziatoADimensioneNumeroSegmento = 2;
  }
  const riferito a = [];
  sia i, ii;
  per (i = 0; i < referenziatoAConteggio; i++) {
    lascia il numero;
    se (dimensioneNumeroSegmentoriferito === 1) {
      numero = dati[posizione];
    } altrimenti se (referredToSegmentNumberSize === 2) {
      numero = (0, _core_utils.readUint16)(dati, posizione);
    } altro {
      numero = (0, _core_utils.readUint32)(dati, posizione);
    }
    riferito a.push(numero);
    posizione += referredToSegmentNumberSize;
  }
  segmentHeader.referredTo = referredTo;
  se (!pageAssociationFieldSize) {
    segmentHeader.pageAssociation = data[position++];
  } altro {
    segmentHeader.pageAssociation = (0, _core_utils.readUint32)(dati, posizione);
    posizione += 4;
  }
  segmentHeader.length = (0, _core_utils.readUint32)(dati, posizione);
  posizione += 4;
  se (segmentHeader.length === 0xffffffff) {
    se (segmentoTipo === 38) {
      const genericRegionInfo = readRegionSegmentInformation(dati, posizione);
      const genericRegionSegmentFlags = data[posizione + RegionSegmentInformationFieldLength];
      const genericRegionMmr = !!(genericRegionSegmentFlags & 1);
      const searchPatternLength = 6;
      const searchPattern = new Uint8Array(searchPatternLength);
      se (!genericRegionMmr) {
        modello di ricerca[0] = 0xff;
        searchPattern[1] = 0xac;
      }
      searchPattern[2] = genericRegionInfo.height >>> 24 & 0xff;
      searchPattern[3] = genericRegionInfo.height >> 16 & 0xff;
      searchPattern[4] = genericRegionInfo.height >> 8 & 0xff;
      searchPattern[5] = genericRegionInfo.height & 0xff;
      per (i = posizione, ii = lunghezza dati; i < ii; i++) {
        sia j = 0;
        while (j < searchPatternLength && searchPattern[j] === data[i + j]) {
          j++;
        }
        se (j === lunghezzamodelloricerca) {
          segmentHeader.length = i + searchPatternLength;
          rottura;
        }
      }
      se (segmentHeader.length === 0xffffffff) {
        throw new Jbig2Error("la fine del segmento non è stata trovata");
      }
    } altro {
      throw new Jbig2Error("lunghezza del segmento sconosciuta non valida");
    }
  }
  segmentHeader.headerEnd = posizione;
  restituisci segmentHeader;
}
funzione readSegments(intestazione, dati, inizio, fine) {
  segmenti costanti = [];
  lascia posizione = inizio;
  while (posizione < fine) {
    const segmentHeader = readSegmentHeader(dati, posizione);
    posizione = segmentHeader.headerEnd;
    segmento costante = {
      intestazione: segmentHeader,
      dati
    };
    se (!header.randomAccess) {
      segmento.inizio = posizione;
      posizione += segmentHeader.length;
      segmento.end = posizione;
    }
    segmenti.push(segmento);
    se (segmentHeader.type === 51) {
      rottura;
    }
  }
  se (intestazione.randomAccess) {
    per (lascia che i = 0, ii = segmenti.lunghezza; i < ii; i++) {
      segmenti[i].inizio = posizione;
      posizione += segmenti[i].header.length;
      segmenti[i].end = posizione;
    }
  }
  segmenti di ritorno;
}
funzione readRegionSegmentInformation(dati, inizio) {
  ritorno {
    larghezza: (0, _core_utils.readUint32)(dati, inizio),
    altezza: (0, _core_utils.readUint32)(dati, inizio + 4),
    x: (0, _core_utils.readUint32)(dati, inizio + 8),
    y: (0, _core_utils.readUint32)(dati, inizio + 12),
    combinationOperator: data[start + 16] & 7
  };
}
const RegionSegmentInformationFieldLength = 17;
funzione processSegment(segmento, visitatore) {
  const header = segmento.header;
  dati costanti = segmento.dati,
    fine = segmento.fine;
  lascia posizione = segmento.inizio;
  lascia args, at, i, atLength;
  switch (header.type) {
    caso 0:
      dizionario costante = {};
      const dictionaryFlags = (0, _core_utils.readUint16)(dati, posizione);
      dizionario.huffman = !!(dictionaryFlags & 1);
      dizionario.raffinamento = !!(dictionaryFlags & 2);
      dizionario.huffmanDHSelector = dictionaryFlags >> 2 & 3;
      dizionario.huffmanDWSelector = dictionaryFlags >> 4 & 3;
      dizionario.bitmapSizeSelector = dictionaryFlags >> 6 & 1;
      dizionario.aggregationInstancesSelector = dictionaryFlags >> 7 & 1;
      dizionario.bitmapCodingContextUsed = !!(dictionaryFlags & 256);
      dizionario.bitmapCodingContextRetained = !!(dictionaryFlags & 512);
      dizionario.template = dizionarioFlags >> 10 & 3;
      dictionary.refinementTemplate = dictionaryFlags >> 12 & 1;
      posizione += 2;
      se (!dizionario.huffman) {
        atLength = dizionario.template === 0 ? 4 : 1;
        a = [];
        per (i = 0; i < atLength; i++) {
          at.push({
            x: (0, _core_utils.readInt8)(dati, posizione),
            y: (0, _core_utils.readInt8)(dati, posizione + 1)
          });
          posizione += 2;
        }
        dizionario.at = at;
      }
      se (dizionario.raffinamento && !dizionario.raffinamentoTemplate) {
        a = [];
        per (i = 0; i < 2; i++) {
          at.push({
            x: (0, _core_utils.readInt8)(dati, posizione),
            y: (0, _core_utils.readInt8)(dati, posizione + 1)
          });
          posizione += 2;
        }
        dizionario.raffinamentoAt = at;
      }
      dizionario.numeroSimboliEsportati = (0, _core_utils.readUint32)(dati, posizione);
      posizione += 4;
      dizionario.numeroNuoviSimboli = (0, _core_utils.readUint32)(dati, posizione);
      posizione += 4;
      args = [dizionario, header.number, header.referredTo, dati, posizione, fine];
      rottura;
    caso 6:
    caso 7:
      const textRegion = {};
      textRegion.info = readRegionSegmentInformation(dati, posizione);
      posizione += RegionSegmentInformationFieldLength;
      const textRegionSegmentFlags = (0, _core_utils.readUint16)(dati, posizione);
      posizione += 2;
      textRegion.huffman = !!(textRegionSegmentFlags & 1);
      textRegion.refinement = !!(textRegionSegmentFlags & 2);
      textRegion.logStripSize = textRegionSegmentFlags >> 2 e 3;
      textRegion.stripSize = 1 << textRegion.logStripSize;
      textRegion.referenceCorner = textRegionSegmentFlags >> 4 & 3;
      textRegion.transposed = !!(textRegionSegmentFlags & 64);
      textRegion.combinationOperator = textRegionSegmentFlags >> 7 & 3;
      textRegion.defaultPixelValue = textRegionSegmentFlags >> 9 & 1;
      textRegion.dsOffset = textRegionSegmentFlags << 17 >> 27;
      textRegion.refinementTemplate = textRegionSegmentFlags >> 15 & 1;
      se (textRegion.huffman) {
        const textRegionHuffmanFlags = (0, _core_utils.readUint16)(dati, posizione);
        posizione += 2;
        textRegion.huffmanFS = textRegionHuffmanFlags & 3;
        textRegion.huffmanDS = textRegionHuffmanFlags >> 2 e 3;
        textRegion.huffmanDT = textRegionHuffmanFlags >> 4 & 3;
        textRegion.huffmanRefinementDW = textRegionHuffmanFlags >> 6 & 3;
        textRegion.huffmanRefinementDH = textRegionHuffmanFlags >> 8 & 3;
        textRegion.huffmanRefinementDX = textRegionHuffmanFlags >> 10 & 3;
        textRegion.huffmanRefinementDY = textRegionHuffmanFlags >> 12 & 3;
        textRegion.huffmanRefinementSizeSelector = !!(textRegionHuffmanFlags & 0x4000);
      }
      se (textRegion.refinement && !textRegion.refinementTemplate) {
        a = [];
        per (i = 0; i < 2; i++) {
          at.push({
            x: (0, _core_utils.readInt8)(dati, posizione),
            y: (0, _core_utils.readInt8)(dati, posizione + 1)
          });
          posizione += 2;
        }
        textRegion.refinementAt = at;
      }
      textRegion.numberOfSymbolInstances = (0, _core_utils.readUint32)(dati, posizione);
      posizione += 4;
      argomenti = [textRegion, header.referredTo, dati, posizione, fine];
      rottura;
    caso 16:
      const patternDictionary = {};
      const patternDictionaryFlags = data[position++];
      patternDictionary.mmr = !!(patternDictionaryFlags & 1);
      patternDictionary.template = patternDictionaryFlags >> 1 & 3;
      patternDictionary.patternWidth = data[position++];
      patternDictionary.patternHeight = data[position++];
      patternDictionary.maxPatternIndex = (0, _core_utils.readUint32)(dati, posizione);
      posizione += 4;
      args = [patternDictionary, header.number, data, position, end];
      rottura;
    caso 22:
    caso 23:
      const halftoneRegion = {};
      halftoneRegion.info = readRegionSegmentInformation(dati, posizione);
      posizione += RegionSegmentInformationFieldLength;
      const halftoneRegionFlags = data[position++];
      halftoneRegion.mmr = !!(halftoneRegionFlags & 1);
      halftoneRegion.template = halftoneRegionFlags >> 1 & 3;
      halftoneRegion.enableSkip = !!(halftoneRegionFlags & 8);
      halftoneRegion.combinationOperator = halftoneRegionFlags >> 4 & 7;
      halftoneRegion.defaultPixelValue = halftoneRegionFlags >> 7 & 1;
      halftoneRegion.gridWidth = (0, _core_utils.readUint32)(dati, posizione);
      posizione += 4;
      halftoneRegion.gridHeight = (0, _core_utils.readUint32)(dati, posizione);
      posizione += 4;
      halftoneRegion.gridOffsetX = (0, _core_utils.readUint32)(dati, posizione) & 0xffffffff;
      posizione += 4;
      halftoneRegion.gridOffsetY = (0, _core_utils.readUint32)(dati, posizione) & 0xffffffff;
      posizione += 4;
      halftoneRegion.gridVectorX = (0, _core_utils.readUint16)(dati, posizione);
      posizione += 2;
      halftoneRegion.gridVectorY = (0, _core_utils.readUint16)(dati, posizione);
      posizione += 2;
      args = [halftoneRegion, header.referredTo, data, position, end];
      rottura;
    caso 38:
    caso 39:
      const genericRegion = {};
      genericRegion.info = readRegionSegmentInformation(dati, posizione);
      posizione += RegionSegmentInformationFieldLength;
      const genericRegionSegmentFlags = data[position++];
      genericRegion.mmr = !!(genericRegionSegmentFlags & 1);
      genericRegion.template = genericRegionSegmentFlags >> 1 & 3;
      genericRegion.prediction = !!(genericRegionSegmentFlags & 8);
      se (!genericRegion.mmr) {
        atLength = genericRegion.template === 0 ? 4 : 1;
        a = [];
        per (i = 0; i < atLength; i++) {
          at.push({
            x: (0, _core_utils.readInt8)(dati, posizione),
            y: (0, _core_utils.readInt8)(dati, posizione + 1)
          });
          posizione += 2;
        }
        genericRegion.at = at;
      }
      args = [genericRegion, dati, posizione, fine];
      rottura;
    caso 48:
      const pageInfo = {
        larghezza: (0, _core_utils.readUint32)(dati, posizione),
        altezza: (0, _core_utils.readUint32)(dati, posizione + 4),
        risoluzioneX: (0, _core_utils.readUint32)(dati, posizione + 8),
        risoluzioneY: (0, _core_utils.readUint32)(dati, posizione + 12)
      };
      se (pageInfo.height === 0xffffffff) {
        elimina pageInfo.height;
      }
      const pageSegmentFlags = data[posizione + 16];
      (0, _core_utils.readUint16)(dati, posizione + 17);
      pageInfo.lossless = !!(pageSegmentFlags & 1);
      pageInfo.refinement = !!(pageSegmentFlags & 2);
      pageInfo.defaultPixelValue = pageSegmentFlags >> 2 e 1;
      pageInfo.combinationOperator = pageSegmentFlags >> 3 & 3;
      pageInfo.requiresBuffer = !!(pageSegmentFlags & 32);
      pageInfo.combinationOperatorOverride = !!(pageSegmentFlags & 64);
      argomenti = [pageInfo];
      rottura;
    caso 49:
      rottura;
    caso 50:
      rottura;
    caso 51:
      rottura;
    caso 53:
      argomenti = [intestazione.numero, dati, posizione, fine];
      rottura;
    caso 62:
      rottura;
    predefinito:
      throw new Jbig2Error(`il tipo di segmento ${header.typeName}(${header.type}) non è implementato`);
  }
  const callbackName = "on" + header.typeName;
  se (callbackName nel visitatore) {
    visitatore[callbackName].apply(visitatore, argomenti);
  }
}
funzione processSegments(segmenti, visitatore) {
  per (lascia che i = 0, ii = segmenti.lunghezza; i < ii; i++) {
    processSegment(segmenti[i], visitatore);
  }
}
funzione parseJbig2Chunks(chunks) {
  const visitor = new SimpleSegmentVisitor();
  per (lascia che i = 0, ii = chunks.length; i < ii; i++) {
    const chunk = chunks[i];
    segmenti costanti = readSegments({}, chunk.data, chunk.start, chunk.end);
    processSegments(segmenti, visitatore);
  }
  visitatore di ritorno.buffer;
}
funzione parseJbig2(dati) {
  genera un nuovo errore("Non implementato: parseJbig2");
}
classe SimpleSegmentVisitor {
  onPageInformation(info) {
    this.currentPageInfo = info;
    const rowSize = info.width + 7 >> 3;
    const buffer = new Uint8ClampedArray(rowSize * info.height);
    se (info.defaultPixelValue) {
      buffer.riempimento(0xff);
    }
    questo.buffer = buffer;
  }
  drawBitmap(regionInfo, bitmap) {
    const pageInfo = this.currentPageInfo;
    larghezza costante = regionInfo.width,
      altezza = regionInfo.height;
    const rowSize = pageInfo.width + 7 >> 3;
    const combinationOperator = pageInfo.combinationOperatorOverride ? regionInfo.combinationOperator : pageInfo.combinationOperator;
    const buffer = this.buffer;
    const mask0 = 128 >> ​​(regionInfo.x & 7);
    lascia offset0 = regionInfo.y * rowSize + (regionInfo.x >> 3);
    lascia i, j, maschera, offset;
    switch (operatore di combinazione) {
      caso 0:
        per (i = 0; i < altezza; i++) {
          maschera = maschera0;
          offset = offset0;
          per (j = 0; j < larghezza; j++) {
            se (bitmap[i][j]) {
              buffer[offset] |= maschera;
            }
            maschera >>= 1;
            se (!maschera) {
              maschera = 128;
              offset++;
            }
          }
          offset0 += rowSize;
        }
        rottura;
      caso 2:
        per (i = 0; i < altezza; i++) {
          maschera = maschera0;
          offset = offset0;
          per (j = 0; j < larghezza; j++) {
            se (bitmap[i][j]) {
              buffer[offset] ^= maschera;
            }
            maschera >>= 1;
            se (!maschera) {
              maschera = 128;
              offset++;
            }
          }
          offset0 += rowSize;
        }
        rottura;
      predefinito:
        throw new Jbig2Error(`l'operatore ${combinationOperator} non è supportato`);
    }
  }
  onImmediateGenericRegion(regione, dati, inizio, fine) {
    const regionInfo = region.info;
    const decodingContext = new DecodingContext(dati, inizio, fine);
    const bitmap = decodeBitmap(region.mmr, regionInfo.width, regionInfo.height, region.template, region.prediction, null, region.at, decodingContext);
    this.drawBitmap(regionInfo, bitmap);
  }
  onImmediateLosslessGenericRegion() {
    this.onImmediateGenericRegion(...argomenti);
  }
  onSymbolDictionary(dizionario, segmentocorrente, segmentiriferiti, dati, inizio, fine) {
    lascia huffmanTables, huffmanInput;
    se (dizionario.huffman) {
      huffmanTables = getSymbolDictionaryHuffmanTables(dizionario, segmenti di riferimento, this.customTables);
      huffmanInput = new Reader(dati, inizio, fine);
    }
    lascia simboli = questo.simboli;
    se (!simboli) {
      questo.simboli = simboli = {};
    }
    const inputSymbols = [];
    per (const referredSegment di referredSegments) {
      const referredSymbols = symbols[referredSegment];
      se (simboli di riferimento) {
        inputSymbols.push(...referredSymbols);
      }
    }
    const decodingContext = new DecodingContext(dati, inizio, fine);
    symbols[currentSegment] = decodeSymbolDictionary(dictionary.huffman, dictionary.refinement, inputSymbols, dictionary.numberOfNewSymbols, dictionary.numberOfExportedSymbols, huffmanTables, dictionary.template, dictionary.at, dictionary.refinementTemplate, dictionary.refinementAt, decodingContext, huffmanInput);
  }
  onImmediateTextRegion(regione, segmenti di riferimento, dati, inizio, fine) {
    const regionInfo = region.info;
    lascia huffmanTables, huffmanInput;
    const simboli = questo.simboli;
    const inputSymbols = [];
    per (const referredSegment di referredSegments) {
      const referredSymbols = symbols[referredSegment];
      se (simboli di riferimento) {
        inputSymbols.push(...referredSymbols);
      }
    }
    const symbolCodeLength = (0, _core_utils.log2)(inputSymbols.length);
    se (regione.huffman) {
      huffmanInput = new Reader(dati, inizio, fine);
      huffmanTables = getTextRegionHuffmanTables(regione, segmenti di riferimento, this.customTables, inputSymbols.length, huffmanInput);
    }
    const decodingContext = new DecodingContext(dati, inizio, fine);
    const bitmap = decodeTextRegion(region.huffman, region.refinement, regionInfo.width, regionInfo.height, region.defaultPixelValue, region.numberOfSymbolInstances, region.stripSize, inputSymbols, symbolCodeLength, region.transposed, region.dsOffset, region.referenceCorner, region.combinationOperator, huffmanTables, region.refinementTemplate, region.refinementAt, decodingContext, region.logStripSize, huffmanInput);
    this.drawBitmap(regionInfo, bitmap);
  }
  onImmediateLosslessTextRegion() {
    this.onImmediateTextRegion(...argomenti);
  }
  onPatternDictionary(dizionario, segmentocorrente, dati, inizio, fine) {
    lascia che i modelli = questo.modelli;
    se (!modelli) {
      questo.patterns = patterns = {};
    }
    const decodingContext = new DecodingContext(dati, inizio, fine);
    patterns[currentSegment] = decodePatternDictionary(dictionary.mmr, dictionary.patternWidth, dictionary.patternHeight, dictionary.maxPatternIndex, dictionary.template, decodingContext);
  }
  onImmediateHalftoneRegion(regione, segmenti di riferimento, dati, inizio, fine) {
    modelli costanti = questo.modelli[segmentiriferiti[0]];
    const regionInfo = region.info;
    const decodingContext = new DecodingContext(dati, inizio, fine);
    const bitmap = decodeHalftoneRegion(region.mmr, patterns, region.template, regionInfo.width, regionInfo.height, region.defaultPixelValue, region.enableSkip, region.combinationOperator, region.gridWidth, region.gridHeight, region.gridOffsetX, region.gridOffsetY, region.gridVectorX, region.gridVectorY, decodingContext);
    this.drawBitmap(regionInfo, bitmap);
  }
  onImmediateLosslessHalftoneRegion() {
    this.onImmediateHalftoneRegion(...argomenti);
  }
  onTables(segmentocorrente, dati, inizio, fine) {
    lascia che customTables = this.customTables;
    se (!Tabellepersonalizzate) {
      questo.tabellepersonalizzate = tabellepersonalizzate = {};
    }
    customTables[currentSegment] = decodeTablesSegment(dati, inizio, fine);
  }
}
classe HuffmanLine {
  costruttore(lineData) {
    se (lineData.length === 2) {
      questo.èOOB = vero;
      questo.intervalloBasso = 0;
      this.prefixLength = lineData[0];
      questo.intervalloLength = 0;
      this.prefixCode = lineData[1];
      this.isLowerRange = false;
    } altro {
      this.isOOB = false;
      questo.intervalloBasso = lineData[0];
      this.prefixLength = lineData[1];
      this.rangeLength = lineData[2];
      this.prefixCode = lineData[3];
      this.isLowerRange = lineData[4] === "inferiore";
    }
  }
}
classe HuffmanTreeNode {
  costruttore(linea) {
    questo.bambini = [];
    se (linea) {
      this.isLeaf = true;
      this.rangeLength = line.rangeLength;
      questo.intervalloBasso = linea.intervalloBasso;
      this.isLowerRange = line.isLowerRange;
      questo.èOOB = linea.èOOB;
    } altro {
      this.isLeaf = false;
    }
  }
  buildTree(linea, spostamento) {
    const bit = line.prefixCode >> shift & 1;
    se (spostamento <= 0) {
      this.children[bit] = new HuffmanTreeNode(line);
    } altro {
      lascia nodo = questo.bambini[bit];
      se (!nodo) {
        this.children[bit] = node = new HuffmanTreeNode(null);
      }
      node.buildTree(linea, shift - 1);
    }
  }
  decodeNode(lettore) {
    se (questo.èFoglia) {
      se (questo.èOOB) {
        restituisci null;
      }
      const htOffset = reader.readBits(this.rangeLength);
      restituisci this.rangeLow + (this.isLowerRange ? -htOffset : htOffset);
    }
    const node = this.children[reader.readBit()];
    se (!nodo) {
      genera un nuovo Jbig2Error("dati Huffman non validi");
    }
    restituisci node.decodeNode(lettore);
  }
}
classe HuffmanTable {
  costruttore(linee, prefissoCodiciFatto) {
    se (!prefixCodesDone) {
      this.assignPrefixCodes(linee);
    }
    this.rootNode = new HuffmanTreeNode(null);
    per (lascia che i = 0, ii = lunghezza linee; i < ii; i++) {
      const line = lines[i];
      se (line.prefixLength > 0) {
        this.rootNode.buildTree(linea, lunghezza prefisso linea - 1);
      }
    }
  }
  decodifica(lettore) {
    restituisci this.rootNode.decodeNode(lettore);
  }
  assegnaPrefixCodes(linee) {
    const linesLength = lines.length;
    lascia prefissoLunghezzaMassima = 0;
    per (lascia che i = 0; i < lunghezzarighe; i++) {
      prefixLengthMax = Math.max(prefixLengthMax, lines[i].prefixLength);
    }
    istogramma costante = nuovo Uint32Array(prefixLengthMax + 1);
    per (lascia che i = 0; i < lunghezzarighe; i++) {
      istogramma[linee[i].prefissoLunghezza]++;
    }
    lascia che lunghezzacorrente = 1,
      primoCodice = 0,
      codicecorrente,
      temperatura attuale,
      linea;
    istogramma[0] = 0;
    while (lunghezzacorrente <= lunghezzaprefissoMax) {
      firstCode = firstCode + istogramma[lunghezzacorrente - 1] << 1;
      codicecorrente = primocodice;
      temperatura attuale = 0;
      while (temperaturacorrente < lunghezzarighe) {
        riga = linee[temperaturacorrente];
        se (line.prefixLength === currentLength) {
          line.prefixCode = currentCode;
          codicecorrente++;
        }
        temperaturacorrente++;
      }
      lunghezzacorrente++;
    }
  }
}
funzione decodeTablesSegment(dati, inizio, fine) {
  const flags = data[start];
  const lowestValue = (0, _core_utils.readUint32)(data, start + 1) & 0xffffffff;
  const highestValue = (0, _core_utils.readUint32)(data, start + 5) & 0xffffffff;
  const reader = new Reader(dati, inizio + 9, fine);
  const prefixSizeBits = (flag >> 1 e 7) + 1;
  const rangeSizeBits = (flag >> 4 e 7) + 1;
  linee costanti = [];
  lascia prefissoLunghezza,
    intervalloLunghezza,
    currentRangeLow = lowestValue;
  Fare {
    prefixLength = reader.readBits(prefixSizeBits);
    intervalloLength = reader.readBits(intervalloSizeBits);
    lines.push(new HuffmanLine([currentRangeLow, prefixLength, rangeLength, 0]));
    currentRangeLow += 1 << rangeLength;
  } while (currentRangeLow < highestValue);
  prefixLength = reader.readBits(prefixSizeBits);
  lines.push(new HuffmanLine([lowestValue - 1, prefixLength, 32, 0, "lower"]));
  prefixLength = reader.readBits(prefixSizeBits);
  lines.push(new HuffmanLine([highestValue, prefixLength, 32, 0]));
  se (flag & 1) {
    prefixLength = reader.readBits(prefixSizeBits);
    linee.push(nuova HuffmanLine([prefissoLunghezza, 0]));
  }
  restituisci nuova HuffmanTable(linee, false);
}
const standardTablesCache = {};
funzione getStandardTable(numero) {
  lascia tabella = standardTablesCache[numero];
  se (tabella) {
    tabella di ritorno;
  }
  lascia linee;
  interruttore (numero) {
    caso 1:
      linee = [[0, 1, 4, 0x0], [16, 2, 8, 0x2], [272, 3, 16, 0x6], [65808, 3, 32, 0x7]];
      rottura;
    caso 2:
      linee = [[0, 1, 0, 0x0], [1, 2, 0, 0x2], [2, 3, 0, 0x6], [3, 4, 3, 0xe], [11, 5, 6, 0x1e], [75, 6, 32, 0x3e], [6, 0x3f]];
      rottura;
    caso 3:
      linee = [[-256, 8, 8, 0xfe], [0, 1, 0, 0x0], [1, 2, 0, 0x2], [2, 3, 0, 0x6], [3, 4, 3, 0xe], [11, 5, 6, 0x1e], [-257, 8, 32, 0xff, "inferiore"], [75, 7, 32, 0x7e], [6, 0x3e]];
      rottura;
    caso 4:
      linee = [[1, 1, 0, 0x0], [2, 2, 0, 0x2], [3, 3, 0, 0x6], [4, 4, 3, 0xe], [12, 5, 6, 0x1e], [76, 5, 32, 0x1f]];
      rottura;
    caso 5:
      linee = [[-255, 7, 8, 0x7e], [1, 1, 0, 0x0], [2, 2, 0, 0x2], [3, 3, 0, 0x6], [4, 4, 3, 0xe], [12, 5, 6, 0x1e], [-256, 7, 32, 0x7f, "inferiore"], [76, 6, 32, 0x3e]];
      rottura;
    caso 6:
      linee = [[-2048, 5, 10, 0x1c], [-1024, 4, 9, 0x8], [-512, 4, 8, 0x9], [-256, 4, 7, 0xa], [-128, 5, 6, 0x1d], [-64, 5, 5, 0x1e], [-32, 4, 5, 0xb], [0, 2, 7, 0x0], [128, 3, 7, 0x2], [256, 3, 8, 0x3], [512, 4, 9, 0xc], [1024, 4, 10, 0xd], [-2049, 6, 32, 0x3e, "inferiore"], [2048, 6, 32, 0x3f]];
      rottura;
    caso 7:
      linee = [[-1024, 4, 9, 0x8], [-512, 3, 8, 0x0], [-256, 4, 7, 0x9], [-128, 5, 6, 0x1a], [-64, 5, 5, 0x1b], [-32, 4, 5, 0xa], [0, 4, 5, 0xb], [32, 5, 5, 0x1c], [64, 5, 6, 0x1d], [128, 4, 7, 0xc], [256, 3, 8, 0x1], [512, 3, 9, 0x2], [1024, 3, 10, 0x3], [-1025, 5, 32, 0x1e, "inferiore"], [2048, 5, 32, 0x1f]];
      rottura;
    caso 8:
      linee = [[-15, 8, 3, 0xfc], [-7, 9, 1, 0x1fc], [-5, 8, 1, 0xfd], [-3, 9, 0, 0x1fd], [-2, 7, 0, 0x7c], [-1, 4, 0, 0xa], [0, 2, 1, 0x0], [2, 5, 0, 0x1a], [3, 6, 0, 0x3a], [4, 3, 4, 0x4], [20, 6, 1, 0x3b], [22, 4, 4, 0xb], [38, 4, 5, 0xc], [70, 5, 6, 0x1b], [134, 5, 7, 0x1c], [262, 6, 7, 0x3c], [390, 7, 8, 0x7d], [646, 6, 10, 0x3d], [-16, 9, 32, 0x1fe, "inferiore"], [1670, 9, 32, 0x1ff], [2, 0x1]];
      rottura;
    caso 9:
      linee = [[-31, 8, 4, 0xfc], [-15, 9, 2, 0x1fc], [-11, 8, 2, 0xfd], [-7, 9, 1, 0x1fd], [-5, 7, 1, 0x7c], [-3, 4, 1, 0xa], [-1, 3, 1, 0x2], [1, 3, 1, 0x3], [3, 5, 1, 0x1a], [5, 6, 1, 0x3a], [7, 3, 5, 0x4], [39, 6, 2, 0x3b], [43, 4, 5, 0xb], [75, 4, 6, 0xc], [139, 5, 7, 0x1b], [267, 5, 8, 0x1c], [523, 6, 8, 0x3c], [779, 7, 9, 0x7d], [1291, 6, 11, 0x3d], [-32, 9, 32, 0x1fe, "inferiore"], [3339, 9, 32, 0x1ff], [2, 0x0]];
      rottura;
    caso 10:
      linee = [[-21, 7, 4, 0x7a], [-5, 8, 0, 0xfc], [-4, 7, 0, 0x7b], [-3, 5, 0, 0x18], [-2, 2, 2, 0x0], [2, 5, 0, 0x19], [3, 6, 0, 0x36], [4, 7, 0, 0x7c], [5, 8, 0, 0xfd], [6, 2, 6, 0x1], [70, 5, 5, 0x1a], [102, 6, 5, 0x37], [134, 6, 6, 0x38], [198, 6, 7, 0x39], [326, 6, 8, 0x3a], [582, 6, 9, 0x3b], [1094, 6, 10, 0x3c], [2118, 7, 11, 0x7d], [-22, 8, 32, 0xfe, "inferiore"], [4166, 8, 32, 0xff], [2, 0x2]];
      rottura;
    caso 11:
      linee = [[1, 1, 0, 0x0], [2, 2, 1, 0x2], [4, 4, 0, 0xc], [5, 4, 1, 0xd], [7, 5, 1, 0x1c], [9, 5, 2, 0x1d], [13, 6, 2, 0x3c], [17, 7, 2, 0x7a], [21, 7, 3, 0x7b], [29, 7, 4, 0x7c], [45, 7, 5, 0x7d], [77, 7, 6, 0x7e], [141, 7, 32, 0x7f]];
      rottura;
    caso 12:
      linee = [[1, 1, 0, 0x0], [2, 2, 0, 0x2], [3, 3, 1, 0x6], [5, 5, 0, 0x1c], [6, 5, 1, 0x1d], [8, 6, 1, 0x3c], [10, 7, 0, 0x7a], [11, 7, 1, 0x7b], [13, 7, 2, 0x7c], [17, 7, 3, 0x7d], [25, 7, 4, 0x7e], [41, 8, 5, 0xfe], [73, 8, 32, 0xff]];
      rottura;
    caso 13:
      linee = [[1, 1, 0, 0x0], [2, 3, 0, 0x4], [3, 4, 0, 0xc], [4, 5, 0, 0x1c], [5, 4, 1, 0xd], [7, 3, 3, 0x5], [15, 6, 1, 0x3a], [17, 6, 2, 0x3b], [21, 6, 3, 0x3c], [29, 6, 4, 0x3d], [45, 6, 5, 0x3e], [77, 7, 6, 0x7e], [141, 7, 32, 0x7f]];
      rottura;
    caso 14:
      linee = [[-2, 3, 0, 0x4], [-1, 3, 0, 0x5], [0, 1, 0, 0x0], [1, 3, 0, 0x6], [2, 3, 0, 0x7]];
      rottura;
    caso 15:
      linee = [[-24, 7, 4, 0x7c], [-8, 6, 2, 0x3c], [-4, 5, 1, 0x1c], [-2, 4, 0, 0xc], [-1, 3, 0, 0x4], [0, 1, 0, 0x0], [1, 3, 0, 0x5], [2, 4, 0, 0xd], [3, 5, 1, 0x1d], [5, 6, 2, 0x3d], [9, 7, 4, 0x7d], [-25, 7, 32, 0x7e, "inferiore"], [25, 7, 32, 0x7f]];
      rottura;
    predefinito:
      throw new Jbig2Error(`la tabella standard B.${number} non esiste`);
  }
  per (lascia che i = 0, ii = lunghezza linee; i < ii; i++) {
    linee[i] = nuova HuffmanLine(linee[i]);
  }
  tabella = new HuffmanTable(linee, true);
  standardTablesCache[numero] = tabella;
  tabella di ritorno;
}
classe Lettore {
  costruttore(dati, inizio, fine) {
    questo.dati = dati;
    questo.inizio = inizio;
    questo.fine = fine;
    questa.posizione = inizio;
    questo.spostamento = -1;
    questo.currentByte = 0;
  }
  leggiBit() {
    se (questo.spostamento < 0) {
      se (questa.posizione >= questa.fine) {
        throw new Jbig2Error("fine dei dati durante la lettura del bit");
      }
      questo.bytecorrente = questo.dato[questa.posizione++];
      questo.shift = 7;
    }
    const bit = this.currentByte >> this.shift & 1;
    questo.shift--;
    bit di ritorno;
  }
  leggiBits(numBits) {
    lascia che il risultato = 0,
      io;
    per (i = numBits - 1; i >= 0; i--) {
      risultato |= this.readBit() << i;
    }
    restituisci il risultato;
  }
  byteAlign() {
    questo.spostamento = -1;
  }
  Prossimo() {
    se (questa.posizione >= questa.fine) {
      restituisci -1;
    }
    restituisci questo.dato[questa.posizione++];
  }
}
funzione getCustomHuffmanTable(indice, referenziato, tabellepersonalizzate) {
  lascia indicecorrente = 0;
  per (lascia che i = 0, ii = referredTo.length; i < ii; i++) {
    const table = customTables[referredTo[i]];
    se (tabella) {
      se (indice === indicecorrente) {
        tabella di ritorno;
      }
      indicecorrente++;
    }
  }
  throw new Jbig2Error("impossibile trovare la tabella Huffman personalizzata");
}
funzione getTextRegionHuffmanTables(textRegion, referredTo, customTables, numberOfSymbols, reader) {
  codici costanti = [];
  per (lascia che i = 0; i <= 34; i++) {
    const codeLength = reader.readBits(4);
    codici.push(new HuffmanLine([i, lunghezzacodice, 0, 0]));
  }
  const runCodesTable = new HuffmanTable(codici, false);
  codici.lunghezza = 0;
  per (lascia che i = 0; i < numeroSimboli;) {
    const codeLength = runCodesTable.decode(lettore);
    se (lunghezzacodice >= 32) {
      lascia repeatLength, numberOfRepeats, j;
      switch (lunghezza del codice) {
        caso 32:
          se (i === 0) {
            throw new Jbig2Error("nessun valore precedente nella tabella degli ID dei simboli");
          }
          numero di ripetizioni = reader.readBits(2) + 3;
          repeatedLength = codes[i - 1].prefixLength;
          rottura;
        caso 33:
          numero di ripetizioni = reader.readBits(3) + 3;
          lunghezzaripetuta = 0;
          rottura;
        caso 34:
          numero di ripetizioni = reader.readBits(7) + 11;
          lunghezzaripetuta = 0;
          rottura;
        predefinito:
          throw new Jbig2Error("lunghezza del codice non valida nella tabella degli ID dei simboli");
      }
      per (j = 0; j < numeroDiRipetizioni; j++) {
        codici.push(new HuffmanLine([i, lunghezzaripetuta, 0, 0]));
        i++;
      }
    } altro {
      codici.push(new HuffmanLine([i, lunghezzacodice, 0, 0]));
      i++;
    }
  }
  lettore.byteAlign();
  const symbolIDTable = new HuffmanTable(codici, false);
  lascia customIndex = 0,
    tableFirstS,
    tabellaDeltaS,
    tabellaDeltaT;
  switch (textRegion.huffmanFS) {
    caso 0:
    caso 1:
      tableFirstS = getStandardTable(textRegion.huffmanFS + 6);
      rottura;
    caso 3:
      tableFirstS = getCustomHuffmanTable(customIndex, referredTo, customTables);
      indicepersonalizzato++;
      rottura;
    predefinito:
      genera un nuovo Jbig2Error("selettore Huffman FS non valido");
  }
  cambia (textRegion.huffmanDS) {
    caso 0:
    caso 1:
    caso 2:
      tableDeltaS = getStandardTable(textRegion.huffmanDS + 8);
      rottura;
    caso 3:
      tableDeltaS = getCustomHuffmanTable(customIndex, referredTo, customTables);
      indicepersonalizzato++;
      rottura;
    predefinito:
      lancia un nuovo Jbig2Error("selettore Huffman DS non valido");
  }
  cambia (textRegion.huffmanDT) {
    caso 0:
    caso 1:
    caso 2:
      tableDeltaT = getStandardTable(textRegion.huffmanDT + 11);
      rottura;
    caso 3:
      tableDeltaT = getCustomHuffmanTable(customIndex, referredTo, customTables);
      indicepersonalizzato++;
      rottura;
    predefinito:
      genera un nuovo Jbig2Error("selettore DT di Huffman non valido");
  }
  se (textRegion.refinement) {
    throw new Jbig2Error("il raffinamento con Huffman non è supportato");
  }
  ritorno {
    symbolIDTable,
    tableFirstS,
    tabellaDeltaS,
    tabellaDeltaT
  };
}
funzione getSymbolDictionaryHuffmanTables(dizionario, referenziato, tabellepersonalizzate) {
  lascia customIndex = 0,
    tableDeltaHeight,
    tabellaDeltaWidth;
  switch (dictionary.huffmanDHSelector) {
    caso 0:
    caso 1:
      tableDeltaHeight = getStandardTable(dictionary.huffmanDHSelector + 4);
      rottura;
    caso 3:
      tableDeltaHeight = getCustomHuffmanTable(customIndex, referredTo, customTables);
      indicepersonalizzato++;
      rottura;
    predefinito:
      genera un nuovo Jbig2Error("selettore Huffman DH non valido");
  }
  switch (dictionary.huffmanDWSelector) {
    caso 0:
    caso 1:
      tableDeltaWidth = getStandardTable(dictionary.huffmanDWSelector + 2);
      rottura;
    caso 3:
      tableDeltaWidth = getCustomHuffmanTable(customIndex, referredTo, customTables);
      indicepersonalizzato++;
      rottura;
    predefinito:
      genera un nuovo Jbig2Error("selettore Huffman DW non valido");
  }
  lascia tableBitmapSize, tableAggregateInstances;
  se (dizionario.bitmapSizeSelector) {
    tableBitmapSize = getCustomHuffmanTable(customIndex, referredTo, customTables);
    indicepersonalizzato++;
  } altro {
    tableBitmapSize = getStandardTable(1);
  }
  se (dizionario.aggregazioneInstancesSelector) {
    tableAggregateInstances = getCustomHuffmanTable(customIndex, referredTo, customTables);
  } altro {
    tableAggregateInstances = getStandardTable(1);
  }
  ritorno {
    tableDeltaHeight,
    tabellaDeltaWidth,
    tableBitmapSize,
    tableAggregateInstances
  };
}
funzione readUncompressedBitmap(lettore, larghezza, altezza) {
  bitmap costante = [];
  per (lascia che y = 0; y < altezza; y++) {
    const row = new Uint8Array(larghezza);
    bitmap.push(riga);
    per (lascia che x = 0; x < larghezza; x++) {
      riga[x] = lettore.readBit();
    }
    lettore.byteAlign();
  }
  restituisci bitmap;
}
funzione decodeMMRBitmap(input, larghezza, altezza, endOfBlock) {
  parametri costanti = {
    K: -1,
    Colonne: larghezza,
    Righe: altezza,
    BlackIs1: vero,
    Fine del blocco: fine del blocco
  };
  const decoder = new _ccitt.CCITTFaxDecoder(input, params);
  bitmap costante = [];
  lascia currentByte,
    eof = falso;
  per (lascia che y = 0; y < altezza; y++) {
    const row = new Uint8Array(larghezza);
    bitmap.push(riga);
    lascia shift = -1;
    per (lascia che x = 0; x < larghezza; x++) {
      se (spostamento < 0) {
        currentByte = decoder.readNextChar();
        se (bytecorrente === -1) {
          currentByte = 0;
          eof = vero;
        }
        spostamento = 7;
      }
      riga[x] = currentByte >> shift & 1;
      spostare--;
    }
  }
  se (endOfBlock && !eof) {
    const lookForEOFLimit = 5;
    per (lascia che i = 0; i < cercaEOFLimit; i++) {
      se (decoder.readNextChar() === -1) {
        rottura;
      }
    }
  }
  restituisci bitmap;
}
classe Jbig2Image {
  parseChunks(frammenti) {
    restituisci parseJbig2Chunks(frammenti);
  }
  analizzare(dati) {
    genera un nuovo errore("Non implementato: Jbig2Image.parse");
  }
}
esportazioni.Jbig2Image = Jbig2Image;

/***/ }),
/* 25 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.ArithmeticDecoder = void 0;
const QeTable = [{
  qe: 0x5601,
  nmps: 1,
  nlps: 1,
  switchFlag: 1
}, {
  qe: 0x3401,
  nmps: 2,
  nlps: 6,
  switchFlag: 0
}, {
  qe: 0x1801,
  nmps: 3,
  nlps: 9,
  switchFlag: 0
}, {
  qe: 0x0ac1,
  nmps: 4,
  nlps: 12,
  switchFlag: 0
}, {
  qe: 0x0521,
  nmps: 5,
  nlps: 29,
  switchFlag: 0
}, {
  qe: 0x0221,
  nmps: 38,
  nlps: 33,
  switchFlag: 0
}, {
  qe: 0x5601,
  nmps: 7,
  nlps: 6,
  switchFlag: 1
}, {
  qe: 0x5401,
  nmps: 8,
  nlps: 14,
  switchFlag: 0
}, {
  qe: 0x4801,
  nmps: 9,
  nlps: 14,
  switchFlag: 0
}, {
  qe: 0x3801,
  nmps: 10,
  nlps: 14,
  switchFlag: 0
}, {
  qe: 0x3001,
  nmps: 11,
  nlps: 17,
  switchFlag: 0
}, {
  qe: 0x2401,
  nmps: 12,
  nlps: 18,
  switchFlag: 0
}, {
  qe: 0x1c01,
  nmps: 13,
  nlps: 20,
  switchFlag: 0
}, {
  qe: 0x1601,
  nmps: 29,
  nlps: 21,
  switchFlag: 0
}, {
  qe: 0x5601,
  nmps: 15,
  nlps: 14,
  switchFlag: 1
}, {
  qe: 0x5401,
  nmps: 16,
  nlps: 14,
  switchFlag: 0
}, {
  qe: 0x5101,
  nmps: 17,
  nlps: 15,
  switchFlag: 0
}, {
  qe: 0x4801,
  nmps: 18,
  nlps: 16,
  switchFlag: 0
}, {
  qe: 0x3801,
  nmps: 19,
  nlps: 17,
  switchFlag: 0
}, {
  qe: 0x3401,
  nmps: 20,
  nlps: 18,
  switchFlag: 0
}, {
  qe: 0x3001,
  nmps: 21,
  nlps: 19,
  switchFlag: 0
}, {
  qe: 0x2801,
  nmps: 22,
  nlps: 19,
  switchFlag: 0
}, {
  qe: 0x2401,
  nmps: 23,
  nlps: 20,
  switchFlag: 0
}, {
  qe: 0x2201,
  nmps: 24,
  nlps: 21,
  switchFlag: 0
}, {
  qe: 0x1c01,
  nmps: 25,
  nlps: 22,
  switchFlag: 0
}, {
  qe: 0x1801,
  nmps: 26,
  nlps: 23,
  switchFlag: 0
}, {
  qe: 0x1601,
  nmps: 27,
  nlps: 24,
  switchFlag: 0
}, {
  qe: 0x1401,
  nmps: 28,
  nlps: 25,
  switchFlag: 0
}, {
  qe: 0x1201,
  nmps: 29,
  nlps: 26,
  switchFlag: 0
}, {
  qe: 0x1101,
  nmps: 30,
  nlps: 27,
  switchFlag: 0
}, {
  qe: 0x0ac1,
  nmps: 31,
  nlps: 28,
  switchFlag: 0
}, {
  qe: 0x09c1,
  nmps: 32,
  nlps: 29,
  switchFlag: 0
}, {
  qe: 0x08a1,
  nmps: 33,
  nlps: 30,
  switchFlag: 0
}, {
  qe: 0x0521,
  nmps: 34,
  nlps: 31,
  switchFlag: 0
}, {
  qe: 0x0441,
  nmps: 35,
  nlps: 32,
  switchFlag: 0
}, {
  qe: 0x02a1,
  nmps: 36,
  nlps: 33,
  switchFlag: 0
}, {
  qe: 0x0221,
  nmps: 37,
  nlps: 34,
  switchFlag: 0
}, {
  qe: 0x0141,
  nmps: 38,
  nlps: 35,
  switchFlag: 0
}, {
  qe: 0x0111,
  nmps: 39,
  nlps: 36,
  switchFlag: 0
}, {
  qe: 0x0085,
  nmps: 40,
  nlps: 37,
  switchFlag: 0
}, {
  qe: 0x0049,
  nmps: 41,
  nlps: 38,
  switchFlag: 0
}, {
  qe: 0x0025,
  nmps: 42,
  nlps: 39,
  switchFlag: 0
}, {
  qe: 0x0015,
  nmps: 43,
  nlps: 40,
  switchFlag: 0
}, {
  qe: 0x0009,
  nmps: 44,
  nlps: 41,
  switchFlag: 0
}, {
  qe: 0x0005,
  nmps: 45,
  nlps: 42,
  switchFlag: 0
}, {
  qe: 0x0001,
  nmps: 45,
  nlps: 43,
  switchFlag: 0
}, {
  qe: 0x5601,
  nmps: 46,
  nlps: 46,
  switchFlag: 0
}];
classe ArithmeticDecoder {
  costruttore(dati, inizio, fine) {
    questo.dati = dati;
    questo.bp = inizio;
    this.dataEnd = fine;
    this.chigh = data[start];
    questo.clow = 0;
    questo.byteIn();
    questo.chigh = questo.chigh << 7 & 0xffff | questo.clow >> 9 & 0x7f;
    questo.clow = questo.clow << 7 & 0xffff;
    questo.ct -= 7;
    questo.a = 0x8000;
  }
  byteIn() {
    const data = this.data;
    lascia bp = questo.bp;
    se (dati[bp] === 0xff) {
      se (dati[bp + 1] > 0x8f) {
        questo.clow += 0xff00;
        questo.ct = 8;
      } altro {
        bp++;
        questo.clow += dati[bp] << 9;
        questo.ct = 7;
        questo.bp = bp;
      }
    } altro {
      bp++;
      questo.clow += bp < questo.dataEnd ? data[bp] << 8 : 0xff00;
      questo.ct = 8;
      questo.bp = bp;
    }
    se (this.clow > 0xffff) {
      questo.chigh += questo.clow >> 16;
      questo.clow &= 0xffff;
    }
  }
  readBit(contesti, pos) {
    lascia cx_index = contexts[pos] >> 1,
      cx_mps = contesti[pos] & 1;
    const qeTableIcx = QeTable[indice_cx];
    const qeIcx = qeTableIcx.qe;
    lascia d;
    sia a = questo.a - qeIcx;
    se (questo.chigh < qeIcx) {
      se (a < qeIcx) {
        a = qeIcx;
        d = cx_mps;
        cx_index = qeTableIcx.nmps;
      } altro {
        a = qeIcx;
        d = 1 ^ cx_mps;
        se (qeTableIcx.switchFlag === 1) {
          cx_mps = d;
        }
        cx_index = qeTableIcx.nlps;
      }
    } altro {
      questo.chigh -= qeIcx;
      se ((a & 0x8000) !== 0) {
        questo.a = a;
        restituisci cx_mps;
      }
      se (a < qeIcx) {
        d = 1 ^ cx_mps;
        se (qeTableIcx.switchFlag === 1) {
          cx_mps = d;
        }
        cx_index = qeTableIcx.nlps;
      } altro {
        d = cx_mps;
        cx_index = qeTableIcx.nmps;
      }
    }
    Fare {
      se (questo.ct === 0) {
        questo.byteIn();
      }
      un <<= 1;
      questo.chigh = questo.chigh << 1 & 0xffff | questo.clow >> 15 & 1;
      questo.clow = questo.clow << 1 & 0xffff;
      questo.ct--;
    } while ((a & 0x8000) === 0);
    questo.a = a;
    contesti[pos] = cx_index << 1 | cx_mps;
    ritorno d;
  }
}
esportazioni.ArithmeticDecoder = ArithmeticDecoder;

/***/ }),
/* 26 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.JpegStream = void 0;
var _decode_stream = __w_pdfjs_require__(18);
var _primitives = __w_pdfjs_require__(4);
var _jpg = __w_pdfjs_require__(27);
var _util = __w_pdfjs_require__(2);
classe JpegStream estende _decode_stream.DecodeStream {
  costruttore(flusso, forseLunghezza, parametri) {
    lascia ch;
    mentre ((ch = stream.getByte()) !== -1) {
      se (ch === 0xff) {
        flusso.salta(-1);
        rottura;
      }
    }
    super(forseLunghezza);
    questo.flusso = flusso;
    questo.dict = stream.dict;
    this.maybeLength = maybeLength;
    questo.parametri = parametri;
  }
  ottieni byte() {
    return (0, _util.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(richiesto) {}
  readBlock() {
    se (questo.eof) {
      ritorno;
    }
    const jpegOptions = {
      decodeTransform: indefinito,
      colorTransform: indefinito
    };
    const decodeArr = this.dict.getArray("D", "Decodifica");
    if ((this.forceRGBA || this.forceRGB) && Array.isArray(decodeArr)) {
      const bitsPerComponent = this.dict.get("BPC", "BitsPerComponent") || 8;
      const decodeArrLength = decodeArr.length;
      const transform = new Int32Array(decodeArrLength);
      lascia che transformNeeded = false;
      const maxValue = (1 << bitPerComponent) - 1;
      per (lascia che i = 0; i < decodeArrLength; i += 2) {
        trasforma[i] = (decodeArr[i + 1] - decodeArr[i]) * 256 | 0;
        transform[i + 1] = decodeArr[i] * maxValue | 0;
        se (trasforma[i] !== 256 || trasforma[i + 1] !== 0) {
          transformNeeded = true;
        }
      }
      se (trasformazioneNecessaria) {
        jpegOptions.decodeTransform = trasforma;
      }
    }
    se (this.params instanceof _primitives.Dict) {
      const colorTransform = this.params.get("ColorTransform");
      se (Numero.èIntero(TrasformazioneColore)) {
        jpegOptions.colorTransform = colorTransform;
      }
    }
    const jpegImage = new _jpg.JpegImage(jpegOptions);
    jpegImage.parse(this.bytes);
    dati costanti = jpegImage.getData({
      larghezza: this.drawWidth,
      altezza: this.drawHeight,
      forceRGBA: questo.forceRGBA,
      forceRGB: questo.forceRGB,
      isSourcePDF: vero
    });
    questo.buffer = dati;
    this.bufferLength = data.length;
    this.eof = true;
  }
}
esportazioni.JpegStream = JpegStream;

/***/ }),
/* 27 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.JpegImage = void 0;
var _util = __w_pdfjs_require__(2);
var _image_utils = __w_pdfjs_require__(28);
var _core_utils = __w_pdfjs_require__(3);
classe JpegError estende _util.BaseException {
  costruttore(msg) {
    super(`Errore JPEG: ${msg}`, "JpegError");
  }
}
classe DNLMarkerError estende _util.BaseException {
  costruttore(messaggio, linee di scansione) {
    super(messaggio, "DNLMarkerError");
    this.scanLines = scanLines;
  }
}
classe EOIMarkerError estende _util.BaseException {
  costruttore(msg) {
    super(msg, "EOIMarkerError");
  }
}
const dctZigZag = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);
const dctCos1 = 4017;
const dctSin1 = 799;
const dctCos3 = 3406;
const dctSin3 = 2276;
const dctCos6 = 1567;
const dctSin6 = 3784;
const dctSqrt2 = 5793;
const dctSqrt1d2 = 2896;
funzione buildHuffmanTable(codeLengths, valori) {
  sia k = 0,
    io,
    J,
    lunghezza = 16;
  while (lunghezza > 0 && !codeLengths[lunghezza - 1]) {
    lunghezza--;
  }
  codice costante = [{
    bambini: [],
    indice: 0
  }];
  lascia p = codice[0],
    Q;
  per (i = 0; i < lunghezza; i++) {
    for (j = 0; j < lunghezzacodice[i]; j++) {
      p = codice.pop();
      p.bambini[p.indice] = valori[k];
      mentre (p.index > 0) {
        p = codice.pop();
      }
      p.indice++;
      codice.push(p);
      mentre (lunghezza del codice <= i) {
        codice.push(q = {
          bambini: [],
          indice: 0
        });
        p.bambini[p.indice] = q.bambini;
        p = q;
      }
      k++;
    }
    se (i + 1 < lunghezza) {
      codice.push(q = {
        bambini: [],
        indice: 0
      });
      p.bambini[p.indice] = q.bambini;
      p = q;
    }
  }
  codice di ritorno[0].bambini;
}
funzione getBlockBufferOffset(componente, riga, colonna) {
  restituisci 64 * ((component.blocksPerLine + 1) * riga + colonna);
}
funzione decodeScan(dati, offset, frame, componenti, resetInterval, spectralStart, spectralEnd, successivePrev, successive, parseDNLMarker = false) {
  const mcusPerLine = frame.mcusPerLine;
  const progressive = frame.progressive;
  const startOffset = offset;
  lascia bitsData = 0,
    bitCount = 0;
  funzione readBit() {
    se (bitsCount > 0) {
      bitsCount--;
      restituisci bitsData >> bitsCount & 1;
    }
    bitsData = dati[offset++];
    se (bitsData === 0xff) {
      const nextByte = data[offset++];
      se (nextByte) {
        se (nextByte === 0xdc && parseDNLMarker) {
          spostamento += 2;
          const scanLines = (0, _core_utils.readUint16)(dati, offset);
          spostamento += 2;
          se (scanLines > 0 && scanLines !== frame.scanLines) {
            throw new DNLMarkerError("Trovato marcatore DNL (0xFFDC) durante l'analisi dei dati di scansione", scanLines);
          }
        } altrimenti se (nextByte === 0xd9) {
          se (parseDNLMarker) {
            const maybeScanLines = blockRow * (frame.precision === 8 ? 8 : 0);
            se (maybeScanLines > 0 && Math.round(frame.scanLines / maybeScanLines) >= 5) {
              throw new DNLMarkerError("Trovato marcatore EOI (0xFFD9) durante l'analisi dei dati di scansione, " + "probabilmente causato dal parametro `scanLines` non corretto", maybeScanLines);
            }
          }
          throw new EOIMarkerError("Trovato marcatore EOI (0xFFD9) durante l'analisi dei dati di scansione");
        }
        genera un nuovo JpegError(`marcatore inaspettato ${(bitsData << 8 | nextByte).toString(16)}`);
      }
    }
    bitCount = 7;
    restituisci bitData >>> 7;
  }
  funzione decodeHuffman(albero) {
    lascia nodo = albero;
    mentre (vero) {
      nodo = nodo[readBit()];
      switch (tipo di nodo) {
        caso "numero":
          nodo di ritorno;
        caso "oggetto":
          continuare;
      }
      throw new JpegError("sequenza di Huffman non valida");
    }
  }
  funzione ricevi(lunghezza) {
    sia n = 0;
    mentre (lunghezza > 0) {
      n = n << 1 | leggiBit();
      lunghezza--;
    }
    restituisci n;
  }
  funzione receiveAndExtend(lunghezza) {
    se (lunghezza === 1) {
      restituisci readBit() === 1 ? 1 : -1;
    }
    const n = ricevi(lunghezza);
    se (n >= 1 << lunghezza - 1) {
      restituisci n;
    }
    restituisce n + (-1 << lunghezza) + 1;
  }
  funzione decodeBaseline(componente, blockOffset) {
    const t = decodeHuffman(component.huffmanTableDC);
    const diff = t === 0 ? 0 : receiveAndExtend(t);
    componente.blockData[blockOffset] = componente.pred += diff;
    sia k = 1;
    mentre (k < 64) {
      const rs = decodeHuffman(component.huffmanTableAC);
      const s = rs & 15,
        r = rs >> 4;
      se (s === 0) {
        se (r < 15) {
          rottura;
        }
        k += 16;
        continuare;
      }
      k += r;
      const z = dctZigZag[k];
      componente.blockData[blockOffset + z] = receiveAndExtend(s);
      k++;
    }
  }
  funzione decodeDCFirst(componente, blockOffset) {
    const t = decodeHuffman(component.huffmanTableDC);
    const diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
    componente.blockData[blockOffset] = componente.pred += diff;
  }
  funzione decodeDCSuccessive(componente, blockOffset) {
    componente.blockData[blockOffset] |= readBit() << successive;
  }
  lascia eobrun = 0;
  funzione decodeACFirst(componente, blockOffset) {
    se (eobrun > 0) {
      eobrun--;
      ritorno;
    }
    lascia k = spectralStart;
    const e = spectralEnd;
    mentre (k <= e) {
      const rs = decodeHuffman(component.huffmanTableAC);
      const s = rs & 15,
        r = rs >> 4;
      se (s === 0) {
        se (r < 15) {
          eobrun = ricevi(r) + (1 << r) - 1;
          rottura;
        }
        k += 16;
        continuare;
      }
      k += r;
      const z = dctZigZag[k];
      componente.blockData[blockOffset + z] = receiveAndExtend(s) * (1 << successivi);
      k++;
    }
  }
  lascia successiveACState = 0,
    successiveACNextValue;
  funzione decodeACSuccessive(componente, blockOffset) {
    lascia k = spectralStart;
    const e = spectralEnd;
    sia r = 0;
    lascia s;
    lascia rs;
    mentre (k <= e) {
      const offsetZ = blockOffset + dctZigZag[k];
      segno costante = componente.blockData[offsetZ] < 0 ? -1 : 1;
      switch (successiveACState) {
        caso 0:
          rs = decodeHuffman(component.huffmanTableAC);
          s = rs & 15;
          r = rs >> 4;
          se (s === 0) {
            se (r < 15) {
              eobrun = ricevi(r) + (1 << r);
              successiveACState = 4;
            } altro {
              r = 16;
              successiveACState = 1;
            }
          } altro {
            se (s !== 1) {
              throw new JpegError("codifica ACn non valida");
            }
            successiveACNextValue = receiveAndExtend(s);
            successiveACState = r ? 2 : 3;
          }
          continuare;
        caso 1:
        caso 2:
          se (componente.blockData[offsetZ]) {
            component.blockData[offsetZ] += segno * (readBit() << successive);
          } altro {
            R--;
            se (r === 0) {
              successiveACState = successiveACState === 2 ? 3 : 0;
            }
          }
          rottura;
        caso 3:
          se (componente.blockData[offsetZ]) {
            component.blockData[offsetZ] += segno * (readBit() << successive);
          } altro {
            component.blockData[offsetZ] = successiveACNextValue << successive;
            successiveACState = 0;
          }
          rottura;
        caso 4:
          se (componente.blockData[offsetZ]) {
            component.blockData[offsetZ] += segno * (readBit() << successive);
          }
          rottura;
      }
      k++;
    }
    se (successiveACState === 4) {
      eobrun--;
      se (eobrun === 0) {
        successiveACState = 0;
      }
    }
  }
  lascia blockRow = 0;
  funzione decodeMcu(componente, decodifica, mcu, riga, colonna) {
    const mcuRow = mcu / mcusPerLine | 0;
    const mcuCol = mcu % mcusPerLine;
    blockRow = mcuRow * component.v + row;
    const blockCol = mcuCol * component.h + col;
    const blockOffset = getBlockBufferOffset(componente, blockRow, blockCol);
    decode(componente, blockOffset);
  }
  funzione decodeBlock(componente, decodifica, mcu) {
    blockRow = mcu / component.blocksPerLine | 0;
    const blockCol = mcu % component.blocksPerLine;
    const blockOffset = getBlockBufferOffset(componente, blockRow, blockCol);
    decode(componente, blockOffset);
  }
  const componentsLength = components.length;
  lascia componente, i, j, k, n;
  lascia decodificaFn;
  se (progressivo) {
    se (spettraleStart === 0) {
      decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
    } altro {
      decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
    }
  } altro {
    decodeFn = decodeBaseline;
  }
  lascia mcu = 0,
    fileMarker;
  const mcuExpected = componentsLength === 1 ? components[0].blocksPerLine * components[0].blocksPerColumn : mcusPerLine * frame.mcusPerColumn;
  siano h, v;
  mentre (mcu <= mcuExpected) {
    const mcuToRead = resetInterval ? Math.min(mcuExpected - mcu, resetInterval) : mcuExpected;
    se (mcuToRead > 0) {
      per (i = 0; i < lunghezzacomponenti; i++) {
        componenti[i].pred = 0;
      }
      eobrun = 0;
      se (lunghezzacomponenti === 1) {
        componente = componenti[0];
        per (n = 0; n < mcuToRead; n++) {
          decodeBlock(componente, decodeFn, mcu);
          mcu++;
        }
      } altro {
        per (n = 0; n < mcuToRead; n++) {
          per (i = 0; i < lunghezzacomponenti; i++) {
            componente = componenti[i];
            h = componente.h;
            v = componente.v;
            per (j = 0; j < v; j++) {
              per (k = 0; k < h; k++) {
                decodeMcu(componente, decodeFn, mcu, j, k);
              }
            }
          }
          mcu++;
        }
      }
    }
    bitCount = 0;
    fileMarker = findNextFileMarker(dati, offset);
    se (!fileMarker) {
      rottura;
    }
    se (fileMarker.non valido) {
      const partialMsg = mcuToRead > 0 ? "inaspettato" : "eccessivo";
      (0, _util.warn)(`decodeScan - ${partialMsg} dati MCU, il marcatore corrente è: ${fileMarker.invalid}`);
      offset = fileMarker.offset;
    }
    se (fileMarker.marker >= 0xffd0 e fileMarker.marker <= 0xffd7) {
      spostamento += 2;
    } altro {
      rottura;
    }
  }
  offset di ritorno - startOffset;
}
funzione quantizeAndInverse(componente, blockBufferOffset, p) {
  const qt = componente.quantizzazioneTable,
    blockData = componente.blockData;
  lascia che v0, v1, v2, v3, v4, v5, v6, v7;
  siano p0, p1, p2, p3, p4, p5, p6, p7;
  lascia t;
  se (!qt) {
    throw new JpegError("manca la tabella di quantizzazione richiesta.");
  }
  per (lascia che riga = 0; riga < 64; riga += 8) {
    p0 = blockData[blockBufferOffset + riga];
    p1 = blockData[blockBufferOffset + riga + 1];
    p2 = blockData[blockBufferOffset + riga + 2];
    p3 = blockData[blockBufferOffset + riga + 3];
    p4 = blockData[blockBufferOffset + riga + 4];
    p5 = blockData[blockBufferOffset + riga + 5];
    p6 = blockData[blockBufferOffset + riga + 6];
    p7 = blockData[blockBufferOffset + riga + 7];
    p0 *= qt[riga];
    se ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
      t = dctSqrt2 * p0 + 512 >> 10;
      p[riga] = t;
      p[riga + 1] = t;
      p[riga + 2] = t;
      p[riga + 3] = t;
      p[riga + 4] = t;
      p[riga + 5] = t;
      p[riga + 6] = t;
      p[riga + 7] = t;
      continuare;
    }
    p1 *= qt[riga + 1];
    p2 *= qt[riga + 2];
    p3 *= qt[riga + 3];
    p4 *= qt[riga + 4];
    p5 *= qt[riga + 5];
    p6 *= qt[riga + 6];
    p7 *= qt[riga + 7];
    v0 = dctSqrt2 * p0 + 128 >> ​​8;
    v1 = dctSqrt2 * p4 + 128 >> ​​8;
    v2 = p2;
    v3 = p6;
    v4 = dctSqrt1d2 * (p1 - p7) + 128 >> ​​8;
    v7 = dctSqrt1d2 * (p1 + p7) + 128 >> ​​8;
    v5 = p3 << 4;
    v6 = p5 << 4;
    v0 = v0 + v1 + 1 >> 1;
    v1 = v0 - v1;
    t = v2 * dctSin6 + v3 * dctCos6 + 128 >> ​​8;
    v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> ​​8;
    v3 = t;
    v4 = v4 + v6 + 1 >> 1;
    v6 = v4 - v6;
    v7 = v7 + v5 + 1 >> 1;
    v5 = v7 - v5;
    v0 = v0 + v3 + 1 >> 1;
    v3 = v0 - v3;
    v1 = v1 + v2 + 1 >> 1;
    v2 = v1 - v2;
    t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
    v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
    v7 = t;
    t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
    v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
    v6 = t;
    p[riga] = v0 + v7;
    p[riga + 7] = v0 - v7;
    p[riga + 1] = v1 + v6;
    p[riga + 6] = v1 - v6;
    p[riga + 2] = v2 + v5;
    p[riga + 5] = v2 - v5;
    p[riga + 3] = v3 + v4;
    p[riga + 4] = v3 - v4;
  }
  per (lascia che col = 0; col < 8; ++col) {
    p0 = p[col];
    p1 = p[col + 8];
    p2 = p[col + 16];
    p3 = p[col + 24];
    p4 = p[col + 32];
    p5 = p[col + 40];
    p6 = p[col + 48];
    p7 = p[col + 56];
    se ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
      t = dctSqrt2 * p0 + 8192 >> 14;
      se (t < -2040) {
        t = 0;
      } altrimenti se (t >= 2024) {
        t = 255;
      } altro {
        t = t + 2056 >> 4;
      }
      blockData[blockBufferOffset + col] = t;
      blockData[blockBufferOffset + col + 8] = t;
      blockData[blockBufferOffset + col + 16] = t;
      blockData[blockBufferOffset + col + 24] = t;
      blockData[blockBufferOffset + col + 32] = t;
      blockData[blockBufferOffset + col + 40] = t;
      blockData[blockBufferOffset + col + 48] = t;
      blockData[blockBufferOffset + col + 56] = t;
      continuare;
    }
    v0 = dctSqrt2 * p0 + 2048 >> 12;
    v1 = dctSqrt2 * p4 + 2048 >> 12;
    v2 = p2;
    v3 = p6;
    v4 = dctSqrt1d2 * (p1 - p7) + 2048 >> 12;
    v7 = dctSqrt1d2 * (p1 + p7) + 2048 >> 12;
    v5 = p3;
    v6 = p5;
    v0 = (v0 + v1 + 1 >> 1) + 4112;
    v1 = v0 - v1;
    t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
    v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
    v3 = t;
    v4 = v4 + v6 + 1 >> 1;
    v6 = v4 - v6;
    v7 = v7 + v5 + 1 >> 1;
    v5 = v7 - v5;
    v0 = v0 + v3 + 1 >> 1;
    v3 = v0 - v3;
    v1 = v1 + v2 + 1 >> 1;
    v2 = v1 - v2;
    t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
    v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
    v7 = t;
    t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
    v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
    v6 = t;
    p0 = v0 + v7;
    p7 = v0 - v7;
    p1 = v1 + v6;
    p6 = v1 - v6;
    p2 = v2 + v5;
    p5 = v2 - v5;
    p3 = v3 + v4;
    p4 = v3 - v4;
    se (p0 < 16) {
      p0 = 0;
    } altrimenti se (p0 >= 4080) {
      p0 = 255;
    } altro {
      p0 >>= 4;
    }
    se (p1 < 16) {
      p1 = 0;
    } altrimenti se (p1 >= 4080) {
      p1 = 255;
    } altro {
      p1 >>= 4;
    }
    se (p2 < 16) {
      p2 = 0;
    } altrimenti se (p2 >= 4080) {
      p2 = 255;
    } altro {
      p2 >>= 4;
    }
    se (p3 < 16) {
      p3 = 0;
    } altrimenti se (p3 >= 4080) {
      p3 = 255;
    } altro {
      p3 >>= 4;
    }
    se (p4 < 16) {
      p4 = 0;
    } altrimenti se (p4 >= 4080) {
      p4 = 255;
    } altro {
      p4 >>= 4;
    }
    se (p5 < 16) {
      p5 = 0;
    } altrimenti se (p5 >= 4080) {
      p5 = 255;
    } altro {
      p5 >>= 4;
    }
    se (p6 < 16) {
      p6 = 0;
    } altrimenti se (p6 >= 4080) {
      p6 = 255;
    } altro {
      p6 >>= 4;
    }
    se (p7 < 16) {
      p7 = 0;
    } altrimenti se (p7 >= 4080) {
      p7 = 255;
    } altro {
      p7 >>= 4;
    }
    blockData[blockBufferOffset + col] = p0;
    blockData[blockBufferOffset + col + 8] = p1;
    blockData[blockBufferOffset + col + 16] = p2;
    blockData[blockBufferOffset + col + 24] = p3;
    blockData[blockBufferOffset + col + 32] = p4;
    blockData[blockBufferOffset + col + 40] = p5;
    blockData[blockBufferOffset + col + 48] = p6;
    blockData[blockBufferOffset + col + 56] = p7;
  }
}
funzione buildComponentData(frame, componente) {
  const blocksPerLine = componente.blocksPerLine;
  const blocchiPerColonna = componente.blocchiPerColonna;
  const computationBuffer = new Int16Array(64);
  per (lascia che blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
    per (lascia che blockCol = 0; blockCol < blocksPerLine; blockCol++) {
      const offset = getBlockBufferOffset(componente, rigablocco, colonnablocco);
      quantizeAndInverse(componente, offset, computationBuffer);
    }
  }
  restituisci componente.blockData;
}
funzione findNextFileMarker(dati, currentPos, startPos = currentPos) {
  const maxPos = data.length - 1;
  lascia newPos = startPos < currentPos ? posizioneinizio: posizionecorrente;
  se (Pos.corrente >= Pos.massima) {
    restituisci null;
  }
  const currentMarker = (0, _core_utils.readUint16)(dati, currentPos);
  se (marcatorecorrente >= 0xffc0 e marcatorecorrente <= 0xfffe) {
    ritorno {
      non valido: nullo,
      marcatore: currentMarker,
      offset: posizione corrente
    };
  }
  lascia newMarker = (0, _core_utils.readUint16)(dati, newPos);
  mentre (!(newMarker >= 0xffc0 && newMarker <= 0xfffe)) {
    se (++nuovaPos >= maxPos) {
      restituisci null;
    }
    newMarker = (0, _core_utils.readUint16)(dati, newPos);
  }
  ritorno {
    non valido: currentMarker.toString(16),
    marcatore: nuovomarcatore,
    offset: newPos
  };
}
classe JpegImage {
  costruttore({
    decodeTransform = null,
    Trasformazione colore = -1
  } = {}) {
    this._decodeTransform = decodeTransform;
    this._colorTransform = colorTransform;
  }
  analizza(dati, {
    dnlScanLines = null
  } = {}) {
    funzione readDataBlock() {
      lunghezza costante = (0, _core_utils.readUint16)(dati, offset);
      spostamento += 2;
      lascia endOffset = offset + lunghezza - 2;
      const fileMarker = findNextFileMarker(dati, endOffset, offset);
      se (fileMarker?.non valido) {
        (0, _util.warn)("readDataBlock - lunghezza errata, il marcatore corrente è: " + fileMarker.invalid);
        endOffset = fileMarker.offset;
      }
      const array = data.subarray(offset, endOffset);
      offset += array.length;
      restituisci array;
    }
    funzione prepareComponents(frame) {
      const mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);
      const mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);
      per (componente costante di frame.components) {
        const blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / frame.maxH);
        const blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / frame.maxV);
        const blocksPerLineForMcu = mcusPerLine * component.h;
        const blocksPerColumnForMcu = mcusPerColumn * component.v;
        const blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);
        componente.blockData = new Int16Array(blocksBufferSize);
        componente.blocchiPerLine = blocchiPerLine;
        componente.blocchiPerColonna = blocchiPerColonna;
      }
      frame.mcusPerLine = mcusPerLine;
      frame.mcusPerColumn = mcusPerColumn;
    }
    lascia offset = 0;
    lascia jfif = null;
    lascia adobe = null;
    lascia frame, resetInterval;
    lascia numSOSMarkers = 0;
    const quantizationTables = [];
    const huffmanTablesAC = [],
      huffmanTablesDC = [];
    lascia fileMarker = (0, _core_utils.readUint16)(dati, offset);
    spostamento += 2;
    se (fileMarker !== 0xffd8) {
      throw new JpegError("SOI non trovato");
    }
    fileMarker = (0, _core_utils.readUint16)(dati, offset);
    spostamento += 2;
    markerLoop: while (fileMarker !== 0xffd9) {
      siano i, j, l;
      switch (fileMarker) {
        caso 0xffe0:
        caso 0xffe1:
        caso 0xffe2:
        caso 0xffe3:
        caso 0xffe4:
        caso 0xffe5:
        caso 0xffe6:
        caso 0xffe7:
        caso 0xffe8:
        caso 0xffe9:
        caso 0xffea:
        caso 0xffeb:
        caso 0xffec:
        caso 0xffed:
        caso 0xffee:
        caso 0xffef:
        caso 0xfffe:
          const appData = readDataBlock();
          se (fileMarker === 0xffe0) {
            se (appData[0] === 0x4a e appData[1] === 0x46 e appData[2] === 0x49 e appData[3] === 0x46 e appData[4] === 0) {
              jfif = {
                versione: {
                  principale: appData[5],
                  minore: appData[6]
                },
                densityUnits: appData[7],
                xDensità: appData[8] << 8 | appData[9],
                yDensità: appData[10] << 8 | appData[11],
                thumbWidth: appData[12],
                thumbHeight: appData[13],
                ThumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
              };
            }
          }
          se (fileMarker === 0xffee) {
            se (appData[0] === 0x41 e appData[1] === 0x64 e appData[2] === 0x6f e appData[3] === 0x62 e appData[4] === 0x65) {
              adobe = {
                versione: appData[5] << 8 | appData[6],
                flags0: appData[7] << 8 | datiapp[8],
                flags1: appData[9] << 8 | datiapp[10],
                Codice di trasformazione: appData[11]
              };
            }
          }
          rottura;
        caso 0xffdb:
          const quantizationTablesLength = (0, _core_utils.readUint16)(dati, offset);
          spostamento += 2;
          const quantizationTablesEnd = quantizationTablesLength + offset - 2;
          lascia z;
          while (offset < quantizationTablesEnd) {
            const quantizationTableSpec = data[offset++];
            const tableData = new Uint16Array(64);
            se (quantizationTableSpec >> 4 === 0) {
              per (j = 0; j < 64; j++) {
                z = dctZigZag[j];
                tableData[z] = data[offset++];
              }
            } altrimenti se (quantizationTableSpec >> 4 === 1) {
              per (j = 0; j < 64; j++) {
                z = dctZigZag[j];
                tableData[z] = (0, _core_utils.readUint16)(dati, offset);
                spostamento += 2;
              }
            } altro {
              throw new JpegError("DQT - specifica tabella non valida");
            }
            quantizationTables[quantizationTableSpec & 15] = tableData;
          }
          rottura;
        caso 0xffc0:
        caso 0xffc1:
        caso 0xffc2:
          se (frame) {
            throw new JpegError("Sono supportati solo JPEG a fotogramma singolo");
          }
          spostamento += 2;
          cornice = {};
          frame.extended = fileMarker === 0xffc1;
          frame.progressive = fileMarker === 0xffc2;
          frame.precision = data[offset++];
          const sofScanLines = (0, _core_utils.readUint16)(dati, offset);
          spostamento += 2;
          frame.scanLines = dnlScanLines || sofScanLines;
          frame.samplesPerLine = (0, _core_utils.readUint16)(dati, offset);
          spostamento += 2;
          frame.components = [];
          frame.componentIds = {};
          const componentsCount = data[offset++];
          sia maxH = 0,
            maxV = 0;
          per (i = 0; i < numerocomponenti; i++) {
            const componentId = dati[offset];
            const h = dati[offset + 1] >> 4;
            const v = dati[offset + 1] & 15;
            se (maxH < h) {
              maxH = h;
            }
            se (maxV < v) {
              maxV = v;
            }
            const qId = dati[offset + 2];
            l = frame.components.push({
              H,
              verso,
              quantizzazioneId: qId,
              quantizationTable: null
            });
            frame.componentIds[componentId] = l - 1;
            spostamento += 3;
          }
          frame.maxH = maxH;
          frame.maxV = maxV;
          prepareComponents(frame);
          rottura;
        caso 0xffc4:
          const huffmanLength = (0, _core_utils.readUint16)(dati, offset);
          spostamento += 2;
          per (i = 2; i < lunghezzaHuffman;) {
            const huffmanTableSpec = data[offset++];
            const codeLengths = new Uint8Array(16);
            lascia che codeLengthSum = 0;
            per (j = 0; j < 16; j++, offset++) {
              codeLengthSum += codeLengths[j] = dati[offset];
            }
            const huffmanValues ​​= new Uint8Array(codeLengthSum);
            per (j = 0; j < codeLengthSum; j++, offset++) {
              huffmanValues[j] = dati[offset];
            }
            i += 17 + codeLengthSum;
            (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
          }
          rottura;
        caso 0xffdd:
          spostamento += 2;
          resetInterval = (0, _core_utils.readUint16)(dati, offset);
          spostamento += 2;
          rottura;
        caso 0xffda:
          const parseDNLMarker = ++numSOSMarkers === 1 && !dnlScanLines;
          spostamento += 2;
          const selectorsCount = data[offset++],
            componenti = [];
          per (i = 0; i < selettoriCount; i++) {
            indice costante = dati[offset++];
            const componentIndex = frame.componentIds[indice];
            const componente = frame.componenti[indicecomponente];
            componente.indice = indice;
            const tableSpec = dati[offset++];
            componente.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
            componente.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
            componenti.push(componente);
          }
          const spectralStart = data[offset++],
            spectralEnd = dati[offset++],
            successiveApproximation = data[offset++];
          Tentativo {
            const processed = decodeScan(dati, offset, frame, componenti, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15, parseDNLMarker);
            offset += elaborato;
          } catturare (es.) {
            se (ad esempio instanceof DNLMarkerError) {
              (0, _util.warn)(`${ex.message} -- tentativo di rianalizzare l'immagine JPEG.`);
              restituisci questo.parse(dati, {
                dnlScanLines: ex.scanLines
              });
            } altrimenti se (ad esempio instanceof EOIMarkerError) {
              (0, _util.warn)(`${ex.message} -- ignorando il resto dei dati dell'immagine.`);
              marcatore di interruzioneLoop;
            }
            lanciare ex;
          }
          rottura;
        caso 0xffdc:
          spostamento += 4;
          rottura;
        caso 0xffff:
          se (dati[offset] !== 0xff) {
            offset--;
          }
          rottura;
        predefinito:
          const nextFileMarker = findNextFileMarker(dati, offset - 2, offset - 3);
          se (nextFileMarker?.non valido) {
            (0, _util.warn)("JpegImage.parse - dati inattesi, il marcatore corrente è: " + nextFileMarker.invalid);
            offset = nextFileMarker.offset;
            rottura;
          }
          se (!nextFileMarker || offset >= data.length - 1) {
            (0, _util.warn)("JpegImage.parse - ha raggiunto la fine dei dati dell'immagine " + "senza trovare un marcatore EOI (0xFFD9).");
            marcatore di interruzioneLoop;
          }
          genera un nuovo JpegError("JpegImage.parse - marcatore sconosciuto: " + fileMarker.toString(16));
      }
      fileMarker = (0, _core_utils.readUint16)(dati, offset);
      spostamento += 2;
    }
    this.width = frame.samplesPerLine;
    this.height = frame.scanLines;
    questo.jfif = jfif;
    questo.adobe = adobe;
    questo.componenti = [];
    per (componente costante di frame.components) {
      const quantizationTable = quantizationTables[component.quantizationId];
      se (tabella di quantizzazione) {
        componente.quantizationTable = quantizationTable;
      }
      questo.componenti.push({
        indice: componente.indice,
        output: buildComponentData(frame, componente),
        scaleX: componente.h / frame.maxH,
        scalaY: componente.v / frame.maxV,
        blocchiPerLine: componente.blocchiPerLine,
        blocchiPerColonna: componente.blocchiPerColonna
      });
    }
    questo.numComponenti = questa.lunghezza componenti;
    restituisci indefinito;
  }
  _getLinearizedBlockData(larghezza, altezza, isSourcePDF = false) {
    const scaleX = this.width / width,
      scaleY = this.height / altezza;
    lascia componente, componentScaleX, componentScaleY, blocksPerScanline;
    siano x, y, i, j, k;
    lascia indice;
    lascia offset = 0;
    lascia l'output;
    const numComponents = this.components.length;
    const dataLength = larghezza * altezza * numComponenti;
    const data = new Uint8ClampedArray(dataLength);
    const xScaleBlockOffset = new Uint32Array(larghezza);
    const mask3LSB = 0xfffffff8;
    lascia lastComponentScaleX;
    per (i = 0; i < numComponents; i++) {
      componente = questo.componenti[i];
      componentScaleX = component.scaleX * scaleX;
      componenteScaleY = componente.scalaY * scalaY;
      spostamento = i;
      output = componente.output;
      blocksPerScanline = componente.blocksPerLine + 1 << 3;
      se (componentScaleX !== lastComponentScaleX) {
        per (x = 0; x < larghezza; x++) {
          j = 0 | x * componenteScaleX;
          xScaleBlockOffset[x] = (j & mask3LSB) << 3 | j & 7;
        }
        lastComponentScaleX = componentScaleX;
      }
      per (y = 0; y < altezza; y++) {
        j = 0 | y * componenteScaleY;
        indice = blocksPerScanline * (j & mask3LSB) | (j & 7) << 3;
        per (x = 0; x < larghezza; x++) {
          dati[offset] = output[indice + xScaleBlockOffset[x]];
          offset += numComponents;
        }
      }
    }
    lascia trasformare = this._decodeTransform;
    se (!isSourcePDF && numComponents === 4 && !transform) {
      trasforma = nuovo Int32Array([-256, 255, -256, 255, -256, 255, -256, 255]);
    }
    se (trasforma) {
      per (i = 0; i < lunghezzadati;) {
        per (j = 0, k = 0; j < numComponents; j++, i++, k += 2) {
          dati[i] = (dati[i] * trasforma[k] >> 8) + trasforma[k + 1];
        }
      }
    }
    restituire i dati;
  }
  ottieni _isColorConversionNeeded() {
    se (questo.adobe) {
      restituisci !!this.adobe.transformCode;
    }
    se (questo.numComponenti === 3) {
      se (this._colorTransform === 0) {
        restituisci falso;
      } altrimenti se (this.components[0].index === 0x52 e this.components[1].index === 0x47 e this.components[2].index === 0x42) {
        restituisci falso;
      }
      restituisci vero;
    }
    se (this._colorTransform === 1) {
      restituisci vero;
    }
    restituisci falso;
  }
  _convertYccToRgb(dati) {
    siano Y, Cb, Cr;
    per (lascia che i = 0, lunghezza = data.length; i < lunghezza; i += 3) {
      Y = dati[i];
      Cb = dati[i + 1];
      Cr = dati[i + 2];
      dati[i] = Y - 179,456 + 1,402 * Cr;
      dati[i + 1] = Y + 135,459 - 0,344 * Cb - 0,714 * Cr;
      dati[i + 2] = Y - 226,816 + 1,772 * Cb;
    }
    restituire i dati;
  }
  _convertYccToRgba(dati, uscita) {
    per (lascia che i = 0, j = 0, lunghezza = data.length; i < lunghezza; i += 3, j += 4) {
      costante Y = dati[i];
      const Cb = dati[i + 1];
      const Cr = dati[i + 2];
      out[j] = Y - 179,456 + 1,402 * Cr;
      out[j + 1] = Y + 135,459 - 0,344 * Cb - 0,714 * Cr;
      out[j + 2] = Y - 226,816 + 1,772 * Cb;
      fuori[j + 3] = 255;
    }
    tornare fuori;
  }
  _convertYcckToRgb(dati) {
    siano Y, Cb, Cr, k;
    lascia offset = 0;
    per (lascia che i = 0, lunghezza = data.length; i < lunghezza; i += 4) {
      Y = dati[i];
      Cb = dati[i + 1];
      Cr = dati[i + 2];
      k = dati[i + 3];
      data[offset++] = -122,67195406894 + Cb * (-6,60635669420364e-5 * Cb + 0,000437130475926232 * Cr - 5,4080610064599e-5 * Y + 0,00048449797120281 * k - 0,154362151871126) + Cr * (-0,000957964378445773 * Cr + 0,000817076911346625 * Y - 0,00477271405408747 * k + 1,53380253221734) + Y * (0,000961250184130688 * Y - 0,00266257332283933 * k + 0,48357088451265) + k * (-0,000336197177618394 * k + 0,484791561490776);
      data[offset++] = 107.268039397724 + Cb * (2.19927104525741e-5 * Cb - 0.000640992018297945 * Cr + 0.000659397001245577 * Y + 0.000426105652938837 * k - 0.176491792462875) + Cr * (-0.000778269941513683 * Cr + 0.00130872261408275 * Y + 0.000770482631801132 * k - 0.151051492775562) + Y * (0,00126935368114843 * Y - 0,00265090189010898 * k + 0,25802910206845) + k * (-0,000318913117588328 * k - 0,213742400323665);
      data[offset++] = -20,810012546947 + Cb * (-0,000570115196973677 * Cb - 2,63409051004589e-5 * Cr + 0,0020741088115012 * Y - 0,00288260236853442 * k + 0,814272968359295) + Cr * (-1,53496057440975e-5 * Cr - 0,000132689043961446 * Y + 0,000560833691242812 * k - 0,195152027534049) + Y * (0,00174418132927582 * Y - 0,00255243321439347 * k + 0,116935020465145) + k * (-0,000343531996510555 * k + 0,24165260232407);
    }
    restituisci dati.subarray(0, offset);
  }
  _convertYcckToRgba(dati) {
    per (lascia che i = 0, lunghezza = data.length; i < lunghezza; i += 4) {
      costante Y = dati[i];
      const Cb = dati[i + 1];
      const Cr = dati[i + 2];
      costante k = dati[i + 3];
      dati[i] = -122,67195406894 + Cb * (-6,60635669420364e-5 * Cb + 0,000437130475926232 * Cr - 5,4080610064599e-5 * Y + 0,00048449797120281 * k - 0,154362151871126) + Cr * (-0,000957964378445773 * Cr + 0,000817076911346625 * Y - 0,00477271405408747 * k + 1,53380253221734) + Y * (0,000961250184130688 * Y - 0,00266257332283933 * k + 0,48357088451265) + k * (-0,000336197177618394 * k + 0,484791561490776);
      dati[i + 1] = 107,268039397724 + Cb * (2,19927104525741e-5 * Cb - 0,000640992018297945 * Cr + 0,000659397001245577 * Y + 0,000426105652938837 * k - 0,176491792462875) + Cr * (-0,000778269941513683 * Cr + 0,00130872261408275 * Y + 0,000770482631801132 * k - 0,151051492775562) + Y * (0,00126935368114843 * Y - 0,00265090189010898 * k + 0,25802910206845) + k * (-0,000318913117588328 * k - 0,213742400323665);
      dati[i + 2] = -20,810012546947 + Cb * (-0,000570115196973677 * Cb - 2,63409051004589e-5 * Cr + 0,0020741088115012 * Y - 0,00288260236853442 * k + 0,814272968359295) + Cr * (-1,53496057440975e-5 * Cr - 0,000132689043961446 * Y + 0,000560833691242812 * k - 0,195152027534049) + Y * (0,00174418132927582 * Y - 0,00255243321439347 * k + 0,116935020465145) + k * (-0,000343531996510555 * k + 0,24165260232407);
      dati[i + 3] = 255;
    }
    restituire i dati;
  }
  _convertYcckToCmyk(dati) {
    siano Y, Cb, Cr;
    per (lascia che i = 0, lunghezza = data.length; i < lunghezza; i += 4) {
      Y = dati[i];
      Cb = dati[i + 1];
      Cr = dati[i + 2];
      dati[i] = 434,456 - Y - 1,402 * Cr;
      dati[i + 1] = 119,541 - Y + 0,344 * Cb + 0,714 * Cr;
      dati[i + 2] = 481,816 - Y - 1,772 * Cb;
    }
    restituire i dati;
  }
  _convertCmykToRgb(dati) {
    siano c, m, y, k;
    lascia offset = 0;
    per (lascia che i = 0, lunghezza = data.length; i < lunghezza; i += 4) {
      c = dati[i];
      m = dati[i + 1];
      y = dati[i + 2];
      k = dati[i + 3];
      dati[offset++] = 255 + c * (-0,00006747147073602441 * c + 0,0008379262121013727 * m + 0,0002894718188643294 * y + 0,003264231057537806 * k - 1,1185611867203937) + m * (0,000026374107616089405 * m - 0,00008626949158638572 * y - 0,0002748769067499491 * k - 0,02155688794978967) + y * (-0,00003878099212869363 * y - 0,0003267808279485286 * k + 0,0686742238595345) - k * (0,0003361971776183937 * k + 0,7430659151342254);
      data[offset++] = 255 + c * (0,00013596372813588848 * c + 0,000924537132573585 * m + 0,00010567359618683593 * y + 0,0004791864687436512 * k - 0,3109689587515875) + m * (-0,00023545346108370344 * m + 0,0002702845253534714 * y + 0,0020200308977307156 * k - 0,7488052167015494) + y * (0,00006834815998235662 * y + 0,00015168452363460973 * k - 0,09751927774728933) - k * (0,0003189131175883281 * k + 0,7364883807733168);
      dati[offset++] = 255 + c * (0,000013598650411385307 * c + 0,00012423956175490851 * m + 0,0004751985097583589 * y - 0,0000036729317476630422 * k - 0,05562186980264034) + m * (0,00016141380598724676 * m + 0,0009692239130725186 * y + 0,0007782692450036253 * k - 0,44015232367526463) + y * (5.068882914068769e-7 * y + 0.0017778369011375071 * k - 0.7591454649749609) - k * (0.0003435319965105553 * k + 0.7063770186160144);
    }
    restituisci dati.subarray(0, offset);
  }
  _convertCmykToRgba(dati) {
    per (lascia che i = 0, lunghezza = data.length; i < lunghezza; i += 4) {
      const c = dati[i];
      const m = dati[i + 1];
      costante y = dati[i + 2];
      costante k = dati[i + 3];
      dati[i] = 255 + c * (-0,00006747147073602441 * c + 0,0008379262121013727 * m + 0,0002894718188643294 * y + 0,003264231057537806 * k - 1,1185611867203937) + m * (0,000026374107616089405 * m - 0,00008626949158638572 * y - 0,0002748769067499491 * k - 0,02155688794978967) + y * (-0,00003878099212869363 * y - 0,0003267808279485286 * k + 0,0686742238595345) - k * (0,0003361971776183937 * k + 0,7430659151342254);
      dati[i + 1] = 255 + c * (0,00013596372813588848 * c + 0,000924537132573585 * m + 0,00010567359618683593 * y + 0,0004791864687436512 * k - 0,3109689587515875) + m * (-0,00023545346108370344 * m + 0,0002702845253534714 * y + 0,0020200308977307156 * k - 0,7488052167015494) + y * (0,00006834815998235662 * y + 0,00015168452363460973 * k - 0,09751927774728933) - k * (0,0003189131175883281 * k + 0,7364883807733168);
      dati[i + 2] = 255 + c * (0,000013598650411385307 * c + 0,00012423956175490851 * m + 0,0004751985097583589 * y - 0,0000036729317476630422 * k - 0,05562186980264034) + m * (0,00016141380598724676 * m + 0,0009692239130725186 * y + 0,0007782692450036253 * k - 0,44015232367526463) + y * (5,068882914068769e-7 * y + 0,0017778369011375071 * k - 0,7591454649749609) - k * (0,0003435319965105553 * k + 0,7063770186160144);
      dati[i + 3] = 255;
    }
    restituire i dati;
  }
  ottieniDati({
    larghezza,
    altezza,
    forceRGBA = falso,
    forceRGB = falso,
    isSourcePDF = falso
  }) {
    se (this.numComponents > 4) {
      throw new JpegError("Modalità colore non supportata");
    }
    const data = this._getLinearizedBlockData(larghezza, altezza, isSourcePDF);
    if (this.numComponents === 1 && (forceRGBA || forceRGB)) {
      const len ​​= data.length * (forceRGBA ? 4: 3);
      const rgbaData = new Uint8ClampedArray(len);
      lascia offset = 0;
      se (forceRGBA) {
        (0, _image_utils.grayToRGBA)(dati, nuovo Uint32Array(rgbaData.buffer));
      } altro {
        per (const grayColor dei dati) {
          rgbaData[offset++] = grayColor;
          rgbaData[offset++] = grayColor;
          rgbaData[offset++] = grayColor;
        }
      }
      restituisci rgbaData;
    } altrimenti se (this.numComponents === 3 && this._isColorConversionNeeded) {
      se (forceRGBA) {
        const rgbaData = new Uint8ClampedArray(lunghezza dati / 3 * 4);
        restituisci questo._convertYccToRgba(dati, rgbaData);
      }
      restituisci questo._convertYccToRgb(dati);
    } altrimenti se (this.numComponents === 4) {
      se (this._isColorConversionNeeded) {
        se (forceRGBA) {
          restituisci questo._convertYcckToRgba(dati);
        }
        se (forzaRGB) {
          restituisci questo._convertYcckToRgb(dati);
        }
        restituisci questo._convertYcckToCmyk(dati);
      } altrimenti se (forceRGBA) {
        restituisci questo._convertCmykToRgba(dati);
      } altrimenti se (forceRGB) {
        restituisci questo._convertCmykToRgb(dati);
      }
    }
    restituire i dati;
  }
}
esportazioni.JpegImage = JpegImage;

/***/ }),
/* 28 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
exports.convertBlackAndWhiteToRGBA = convertBlackAndWhiteToRGBA;
esportazioni.convertToRGBA = convertToRGBA;
esportazioni.grayToRGBA = greyToRGBA;
var _util = __w_pdfjs_require__(2);
funzione convertToRGBA(parametri) {
  switch (params.kind) {
    caso _util.ImageKind.GRAYSCALE_1BPP:
      restituisci convertBlackAndWhiteToRGBA(parametri);
    caso _util.ImageKind.RGB_24BPP:
      restituisci convertRGBToRGBA(parametri);
  }
  restituisci null;
}
funzione convertBlackAndWhiteToRGBA({
  fonte,
  srcPos = 0,
  destinazione,
  larghezza,
  altezza,
  nonBlackColor = 0xffffffff,
  inverseDecode = false
}) {
  const nero = _util.FeatureTest.isLittleEndian ? 0xff000000: 0x000000ff;
  const [zeroMapping, oneMapping] = inverseDecode ? [nonBlackColor, nero] : [nero, nonBlackColor];
  const widthInSource = larghezza >> 3;
  const widthRemainder = width & 7;
  const srcLength = src.length;
  destinazione = nuovo Uint32Array(dest.buffer);
  lascia destPos = 0;
  per (lascia che i = 0; i < altezza; i++) {
    per (const max = srcPos + widthInSource; srcPos < max; srcPos++) {
      const elem = srcPos < srcLength ? src[srcPos] : 255;
      dest[destPos++] = elem & 0b10000000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b1000000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b100000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b10000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b1000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b100 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b10 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b1 ? oneMapping : zeroMapping;
    }
    se (larghezzaResto === 0) {
      continuare;
    }
    const elem = srcPos < srcLength ? src[srcPos++] : 255;
    per (lascia che j = 0; j < widthRemainder; j++) {
      dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;
    }
  }
  ritorno {
    srcPos,
    Posizione di destinazione
  };
}
funzione convertRGBToRGBA({
  fonte,
  srcPos = 0,
  destinazione,
  Posizione di destinazione = 0,
  larghezza,
  altezza
}) {
  sia i = 0;
  const len32 = src.length >> 2;
  const src32 = new Uint32Array(src.buffer, srcPos, len32);
  se (_util.FeatureTest.isLittleEndian) {
    per (; i < len32 - 2; i += 3, destPos += 4) {
      costante s1 = src32[i];
      costante s2 = src32[i + 1];
      costante s3 = src32[i + 2];
      dest[Pos.dest] = s1 | 0xff000000;
      dest[destPos + 1] = s1 >>> 24 | s2 << 8 | 0xff000000;
      dest[destPos + 2] = s2 >>> 16 | s3 << 16 | 0xff000000;
      dest[destPos + 3] = s3 >>> 8 | 0xff000000;
    }
    per (lascia che j = i * 4, jj = lunghezza src; j < jj; j += 3) {
      dest[destPos++] = src[j] | src[j + 1] << 8 | src[j + 2] << 16 | 0xff000000;
    }
  } altro {
    per (; i < len32 - 2; i += 3, destPos += 4) {
      costante s1 = src32[i];
      costante s2 = src32[i + 1];
      costante s3 = src32[i + 2];
      dest[Pos.dest] = s1 | 0xff;
      dest[destPos + 1] = s1 << 24 | s2 >>> 8 | 0xff;
      dest[destPos + 2] = s2 << 16 | s3 >>> 16 | 0xff;
      dest[destPos + 3] = s3 << 8 | 0xff;
    }
    per (lascia che j = i * 4, jj = lunghezza src; j < jj; j += 3) {
      dest[destPos++] = src[j] << 24 | src[j + 1] << 16 | src[j + 2] << 8 | 0xff;
    }
  }
  ritorno {
    srcPos,
    Posizione di destinazione
  };
}
funzione grayToRGBA(src, dest) {
  se (_util.FeatureTest.isLittleEndian) {
    per (lascia che i = 0, ii = lunghezza src; i < ii; i++) {
      dest[i] = src[i] * 0x10101 | 0xff000000;
    }
  } altro {
    per (lascia che i = 0, ii = lunghezza src; i < ii; i++) {
      dest[i] = src[i] * 0x1010100 | 0x000000ff;
    }
  }
}

/***/ }),
/* 29 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.JpxStream = void 0;
var _decode_stream = __w_pdfjs_require__(18);
variabile _jpx = __w_pdfjs_require__(30);
var _util = __w_pdfjs_require__(2);
classe JpxStream estende _decode_stream.DecodeStream {
  costruttore(flusso, forseLunghezza, parametri) {
    super(forseLunghezza);
    questo.flusso = flusso;
    questo.dict = stream.dict;
    this.maybeLength = maybeLength;
    questo.parametri = parametri;
  }
  ottieni byte() {
    return (0, _util.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(richiesto) {}
  readBlock() {
    se (questo.eof) {
      ritorno;
    }
    const jpxImage = new _jpx.JpxImage();
    jpxImage.parse(this.bytes);
    const width = jpxImage.width;
    altezza costante = jpxImage.height;
    const componentsCount = jpxImage.componentsCount;
    const tileCount = jpxImage.tiles.length;
    se (tileCount === 1) {
      questo.buffer = jpxImage.tiles[0].items;
    } altro {
      const data = new Uint8ClampedArray(larghezza * altezza * componentsCount);
      per (lascia che k = 0; k < tileCount; k++) {
        const tileComponents = jpxImage.tiles[k];
        const tileWidth = tileComponents.width;
        const tileHeight = tileComponents.height;
        const tileLeft = tileComponents.left;
        const tileTop = tileComponents.top;
        const src = tileComponents.items;
        lascia che srcPosition = 0;
        lascia dataPosition = (larghezza * tileTop + tileLeft) * componentsCount;
        const imgRowSize = larghezza * numero componenti;
        const tileRowSize = tileWidth * componentsCount;
        per (lascia che j = 0; j < tileHeight; j++) {
          const rowBytes = src.subarray(posizionesrc, posizionesrc + tileRowSize);
          data.set(rowBytes, dataPosition);
          srcPosition += tileRowSize;
          posizioneDati += dimensioneRigaImg;
        }
      }
      questo.buffer = dati;
    }
    questa.lunghezzadelbuffer = questa.lunghezzadelbuffer;
    this.eof = true;
  }
}
esportazioni.JpxStream = JpxStream;

/***/ }),
/* 30 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.JpxImage = void 0;
var _util = __w_pdfjs_require__(2);
var _core_utils = __w_pdfjs_require__(3);
var _arithmetic_decoder = __w_pdfjs_require__(25);
classe JpxError estende _util.BaseException {
  costruttore(msg) {
    super(`Errore JPX: ${msg}`, "JpxError");
  }
}
const SottobandeGuadagnoLog2 = {
  LL: 0,
  LH: 1,
  HL: 1,
  HH: 2
};
classe JpxImage {
  costruttore() {
    this.failOnCorruptedImage = false;
  }
  analizzare(dati) {
    const head = (0, _core_utils.readUint16)(dati, 0);
    se (testa === 0xff4f) {
      this.parseCodestream(dati, 0, lunghezza dati);
      ritorno;
    }
    lunghezza costante = lunghezza dati;
    lascia posizione = 0;
    while (posizione < lunghezza) {
      lascia headerSize = 8;
      lascia lbox = (0, _core_utils.readUint32)(dati, posizione);
      const tbox = (0, _core_utils.readUint32)(dati, posizione + 4);
      posizione += dimensioneintestazione;
      se (lbox === 1) {
        lbox = (0, _core_utils.readUint32)(dati, posizione) * 4294967296 + (0, _core_utils.readUint32)(dati, posizione + 4);
        posizione += 8;
        dimensioneintestazione += 8;
      }
      se (lbox === 0) {
        lbox = lunghezza - posizione + headerSize;
      }
      se (lbox < dimensioneintestazione) {
        throw new JpxError("Dimensione del campo casella non valida");
      }
      const dataLength = lbox - headerSize;
      lascia che jumpDataLength = true;
      interruttore (tbox) {
        caso 0x6a703268:
          jumpDataLength = falso;
          rottura;
        caso 0x636f6c72:
          metodo costante = dati[posizione];
          se (metodo === 1) {
            const colorspace = (0, _core_utils.readUint32)(dati, posizione + 3);
            cambia (spazio colore) {
              caso 16:
              caso 17:
              caso 18:
                rottura;
              predefinito:
                (0, _util.warn)("Spazio colore sconosciuto " + spazio colore);
                rottura;
            }
          } altrimenti se (metodo === 2) {
            (0, _util.info)("Profilo ICC non supportato");
          }
          rottura;
        caso 0x6a703263:
          this.parseCodestream(dati, posizione, posizione + lunghezzadati);
          rottura;
        caso 0x6a502020:
          se ((0, _core_utils.readUint32)(dati, posizione) !== 0x0d0a870a) {
            (0, _util.warn)("Firma JP2 non valida");
          }
          rottura;
        caso 0x6a501a1a:
        caso 0x66747970:
        caso 0x72726571:
        caso 0x72657320:
        caso 0x69686472:
          rottura;
        predefinito:
          const headerType = String.fromCharCode(tbox >> 24 & 0xff, tbox >> 16 & 0xff, tbox >> 8 & 0xff, tbox & 0xff);
          (0, _util.warn)(`Tipo di intestazione non supportato ${tbox} (${headerType}).`);
          rottura;
      }
      se (jumpDataLength) {
        posizione += lunghezzadati;
      }
    }
  }
  parseImageProperties(flusso) {
    lascia newByte = stream.getByte();
    mentre (nuovoByte >= 0) {
      const vecchioByte = nuovoByte;
      newByte = stream.getByte();
      codice costante = vecchioByte << 8 | nuovoByte;
      se (codice === 0xff51) {
        flusso.salta(4);
        const Xsiz = stream.getInt32() >>> 0;
        const Ysiz = stream.getInt32() >>> 0;
        const XOsiz = stream.getInt32() >>> 0;
        const YOsiz = stream.getInt32() >>> 0;
        flusso.salta(16);
        const Csiz = stream.getUint16();
        questa.larghezza = Xsiz - XOsiz;
        this.height = Ysiz - YOsiz;
        questo.componentsCount = Csiz;
        questo.bitsPerComponent = 8;
        ritorno;
      }
    }
    throw new JpxError("Nessun marcatore di dimensione trovato nel flusso JPX");
  }
  parseCodestream(dati, inizio, fine) {
    contesto costante = {};
    lascia che doNotRecover = false;
    Tentativo {
      lascia posizione = inizio;
      while (posizione + 1 < fine) {
        codice costante = (0, _core_utils.readUint16)(dati, posizione);
        posizione += 2;
        lascia che la lunghezza = 0,
          J,
          sqcd,
          spqcds,
          spqcdSize,
          scalareEsposto,
          piastrella;
        interruttore (codice) {
          caso 0xff4f:
            contesto.mainHeader = true;
            rottura;
          caso 0xffd9:
            rottura;
          caso 0xff51:
            lunghezza = (0, _core_utils.readUint16)(dati, posizione);
            costante dimensione = {};
            siz.Xsiz = (0, _core_utils.readUint32)(dati, posizione + 4);
            siz.Ysiz = (0, _core_utils.readUint32)(dati, posizione + 8);
            siz.XOsiz = (0, _core_utils.readUint32)(dati, posizione + 12);
            siz.YOsiz = (0, _core_utils.readUint32)(dati, posizione + 16);
            siz.XTsiz = (0, _core_utils.readUint32)(dati, posizione + 20);
            siz.YTsiz = (0, _core_utils.readUint32)(dati, posizione + 24);
            siz.XTOsiz = (0, _core_utils.readUint32)(dati, posizione + 28);
            siz.YTOsiz = (0, _core_utils.readUint32)(dati, posizione + 32);
            const componentsCount = (0, _core_utils.readUint16)(dati, posizione + 36);
            siz.Csiz = componentsCount;
            componenti costanti = [];
            j = posizione + 38;
            per (lascia che i = 0; i < componentsCount; i++) {
              componente costante = {
                precisione: (data[j] & 0x7f) + 1,
                è firmato: !!(data[j] & 0x80),
                XRsiz: dati[j + 1],
                YRsiz: dati[j + 2]
              };
              j += 3;
              calculateComponentDimensions(componente, dimensione);
              componenti.push(componente);
            }
            contesto.SIZ = siz;
            contesto.componenti = componenti;
            calculateTileGrids(contesto, componenti);
            contesto.QCC = [];
            contesto.COC = [];
            rottura;
          caso 0xff5c:
            lunghezza = (0, _core_utils.readUint16)(dati, posizione);
            const qcd = {};
            j = posizione + 2;
            sqcd = dati[j++];
            interruttore (sqcd e 0x1f) {
              caso 0:
                spqcdSize = 8;
                scalarExpounded = true;
                rottura;
              caso 1:
                spqcdSize = 16;
                scalarExpounded = false;
                rottura;
              caso 2:
                spqcdSize = 16;
                scalarExpounded = true;
                rottura;
              predefinito:
                genera un nuovo errore("Valore SQcd non valido" + sqcd);
            }
            qcd.noQuantization = spqcdSize === 8;
            qcd.scalarExpounded = scalarExpounded;
            qcd.guardBits = sqcd >> 5;
            spqcds = [];
            mentre (j < lunghezza + posizione) {
              const spqcd = {};
              se (spqcdSize === 8) {
                spqcd.epsilon = data[j++] >> 3;
                spqcd.mu = 0;
              } altro {
                spqcd.epsilon = data[j] >> 3;
                spqcd.mu = (data[j] & 0x7) << 8 | data[j + 1];
                j += 2;
              }
              spqcds.push(spqcd);
            }
            qcd.SPqcds = spqcds;
            se (contesto.intestazioneprincipale) {
              contesto.QCD = qcd;
            } altro {
              contesto.currentTile.QCD = qcd;
              contesto.currentTile.QCC = [];
            }
            rottura;
          caso 0xff5d:
            lunghezza = (0, _core_utils.readUint16)(dati, posizione);
            const qcc = {};
            j = posizione + 2;
            lascia cqcc;
            se (contesto.SIZ.Csiz < 257) {
              cqcc = dati[j++];
            } altro {
              cqcc = (0, _core_utils.readUint16)(dati, j);
              j += 2;
            }
            sqcd = dati[j++];
            interruttore (sqcd e 0x1f) {
              caso 0:
                spqcdSize = 8;
                scalarExpounded = true;
                rottura;
              caso 1:
                spqcdSize = 16;
                scalarExpounded = false;
                rottura;
              caso 2:
                spqcdSize = 16;
                scalarExpounded = true;
                rottura;
              predefinito:
                genera un nuovo errore("Valore SQcd non valido" + sqcd);
            }
            qcc.noQuantization = spqcdSize === 8;
            qcc.scalarExpounded = scalarExpounded;
            qcc.guardBits = sqcd >> 5;
            spqcds = [];
            mentre (j < lunghezza + posizione) {
              const spqcd = {};
              se (spqcdSize === 8) {
                spqcd.epsilon = data[j++] >> 3;
                spqcd.mu = 0;
              } altro {
                spqcd.epsilon = data[j] >> 3;
                spqcd.mu = (data[j] & 0x7) << 8 | data[j + 1];
                j += 2;
              }
              spqcds.push(spqcd);
            }
            qcc.SPqcds = spqcds;
            se (contesto.intestazioneprincipale) {
              contesto.QCC[cqcc] = qcc;
            } altro {
              contesto.currentTile.QCC[cqcc] = qcc;
            }
            rottura;
          caso 0xff52:
            lunghezza = (0, _core_utils.readUint16)(dati, posizione);
            const merluzzo = {};
            j = posizione + 2;
            const scod = data[j++];
            cod.entropyCoderWithCustomPrecincts = !!(scod & 1);
            cod.sopMarkerUsed = !!(scod & 2);
            cod.ephMarkerUsed = !!(scod & 4);
            cod.progressionOrder = data[j++];
            cod.layersCount = (0, _core_utils.readUint16)(dati, j);
            j += 2;
            cod.multipleComponentTransform = data[j++];
            cod.decompositionLevelsCount = data[j++];
            cod.xcb = (data[j++] & 0xf) + 2;
            cod.ycb = (dati[j++] & 0xf) + 2;
            const blockStyle = data[j++];
            cod.selectiveArithmeticCodingBypass = !!(blockStyle & 1);
            cod.resetContextProbabilities = !!(blockStyle & 2);
            cod.terminationOnEachCodingPass = !!(blockStyle & 4);
            cod.verticallyStripe = !!(blockStyle & 8);
            cod.predictableTermination = !!(blockStyle & 16);
            cod.segmentationSymbolUsed = !!(blockStyle & 32);
            cod.reversibleTransformation = data[j++];
            se (cod.entropyCoderWithCustomPrecincts) {
              const precinctsSizes = [];
              mentre (j < lunghezza + posizione) {
                const precinctsSize = data[j++];
                precinctsSizes.push({
                  PPx: dimensioni dei distretti e 0xf,
                  PPy: distrettiDimensione >> 4
                });
              }
              cod.precinctsSizes = precinctsSizes;
            }
            const non supportato = [];
            se (cod.selectiveArithmeticCodingBypass) {
              unsupported.push("selectiveArithmeticCodingBypass");
            }
            se (cod.terminationOnEachCodingPass) {
              unsupported.push("terminationOnEachCodingPass");
            }
            se (cod.verticallyStripe) {
              unsupported.push("verticallyStripe");
            }
            se (cod.predictableTermination) {
              unsupported.push("predictableTermination");
            }
            se (lunghezza non supportata > 0) {
              non recuperare = vero;
              (0, _util.warn)(`JPX: Opzioni COD non supportate (${unsupported.join(", ")}).`);
            }
            se (contesto.intestazioneprincipale) {
              contesto.COD = cod;
            } altro {
              contesto.currentTile.COD = cod;
              contesto.currentTile.COC = [];
            }
            rottura;
          caso 0xff90:
            lunghezza = (0, _core_utils.readUint16)(dati, posizione);
            piastrella = {};
            tile.index = (0, _core_utils.readUint16)(dati, posizione + 2);
            tile.length = (0, _core_utils.readUint32)(dati, posizione + 4);
            tile.dataEnd = tile.length + posizione - 2;
            tile.partIndex = data[posizione + 8];
            tile.partsCount = data[posizione + 9];
            contesto.mainHeader = false;
            se (tile.partIndex === 0) {
              tile.COD = contesto.COD;
              tile.COC = context.COC.slice(0);
              tile.QCD = contesto.QCD;
              tile.QCC = context.QCC.slice(0);
            }
            contesto.currentTile = tile;
            rottura;
          caso 0xff93:
            tile = contesto.currentTile;
            se (tile.partIndex === 0) {
              initializeTile(contesto, tile.index);
              buildPackets(contesto);
            }
            lunghezza = tile.dataEnd - posizione;
            parseTilePackets(contesto, dati, posizione, lunghezza);
            rottura;
          caso 0xff53:
            (0, _util.warn)("JPX: il codice del flusso di codice 0xFF53 (COC) non è implementato.");
          caso 0xff55:
          caso 0xff57:
          caso 0xff58:
          caso 0xff64:
            lunghezza = (0, _core_utils.readUint16)(dati, posizione);
            rottura;
          predefinito:
            genera un nuovo errore("Codice del flusso di codice sconosciuto: " + code.toString(16));
        }
        posizione += lunghezza;
      }
    } cattura (e) {
      se (doNotRecover || this.failOnCorruptedImage) {
        genera un nuovo JpxError(e.message);
      } altro {
        (0, _util.warn)(`JPX: tentativo di ripristino da: "${e.message}".`);
      }
    }
    this.tiles = transformComponents(context t);
    this.width = contesto.SIZ.Xsiz - contesto.SIZ.XOsiz;
    this.height = contesto.SIZ.Ysiz - contesto.SIZ.YOsiz;
    this.componentsCount = context.SIZ.Csiz;
  }
}
esportazioni.JpxImage = JpxImage;
funzione calculateComponentDimensions(componente, dimensione) {
  componente.x0 = Math.ceil(siz.XOsiz / componente.XRsiz);
  componente.x1 = Math.ceil(siz.Xsiz / componente.XRsiz);
  componente.y0 = Math.ceil(siz.YOsiz / componente.YRsiz);
  componente.y1 = Math.ceil(siz.Ysiz / componente.YRsiz);
  componente.larghezza = componente.x1 - componente.x0;
  componente.altezza = componente.y1 - componente.y0;
}
funzione calculateTileGrids(contesto, componenti) {
  const siz = contesto.SIZ;
  const tiles = [];
  lasciare piastrellare;
  const numXtiles = Math.ceil((siz.Xsiz - siz.XTOsiz) / siz.XTsiz);
  const numYtiles = Math.ceil((siz.Ysiz - siz.YTOsiz) / siz.YTsiz);
  per (lascia che q = 0; q < numYtiles; q++) {
    per (lascia che p = 0; p < numXtiles; p++) {
      piastrella = {};
      piastrella.tx0 = Math.max(siz.XTOsiz + p * siz.XTsiz, siz.XOsiz);
      piastrella.ty0 = Math.max(siz.YTOsiz + q * siz.YTsiz, siz.YOsiz);
      piastrella.tx1 = Math.min(siz.XTOsiz + (p + 1) * siz.XTsiz, siz.Xsiz);
      piastrella.ty1 = Math.min(siz.YTOsiz + (q + 1) * siz.YTsiz, siz.Ysiz);
      tile.width = tile.tx1 - tile.tx0;
      tile.height = tile.ty1 - tile.ty0;
      tile.components = [];
      piastrelle.push(piastrella);
    }
  }
  contesto.tiles = tessere;
  const componentsCount = siz.Csiz;
  per (lascia che i = 0, ii = componentsCount; i < ii; i++) {
    componente costante = componenti[i];
    per (lascia che j = 0, jj = tiles.length; j < jj; j++) {
      const tileComponent = {};
      piastrella = piastrelle[j];
      tileComponent.tcx0 = Math.ceil(tile.tx0 / component.XRsiz);
      tileComponent.tcy0 = Math.ceil(tile.ty0 / component.YRsiz);
      tileComponent.tcx1 = Math.ceil(tile.tx1 / component.XRsiz);
      tileComponent.tcy1 = Math.ceil(tile.ty1 / component.YRsiz);
      tileComponent.width = tileComponent.tcx1 - tileComponent.tcx0;
      tileComponent.height = tileComponent.tcy1 - tileComponent.tcy0;
      tile.components[i] = tileComponent;
    }
  }
}
funzione getBlocksDimensions(contesto, componente, r) {
  const codOrCoc = componente.codingStyleParameters;
  risultato costante = {};
  se (!codOrCoc.entropyCoderWithCustomPrecincts) {
    risultato.PPx = 15;
    risultato.PPy = 15;
  } altro {
    risultato.PPx = codOrCoc.precinctsSizes[r].PPx;
    risultato.PPy = codOrCoc.precinctsSizes[r].PPy;
  }
  risultato.xcb_ = r > 0 ? Math.min(codOrCoc.xcb, risultato.PPx - 1) : Math.min(codOrCoc.xcb, risultato.PPx);
  risultato.ycb_ = r > 0 ? Math.min(codOrCoc.ycb, risultato.PPy - 1) : Math.min(codOrCoc.ycb, risultato.PPy);
  restituisci il risultato;
}
funzione buildPrecincts(contesto, risoluzione, dimensioni) {
  const precinctWidth = 1 << dimensioni.PPx;
  const precinctHeight = 1 << dimensions.PPy;
  const isZeroRes = resolution.resLevel === 0;
  const precinctWidthInSubband = 1 << dimensions.PPx + (isZeroRes ? 0 : -1);
  const precinctHeightInSubband = 1 << dimensions.PPy + (isZeroRes ? 0 : -1);
  const numprecinctswide = risoluzione.trx1 > risoluzione.trx0 ? Math.ceil(risoluzione.trx1 / precinctWidth) - Math.floor(risoluzione.trx0 / precinctWidth) : 0;
  const numprecinctshigh = resolution.try1 > resolution.try0 ? Math.ceil(resolution.try1 / precinctHeight) - Math.floor(resolution.try0 / precinctHeight) : 0;
  const numprecincts = numprecinctswide * numprecinctshigh;
  risoluzione.precinctParameters = {
    larghezza del distretto,
    altezza del distretto,
    numprecinctswide,
    numprecinctshigh,
    numprecincts,
    precinctWidthInSubband,
    precinctHeightInSubband
  };
}
funzione buildCodeblocks(contesto, sottobanda, dimensioni) {
  const xcb_ = dimensioni.xcb_;
  const ycb_ = dimensioni.ycb_;
  const codeblockWidth = 1 << xcb_;
  const codeblockHeight = 1 << ycb_;
  const cbx0 = subband.tbx0 >> xcb_;
  const cby0 = sottobanda.tby0 >> ycb_;
  const cbx1 = subband.tbx1 + codeblockWidth - 1 >> xcb_;
  const cby1 = sottobanda.tby1 + codeblockHeight - 1 >> ycb_;
  const precinctParameters = subband.resolution.precinctParameters;
  blocchi di codice costanti = [];
  const precincts = [];
  lascia i, j, blocco di codice, precinctNumber;
  per (j = cby0; j < cby1; j++) {
    per (i = cbx0; i < cbx1; i++) {
      blocco di codice = {
        cbx: io,
        cby: j,
        tbx0: larghezza del blocco di codice * i,
        tby0: altezza del blocco di codice * j,
        tbx1: larghezza del blocco di codice * (i + 1),
        tby1: altezza del blocco di codice * (j + 1)
      };
      codeblock.tbx0_ = Math.max(sottobanda.tbx0, codeblock.tbx0);
      codeblock.tby0_ = Math.max(sottobanda.tby0, codeblock.tby0);
      codeblock.tbx1_ = Math.min(sottobanda.tbx1, codeblock.tbx1);
      codeblock.tby1_ = Math.min(sottobanda.tby1, codeblock.tby1);
      const pi = Math.floor((codeblock.tbx0_ - subband.tbx0) / precinctParameters.precinctWidthInSubband);
      const pj = Math.floor((codeblock.tby0_ - subband.tby0) / precinctParameters.precinctHeightInSubband);
      precinctNumber = pi + pj * precinctParameters.numprecinctswide;
      codeblock.precinctNumber = precinctNumber;
      codeblock.subbandType = subband.type;
      blocco di codice.Lblock = 3;
      se (codeblock.tbx1_ <= codeblock.tbx0_ || codeblock.tby1_ <= codeblock.tby0_) {
        continuare;
      }
      blocchi di codice.push(blocco di codice);
      lascia distretto = distretti[numerodistretto];
      se (distretto !== indefinito) {
        se (i < precinct.cbxMin) {
          distretto.cbxMin = i;
        } altrimenti se (i > precinct.cbxMax) {
          precinct.cbxMax = i;
        }
        se (j < precinct.cbyMin) {
          distretto.cbxMin = j;
        } altrimenti se (j > precinct.cbyMax) {
          precinct.cbyMax = j;
        }
      } altro {
        distretti[numerodistretto] = distretto = {
          cbxMin: io,
          cbyMin: j,
          cbxMax: io,
          cbyMax: j
        };
      }
      codeblock.precinct = distretto;
    }
  }
  subband.codeblockParameters = {
    Larghezza del blocco di codice: xcb_,
    altezza del blocco di codice: ycb_,
    numcodeblockwide: cbx1 - cbx0 + 1,
    numcodeblockhigh: cby1 - cby0 + 1
  };
  subband.codeblocks = blocchi di codice;
  subband.precincts = distretti;
}
funzione createPacket(risoluzione, precinctNumber, layerNumber) {
  const precinctCodeblocks = [];
  const sottobande = risoluzione.sottobande;
  per (lascia che i = 0, ii = sottobande.lunghezza; i < ii; i++) {
    const sottobanda = sottobande[i];
    const codeblocks = subband.codeblocks;
    per (lascia che j = 0, jj = codeblocks.length; j < jj; j++) {
      const codeblock = codeblocks[j];
      se (codeblock.precinctNumber !== precinctNumber) {
        continuare;
      }
      precinctCodeblocks.push(codeblock);
    }
  }
  ritorno {
    numero di livello,
    blocchi di codice: precinctCodeblocks
  };
}
funzione LayerResolutionComponentPositionIterator(contesto) {
  const siz = contesto.SIZ;
  const tileIndex = contesto.currentTile.index;
  const tile = contesto.tiles[indicetile];
  const layersCount = tile.codingStyleDefaultParameters.layersCount;
  const componentsCount = siz.Csiz;
  lascia maxDecompositionLevelsCount = 0;
  per (lascia che q = 0; q < componentsCount; q++) {
    maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount);
  }
  sia l = 0,
    r = 0,
    io = 0,
    k = 0;
  this.nextPacket = funzione JpxImage_nextPacket() {
    per (; l < layersCount; l++) {
      per (; r <= maxDecompositionLevelsCount; r++) {
        per (; i < numerocomponenti; i++) {
          componente costante = tile.components[i];
          se (r > componente.codingStyleParameters.decompositionLevelsCount) {
            continuare;
          }
          risoluzione costante = componente.risoluzione[r];
          const numprecincts = risoluzione.precinctParameters.numprecincts;
          per (; k < numprecincts;) {
            const pacchetto = createPacket(risoluzione, k, l);
            k++;
            pacco di ritorno;
          }
          k = 0;
        }
        io = 0;
      }
      r = 0;
    }
    throw new JpxError("Pacchetti esauriti");
  };
}
funzione ResolutionLayerComponentPositionIterator(contesto) {
  const siz = contesto.SIZ;
  const tileIndex = contesto.currentTile.index;
  const tile = contesto.tiles[indicetile];
  const layersCount = tile.codingStyleDefaultParameters.layersCount;
  const componentsCount = siz.Csiz;
  lascia maxDecompositionLevelsCount = 0;
  per (lascia che q = 0; q < componentsCount; q++) {
    maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount);
  }
  sia r = 0,
    l = 0,
    io = 0,
    k = 0;
  this.nextPacket = funzione JpxImage_nextPacket() {
    per (; r <= maxDecompositionLevelsCount; r++) {
      per (; l < layersCount; l++) {
        per (; i < numerocomponenti; i++) {
          componente costante = tile.components[i];
          se (r > componente.codingStyleParameters.decompositionLevelsCount) {
            continuare;
          }
          risoluzione costante = componente.risoluzione[r];
          const numprecincts = risoluzione.precinctParameters.numprecincts;
          per (; k < numprecincts;) {
            const pacchetto = createPacket(risoluzione, k, l);
            k++;
            pacco di ritorno;
          }
          k = 0;
        }
        io = 0;
      }
      l = 0;
    }
    throw new JpxError("Pacchetti esauriti");
  };
}
funzione ResolutionPositionComponentLayerIterator(contesto) {
  const siz = contesto.SIZ;
  const tileIndex = contesto.currentTile.index;
  const tile = contesto.tiles[indicetile];
  const layersCount = tile.codingStyleDefaultParameters.layersCount;
  const componentsCount = siz.Csiz;
  siano l, r, c, p;
  lascia maxDecompositionLevelsCount = 0;
  per (c = 0; c < numerocomponenti; c++) {
    componente costante = tile.components[c];
    maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, component.codingStyleParameters.decompositionLevelsCount);
  }
  const maxNumPrecinctsInLevel = new Int32Array(maxDecompositionLevelsCount + 1);
  per (r = 0; r <= maxDecompositionLevelsCount; ++r) {
    lascia maxNumPrecincts = 0;
    per (c = 0; c < numerocomponenti; ++c) {
      risoluzioni costanti = tile.components[c].resolutions;
      se (r < lunghezza risoluzioni) {
        maxNumPrecincts = Math.max(maxNumPrecincts, resolutions[r].precinctParameters.numprecincts);
      }
    }
    maxNumPrecinctsInLevel[r] = maxNumPrecincts;
  }
  l = 0;
  r = 0;
  c = 0;
  p = 0;
  this.nextPacket = funzione JpxImage_nextPacket() {
    per (; r <= maxDecompositionLevelsCount; r++) {
      per (; p < maxNumPrecinctsInLevel[r]; p++) {
        per (; c < numerocomponenti; c++) {
          componente costante = tile.components[c];
          se (r > componente.codingStyleParameters.decompositionLevelsCount) {
            continuare;
          }
          risoluzione costante = componente.risoluzione[r];
          const numprecincts = risoluzione.precinctParameters.numprecincts;
          se (p >= numprecincts) {
            continuare;
          }
          per (; l < layersCount;) {
            const pacchetto = createPacket(risoluzione, p, l);
            l++;
            pacco di ritorno;
          }
          l = 0;
        }
        c = 0;
      }
      p = 0;
    }
    throw new JpxError("Pacchetti esauriti");
  };
}
funzione PositionComponentResolutionLayerIterator(contesto) {
  const siz = contesto.SIZ;
  const tileIndex = contesto.currentTile.index;
  const tile = contesto.tiles[indicetile];
  const layersCount = tile.codingStyleDefaultParameters.layersCount;
  const componentsCount = siz.Csiz;
  const precinctsSizes = getPrecinctSizesInImageScale(tile);
  const precinctsIterationSizes = precinctsSizes;
  sia l = 0,
    r = 0,
    c = 0,
    px = 0,
    pi = 0;
  this.nextPacket = funzione JpxImage_nextPacket() {
    per (; py < precinctsIterationSizes.maxNumHigh; py++) {
      per (; px < precinctsIterationSizes.maxNumWide; px++) {
        per (; c < numerocomponenti; c++) {
          componente costante = tile.components[c];
          const decompositionLevelsCount = componente.codingStyleParameters.decompositionLevelsCount;
          per (; r <= decompositionLevelsCount; r++) {
            risoluzione costante = componente.risoluzione[r];
            const sizeInImageScale = precinctsSizes.components[c].resolutions[r];
            const k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);
            se (k === null) {
              continuare;
            }
            per (; l < layersCount;) {
              const pacchetto = createPacket(risoluzione, k, l);
              l++;
              pacco di ritorno;
            }
            l = 0;
          }
          r = 0;
        }
        c = 0;
      }
      px = 0;
    }
    throw new JpxError("Pacchetti esauriti");
  };
}
funzione ComponentPositionResolutionLayerIterator(contesto) {
  const siz = contesto.SIZ;
  const tileIndex = contesto.currentTile.index;
  const tile = contesto.tiles[indicetile];
  const layersCount = tile.codingStyleDefaultParameters.layersCount;
  const componentsCount = siz.Csiz;
  const precinctsSizes = getPrecinctSizesInImageScale(tile);
  sia l = 0,
    r = 0,
    c = 0,
    px = 0,
    pi = 0;
  this.nextPacket = funzione JpxImage_nextPacket() {
    per (; c < numerocomponenti; ++c) {
      componente costante = tile.components[c];
      const precinctsIterationSizes = precinctsSizes.components[c];
      const decompositionLevelsCount = componente.codingStyleParameters.decompositionLevelsCount;
      per (; py < precinctsIterationSizes.maxNumHigh; py++) {
        per (; px < precinctsIterationSizes.maxNumWide; px++) {
          per (; r <= decompositionLevelsCount; r++) {
            risoluzione costante = componente.risoluzione[r];
            const sizeInImageScale = precinctsIterationSizes.resolutions[r];
            const k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);
            se (k === null) {
              continuare;
            }
            per (; l < layersCount;) {
              const pacchetto = createPacket(risoluzione, k, l);
              l++;
              pacco di ritorno;
            }
            l = 0;
          }
          r = 0;
        }
        px = 0;
      }
      pi = 0;
    }
    throw new JpxError("Pacchetti esauriti");
  };
}
funzione getPrecinctIndexIfExist(pxIndex, pyIndex, sizeInImageScale, precinctIterationSizes, risoluzione) {
  const posX = pxIndex * precinctIterationSizes.minWidth;
  const posY = pyIndex * precinctIterationSizes.minHeight;
  se (posX % sizeInImageScale.width !== 0 || posY % sizeInImageScale.height !== 0) {
    restituisci null;
  }
  const startPrecinctRowIndex = posY / sizeInImageScale.width * resolution.precinctParameters.numprecinctswide;
  return posX / sizeInImageScale.height + startPrecinctRowIndex;
}
funzione getPrecinctSizesInImageScale(tile) {
  const componentsCount = tile.components.length;
  lascia minWidth = Number.MAX_VALUE;
  lascia minHeight = Numero.VALORE_MAX;
  lascia maxNumWide = 0;
  lascia maxNumHigh = 0;
  const sizePerComponent = new Array(componentsCount);
  per (lascia che c = 0; c < componentsCount; c++) {
    componente costante = tile.components[c];
    const decompositionLevelsCount = componente.codingStyleParameters.decompositionLevelsCount;
    const sizePerResolution = new Array(decompositionLevelsCount + 1);
    lascia minWidthCurrentComponent = Number.MAX_VALUE;
    lascia minHeightCurrentComponent = Number.MAX_VALUE;
    lascia maxNumWideCurrentComponent = 0;
    lascia maxNumHighCurrentComponent = 0;
    lascia scala = 1;
    per (lascia che r = decompositionLevelsCount; r >= 0; --r) {
      risoluzione costante = componente.risoluzione[r];
      const widthCurrentResolution = scala * risoluzione.precinctParameters.precinctWidth;
      const heightCurrentResolution = scala * risoluzione.precinctParameters.precinctHeight;
      minWidthCurrentComponent = Math.min(minWidthCurrentComponent, widthCurrentResolution);
      minHeightCurrentComponent = Math.min(minHeightCurrentComponent, heightCurrentResolution);
      maxNumWideCurrentComponent = Math.max(maxNumWideCurrentComponent, resolution.precinctParameters.numprecinctswide);
      maxNumHighCurrentComponent = Math.max(maxNumHighCurrentComponent, resolution.precinctParameters.numprecinctshigh);
      sizePerResolution[r] = {
        larghezza: widthCurrentResolution,
        altezza: altezzaRisoluzioneCorrente
      };
      scala <<= 1;
    }
    minWidth = Math.min(minWidth, minWidthCurrentComponent);
    minHeight = Math.min(minHeight, minHeightCurrentComponent);
    maxNumWide = Math.max(maxNumWide, maxNumWideCurrentComponent);
    maxNumHigh = Math.max(maxNumHigh, maxNumHighCurrentComponent);
    dimensionePerComponente[c] = {
      risoluzioni: sizePerResolution,
      minWidth: minWidthCurrentComponent,
      minHeight: minHeightCurrentComponent,
      maxNumWide: maxNumWideCurrentComponent,
      maxNumHigh: maxNumHighCurrentComponent
    };
  }
  ritorno {
    componenti: sizePerComponent,
    minLarghezza,
    minAltezza,
    maxNumWide,
    maxNumHigh
  };
}
funzione buildPackets(contesto) {
  const siz = contesto.SIZ;
  const tileIndex = contesto.currentTile.index;
  const tile = contesto.tiles[indicetile];
  const componentsCount = siz.Csiz;
  per (lascia che c = 0; c < componentsCount; c++) {
    componente costante = tile.components[c];
    const decompositionLevelsCount = componente.codingStyleParameters.decompositionLevelsCount;
    risoluzioni costanti = [];
    sottobande costanti = [];
    per (lascia che r = 0; r <= decompositionLevelsCount; r++) {
      const blocksDimensions = getBlocksDimensions(contesto, componente, r);
      risoluzione costante = {};
      const scale = 1 << decompositionLevelsCount - r;
      risoluzione.trx0 = Math.ceil(componente.tcx0 / scala);
      risoluzione.try0 = Math.ceil(componente.tcy0 / scala);
      risoluzione.trx1 = Math.ceil(componente.tcx1 / scala);
      risoluzione.try1 = Math.ceil(componente.tcy1 / scala);
      risoluzione.resLevel = r;
      buildPrecincts(contesto, risoluzione, blocchiDimensioni);
      risoluzioni.push(risoluzione);
      lascia sottobanda;
      se (r === 0) {
        sottobanda = {};
        sottobanda.tipo = "LL";
        subband.tbx0 = Math.ceil(component.tcx0 / scala);
        subband.tby0 = Math.ceil(component.tcy0 / scala);
        subband.tbx1 = Math.ceil(component.tcx1 / scala);
        subband.tby1 = Math.ceil(component.tcy1 / scala);
        subband.resolution = risoluzione;
        buildCodeblocks(contesto, sottobanda, blocchiDimensioni);
        sottobande.push(sottobanda);
        risoluzione.sottobande = [sottobanda];
      } altro {
        const bscale = 1 << decompositionLevelsCount - r + 1;
        risoluzione costanteSottobande = [];
        sottobanda = {};
        sottobanda.tipo = "HL";
        sottobanda.tbx0 = Math.ceil(componente.tcx0 / bscale - 0,5);
        subband.tby0 = Math.ceil(component.tcy0 / bscale);
        sottobanda.tbx1 = Math.ceil(componente.tcx1 / bscale - 0,5);
        sottobanda.tby1 = Math.ceil(componente.tcy1 / bscale);
        subband.resolution = risoluzione;
        buildCodeblocks(contesto, sottobanda, blocchiDimensioni);
        sottobande.push(sottobanda);
        risoluzioneSubbands.push(sottobanda);
        sottobanda = {};
        sottobanda.tipo = "LH";
        sottobanda.tbx0 = Math.ceil(componente.tcx0 / bscale);
        subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
        sottobanda.tbx1 = Math.ceil(componente.tcx1 / bscale);
        subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
        subband.resolution = risoluzione;
        buildCodeblocks(contesto, sottobanda, blocchiDimensioni);
        sottobande.push(sottobanda);
        risoluzioneSubbands.push(sottobanda);
        sottobanda = {};
        sottobanda.tipo = "HH";
        sottobanda.tbx0 = Math.ceil(componente.tcx0 / bscale - 0,5);
        subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
        sottobanda.tbx1 = Math.ceil(componente.tcx1 / bscale - 0,5);
        subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
        subband.resolution = risoluzione;
        buildCodeblocks(contesto, sottobanda, blocchiDimensioni);
        sottobande.push(sottobanda);
        risoluzioneSubbands.push(sottobanda);
        risoluzione.sottobande = risoluzioneSottobande;
      }
    }
    componente.risoluzione = risoluzioni;
    componente.sottobande = sottobande;
  }
  const progressionOrder = tile.codingStyleDefaultParameters.progressionOrder;
  switch (ordine di progressione) {
    caso 0:
      tile.packetsIterator = new LayerResolutionComponentPositionIterator(context);
      rottura;
    caso 1:
      tile.packetsIterator = new ResolutionLayerComponentPositionIterator(context);
      rottura;
    caso 2:
      tile.packetsIterator = new ResolutionPositionComponentLayerIterator(context);
      rottura;
    caso 3:
      tile.packetsIterator = new PositionComponentResolutionLayerIterator(context);
      rottura;
    caso 4:
      tile.packetsIterator = new ComponentPositionResolutionLayerIterator(context);
      rottura;
    predefinito:
      throw new JpxError(`Ordine di progressione non supportato ${progressionOrder}`);
  }
}
funzione parseTilePackets(contesto, dati, offset, lunghezzadati) {
  lascia posizione = 0;
  lascia il buffer,
    bufferSize = 0,
    skipNextBit = falso;
  funzione readBits(count) {
    mentre (bufferSize < conteggio) {
      const b = dati[offset + posizione];
      posizione++;
      se (salta il bit successivo) {
        buffer = buffer << 7 | b;
        bufferSize += 7;
        skipNextBit = falso;
      } altro {
        buffer = buffer << 8 | b;
        bufferSize += 8;
      }
      se (b === 0xff) {
        saltaBitSuccessivo = vero;
      }
    }
    bufferSize -= conteggio;
    restituisci buffer >>> bufferSize & (1 << conteggio) - 1;
  }
  funzione skipMarkerIfEqual(valore) {
    se (dati[offset + posizione - 1] === 0xff && dati[offset + posizione] === valore) {
      saltaByte(1);
      restituisci vero;
    } altrimenti se (dati[offset + posizione] === 0xff && dati[offset + posizione + 1] === valore) {
      saltaByte(2);
      restituisci vero;
    }
    restituisci falso;
  }
  funzione skipBytes(conteggio) {
    posizione += conteggio;
  }
  funzione alignToByte() {
    bufferSize = 0;
    se (salta il bit successivo) {
      posizione++;
      skipNextBit = falso;
    }
  }
  funzione readCodingpasses() {
    se (readBits(1) === 0) {
      restituisci 1;
    }
    se (readBits(1) === 0) {
      ritorno 2;
    }
    lascia valore = readBits(2);
    se (valore < 3) {
      valore di ritorno + 3;
    }
    valore = readBits(5);
    se (valore < 31) {
      valore di ritorno + 6;
    }
    valore = readBits(7);
    valore di ritorno + 37;
  }
  const tileIndex = contesto.currentTile.index;
  const tile = contesto.tiles[indicetile];
  const sopMarkerUsed = context.COD.sopMarkerUsed;
  const ephMarkerUsed = contesto.COD.ephMarkerUsed;
  const packetsIterator = tile.packetsIterator;
  while (posizione < lunghezzadati) {
    allinea a byte();
    se (sopMarkerUsed && skipMarkerIfEqual(0x91)) {
      saltaByte(4);
    }
    const pacchetto = packetsIterator.nextPacket();
    se (!readBits(1)) {
      continuare;
    }
    const numerolivello = pacchetto.numerolivello,
      coda = [];
    lascia il codice bloccato;
    per (lascia che i = 0, ii = pacchetto.codiceblocchi.lunghezza; i < ii; i++) {
      blocco di codice = pacchetto.bloccodicodice[i];
      lascia precinct = codeblock.precinct;
      const codeblockColumn = codeblock.cbx - precinct.cbxMin;
      const codeblockRow = codeblock.cby - distretto.cbyMin;
      lascia che codeblockIncluded = false;
      lascia firstTimeInclusion = false;
      lascia valueReady, zeroBitPlanesTree;
      se (codeblock.included !== indefinito) {
        codeblockIncluded = !!readBits(1);
      } altro {
        distretto = codeblock.distretto;
        lascia inclusionTree;
        se (precinct.inclusionTree !== indefinito) {
          inclusionTree = precinct.inclusionTree;
        } altro {
          larghezza costante = precinct.cbxMax - precinct.cbxMin + 1;
          altezza costante = precinct.cbyMax - precinct.cbyMin + 1;
          inclusionTree = new InclusionTree(larghezza, altezza, numerolivello);
          zeroBitPlanesTree = new TagTree(larghezza, altezza);
          precinct.inclusionTree = inclusionTree;
          precinct.zeroBitPlanesTree = zeroBitPlanesTree;
          for (let l = 0; l < layerNumber; l++) {
            se (readBits(1) !== 0) {
              throw new JpxError("Albero dei tag non valido");
            }
          }
        }
        se (inclusionTree.reset(codeblockColumn, codeblockRow, layerNumber)) {
          mentre (vero) {
            se (readBits(1)) {
              valueReady = !inclusionTree.nextLevel();
              se (valorePronto) {
                codeblock.included = true;
                codeblockIncluded = firstTimeInclusion = true;
                rottura;
              }
            } altro {
              inclusionTree.incrementValue(layerNumber);
              rottura;
            }
          }
        }
      }
      se (!codeblockIncluded) {
        continuare;
      }
      se (firstTimeInclusion) {
        zeroBitPlanesTree = distretto.zeroBitPlanesTree;
        zeroBitPlanesTree.reset(codeblockColumn, codeblockRow);
        mentre (vero) {
          se (readBits(1)) {
            valueReady = !zeroBitPlanesTree.nextLevel();
            se (valorePronto) {
              rottura;
            }
          } altro {
            zeroBitPlanesTree.incrementValue();
          }
        }
        codeblock.zeroBitPlanes = zeroBitPlanesTree.value;
      }
      const codingpasses = readCodingpasses();
      mentre (readBits(1)) {
        blocco di codice.Lblock++;
      }
      const codingpassesLog2 = (0, _core_utils.log2)(codingpasses);
      const bits = (codingpasses < 1 << codingpassesLog2 ? codingpassesLog2 - 1 : codingpassesLog2) + codeblock.Lblock;
      const codedDataLength = readBits(bit);
      coda.push({
        blocco di codice,
        passaggi di codifica,
        dataLength: codedDataLength
      });
    }
    allinea a byte();
    se (ephMarkerUsed) {
      saltaMarcatoreSeUguale(0x92);
    }
    while (lunghezza coda > 0) {
      const packetItem = coda.shift();
      codeblock = packetItem.codeblock;
      se (codeblock.data === indefinito) {
        blocco di codice.dati = [];
      }
      blocco di codice.dati.push({
        dati,
        inizio: offset + posizione,
        fine: offset + posizione + packetItem.dataLength,
        codingpasses: packetItem.codingpasses
      });
      posizione += packetItem.dataLength;
    }
  }
  posizione di ritorno;
}
funzione copyCoefficients(coefficienti, levelWidth, levelHeight, sottobanda, delta, mb, reversibile, segmentationSymbolUsed, resetContextProbabilities) {
  const x0 = sottobanda.tbx0;
  const y0 = sottobanda.tby0;
  larghezza costante = sottobanda.tbx1 - sottobanda.tbx0;
  const codeblocks = subband.codeblocks;
  const right = subband.type.charAt(0) === "H" ? 1 : 0;
  const bottom = subband.type.charAt(1) === "H" ? levelWidth : 0;
  per (lascia che i = 0, ii = codeblocks.length; i < ii; ++i) {
    const codeblock = codeblocks[i];
    const blockWidth = codeblock.tbx1_ - codeblock.tbx0_;
    const blockHeight = codeblock.tby1_ - codeblock.tby0_;
    se (larghezzablocco === 0 || altezzablocco === 0) {
      continuare;
    }
    se (codeblock.data === indefinito) {
      continuare;
    }
    const bitModel = new BitModel(blockWidth, blockHeight, codeblock.subbandType, codeblock.zeroBitPlanes, mb);
    lascia currentCodingpassType = 2;
    const data = codeblock.data;
    lascia totalLength = 0,
      passaggi di codifica = 0;
    lascia j, jj, dataItem;
    per (j = 0, jj = lunghezza dati; j < jj; j++) {
      elemento dati = dati[j];
      lunghezza totale += dataItem.end - dataItem.start;
      codingpasses += dataItem.codingpasses;
    }
    const encodedData = new Uint8Array(totalLength);
    lascia posizione = 0;
    per (j = 0, jj = lunghezza dati; j < jj; j++) {
      elemento dati = dati[j];
      const pezzo = dataItem.data.subarray(dataItem.start, dataItem.end);
      encodedData.set(chunk, posizione);
      posizione += lunghezza del pezzo;
    }
    const decoder = new _arithmetic_decoder.ArithmeticDecoder(encodedData, 0, totalLength);
    bitModel.setDecoder(decodificatore);
    per (j = 0; j < passaggi di codifica; j++) {
      switch (currentCodingpassType) {
        caso 0:
          bitModel.runSignificancePropagationPass();
          rottura;
        caso 1:
          bitModel.runMagnitudeRefinementPass();
          rottura;
        caso 2:
          bitModel.runCleanupPass();
          se (segmentationSymbolUsed) {
            bitModel.checkSegmentationSymbol();
          }
          rottura;
      }
      se (reimpostaContestoProbabilità) {
        bitModel.reset();
      }
      currentCodingpassType = (currentCodingpassType + 1) % 3;
    }
    lascia offset = codeblock.tbx0_ - x0 + (codeblock.tby0_ - y0) * larghezza;
    const sign = bitModel.coefficentsSign;
    const magnitude = bitModel.coefficentsMagnitude;
    const bitsDecoded = bitModel.bitsDecoded;
    const magnitudeCorrection = reversibile ? 0 : 0.5;
    siano k, n, nb;
    posizione = 0;
    const interleave = subband.type !== "LL";
    per (j = 0; j < altezzablocco; j++) {
      const row = offset / larghezza | 0;
      const levelOffset = 2 * row * (levelWidth - larghezza) + right + bottom;
      per (k = 0; k < larghezzablocco; k++) {
        n = grandezza[posizione];
        se (n !== 0) {
          n = (n + correzione di magnitudine) * delta;
          se (segno[posizione] !== 0) {
            n = -n;
          }
          nb = bitsDecoded[posizione];
          const pos = interleave ? levelOffset + (offset << 1) : offset;
          coefficienti[pos] = reversibile && nb >= mb ? n : n * (1 << mb - nb);
        }
        offset++;
        posizione++;
      }
      offset += larghezza - larghezzablocco;
    }
  }
}
funzione transformTile(contesto, tile, c) {
  componente costante = tile.components[c];
  const codingStyleParameters = componente.codingStyleParameters;
  const quantizationParameters = componente.quantizationParameters;
  const decompositionLevelsCount = codingStyleParameters.decompositionLevelsCount;
  const spqcds = quantizationParameters.SPqcds;
  const scalarExpounded = quantizationParameters.scalarExpounded;
  const guardBits = quantizationParameters.guardBits;
  const segmentationSymbolUsed = codingStyleParameters.segmentationSymbolUsed;
  const resetContextProbabilities = codingStyleParameters.resetContextProbabilities;
  const precision = context.components[c].precision;
  const reversible = codingStyleParameters.reversibleTransformation;
  const transform = reversible ? new ReversibleTransform() : new IrreversibleTransform();
  const subbandCoefficients = [];
  sia b = 0;
  per (lascia che i = 0; i <= decompositionLevelsCount; i++) {
    risoluzione costante = componente.risoluzione[i];
    const width = risoluzione.trx1 - risoluzione.trx0;
    const altezza = risoluzione.prova1 - risoluzione.prova0;
    coefficienti costanti = new Float32Array(larghezza * altezza);
    per (lascia che j = 0, jj = risoluzione.sottobande.lunghezza; j < jj; j++) {
      lascia mu, epsilon;
      se (!scalareEsposto) {
        mu = spqcds[0].mu;
        epsilon = spqcds[0].epsilon + (i > 0 ? 1 - i : 0);
      } altro {
        mu = spqcds[b].mu;
        epsilon = spqcds[b].epsilon;
        b++;
      }
      const sottobanda = risoluzione.sottobande[j];
      const gainLog2 = SubbandsGainLog2[subband.type];
      const delta = reversibile ? 1 : 2 ** (precisione + guadagnoLog2 - epsilon) * (1 + mu / 2048);
      const mb = guardBits + epsilon - 1;
      copyCoefficients(coefficienti, larghezza, altezza, sottobanda, delta, mb, reversibile, segmentationSymbolUsed, resetContextProbabilities);
    }
    subbandCoefficients.push({
      larghezza,
      altezza,
      elementi: coefficienti
    });
  }
  risultato costante = trasforma.calcola(coefficienti di sottobanda, componente.tcx0, componente.tcy0);
  ritorno {
    sinistra: componente.tcx0,
    in alto: componente.tcy0,
    larghezza: risultato.larghezza,
    altezza: risultato.altezza,
    elementi: risultato.elementi
  };
}
funzione transformComponents(contesto) {
  const siz = contesto.SIZ;
  componenti costanti = contesto.componenti;
  const componentsCount = siz.Csiz;
  const risultatoImmagini = [];
  per (lascia che i = 0, ii = contesto.tiles.length; i < ii; i++) {
    const tile = contesto.tiles[i];
    const trasformateTiles = [];
    per (lascia che c = 0; c < componentsCount; c++) {
      transformedTiles[c] = transformTile(contesto, tile, c);
    }
    const tile0 = transformedTiles[0];
    const out = new Uint8ClampedArray(tile0.items.length * componentsCount);
    risultato costante = {
      sinistra: tile0.left,
      in alto: tile0.top,
      larghezza: tile0.width,
      altezza: tile0.height,
      articoli: fuori
    };
    lascia spostare, compensare;
    lascia pos = 0,
      J,
      jj,
      y0,
      y1,
      y2;
    se (tile.codingStyleDefaultParameters.multipleComponentTransform) {
      const fourComponents = componentsCount === 4;
      const y0items = transformedTiles[0].items;
      const y1items = transformedTiles[1].items;
      const y2items = transformedTiles[2].items;
      const y3items = fourComponents ? transformedTiles[3].items : null;
      shift = componenti[0].precisione - 8;
      offset = (128 << spostamento) + 0,5;
      const componente0 = tile.components[0];
      const alpha01 = componentsCount - 3;
      jj = y0items.length;
      se (!component0.codingStyleParameters.reversibleTransformation) {
        per (j = 0; j < jj; j++, pos += alpha01) {
          y0 = y0items[j] + offset;
          y1 = y1elementi[j];
          y2 = y2elementi[j];
          out[pos++] = y0 + 1.402 * y2 >> shift;
          out[pos++] = y0 - 0,34413 * y1 - 0,71414 * y2 >> spostamento;
          out[pos++] = y0 + 1.772 * y1 >> shift;
        }
      } altro {
        per (j = 0; j < jj; j++, pos += alpha01) {
          y0 = y0items[j] + offset;
          y1 = y1elementi[j];
          y2 = y2elementi[j];
          costante g = y0 - (y2 + y1 >> 2);
          out[pos++] = g + y2 >> shift;
          out[pos++] = g >> shift;
          out[pos++] = g + y1 >> shift;
        }
      }
      se (quattroComponenti) {
        per (j = 0, pos = 3; j < jj; j++, pos += 4) {
          out[pos] = y3items[j] + offset >> shift;
        }
      }
    } altro {
      per (lascia che c = 0; c < componentsCount; c++) {
        const items = transformedTiles[c].items;
        shift = componenti[c].precisione - 8;
        offset = (128 << spostamento) + 0,5;
        per (pos = c, j = 0, jj = elementi.lunghezza; j < jj; j++) {
          out[pos] = items[j] + offset >> shift;
          pos += conteggio componenti;
        }
      }
    }
    resultImages.push(risultato);
  }
  restituisci resultImages;
}
funzione initializeTile(contesto, tileIndex) {
  const siz = contesto.SIZ;
  const componentsCount = siz.Csiz;
  const tile = contesto.tiles[indicetile];
  per (lascia che c = 0; c < componentsCount; c++) {
    componente costante = tile.components[c];
    const qcdOrQcc = context.currentTile.QCC[c] !== indefinito ? context.currentTile.QCC[c] : context.currentTile.QCD;
    componente.parametri di quantizzazione = qcdOrQcc;
    const codOrCoc = context.currentTile.COC[c] !== indefinito ? context.currentTile.COC[c] : context.currentTile.COD;
    componente.codingStyleParameters = codOrCoc;
  }
  tile.codingStyleDefaultParameters = context.currentTile.COD;
}
classe TagTree {
  costruttore(larghezza, altezza) {
    const levelsLength = (0, _core_utils.log2)(Math.max(larghezza, altezza)) + 1;
    questo.livelli = [];
    per (lascia che i = 0; i < lunghezzalivelli; i++) {
      livello costante = {
        larghezza,
        altezza,
        elementi: []
      };
      questo.livelli.push(livello);
      larghezza = Math.ceil(larghezza / 2);
      altezza = Math.ceil(altezza / 2);
    }
  }
  reset(i, j) {
    lascia currentLevel = 0,
      valore = 0,
      livello;
    while (currentLevel < this.levels.length) {
      livello = questo.livelli[livellocorrente];
      indice costante = i + j * livello.larghezza;
      se (livello.elementi[indice] !== indefinito) {
        valore = livello.elementi[indice];
        rottura;
      }
      livello.indice = indice;
      io >>= 1;
      j >>= 1;
      livellocorrente++;
    }
    livellocorrente--;
    livello = questo.livelli[livellocorrente];
    livello.elementi[livello.indice] = valore;
    questo.livellocorrente = livellocorrente;
    elimina questo.valore;
  }
  incrementValue() {
    livello costante = questo.livelli[questo.livellocorrente];
    livello.elementi[livello.indice]++;
  }
  livello successivo() {
    lascia livellocorrente = questo.livellocorrente;
    lascia livello = questo.livelli[livellocorrente];
    valore costante = livello.elementi[livello.indice];
    livellocorrente--;
    se (livellocorrente < 0) {
      questo.valore = valore;
      restituisci falso;
    }
    questo.livellocorrente = livellocorrente;
    livello = questo.livelli[livellocorrente];
    livello.elementi[livello.indice] = valore;
    restituisci vero;
  }
}
classe InclusionTree {
  costruttore(larghezza, altezza, valorepredefinito) {
    const levelsLength = (0, _core_utils.log2)(Math.max(larghezza, altezza)) + 1;
    questo.livelli = [];
    per (lascia che i = 0; i < lunghezzalivelli; i++) {
      const items = new Uint8Array(larghezza * altezza);
      per (lascia che j = 0, jj = elementi.lunghezza; j < jj; j++) {
        elementi[j] = valorepredefinito;
      }
      livello costante = {
        larghezza,
        altezza,
        elementi
      };
      questo.livelli.push(livello);
      larghezza = Math.ceil(larghezza / 2);
      altezza = Math.ceil(altezza / 2);
    }
  }
  reset(i, j, stopValue) {
    lascia che livellocorrente = 0;
    while (currentLevel < this.levels.length) {
      livello costante = questo.livelli[livellocorrente];
      indice costante = i + j * livello.larghezza;
      livello.indice = indice;
      valore costante = livello.elementi[indice];
      se (valore === 0xff) {
        rottura;
      }
      se (valore > stopValue) {
        questo.livellocorrente = livellocorrente;
        questo.propagaValori();
        restituisci falso;
      }
      io >>= 1;
      j >>= 1;
      livellocorrente++;
    }
    questo.livellocorrente = livellocorrente - 1;
    restituisci vero;
  }
  incrementValue(stopValue) {
    livello costante = questo.livelli[questo.livellocorrente];
    livello.elementi[livello.indice] = stopValue + 1;
    questo.propagaValori();
  }
  propagaValori() {
    lascia levelIndex = this.currentLevel;
    lascia livello = questo.livelli[indicelivello];
    const currentValue = livello.elementi[livello.indice];
    mentre (--levelIndex >= 0) {
      livello = questo.livelli[indicelivello];
      livello.elementi[livello.indice] = valorecorrente;
    }
  }
  livello successivo() {
    lascia livellocorrente = questo.livellocorrente;
    lascia livello = questo.livelli[livellocorrente];
    valore costante = livello.elementi[livello.indice];
    livello.elementi[livello.indice] = 0xff;
    livellocorrente--;
    se (livellocorrente < 0) {
      restituisci falso;
    }
    questo.livellocorrente = livellocorrente;
    livello = questo.livelli[livellocorrente];
    livello.elementi[livello.indice] = valore;
    restituisci vero;
  }
}
classe BitModel {
  statico UNIFORM_CONTEXT = 17;
  statico RUNLENGTH_CONTEXT = 18;
  statico LLAndLHContextsLabel = new Uint8Array([0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8]);
  HLContextLabel statico = new Uint8Array([0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8]);
  static HHContextLabel = new Uint8Array([0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5, 5, 5, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8]);
  costruttore(larghezza, altezza, sottobanda, zeroBitPlanes, mb) {
    this.width = larghezza;
    this.height = altezza;
    lascia contextLabelTable;
    se (sottobanda === "HH") {
      contextLabelTable = BitModel.HHContextLabel;
    } altrimenti se (sottobanda === "HL") {
      contextLabelTable = BitModel.HLContextLabel;
    } altro {
      contextLabelTable = BitModel.LLAndLHContextsLabel;
    }
    this.contextLabelTable = contextLabelTable;
    const coefficientCount = larghezza * altezza;
    this.neighborsSignificance = new Uint8Array(coefficientCount);
    this.coefficentsSign = new Uint8Array(coefficientCount);
    lascia coefficentiMagnitudo;
    se (mb > 14) {
      coefficentsMagnitude = new Uint32Array(coefficientCount);
    } altrimenti se (mb > 6) {
      coefficentsMagnitude = new Uint16Array(coefficientCount);
    } altro {
      coefficentsMagnitude = new Uint8Array(coefficientCount);
    }
    questo.coefficentsMagnitude = coefficentsMagnitude;
    this.processingFlags = new Uint8Array(coefficientCount);
    const bitsDecoded = new Uint8Array(coefficientCount);
    se (zeroBitPlanes !== 0) {
      per (lascia che i = 0; i < coefficientCount; i++) {
        bitsDecoded[i] = zeroBitPlanes;
      }
    }
    questo.bitsDecoded = bitsDecoded;
    questo.reset();
  }
  setDecoder(decodificatore) {
    this.decoder = decodificatore;
  }
  reimposta() {
    questo.contesti = nuovo Int8Array(19);
    questo.contesto[0] = 4 << 1 | 0;
    this.contexts[BitModel.UNIFORM_CONTEXT] = 46 << 1 | 0;
    this.contexts[BitModel.RUNLENGTH_CONTEXT] = 3 << 1 | 0;
  }
  setNeighborsSignificance(riga, colonna, indice) {
    const neighborsSignificance = this.neighborsSignificance;
    const width = this.width,
      altezza = this.height;
    const left = colonna > 0;
    const right = colonna + 1 < larghezza;
    lascia che io;
    se (riga > 0) {
      i = indice - larghezza;
      se (sinistra) {
        viciniSignificato[i - 1] += 0x10;
      }
      se (a destra) {
        viciniSignificato[i + 1] += 0x10;
      }
      viciniSignificato[i] += 0x04;
    }
    se (riga + 1 < altezza) {
      i = indice + larghezza;
      se (sinistra) {
        viciniSignificato[i - 1] += 0x10;
      }
      se (a destra) {
        viciniSignificato[i + 1] += 0x10;
      }
      viciniSignificato[i] += 0x04;
    }
    se (sinistra) {
      viciniSignificato[indice - 1] += 0x01;
    }
    se (a destra) {
      viciniSignificato[indice + 1] += 0x01;
    }
    viciniSignificato[indice] |= 0x80;
  }
  runSignificancePropagationPass() {
    const decoder = this.decoder;
    const width = this.width,
      altezza = this.height;
    const coefficentsMagnitude = this.coefficentsMagnitude;
    const coefficentsSign = this.coefficentsSign;
    const neighborsSignificance = this.neighborsSignificance;
    const processingFlags = this.processingFlags;
    const contesti = this.contexts;
    const labels = this.contextLabelTable;
    const bitsDecoded = this.bitsDecoded;
    const processedInverseMask = ~1;
    const processedMask = 1;
    const firstMagnitudeBitMask = 2;
    per (lascia che i0 = 0; i0 < altezza; i0 += 4) {
      per (lascia che j = 0; j < larghezza; j++) {
        lascia indice = i0 * larghezza + j;
        per (lascia che i1 = 0; i1 < 4; i1++, indice += larghezza) {
          costante i = i0 + i1;
          se (i >= altezza) {
            rottura;
          }
          processingFlags[indice] &= processedInverseMask;
          se (coefficientiMagnitudo[indice] || !viciniSignificato[indice]) {
            continuare;
          }
          const contextLabel = etichette[viciniSignificanza[indice]];
          decisione costante = decoder.readBit(contesti, etichetta contesto);
          se (decisione) {
            const sign = this.decodeSignBit(i, j, indice);
            coefficientiSign[indice] = segno;
            coefficientiMagnitudo[indice] = 1;
            this.setNeighborsSignificance(i, j, indice);
            processingFlags[indice] |= firstMagnitudeBitMask;
          }
          bitsDecoded[indice]++;
          processingFlags[indice] |= processedMask;
        }
      }
    }
  }
  decodeSignBit(riga, colonna, indice) {
    const width = this.width,
      altezza = this.height;
    const coefficentsMagnitude = this.coefficentsMagnitude;
    const coefficentsSign = this.coefficentsSign;
    lascia contributo, segno0, segno1, significatività1;
    lascia contextLabel, decodificato;
    significatività1 = colonna > 0 && coefficientiMagnitudo[indice - 1] !== 0;
    se (colonna + 1 < larghezza && coefficientiMagnitudo[indice + 1] !== 0) {
      segno1 = coefficientiSegno[indice + 1];
      se (significanza1) {
        sign0 = coefficentsSign[indice - 1];
        contributo = 1 - segno1 - segno0;
      } altro {
        contributo = 1 - segno1 - segno1;
      }
    } altrimenti se (significanza1) {
      sign0 = coefficentsSign[indice - 1];
      contributo = 1 - segno0 - segno0;
    } altro {
      contributo = 0;
    }
    const horizontalContribution = 3 * contributo;
    significatività1 = riga > 0 && coefficientiMagnitudo[indice - larghezza] !== 0;
    se (riga + 1 < altezza && coefficientiMagnitudo[indice + larghezza] !== 0) {
      sign1 = coefficentsSign[indice + larghezza];
      se (significanza1) {
        sign0 = coefficentsSign[indice - larghezza];
        contributo = 1 - segno1 - segno0 + contributoorizzontale;
      } altro {
        contributo = 1 - segno1 - segno1 + contributoorizzontale;
      }
    } altrimenti se (significanza1) {
      sign0 = coefficentsSign[indice - larghezza];
      contributo = 1 - segno0 - segno0 + contributoorizzontale;
    } altro {
      contributo = contributoorizzontale;
    }
    se (contributo >= 0) {
      contextLabel = 9 + contributo;
      decodificato = this.decoder.readBit(this.contexts, contextLabel);
    } altro {
      contextLabel = 9 - contributo;
      decodificato = this.decoder.readBit(this.contexts, contextLabel) ^ 1;
    }
    ritorno decodificato;
  }
  runMagnitudeRefinementPass() {
    const decoder = this.decoder;
    const width = this.width,
      altezza = this.height;
    const coefficentsMagnitude = this.coefficentsMagnitude;
    const neighborsSignificance = this.neighborsSignificance;
    const contesti = this.contexts;
    const bitsDecoded = this.bitsDecoded;
    const processingFlags = this.processingFlags;
    const processedMask = 1;
    const firstMagnitudeBitMask = 2;
    lunghezza costante = larghezza * altezza;
    const width4 = larghezza * 4;
    for (let indice0 = 0, indiceSuccessivo; indice0 < lunghezza; indice0 = indiceSuccessivo) {
      indexNext = Math.min(lunghezza, indice0 + larghezza4);
      per (lascia che j = 0; j < larghezza; j++) {
        per (lascia che indice = indice0 + j; indice < indiceSuccessivo; indice += larghezza) {
          se (!coefficentsMagnitude[indice] || (processingFlags[indice] & processedMask) !== 0) {
            continuare;
          }
          lascia contextLabel = 16;
          se ((processingFlags[indice] & firstMagnitudeBitMask) !== 0) {
            processingFlags[indice] ^= firstMagnitudeBitMask;
            const meaning = neighborsSignificance[index] & 127;
            contextLabel = significatività === 0 ? 15 : 14;
          }
          const bit = decoder.readBit(contesti, contextLabel);
          coefficentsMagnitude[indice] = coefficentsMagnitude[indice] << 1 | bit;
          bitsDecoded[indice]++;
          processingFlags[indice] |= processedMask;
        }
      }
    }
  }
  eseguiCleanupPass() {
    const decoder = this.decoder;
    const width = this.width,
      altezza = this.height;
    const neighborsSignificance = this.neighborsSignificance;
    const coefficentsMagnitude = this.coefficentsMagnitude;
    const coefficentsSign = this.coefficentsSign;
    const contesti = this.contexts;
    const labels = this.contextLabelTable;
    const bitsDecoded = this.bitsDecoded;
    const processingFlags = this.processingFlags;
    const processedMask = 1;
    const firstMagnitudeBitMask = 2;
    const oneRowDown = larghezza;
    const twoRowsDown = larghezza * 2;
    const threeRowsDown = larghezza * 3;
    lascia iNext;
    per (lascia che i0 = 0; i0 < altezza; i0 = iNext) {
      iNext = Math.min(i0 + 4, altezza);
      const indexBase = i0 * larghezza;
      const checkAllEmpty = i0 + 3 < altezza;
      per (lascia che j = 0; j < larghezza; j++) {
        const index0 = indexBase + j;
        const allEmpty = checkAllEmpty && processingFlags[index0] === 0 && processingFlags[index0 + oneRowDown] === 0 && processingFlags[index0 + twoRowsDown] === 0 && processingFlags[index0 + threeRowsDown] === 0 && neighborsSignificance[index0] === 0 && neighborsSignificance[index0 + oneRowDown] === 0 && neighborsSignificance[index0 + twoRowsDown] === 0 && neighborsSignificance[index0 + threeRowsDown] === 0;
        sia i1 = 0,
          indice = indice0;
        sia i = i0,
          cartello;
        se (tuttoVuoto) {
          const hasSignificantCoefficent = decoder.readBit(contesti, BitModel.RUNLENGTH_CONTEXT);
          se (!hasSignificantCoefficent) {
            bitsDecoded[indice0]++;
            bitsDecoded[indice0 + unaRigaDown]++;
            bitsDecoded[indice0 + dueRigheGiù]++;
            bitsDecoded[indice0 + treRigheGiù]++;
            continuare;
          }
          i1 = decoder.readBit(contesti, BitModel.UNIFORM_CONTEXT) << 1 | decoder.readBit(contesti, BitModel.UNIFORM_CONTEXT);
          se (i1 !== 0) {
            io = i0 + i1;
            indice += i1 * larghezza;
          }
          segno = this.decodeSignBit(i, j, indice);
          coefficientiSign[indice] = segno;
          coefficientiMagnitudo[indice] = 1;
          this.setNeighborsSignificance(i, j, indice);
          processingFlags[indice] |= firstMagnitudeBitMask;
          indice = indice0;
          per (lascia che i2 = i0; i2 <= i; i2++, indice += larghezza) {
            bitsDecoded[indice]++;
          }
          i1++;
        }
        per (i = i0 + i1; i < iNext; i++, indice += larghezza) {
          se (coefficientiMagnitudo[indice] || (Flag di elaborazione[indice] & Maschera elaborata) !== 0) {
            continuare;
          }
          const contextLabel = etichette[viciniSignificanza[indice]];
          decisione costante = decoder.readBit(contesti, etichetta contesto);
          se (decisione === 1) {
            segno = this.decodeSignBit(i, j, indice);
            coefficientiSign[indice] = segno;
            coefficientiMagnitudo[indice] = 1;
            this.setNeighborsSignificance(i, j, indice);
            processingFlags[indice] |= firstMagnitudeBitMask;
          }
          bitsDecoded[indice]++;
        }
      }
    }
  }
  checkSegmentationSymbol() {
    const decoder = this.decoder;
    const contesti = this.contexts;
    const symbol = decoder.readBit(contesti, BitModel.UNIFORM_CONTEXT) << 3 | decoder.readBit(contesti, BitModel.UNIFORM_CONTEXT) << 2 | decoder.readBit(contesti, BitModel.UNIFORM_CONTEXT) << 1 | decoder.readBit(contesti, BitModel.UNIFORM_CONTEXT);
    se (simbolo !== 0xa) {
      throw new JpxError("Simbolo di segmentazione non valido");
    }
  }
}
classe Trasforma {
  costruttore() {
    se (questo.costruttore === Trasforma) {
      (0, _util.unreachable)("Impossibile inizializzare Transform.");
    }
  }
  calcola(sottobande, u0, v0) {
    lascia ll = sottobande[0];
    per (lascia che i = 1, ii = sottobande.lunghezza; i < ii; i++) {
      ll = this.iterate(ll, subbands[i], u0, v0);
    }
    ritorno ll;
  }
  estendi(buffer, offset, dimensione) {
    sia i1 = offset - 1,
      j1 = offset + 1;
    sia i2 = offset + dimensione - 2,
      j2 = offset + dimensione;
    buffer[i1--] = buffer[j1++];
    buffer[j2++] = buffer[i2--];
    buffer[i1--] = buffer[j1++];
    buffer[j2++] = buffer[i2--];
    buffer[i1--] = buffer[j1++];
    buffer[j2++] = buffer[i2--];
    buffer[i1] = buffer[j1];
    buffer[j2] = buffer[i2];
  }
  filtro(x, offset, lunghezza) {
    (0, _util.unreachable)("Metodo astratto `filter` chiamato");
  }
  iterare(ll, hl_lh_hh, u0, v0) {
    const llWidth = ll.width,
      llHeight = ll.altezza;
    lascia llItems = ll.items;
    larghezza costante = hl_lh_hh.width;
    altezza costante = hl_lh_hh.altezza;
    const elementi = hl_lh_hh.elementi;
    siano i, j, k, l, u, v;
    per (k = 0, i = 0; i < llHeight; i++) {
      l = i * 2 * larghezza;
      per (j = 0; j < llWidth; j++, k++, l += 2) {
        elementi[l] = llElementi[k];
      }
    }
    llItems = ll.items = null;
    const bufferPadding = 4;
    const rowBuffer = new Float32Array(larghezza + 2 * bufferPadding);
    se (larghezza === 1) {
      se ((u0 & 1) !== 0) {
        per (v = 0, k = 0; v < altezza; v++, k += larghezza) {
          elementi[k] *= 0,5;
        }
      }
    } altro {
      per (v = 0, k = 0; v < altezza; v++, k += larghezza) {
        rowBuffer.set(items.subarray(k, k + larghezza), bufferPadding);
        this.extend(rowBuffer, bufferPadding, width);
        this.filter(rowBuffer, bufferPadding, width);
        items.set(rowBuffer.subarray(bufferPadding, bufferPadding + width), k);
      }
    }
    lascia numBuffers = 16;
    const colBuffers = [];
    per (i = 0; i < numBuffers; i++) {
      colBuffers.push(new Float32Array(altezza + 2 * bufferPadding));
    }
    lascia b,
      buffercorrente = 0;
    ll = bufferPadding + altezza;
    se (altezza === 1) {
      se ((v0 & 1) !== 0) {
        per (u = 0; u < larghezza; u++) {
          elementi[u] *= 0,5;
        }
      }
    } altro {
      per (u = 0; u < larghezza; u++) {
        se (buffercorrente === 0) {
          numBuffers = Math.min(larghezza - u, numBuffers);
          per (k = u, l = bufferPadding; l < ll; k += larghezza, l++) {
            per (b = 0; b < numBuffers; b++) {
              colBuffers[b][l] = elementi[k + b];
            }
          }
          buffercorrente = numBuffer;
        }
        buffercorrente--;
        const buffer = colBuffers[currentBuffer];
        this.extend(buffer, bufferPadding, altezza);
        this.filter(buffer, bufferPadding, altezza);
        se (buffercorrente === 0) {
          k = u - numBuffer + 1;
          per (l = bufferPadding; l < ll; k += larghezza, l++) {
            per (b = 0; b < numBuffers; b++) {
              elementi[k + b] = colBuffers[b][l];
            }
          }
        }
      }
    }
    ritorno {
      larghezza,
      altezza,
      elementi
    };
  }
}
classe IrreversibleTransform estende Transform {
  filtro(x, offset, lunghezza) {
    const len ​​= lunghezza >> 1;
    spostamento |= 0;
    lascia j, n, corrente, successivo;
    costante alfa = -1,586134342059924;
    costante beta = -0,052980118572961;
    cost gamma = 0,882911075530934;
    delta costante = 0,443506852043971;
    costante K = 1,230174104914001;
    costante K_ = 1 / K;
    j = spostamento - 3;
    for (n = len + 4; n--; j += 2) {
      x[j] *= K_;
    }
    j = spostamento - 2;
    corrente = delta * x[j - 1];
    for (n = len + 3; n--; j += 2) {
      successivo = delta * x[j + 1];
      x[j] = K * x[j] - corrente - successivo;
      se (n--) {
        j += 2;
        corrente = delta * x[j + 1];
        x[j] = K * x[j] - corrente - successivo;
      } altro {
        rottura;
      }
    }
    j = spostamento - 1;
    corrente = gamma * x[j - 1];
    for (n = len + 2; n--; j += 2) {
      successivo = gamma * x[j + 1];
      x[j] -= corrente + successivo;
      se (n--) {
        j += 2;
        corrente = gamma * x[j + 1];
        x[j] -= corrente + successivo;
      } altro {
        rottura;
      }
    }
    j = spostamento;
    corrente = beta * x[j - 1];
    for (n = len + 1; n--; j += 2) {
      successivo = beta * x[j + 1];
      x[j] -= corrente + successivo;
      se (n--) {
        j += 2;
        corrente = beta * x[j + 1];
        x[j] -= corrente + successivo;
      } altro {
        rottura;
      }
    }
    se (len !== 0) {
      j = spostamento + 1;
      corrente = alfa * x[j - 1];
      per (n = len; n--; j += 2) {
        successivo = alfa * x[j + 1];
        x[j] -= corrente + successivo;
        se (n--) {
          j += 2;
          corrente = alfa * x[j + 1];
          x[j] -= corrente + successivo;
        } altro {
          rottura;
        }
      }
    }
  }
}
classe ReversibleTransform estende Transform {
  filtro(x, offset, lunghezza) {
    const len ​​= lunghezza >> 1;
    spostamento |= 0;
    siano j, n;
    per (j = offset, n = len + 1; n--; j += 2) {
      x[j] -= x[j - 1] + x[j + 1] + 2 >> 2;
    }
    per (j = offset + 1, n = len; n--; j += 2) {
      x[j] += x[j - 1] + x[j + 1] >> 1;
    }
  }
}

/***/ }),
/* 31 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.LZWStream = void 0;
var _decode_stream = __w_pdfjs_require__(18);
classe LZWStream estende _decode_stream.DecodeStream {
  costruttore(str, forseLunghezza, cambiamentoprecoce) {
    super(forseLunghezza);
    questo.str = str;
    questo.dizionario = str.dizionario;
    questo.cachedData = 0;
    questo.bitsCached = 0;
    const maxLzwDictionarySize = 4096;
    const lzwState = {
      cambiamento anticipato,
      Lunghezza del codice: 9,
      nextCodice: 258,
      dictionaryValues: nuovo Uint8Array(maxLzwDictionarySize),
      lunghezze del dizionario: nuovo Uint16Array(maxLzwDictionarySize),
      dictionaryPrevCodes: new Uint16Array(maxLzwDictionarySize),
      sequenzacorrente: nuovo Uint8Array(maxLzwDictionarySize),
      lunghezzasequenzacorrente: 0
    };
    per (lascia che i = 0; i < 256; ++i) {
      lzwState.dictionaryValues[i] = i;
      lzwState.dictionaryLengths[i] = 1;
    }
    questo.lzwState = lzwState;
  }
  leggiBits(n) {
    lascia bitsCached = this.bitsCached;
    lascia cachedData = this.cachedData;
    mentre (bitsCached < n) {
      const c = this.str.getByte();
      se (c === -1) {
        this.eof = true;
        restituisci null;
      }
      dati memorizzati nella cache = dati memorizzati nella cache << 8 | c;
      bit memorizzati nella cache += 8;
    }
    questo.bitsCached = bitsCached -= n;
    this.cachedData = cachedData;
    this.lastCode = null;
    restituisci cachedData >>> bitsCached & (1 << n) - 1;
  }
  readBlock() {
    const blockSize = 512,
      decodedSizeDelta = blockSize;
    lascia estimatedDecodedSize = blockSize * 2;
    siano i, j, q;
    const lzwState = this.lzwState;
    se (!lzwState) {
      ritorno;
    }
    const earlyChange = lzwState.earlyChange;
    lascia nextCode = lzwState.nextCode;
    const dictionaryValues ​​= lzwState.dictionaryValues;
    const dictionaryLengths = lzwState.dictionaryLengths;
    const dictionaryPrevCodes = lzwState.dictionaryPrevCodes;
    lascia codeLength = lzwState.codeLength;
    lascia prevCode = lzwState.prevCode;
    const currentSequence = lzwState.currentSequence;
    lascia che currentSequenceLength = lzwState.currentSequenceLength;
    lascia decodedLength = 0;
    lascia che currentBufferLength = this.bufferLength;
    lascia buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
    per (i = 0; i < dimensioneblocco; i++) {
      codice costante = this.readBits(lunghezzacodice);
      const hasPrev = currentSequenceLength > 0;
      se (codice < 256) {
        currentSequence[0] = codice;
        lunghezzasequenzacorrente = 1;
      } altrimenti se (codice >= 258) {
        se (codice < codice successivo) {
          lunghezzaSequenzacorrente = lunghezzedeldizionario[codice];
          per (j = lunghezzasequenzacorrente - 1, q = codice; j >= 0; j--) {
            currentSequence[j] = dictionaryValues[q];
            q = dizionarioPrevCodes[q];
          }
        } altro {
          sequenzacorrente[lunghezzasequenzacorrente++] = sequenzacorrente[0];
        }
      } altrimenti se (codice === 256) {
        lunghezza del codice = 9;
        Codice successivo = 258;
        lunghezzasequenzacorrente = 0;
        continuare;
      } altro {
        this.eof = true;
        elimina questo.lzwState;
        rottura;
      }
      se (haPrev) {
        dizionarioPrevCodes[nextCode] = prevCode;
        lunghezzedeldizionario[codicesuccessivo] = lunghezzedeldizionario[codiceprecedente] + 1;
        dictionaryValues[nextCode] = currentSequence[0];
        nextCode++;
        codeLength = nextCode + earlyChange & nextCode + earlyChange - 1 ? codeLength : Math.min(Math.log(nextCode + earlyChange) / 0.6931471805599453 + 1, 12) | 0;
      }
      prevCode = codice;
      decodedLength += currentSequenceLength;
      se (dimensionedecodificatastima < lunghezzadecodificata) {
        Fare {
          estimatedDecodedSize += decodedSizeDelta;
        } while (estimatedDecodedSize < decodedLength);
        buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
      }
      per (j = 0; j < lunghezzasequenzacorrente; j++) {
        buffer[currentBufferLength++] = currentSequence[j];
      }
    }
    lzwState.nextCode = nextCode;
    lzwState.codeLength = lunghezzadelcodice;
    lzwState.prevCode = prevCode;
    lzwState.currentSequenceLength = currentSequenceLength;
    this.bufferLength = currentBufferLength;
  }
}
esportazioni.LZWStream = LZWStream;

/***/ }),
/* 32 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.PredictorStream = void 0;
var _decode_stream = __w_pdfjs_require__(18);
var _primitives = __w_pdfjs_require__(4);
var _util = __w_pdfjs_require__(2);
classe PredictorStream estende _decode_stream.DecodeStream {
  costruttore(str, forseLunghezza, parametri) {
    super(forseLunghezza);
    se (!(parametri instanceof _primitives.Dict)) {
      ritorno str;
    }
    const predictor = this.predictor = params.get("Predictor") || 1;
    se (predittore <= 1) {
      ritorno str;
    }
    se (predittore !== 2 && (predittore < 10 || predittore > 15)) {
      throw new _util.FormatError(`Predictor non supportato: ${predictor}`);
    }
    this.readBlock = predictor === 2 ? this.readBlockTiff : this.readBlockPng;
    questo.str = str;
    questo.dizionario = str.dizionario;
    const colori = this.colors = params.get("Colori") || 1;
    const bit = this.bits = params.get("BPC", "BitsPerComponent") || 8;
    const columns = this.columns = params.get("Colonne") || 1;
    this.pixBytes = colori * bit + 7 >> 3;
    this.rowBytes = colonne * colori * bit + 7 >> 3;
    restituisci questo;
  }
  leggiBlockTiff() {
    const rowBytes = this.rowBytes;
    const bufferLength = this.bufferLength;
    const buffer = this.ensureBuffer(bufferLength + rowBytes);
    const bit = this.bits;
    const colori = questo.colori;
    const rawBytes = this.str.getBytes(rowBytes);
    this.eof = !rawBytes.length;
    se (questo.eof) {
      ritorno;
    }
    sia inbuf = 0,
      outbuf = 0;
    lascia inbits = 0,
      bit in uscita = 0;
    lascia pos = lunghezzabuffer;
    lascia che io;
    se (bit === 1 e colori === 1) {
      per (i = 0; i < rowBytes; ++i) {
        lascia c = rawBytes[i] ^ inbuf;
        c ^= c >> 1;
        c ^= c >> 2;
        c ^= c >> 4;
        inbuf = (c & 1) << 7;
        buffer[pos++] = c;
      }
    } altrimenti se (bit === 8) {
      per (i = 0; i < colori; ++i) {
        buffer[pos++] = rawBytes[i];
      }
      per (; i < rowBytes; ++i) {
        buffer[pos] = buffer[pos - colori] + rawBytes[i];
        posizione++;
      }
    } altrimenti se (bit === 16) {
      const bytesPerPixel = colori * 2;
      per (i = 0; i < bytePerPixel; ++i) {
        buffer[pos++] = rawBytes[i];
      }
      per (; i < rowBytes; i += 2) {
        somma costante = ((rawBytes[i] & 0xff) << 8) + (rawBytes[i + 1] & 0xff) + ((buffer[pos - bytesPerPixel] & 0xff) << 8) + (buffer[pos - bytesPerPixel + 1] & 0xff);
        buffer[pos++] = somma >> 8 & 0xff;
        buffer[pos++] = somma & 0xff;
      }
    } altro {
      const compArray = new Uint8Array(colori + 1);
      const bitMask = (1 << bit) - 1;
      sia j = 0,
        k = lunghezza del buffer;
      const colonne = this.columns;
      per (i = 0; i < colonne; ++i) {
        per (lascia che kk = 0; kk < colori; ++kk) {
          se (inbit < bit) {
            inbuf = inbuf << 8 | rawBytes[j++] & 0xff;
            inbit += 8;
          }
          compArray[kk] = compArray[kk] + (inbuf >> inbits - bit) & bitMask;
          inbits -= bit;
          outbuf = outbuf << bit | compArray[kk];
          outbits += bit;
          se (outbits >= 8) {
            buffer[k++] = outbuf >> outbits - 8 & 0xff;
            outbits -= 8;
          }
        }
      }
      se (outbit > 0) {
        buffer[k++] = (outbuf << 8 - outbit) + (inbuf & (1 << 8 - outbit) - 1);
      }
    }
    this.bufferLength += rowBytes;
  }
  leggiBloccoPng() {
    const rowBytes = this.rowBytes;
    const pixBytes = this.pixBytes;
    const predictor = this.str.getByte();
    const rawBytes = this.str.getBytes(rowBytes);
    this.eof = !rawBytes.length;
    se (questo.eof) {
      ritorno;
    }
    const bufferLength = this.bufferLength;
    const buffer = this.ensureBuffer(bufferLength + rowBytes);
    lascia prevRow = buffer.subarray(bufferLength - rowBytes, bufferLength);
    se (prevRow.length === 0) {
      prevRow = new Uint8Array(rowBytes);
    }
    lasciami,
      j = lunghezza del buffer,
      su,
      C;
    interruttore (predittore) {
      caso 0:
        per (i = 0; i < rowBytes; ++i) {
          buffer[j++] = rawBytes[i];
        }
        rottura;
      caso 1:
        per (i = 0; i < pixBytes; ++i) {
          buffer[j++] = rawBytes[i];
        }
        per (; i < rowBytes; ++i) {
          buffer[j] = buffer[j - pixBytes] + rawBytes[i] & 0xff;
          j++;
        }
        rottura;
      caso 2:
        per (i = 0; i < rowBytes; ++i) {
          buffer[j++] = prevRow[i] + rawBytes[i] & 0xff;
        }
        rottura;
      caso 3:
        per (i = 0; i < pixBytes; ++i) {
          buffer[j++] = (prevRow[i] >> 1) + rawBytes[i];
        }
        per (; i < rowBytes; ++i) {
          buffer[j] = (prevRow[i] + buffer[j - pixBytes] >> 1) + rawBytes[i] & 0xff;
          j++;
        }
        rottura;
      caso 4:
        per (i = 0; i < pixBytes; ++i) {
          su = prevRow[i];
          c = rawBytes[i];
          buffer[j++] = su + c;
        }
        per (; i < rowBytes; ++i) {
          su = prevRow[i];
          const upLeft = prevRow[i - pixBytes];
          const left = buffer[j - pixBytes];
          const p = sinistra + su - suSinistra;
          lascia pa = p - sinistra;
          se (pa < 0) {
            pa = -pa;
          }
          lascia pb = p - su;
          se (pb < 0) {
            pb = -pb;
          }
          lascia pc = p - upLeft;
          se (pc < 0) {
            pc = -pc;
          }
          c = rawBytes[i];
          se (pa <= pb e pa <= pc) {
            buffer[j++] = sinistra + c;
          } altrimenti se (pb <= pc) {
            buffer[j++] = su + c;
          } altro {
            buffer[j++] = upLeft + c;
          }
        }
        rottura;
      predefinito:
        throw new _util.FormatError(`Predictor non supportato: ${predictor}`);
    }
    this.bufferLength += rowBytes;
  }
}
esportazioni.PredictorStream = PredictorStream;

/***/ }),
/* 33 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.RunLengthStream = void 0;
var _decode_stream = __w_pdfjs_require__(18);
classe RunLengthStream estende _decode_stream.DecodeStream {
  costruttore(str, forseLunghezza) {
    super(forseLunghezza);
    questo.str = str;
    questo.dizionario = str.dizionario;
  }
  readBlock() {
    const repeatHeader = this.str.getBytes(2);
    se (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {
      this.eof = true;
      ritorno;
    }
    lascia buff ;
    lascia che bufferLength = this.bufferLength;
    lascia n = repeatHeader[0];
    se (n < 128) {
      buffer = this.ensureBuffer(lunghezzabuffer + n + 1);
      buffer[lunghezzabuffer++] = repeatHeader[1];
      se (n > 0) {
        const source = this.str.getBytes(n);
        buffer.set(sorgente, lunghezza buffer);
        lunghezza del buffer += n;
      }
    } altro {
      n = 257 - n;
      const b = repeatHeader[1];
      buffer = this.ensureBuffer(lunghezzabuffer + n + 1);
      per (lascia che i = 0; i < n; i++) {
        buffer[lunghezzabuffer++] = b;
      }
    }
    this.bufferLength = bufferLength;
  }
}
esportazioni.RunLengthStream = RunLengthStream;

/***/ }),
/* 34 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.Font = esportazioni.ErrorFont = void 0;
var _util = __w_pdfjs_require__(2);
var _cff_parser = __w_pdfjs_require__(35);
var _fonts_utils = __w_pdfjs_require__(38);
var _unicode = __w_pdfjs_require__(40);
var _glyphlist = __w_pdfjs_require__(39);
var _encodings = __w_pdfjs_require__(37);
var _standard_fonts = __w_pdfjs_require__(41);
var _to_unicode_map = __w_pdfjs_require__(42);
var _cff_font = __w_pdfjs_require__(43);
var _font_renderer = __w_pdfjs_require__(44);
var _metrics = __w_pdfjs_require__(45);
var _glyf = __w_pdfjs_require__(46);
var _cmap = __w_pdfjs_require__(14);
var _opentype_file_builder = __w_pdfjs_require__(47);
var _core_utils = __w_pdfjs_require__(3);
var _stream = __w_pdfjs_require__(8);
var _type1_font = __w_pdfjs_require__(48);
const PRIVATE_USE_AREAS = [[0xe000, 0xf8ff], [0x100000, 0x10fffd]];
const PDF_GLYPH_SPACE_UNITS = 1000;
const EXPORT_DATA_PROPERTIES = ["ascent", "bbox", "black", "bold", "charProcOperatorList", "composite", "cssFontInfo", "data", "defaultVMetrics", "defaultWidth", "descent", "fallbackName", "fontMatrix", "isInvalidPDFjsFont", "isType3Font", "corsivo", "loadedName", "mimetype", "missingFile", "name", "remeasure", "subtype", "systemFontInfo", "type", "vertical"];
const EXPORT_DATA_EXTRA_PROPERTIES = ["cMap", "defaultEncoding", "differences", "isMonospace", "isSerifFont", "isSymbolicFont", "seacMap", "toFontChar", "toUnicode", "vmetrics", "widths"];
funzione adjustWidths(proprietà) {
  se (!properties.fontMatrix) {
    ritorno;
  }
  se (proprietà.fontMatrix[0] === _util.FONT_IDENTITY_MATRIX[0]) {
    ritorno;
  }
  scala costante = 0,001 / proprietà.fontMatrix[0];
  const glyphsWidths = properties.widths;
  per (glifo costante in glifiLarghezze) {
    glyphsWidths[glyph] *= scala;
  }
  proprietà.defaultWidth *= scala;
}
funzione adjustTrueTypeToUnicode(proprietà, isSymbolicFont, nameRecords) {
  se (proprietà.isInternalFont) {
    ritorno;
  }
  se (properties.hasIncludedToUnicodeMap) {
    ritorno;
  }
  se (properties.hasEncoding) {
    ritorno;
  }
  se (proprietà.istanzaUnicode di _a_unicode_map.IdentityToUnicodeMap) {
    ritorno;
  }
  se (!isSymbolicFont) {
    ritorno;
  }
  se (nameRecords.length === 0) {
    ritorno;
  }
  se (properties.defaultEncoding === _encodings.WinAnsiEncoding) {
    ritorno;
  }
  per (const r di nameRecords) {
    se (!isWinNameRecord(r)) {
      ritorno;
    }
  }
  codifica costante = _encodings.WinAnsiEncoding;
  const toUnicode = [],
    glifiUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
  per (codicecarattere costante nella codifica) {
    const glyphName = encoding[charCode];
    se (glifoName === "") {
      continuare;
    }
    const unicode = glyphsUnicodeMap[glyphName];
    se (unicode === indefinito) {
      continuare;
    }
    toUnicode[charCode] = String.fromCharCode(unicode);
  }
  se (toUnicode.length > 0) {
    proprietà.toUnicode.amend(toUnicode);
  }
}
funzione adjustType1ToUnicode(proprietà, builtInEncoding) {
  se (proprietà.isInternalFont) {
    ritorno;
  }
  se (properties.hasIncludedToUnicodeMap) {
    ritorno;
  }
  se (builtInEncoding === proprietà.defaultEncoding) {
    ritorno;
  }
  se (proprietà.istanzaUnicode di _a_unicode_map.IdentityToUnicodeMap) {
    ritorno;
  }
  const toUnicode = [],
    glifiUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
  per (const charCode in builtInEncoding) {
    se (properties.hasEncoding) {
      se (properties.baseEncodingName || properties.differences[charCode] !== indefinito) {
        continuare;
      }
    }
    const glyphName = builtInEncoding[charCode];
    const unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap);
    se (unicode !== -1) {
      toUnicode[charCode] = String.fromCharCode(unicode);
    }
  }
  se (toUnicode.length > 0) {
    proprietà.toUnicode.amend(toUnicode);
  }
}
funzione amendFallbackToUnicode(proprietà) {
  se (!properties.fallbackToUnicode) {
    ritorno;
  }
  se (proprietà.istanzaUnicode di _a_unicode_map.IdentityToUnicodeMap) {
    ritorno;
  }
  const toUnicode = [];
  per (const charCode in properties.fallbackToUnicode) {
    se (proprietà.toUnicode.has(charCode)) {
      continuare;
    }
    toUnicode[charCode] = properties.fallbackToUnicode[charCode];
  }
  se (toUnicode.length > 0) {
    proprietà.toUnicode.amend(toUnicode);
  }
}
classe Glifo {
  costruttore(originalCharCode, fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont) {
    this.originalCharCode = originalCharCode;
    questo.fontChar = fontChar;
    questo.unicode = unicode;
    this.accent = accento;
    this.width = larghezza;
    questo.vmetrico = vmetrico;
    this.operatorListId = operatorListId;
    questo.èSpazio = èSpazio;
    this.isInFont = isInFont;
  }
  ottieni categoria() {
    return (0, _util.shadow)(this, "category", (0, _unicode.getCharUnicodeCategory)(this.unicode), true);
  }
}
funzione int16(b0, b1) {
  ritorno (b0 << 8) + b1;
}
funzione writeSignedInt16(byte, indice, valore) {
  byte[indice + 1] = valore;
  byte[indice] = valore >>> 8;
}
funzione signedInt16(b0, b1) {
  valore costante = (b0 << 8) + b1;
  valore di ritorno & 1 << 15 ? valore - 0x10000 : valore;
}
funzione int32(b0, b1, b2, b3) {
  ritorno (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
}
funzione string16(valore) {
  return String.fromCharCode(valore >> 8 & 0xff, valore & 0xff);
}
funzione safeString16(valore) {
  se (valore > 0x7fff) {
    valore = 0x7fff;
  } altrimenti se (valore < -0x8000) {
    valore = -0x8000;
  }
  return String.fromCharCode(valore >> 8 & 0xff, valore & 0xff);
}
funzione isTrueTypeFile(file) {
  const header = file.peekBytes(4);
  return (0, _core_utils.readUint32)(header, 0) === 0x00010000 || (0, _util.bytesToString)(header) === "true";
}
funzione isTrueTypeCollectionFile(file) {
  const header = file.peekBytes(4);
  return (0, _util.bytesToString)(intestazione) === "ttcf";
}
funzione isOpenTypeFile(file) {
  const header = file.peekBytes(4);
  return (0, _util.bytesToString)(header) === "OTTO";
}
funzione isType1File(file) {
  const header = file.peekBytes(2);
  se (intestazione[0] === 0x25 e intestazione[1] === 0x21) {
    restituisci vero;
  }
  se (intestazione[0] === 0x80 && intestazione[1] === 0x01) {
    restituisci vero;
  }
  restituisci falso;
}
funzione isCFFFile(file) {
  const header = file.peekBytes(4);
  se (intestazione[0] >= 1 e intestazione[3] >= 1 e intestazione[3] <= 4) {
    restituisci vero;
  }
  restituisci falso;
}
funzione getFontFileType(file, {
  tipo,
  sottotipo,
  composito
}) {
  lascia fileType, fileSubtype;
  se (isTrueTypeFile(file) || isTrueTypeCollectionFile(file)) {
    fileType = composito ? "CIDFontType2" : "TrueType";
  } altrimenti se (isOpenTypeFile(file)) {
    fileType = composito ? "CIDFontType2" : "OpenType";
  } altrimenti se (isType1File(file)) {
    se (composto) {
      fileType = "CIDFontType0";
    } altro {
      fileType = tipo === "MMType1" ? "MMType1" : "Tipo1";
    }
  } altrimenti se (isCFFFile(file)) {
    se (composto) {
      fileType = "CIDFontType0";
      fileSubtype = "CIDFontType0C";
    } altro {
      fileType = tipo === "MMType1" ? "MMType1" : "Tipo1";
      fileSubtype = "Tipo1C";
    }
  } altro {
    (0, _util.warn)("getFontFileType: Impossibile rilevare il tipo/sottotipo corretto del file di font.");
    fileType = tipo;
    fileSubtype = sottotipo;
  }
  restituisci [fileType, fileSubtype];
}
funzione applyStandardFontGlyphMap(mappa, glyphMap) {
  per (const charCode in glyphMap) {
    mappa[+codicecarattere] = glifoMappa[codicecarattere];
  }
}
funzione buildToFontChar(codifica, glifiUnicodeMap, differenze) {
  const toFontChar = [];
  lascia unicode;
  per (lascia che i = 0, ii = lunghezza di codifica; i < ii; i++) {
    unicode = (0, _unicode.getUnicodeForGlyph)(encoding[i], glyphsUnicodeMap);
    se (unicode !== -1) {
      toFontChar[i] = unicode;
    }
  }
  per (const charCode nelle differenze) {
    unicode = (0, _unicode.getUnicodeForGlyph)(differenze[charCode], glifiUnicodeMap);
    se (unicode !== -1) {
      toFontChar[+charCode] = unicode;
    }
  }
  torna aFontChar;
}
funzione isMacNameRecord(r) {
  restituisci r.platform === 1 && r.encoding === 0 && r.language === 0;
}
funzione isWinNameRecord(r) {
  restituisci r.platform === 3 && r.encoding === 1 && r.language === 0x409;
}
funzione convertCidString(charCode, cid, shouldThrow = false) {
  switch (cid.length) {
    caso 1:
      restituisci cid.charCodeAt(0);
    caso 2:
      restituisci cid.charCodeAt(0) << 8 | cid.charCodeAt(1);
  }
  const msg = `Stringa CID non supportata (charCode ${charCode}): "${cid}".`;
  se (dovrebbeLanciare) {
    lancia nuovo _util.FormatError(msg);
  }
  (0, _util.warn)(msg);
  restituisci cid;
}
funzione adjustMapping(charCodeToGlyphId, hasGlyph, newGlyphZeroId, toUnicode) {
  const newMap = Object.create(null);
  const toUnicodeExtraMap = new Map();
  const toFontChar = [];
  const usedGlyphIds = new Set();
  lascia privateUseAreaIndex = 0;
  const privateUseOffetStart = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
  lascia nextAvailableFontCharCode = privateUseOffetStart;
  lascia privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];
  const isInPrivateArea = codice => PRIVATE_USE_AREAS[0][0] <= codice && codice <= PRIVATE_USE_AREAS[0][1] || PRIVATE_USE_AREAS[1][0] <= codice && codice <= PRIVATE_USE_AREAS[1][1];
  per (lascia originalCharCode in charCodeToGlyphId) {
    originalCharCode |= 0;
    lascia glyphId = charCodeToGlyphId[originalCharCode];
    se (!hasGlyph(glyphId)) {
      continuare;
    }
    se (nextAvailableFontCharCode > privateUseOffetEnd) {
      privateUseAreaIndex++;
      se (privateUseAreaIndex >= PRIVATE_USE_AREAS.length) {
        (0, _util.warn)("Spazio esaurito nell'area di utilizzo privato del font.");
        rottura;
      }
      nextAvailableFontCharCode = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
      privateUseOffetEnd = AREE_DI_USO_PRIVATE[privateUseAreaIndex][1];
    }
    const fontCharCode = nextAvailableFontCharCode++;
    se (glyphId === 0) {
      glyphId = newGlyphZeroId;
    }
    lascia unicode = toUnicode.get(originalCharCode);
    se (tipo di unicode === "stringa") {
      unicode = unicode.codePointAt(0);
    }
    se (unicode && !isInPrivateArea(unicode) && !usedGlyphIds.has(glyphId)) {
      toUnicodeExtraMap.set(unicode, glyphId);
      usedGlyphIds.add(glyphId);
    }
    newMap[fontCharCode] = glyphId;
    toFontChar[originalCharCode] = fontCharCode;
  }
  ritorno {
    toFontChar,
    charCodeToGlyphId: nuovaMappa,
    aUnicodeExtraMap,
    nextAvailableFontCharCode
  };
}
funzione getRanges(glifi, toUnicodeExtraMap, numGlyphs) {
  codici costanti = [];
  per (const charCode in glifi) {
    se (glifi[codicecarattere] >= numGlifi) {
      continuare;
    }
    codici.push({
      fontCharCode: charCode | 0,
      glyphId: glifi[charCode]
    });
  }
  se (suUnicodeExtraMap) {
    per (const [unicode, glyphId] di toUnicodeExtraMap) {
      se (glyphId >= numGlyphs) {
        continuare;
      }
      codici.push({
        fontCharCode: unicode,
        glyphId
      });
    }
  }
  se (codici.lunghezza === 0) {
    codici.push({
      fontCharCode: 0,
      glyphId: 0
    });
  }
  codes.sort(funzione fontGetRangesSort(a, b) {
    restituisci a.fontCharCode - b.fontCharCode;
  });
  intervalli costanti = [];
  lunghezza costante = codici.lunghezza;
  per (lascia che n = 0; n < lunghezza;) {
    const start = codes[n].fontCharCode;
    const codeIndices = [codes[n].glyphId];
    ++n;
    lascia fine = inizio;
    while (n < lunghezza && fine + 1 === codici[n].fontCharCode) {
      codeIndices.push(codes[n].glyphId);
      ++fine;
      ++n;
      se (fine === 0xffff) {
        rottura;
      }
    }
    ranges.push([inizio, fine, indici di codice]);
  }
  intervalli di ritorno;
}
funzione createCmapTable(glifi, toUnicodeExtraMap, numGlifi) {
  const ranges = getRanges(glifi, toUnicodeExtraMap, numGlifi);
  const numTables = ranges.at(-1)[1] > 0xffff ? 2 : 1;
  lascia cmap = "\x00\x00" + string16(numTables) + "\x00\x03" + "\x00\x01" + (0, _util.string32)(4 + numTables * 8);
  siano i, ii, j, jj;
  per (i = intervalli.lunghezza - 1; i >= 0; --i) {
    se (intervalli[i][0] <= 0xffff) {
      rottura;
    }
  }
  const bmpLength = i + 1;
  se (intervalli[i][0] < 0xffff && intervalli[i][1] === 0xffff) {
    intervalli[i][1] = 0xfffe;
  }
  const trailingRangesCount = ranges[i][1] < 0xffff ? 1 : 0;
  const segCount = bmpLength + trailingRangesCount;
  const searchParams = _opentype_file_builder.OpenTypeFileBuilder.getSearchParams(segCount, 2);
  lascia startCount = "";
  lascia endCount = "";
  lascia idDeltas = "";
  lascia idRangeOffsets = "";
  lascia che glyphsIds = "";
  lascia che bias = 0;
  lascia intervallo, inizio, fine, codici;
  per (i = 0, ii = bmpLength; i < ii; i++) {
    intervallo = intervalli[i];
    inizio = intervallo[0];
    fine = intervallo[1];
    startCount += string16(inizio);
    endCount += string16(fine);
    codici = intervallo[2];
    lascia contiguo = vero;
    per (j = 1, jj = lunghezza codici; j < jj; ++j) {
      se (codici[j] !== codici[j - 1] + 1) {
        contiguo = falso;
        rottura;
      }
    }
    se (! contiguo) {
      offset costante = (segCount - i) * 2 + bias * 2;
      bias += fine - inizio + 1;
      idDeltas += string16(0);
      idRangeOffsets += string16(offset);
      per (j = 0, jj = lunghezza codici; j < jj; ++j) {
        glyphsIds += string16(codes[j]);
      }
    } altro {
      const startCode = codici[0];
      idDeltas += string16(startCode - start & 0xffff);
      idRangeOffsets += string16(0);
    }
  }
  se (trailingRangesCount > 0) {
    endCount += "\xFF\xFF";
    startCount += "\xFF\xFF";
    idDeltas += "\x00\x01";
    idRangeOffsets += "\x00\x00";
  }
  const format314 = "\x00\x00" + string16(2 * segCount) + string16(searchParams.range) + string16(searchParams.entry) + string16(searchParams.rangeShift) + endCount + "\x00\x00" + startCount + idDeltas + idRangeOffsets + glyphsIds;
  lascia format31012 = "";
  lascia header31012 = "";
  se (numTabelle > 1) {
    cmap += "\x00\x03" + "\x00\x0A" + (0, _util.string32)(4 + numTables * 8 + 4 + format314.length);
    formato31012 = "";
    per (i = 0, ii = intervalli.lunghezza; i < ii; i++) {
      intervallo = intervalli[i];
      inizio = intervallo[0];
      codici = intervallo[2];
      lascia codice = codici[0];
      per (j = 1, jj = lunghezza codici; j < jj; ++j) {
        se (codici[j] !== codici[j - 1] + 1) {
          fine = intervallo[0] + j - 1;
          format31012 += (0, _util.string32)(inizio) + (0, _util.string32)(fine) + (0, _util.string32)(codice);
          inizio = fine + 1;
          codice = codici[j];
        }
      }
      format31012 += (0, _util.string32)(inizio) + (0, _util.string32)(intervallo[1]) + (0, _util.string32)(codice);
    }
    header31012 = "\x00\x0C" + "\x00\x00" + (0, _util.string32)(format31012.length + 16) + "\x00\x00\x00\x00" + (0, _util.string32)(format31012.length / 12);
  }
  restituisci cmap + "\x00\x04" + string16(format314.length + 4) + format314 + header31012 + format31012;
}
funzione validateOS2Table(os2, file) {
  file.pos = (file.start || 0) + os2.offset;
  versione costante = file.getUint16();
  file.skip(60);
  selezione costante = file.getUint16();
  se (versione < 4 e selezione e 0x0300) {
    restituisci falso;
  }
  const firstChar = file.getUint16();
  const lastChar = file.getUint16();
  se (primoCar > ultimoCar) {
    restituisci falso;
  }
  file.salta(6);
  const usWinAscent = file.getUint16();
  se (usWinAscent === 0) {
    restituisci falso;
  }
  os2.data[8] = os2.data[9] = 0;
  restituisci vero;
}
funzione createOS2Table(proprietà, stringhe di caratteri, override) {
  sovrascrivi ||= {
    unitàPerEm: 0,
    yMax: 0,
    yMin: 0,
    salita: 0,
    discesa: 0
  };
  lascia ulUnicodeRange1 = 0;
  lascia ulUnicodeRange2 = 0;
  lascia ulUnicodeRange3 = 0;
  lascia ulUnicodeRange4 = 0;
  lascia firstCharIndex = null;
  lascia ultimoIndiceCarattere = 0;
  lascia posizione = -1;
  se (stringhe di caratteri) {
    per (lascia il codice nelle stringhe di caratteri) {
      codice |= 0;
      se (firstCharIndex > codice || !firstCharIndex) {
        firstCharIndex = codice;
      }
      se (lastCharIndex < codice) {
        lastCharIndex = codice;
      }
      posizione = (0, _unicode.getUnicodeRangeFor)(codice, posizione);
      se (posizione < 32) {
        ulUnicodeRange1 |= 1 << posizione;
      } altrimenti se (posizione < 64) {
        ulUnicodeRange2 |= 1 << posizione - 32;
      } altrimenti se (posizione < 96) {
        ulUnicodeRange3 |= 1 << posizione - 64;
      } altrimenti se (posizione < 123) {
        ulUnicodeRange4 |= 1 << posizione - 96;
      } altro {
        throw new _util.FormatError("Gli intervalli Unicode Bit > 123 sono riservati per uso interno");
      }
    }
    se (ultimoIndiceCarattere > 0xffff) {
      ultimoIndiceCarattere = 0xffff;
    }
  } altro {
    primoCarattereIndice = 0;
    ultimoIndiceCarattere = 255;
  }
  const bbox = proprietà.bbox || [0, 0, 0, 0];
  const unitsPerEm = override.unitsPerEm || 1 / (properties.fontMatrix || _util.FONT_IDENTITY_MATRIX)[0];
  const scale = properties.ascentScaled ? 1.0 : unitsPerEm / PDF_GLYPH_SPACE_UNITS;
  const typoAscent = override.ascent || Math.round(scale * (properties.ascent || bbox[3]));
  lascia typoDescent = override.descent || Math.round(scale * (properties.descent || bbox[1]));
  se (typoDescent > 0 && properties.descent > 0 && bbox[1] < 0) {
    typoDescent = -typoDescent;
  }
  const winAscent = override.yMax || typoAscent;
  const winDescent = -override.yMin || -typoDescent;
  restituisci "\x00\x03" + "\x02\x24" + "\x01\xF4" + "\x00\x05" + "\x00\x00" + "\x02\x8A" + "\x02\xBB" + "\x00\x00" + "\x00\x8C" + "\x02\x8A" + "\x02\xBB" + "\x00\x00" + "\x01\xDF" + "\x00\x31" + "\x01\x02" + "\x00\x00" + "\x00\x00\x06" + String.fromCharCode(properties.fixedPitch ? 0x09 : 0x00) + "\x00\x00\x00\x00\x00\x00" + (0, _util.string32)(ulUnicodeRange1) + (0, _util.string32)(ulUnicodeRange2) + (0, _util.string32)(ulUnicodeRange3) + (0, _util.string32)(ulUnicodeRange4) + "\x2A\x32\x31\x2A" + string16(properties.italicAngle ? 1 : 0) + string16(firstCharIndex || properties.firstChar) + string16(lastCharIndex || properties.lastChar) + string16(typoAscent) + string16(typoDescent) + "\x00\x64" + string16(winAscent) + string16(winDescent) + "\x00\x00\x00\x00" + "\x00\x00\x00\x00" + string16(properties.xHeight) + string16(properties.capHeight) + string16(0) + string16(firstCharIndex || properties.firstChar) + "\x00\x03";
}
funzione createPostTable(proprietà) {
  angolo costante = Math.floor(properties.italicAngle * 2 ** 16);
  restituisci "\x00\x03\x00\x00" + (0, _util.string32)(angolo) + "\x00\x00" + "\x00\x00" + (0, _util.string32)(properties.fixedPitch ? 1 : 0) + "\x00\x00\x00\x00" + "\x00\x00\x00\x00" + "\x00\x00\x00\x00" + "\x00\x00\x00\x00";
}
funzione createPostscriptName(nome) {
  restituisci nome.replaceAll(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
}
funzione createNameTable(nome, proto) {
  se (!proto) {
    prototipo = [[], []];
  }
  stringhe costanti = [proto[0][0] || "Licenza originale", proto[0][1] || nome, proto[0][2] || "Sconosciuto", proto[0][3] || "ID univoco", proto[0][4] || nome, proto[0][5] || "Versione 0.11", proto[0][6] || createPostscriptName(nome), proto[0][7] || "Sconosciuto", proto[0][8] || "Sconosciuto", proto[0][9] || "Sconosciuto"];
  stringhe costantiUnicode = [];
  siano i, ii, j, jj, str;
  per (i = 0, ii = stringhe.lunghezza; i < ii; i++) {
    str = proto[1][i] || stringhe[i];
    const strBufUnicode = [];
    per (j = 0, jj = lunghezza str; j < jj; j++) {
      strBufUnicode.push(string16(str.charCodeAt(j)));
    }
    stringheUnicode.push(strBufUnicode.join(""));
  }
  const names = [stringhe, stringheUnicode];
  piattaforme costanti = ["\x00\x01", "\x00\x03"];
  codifiche costanti = ["\x00\x00", "\x00\x01"];
  const lingue = ["\x00\x00", "\x04\x09"];
  const namesRecordCount = stringhe.lunghezza * piattaforme.lunghezza;
  lascia nameTable = "\x00\x00" + string16(namesRecordCount) + string16(namesRecordCount * 12 + 6);
  lascia strOffset = 0;
  per (i = 0, ii = piattaforme.lunghezza; i < ii; i++) {
    const strs = nomi[i];
    per (j = 0, jj = lunghezza str; j < jj; j++) {
      str = strs[j];
      const nameRecord = platforms[i] + encodings[i] + languages[i] + string16(j) + string16(str.length) + string16(strOffset);
      nameTable += nameRecord;
      strOffset += lunghezza str;
    }
  }
  nameTable += stringhe.join("") + stringheUnicode.join("");
  restituisci nomeTabella;
}
classe Font {
  costruttore(nome, file, proprietà) {
    questo.nome = nome;
    this.psName = null;
    questo.mimetype = null;
    this.disableFontFace = false;
    questo.nomecaricato = proprietà.nomecaricato;
    this.isType3Font = proprietà.isType3Font;
    this.missingFile = false;
    this.cssFontInfo = proprietà.cssFontInfo;
    this._charsCache = Object.create(null);
    this._glyphCache = Object.create(null);
    lascia che isSerifFont = !!(properties.flags & _fonts_utils.FontFlags.Serif);
    se (!isSerifFont && !properties.isSimulatedFlags) {
      const baseName = name.replaceAll(/[,_]/g, "-").split("-")[0],
        serifFonts = (0, _standard_fonts.getSerifFonts)();
      per (const namePart di baseName.split("+")) {
        se (serifFonts[namePart]) {
          isSerifFont = true;
          rottura;
        }
      }
    }
    this.isSerifFont = isSerifFont;
    this.isSymbolicFont = !!(properties.flags & _fonts_utils.FontFlags.Symbolic);
    this.isMonospace = !!(properties.flags & _fonts_utils.FontFlags.FixedPitch);
    permettere {
      tipo,
      sottotipo
    } = proprietà;
    questo.tipo = tipo;
    this.subtype = sottotipo;
    this.systemFontInfo = proprietà.systemFontInfo;
    const corrispondenze = nome.match(/^InvalidPDFjsFont_(.*)_\d+$/);
    this.isInvalidPDFjsFont = !!matches;
    se (questo.isInvalidPDFjsFont) {
      this.fallbackName = corrispondenze[1];
    } altrimenti se (this.isMonospace) {
      this.fallbackName = "monospace";
    } altrimenti se (this.isSerifFont) {
      this.fallbackName = "serif";
    } altro {
      this.fallbackName = "sans-serif";
    }
    se (this.systemFontInfo?.guessFallback) {
      this.systemFontInfo.guessFallback = false;
      this.systemFontInfo.css += `,${this.fallbackName}`;
    }
    questo.differenze = proprietà.differenze;
    questo.larghezze = proprietà.larghezze;
    this.defaultWidth = proprietà.defaultWidth;
    questo.composito = proprietà.composito;
    this.cMap = properties.cMap;
    this.capHeight = properties.capHeight / PDF_GLYPH_SPACE_UNITS;
    this.ascent = properties.ascent / PDF_GLYPH_SPACE_UNITS;
    this.descent = properties.descent / PDF_GLYPH_SPACE_UNITS;
    this.lineHeight = this.ascent - this.descent;
    this.fontMatrix = properties.fontMatrix;
    questo.bbox = proprietà.bbox;
    this.defaultEncoding = properties.defaultEncoding;
    this.toUnicode = properties.toUnicode;
    questo.toFontChar = [];
    se (proprietà.tipo === "Tipo3") {
      per (lascia che charCode = 0; charCode < 256; charCode++) {
        this.toFontChar[charCode] = this.differences[charCode] || properties.defaultEncoding[charCode];
      }
      ritorno;
    }
    this.cidEncoding = properties.cidEncoding || "";
    questo.verticale = !!proprietà.verticale;
    se (questo.verticale) {
      questo.vmetrics = proprietà.vmetrics;
      this.defaultVMetrics = proprietà.defaultVMetrics;
    }
    se (!file || file.èVuoto) {
      se (file) {
        (0, _util.warn)('Il file del font è vuoto in "' + name + '" (' + this.loadedName + ")");
      }
      this.fallbackToSystemFont(proprietà);
      ritorno;
    }
    [tipo, sottotipo] = getFontFileType(file, proprietà);
    se (tipo !== questo.tipo || sottotipo !== questo.sottotipo) {
      (0, _util.info)("Tipo/sottotipo del file di font incoerente, previsto: " + `${this.type}/${this.subtype} ma trovato: ${type}/${subtype}.`);
    }
    lascia i dati;
    Tentativo {
      interruttore (tipo) {
        caso "MMType1":
          (0, _util.info)("Font MMType1 (" + nome + "), tornando a Type1.");
        caso "Tipo1":
        caso "CIDFontType0":
          this.mimetype = "font/opentype";
          const cff = sottotipo === "Tipo1C" || sottotipo === "CIDFontType0C" ? new _cff_font.CFFFont(file, proprietà) : new _type1_font.Type1Font(nome, file, proprietà);
          adjustWidths(proprietà);
          dati = this.convert(nome, cff, proprietà);
          rottura;
        caso "OpenType":
        caso "TrueType":
        caso "CIDFontType2":
          this.mimetype = "font/opentype";
          dati = this.checkAndRepair(nome, file, proprietà);
          se (questo.èOpenType) {
            adjustWidths(proprietà);
            tipo = "OpenType";
          }
          rottura;
        predefinito:
          throw new _util.FormatError(`Il carattere ${type} non è supportato`);
      }
    } cattura (e) {
      (0, _util.warn)(e);
      this.fallbackToSystemFont(proprietà);
      ritorno;
    }
    amendFallbackToUnicode(proprietà);
    questo.dati = dati;
    questo.tipo = tipo;
    this.subtype = sottotipo;
    this.fontMatrix = properties.fontMatrix;
    questo.larghezze = proprietà.larghezze;
    this.defaultWidth = proprietà.defaultWidth;
    this.toUnicode = properties.toUnicode;
    this.seacMap = proprietà.seacMap;
  }
  ottieni renderer() {
    const renderer = _font_renderer.FontRendererFactory.create(this, _fonts_utils.SEAC_ANALYSIS_ENABLED);
    return (0, _util.shadow)(this, "renderer", renderer);
  }
  exportData(extraProperties = false) {
    const exportDataProperties = extraProperties ? [...EXPORT_DATA_PROPERTIES, ...EXPORT_DATA_EXTRA_PROPERTIES] : EXPORT_DATA_PROPERTIES;
    dati costanti = Object.create(null);
    lasciare proprietà, valore;
    per (proprietà di exportDataProperties) {
      valore = questo[proprietà];
      se (valore !== indefinito) {
        dati[proprietà] = valore;
      }
    }
    restituire i dati;
  }
  fallbackToSystemFont(proprietà) {
    this.missingFile = true;
    costante {
      nome,
      tipo
    } = questo;
    lascia fontName = (0, _fonts_utils.normalizeFontName)(nome);
    const stdFontMap = (0, _standard_fonts.getStdFontMap)(),
      nonStdFontMap = (0, _standard_fonts.getNonStdFontMap)();
    const isStandardFont = !!stdFontMap[fontName];
    const isMappedToStandardFont = !!(nonStdFontMap[fontName] && stdFontMap[nonStdFontMap[fontName]]);
    fontName = stdFontMap[fontName] || nonStdFontMap[fontName] || fontName;
    const fontBasicMetricsMap = (0, _metrics.getFontBasicMetrics)();
    const metrics = fontBasicMetricsMap[nomecarattere];
    se (metriche) {
      se (isNaN(this.ascent)) {
        this.ascent = metrics.ascent / PDF_GLYPH_SPACE_UNITS;
      }
      se (isNaN(this.descent)) {
        this.descent = metrics.descent / PDF_GLYPH_SPACE_UNITS;
      }
      se (isNaN(this.capHeight)) {
        this.capHeight = metrics.capHeight / PDF_GLYPH_SPACE_UNITS;
      }
    }
    this.bold = /bold/gi.test(fontName);
    this.italic = /oblique|italic/gi.test(fontName);
    this.black = /Black/g.test(nome);
    const isNarrow = /Narrow/g.test(nome);
    this.remeasure = (!isStandardFont || isNarrow) && Object.keys(this.widths).length > 0;
    se ((isStandardFont || isMappedToStandardFont) && tipo === "CIDFontType2" && this.cidEncoding.startsWith("Identity-")) {
      const cidToGidMap = proprietà.cidToGidMap;
      mappa costante = [];
      applyStandardFontGlyphMap(map, (0, _standard_fonts.getGlyphMapForStandardFonts)());
      se (/Arial-?Black/i.test(nome)) {
        applyStandardFontGlyphMap(map, (0, _standard_fonts.getSupplementalGlyphMapForArialBlack)());
      } altrimenti se (/Calibri/i.test(nome)) {
        applyStandardFontGlyphMap(map, (0, _standard_fonts.getSupplementalGlyphMapForCalibri)());
      }
      se (cidToGidMap) {
        per (codicecarattere costante nella mappa) {
          const cid = map[charCode];
          se (cidToGidMap[cid] !== indefinito) {
            mappa[+charCode] = cidToGidMap[cid];
          }
        }
        if (cidToGidMap.length !== this.toUnicode.length && properties.hasIncludedToUnicodeMap && this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap) {
          this.toUnicode.forEach(function (charCode, unicodeCharCode) {
            const cid = map[charCode];
            se (cidToGidMap[cid] === non definito) {
              map[+charCode] = unicodeCharCode;
            }
          });
        }
      }
      se (!(this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap)) {
        this.toUnicode.forEach(function (charCode, unicodeCharCode) {
          map[+charCode] = unicodeCharCode;
        });
      }
      this.toFontChar = mappa;
      this.toUnicode = new _to_unicode_map.ToUnicodeMap(map);
    } altrimenti se (/Symbol/i.test(fontName)) {
      this.toFontChar = buildToFontChar(_encodings.SymbolSetEncoding, (0, _glyphlist.getGlyphsUnicode)(), this.differences);
    } altrimenti se (/Dingbats/i.test(fontName)) {
      this.toFontChar = buildToFontChar(_encodings.ZapfDingbatsEncoding, (0, _glyphlist.getDingbatsGlyphsUnicode)(), this.differences);
    } altrimenti se (èStandardFont) {
      const map = buildToFontChar(this.defaultEncoding, (0, _glyphlist.getGlyphsUnicode)(), this.differences);
      se (tipo === "CIDFontType2" && !this.cidEncoding.startsWith("Identity-") && !(this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap)) {
        this.toUnicode.forEach(function (charCode, unicodeCharCode) {
          map[+charCode] = unicodeCharCode;
        });
      }
      this.toFontChar = mappa;
    } altro {
      const glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
      mappa costante = [];
      this.toUnicode.forEach((charCode, unicodeCharCode) => {
        se (!questo.composito) {
          const glyphName = this.differences[charCode] || this.defaultEncoding[charCode];
          const unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap);
          se (unicode !== -1) {
            unicodeCharCode = unicode;
          }
        }
        map[+charCode] = unicodeCharCode;
      });
      se (this.composite && this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap) {
        se (/Tahoma|Verdana/i.test(nome)) {
          applyStandardFontGlyphMap(map, (0, _standard_fonts.getGlyphMapForStandardFonts)());
        }
      }
      this.toFontChar = mappa;
    }
    amendFallbackToUnicode(proprietà);
    this.loadedName = fontName.split("-")[0];
  }
  checkAndRepair(nome, carattere, proprietà) {
    const VALID_TABLES = ["OS/2", "cmap", "head", "hhea", "hmtx", "maxp", "name", "post", "loca", "glyf", "fpgm", "prep", "cvt ", "CFF "];
    funzione readTables(file, numTables) {
      tabelle costanti = Object.create(null);
      tabelle["OS/2"] = null;
      tabelle.cmap = null;
      tabelle.testa = null;
      tabelle.hhea = null;
      tabelle.hmtx = null;
      tabelle.maxp = null;
      tabelle.nome = null;
      tabelle.post = null;
      per (lascia che i = 0; i < numTables; i++) {
        const table = readTableEntry(file);
        se (!VALID_TABLES.includes(table.tag)) {
          continuare;
        }
        se (lunghezza della tabella === 0) {
          continuare;
        }
        tabelle[tabella.tag] = tabella;
      }
      tabelle di ritorno;
    }
    funzione readTableEntry(file) {
      const tag = file.getString(4);
      checksum costante = file.getInt32() >>> 0;
      const offset = file.getInt32() >>> 0;
      lunghezza costante = file.getInt32() >>> 0;
      const previousPosition = file.pos;
      file.pos = file.start || 0;
      file.skip(offset);
      const data = file.getBytes(lunghezza);
      file.pos = posizioneprecedente;
      se (tag === "testa") {
        dati[8] = dati[9] = dati[10] = dati[11] = 0;
        dati[17] |= 0x20;
      }
      ritorno {
        etichetta,
        somma di controllo,
        lunghezza,
        offset,
        dati
      };
    }
    funzione readOpenTypeHeader(ttf) {
      ritorno {
        versione: ttf.getString(4),
        numTables: ttf.getUint16(),
        intervallo di ricerca: ttf.getUint16(),
        Selettore di voce: ttf.getUint16(),
        rangeShift: ttf.getUint16()
      };
    }
    funzione readTrueTypeCollectionHeader(ttc) {
      const ttcTag = ttc.getString(4);
      (0, _util.assert)(ttcTag === "ttcf", "Deve essere un font della raccolta TrueType.");
      const majorVersion = ttc.getUint16();
      const minorVersion = ttc.getUint16();
      const numFonts = ttc.getInt32() >>> 0;
      const offsetTable = [];
      per (lascia che i = 0; i < numFonts; i++) {
        offsetTable.push(ttc.getInt32() >>> 0);
      }
      intestazione costante = {
        ttcTag,
        versione principale,
        versione minore,
        numFonts,
        offsetTable
      };
      switch (majorVersion) {
        caso 1:
          intestazione di ritorno;
        caso 2:
          header.dsigTag = ttc.getInt32() >>> 0;
          header.dsigLength = ttc.getInt32() >>> 0;
          header.dsigOffset = ttc.getInt32() >>> 0;
          intestazione di ritorno;
      }
      throw new _util.FormatError(`Raccolta TrueType non valida majorVersion: ${majorVersion}.`);
    }
    funzione readTrueTypeCollectionData(ttc, fontName) {
      costante {
        numFonts,
        offsetTable
      } = readTrueTypeCollectionHeader(ttc);
      const fontNameParts = fontName.split("+");
      lascia fallbackData;
      per (lascia che i = 0; i < numFonts; i++) {
        ttc.pos = (ttc.start || 0) + offsetTable[i];
        const potentialHeader = readOpenTypeHeader(ttc);
        const potentialTables = readTables(ttc, potentialHeader.numTables);
        se (!potentialTables.name) {
          throw new _util.FormatError('Il font della raccolta TrueType deve contenere una tabella "name".');
        }
        const [nameTable] = readNameTable(potentialTables.name);
        per (lascia che j = 0, jj = nameTable.length; j < jj; j++) {
          per (lascia che k = 0, kk = nameTable[j].length; k < kk; k++) {
            const nameEntry = nameTable[j][k]?.replaceAll(/\s/g, "");
            se (!nomeEntry) {
              continuare;
            }
            se (nomeEntry === fontName) {
              ritorno {
                intestazione: potentialHeader,
                tabelle: potentialTables
              };
            }
            se (fontNameParts.length < 2) {
              continuare;
            }
            per (parte costante di fontNameParts) {
              se (nomeEntry === parte) {
                fallbackData = {
                  nome: parte,
                  intestazione: potentialHeader,
                  tabelle: potentialTables
                };
              }
            }
          }
        }
      }
      se (fallbackData) {
        (0, _util.warn)(`La raccolta TrueType non contiene il font "${fontName}", ` + `verrà utilizzato il font "${fallbackData.name}".`);
        ritorno {
          intestazione: fallbackData.header,
          tabelle: fallbackData.tables
        };
      }
      throw new _util.FormatError(`La raccolta TrueType non contiene il font "${fontName}".`);
    }
    funzione readCmapTable(cmap, file, isSymbolicFont, hasEncoding) {
      se (!cmap) {
        (0, _util.warn)("Nessuna tabella cmap disponibile.");
        ritorno {
          ID piattaforma: -1,
          encodingId: -1,
          mappature: [],
          hasShortCmap: falso
        };
      }
      lascia segmento;
      lascia inizio = (file.start || 0) + cmap.offset;
      file.pos = inizio;
      file.salta(2);
      const numTables = file.getUint16();
      lascia che potentialTable;
      lascia che canBreak = false;
      per (lascia che i = 0; i < numTables; i++) {
        const platformId = file.getUint16();
        const encodingId = file.getUint16();
        const offset = file.getInt32() >>> 0;
        lascia che useTable = false;
        se (potentialTable?.platformId === platformId && potentialTable?.encodingId === encodingId) {
          continuare;
        }
        se (platformId === 0 e (encodingId === 0 || encodingId === 1 || encodingId === 3)) {
          useTable = true;
        } altrimenti se (platformId === 1 e encodingId === 0) {
          useTable = true;
        } altrimenti se (platformId === 3 && encodingId === 1 && (hasEncoding || !potentialTable)) {
          useTable = true;
          se (!isSymbolicFont) {
            puòBreak = vero;
          }
        } altrimenti se (isSymbolicFont && platformId === 3 && encodingId === 0) {
          useTable = true;
          lascia che sia correttamente ordinato = vero;
          se (i < numTables - 1) {
            const nextBytes = file.peekBytes(2),
              nextPlatformId = int16(nextBytes[0], nextBytes[1]);
            se (nextPlatformId < platformId) {
              correttamenteordinato = falso;
            }
          }
          se (ordinato correttamente) {
            puòBreak = vero;
          }
        }
        se (usaTabella) {
          Tabellapotenziale = {
            ID piattaforma,
            encodingId,
            offset
          };
        }
        se (puòrompersi) {
          rottura;
        }
      }
      se (potentialTable) {
        file.pos = start + potentialTable.offset;
      }
      se (!potentialTable || file.peekByte() === -1) {
        (0, _util.warn)("Impossibile trovare una tabella cmap preferita.");
        ritorno {
          ID piattaforma: -1,
          encodingId: -1,
          mappature: [],
          hasShortCmap: falso
        };
      }
      formato costante = file.getUint16();
      lascia che hasShortCmap = false;
      mappature costanti = [];
      lascia j, glyphId;
      se (formato === 0) {
        file.skip(2 + 2);
        per (j = 0; j < 256; j++) {
          indice costante = file.getByte();
          se (!indice) {
            continuare;
          }
          mappature.push({
            codice carattere: j,
            glyphId: indice
          });
        }
        hasShortCmap = true;
      } altrimenti se (formato === 2) {
        file.skip(2 + 2);
        const subHeaderKeys = [];
        lascia maxSubHeaderKey = 0;
        per (lascia che i = 0; i < 256; i++) {
          const subHeaderKey = file.getUint16() >> 3;
          subHeaderKeys.push(subHeaderKey);
          maxSubHeaderKey = Math.max(subHeaderKey, maxSubHeaderKey);
        }
        const sottointestazioni = [];
        per (lascia che i = 0; i <= maxSubHeaderKey; i++) {
          sottointestazioni.push({
            primoCodice: file.getUint16(),
            entryCount: file.getUint16(),
            idDelta: signedInt16(file.getByte(), file.getByte()),
            idRangePos: file.pos + file.getUint16()
          });
        }
        per (lascia che i = 0; i < 256; i++) {
          se (subHeaderKeys[i] === 0) {
            file.pos = subHeaders[0].idRangePos + 2 * i;
            glyphId = file.getUint16();
            mappature.push({
              charCode: i,
              glyphId
            });
          } altro {
            const s = subHeaders[subHeaderKeys[i]];
            for (j = 0; j < s.entryCount; j++) {
              const charCode = (i << 8) + j + s.firstCode;
              file.pos = s.idRangePos + 2 * j;
              glyphId = file.getUint16();
              se (glyphId !== 0) {
                glyphId = (glyphId + s.idDelta) % 65536;
              }
              mappature.push({
                charCode,
                glyphId
              });
            }
          }
        }
      } altrimenti se (formato === 4) {
        file.skip(2 + 2);
        const segCount = file.getUint16() >> 1;
        file.salta(6);
        segmenti costanti = [];
        lascia segIndex;
        per (segIndex = 0; segIndex < segCount; segIndex++) {
          segmenti.push({
            fine: file.getUint16()
          });
        }
        file.salta(2);
        per (segIndex = 0; segIndex < segCount; segIndex++) {
          segmenti[segIndex].start = file.getUint16();
        }
        per (segIndex = 0; segIndex < segCount; segIndex++) {
          segmenti[segIndex].delta = file.getUint16();
        }
        lascia offsetsCount = 0,
          offsetIndice;
        per (segIndex = 0; segIndex < segCount; segIndex++) {
          segmento = segmenti[indiceseg];
          const rangeOffset = file.getUint16();
          se (!rangeOffset) {
            segmento.offsetIndex = -1;
            continuare;
          }
          offsetIndex = (rangeOffset >> 1) - (segCount - segIndex);
          segmento.offsetIndex = offsetIndex;
          offsetsCount = Math.max(offsetsCount, offsetIndex + segmento.end - segmento.start + 1);
        }
        offset costanti = [];
        per (j = 0; j < offsetsCount; j++) {
          offset.push(file.getUint16());
        }
        per (segIndex = 0; segIndex < segCount; segIndex++) {
          segmento = segmenti[indiceseg];
          inizio = segmento.inizio;
          const end = segmento.end;
          const delta = segmento.delta;
          offsetIndex = segmento.offsetIndex;
          per (j = inizio; j <= fine; j++) {
            se (j === 0xffff) {
              continuare;
            }
            glyphId = offsetIndex < 0 ? j : offsets[offsetIndex + j - inizio];
            glyphId = glyphId + delta & 0xffff;
            mappature.push({
              codice carattere: j,
              glyphId
            });
          }
        }
      } altrimenti se (formato === 6) {
        file.skip(2 + 2);
        const firstCode = file.getUint16();
        const entryCount = file.getUint16();
        for (j = 0; j < entryCount; j++) {
          glyphId = file.getUint16();
          const charCode = firstCode + j;
          mappature.push({
            charCode,
            glyphId
          });
        }
      } altrimenti se (formato === 12) {
        file.skip(2 + 4 + 4);
        const nGroups = file.getInt32() >>> 0;
        per (j = 0; j < nGruppi; j++) {
          const startCharCode = file.getInt32() >>> 0;
          const endCharCode = file.getInt32() >>> 0;
          lascia glyphCode = file.getInt32() >>> 0;
          per (let charCode = startCharCode; charCode <= endCharCode; charCode++) {
            mappature.push({
              charCode,
              glyphId: glyphCode++
            });
          }
        }
      } altro {
        (0, _util.warn)("La tabella cmap ha un formato non supportato: " + format);
        ritorno {
          ID piattaforma: -1,
          encodingId: -1,
          mappature: [],
          hasShortCmap: falso
        };
      }
      mapping.sort(funzione (a, b) {
        restituisci a.charCode - b.charCode;
      });
      per (lascia che i = 1; i < mappings.length; i++) {
        se (mappings[i - 1].charCode === mappings[i].charCode) {
          mappature.splice(i, 1);
          io--;
        }
      }
      ritorno {
        platformId: potentialTable.platformId,
        encodingId: potentialTable.encodingId,
        mappature,
        haShortCmap
      };
    }
    funzione sanitizeMetrics(file, intestazione, metriche, headTable, numGlyphs, dupFirstEntry) {
      se (!intestazione) {
        se (metriche) {
          metriche.dati = null;
        }
        ritorno;
      }
      file.pos = (file.start || 0) + header.offset;
      file.pos += 4;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      const caretOffset = file.getUint16();
      file.pos += 8;
      file.pos += 2;
      lascia numOfMetrics = file.getUint16();
      se (caretOffset !== 0) {
        const macStyle = int16(headTable.data[44], headTable.data[45]);
        se (!(macStyle & 2)) {
          intestazione.data[22] = 0;
          intestazione.data[23] = 0;
        }
      }
      se (numMetriche > numGlifi) {
        (0, _util.info)(`Il numOfMetrics (${numOfMetrics}) non dovrebbe essere ` + `maggiore del numGlyphs (${numGlyphs}).`);
        numOfMetrics = numGlyphs;
        header.data[34] = (numOfMetrics & 0xff00) >> 8;
        header.data[35] = numOfMetrics & 0x00ff;
      }
      const numOfSidebearings = numGlyphs - numOfMetrics;
      const numMissing = numOfSidebearings - (metrics.length - numOfMetrics * 4 >> 1);
      se (numMancante > 0) {
        voci costanti = nuovo Uint8Array(metrics.length + numMissing * 2);
        voci.set(metriche.dati);
        se (dupFirstEntry) {
          voci[lunghezza metriche] = dati metriche[2];
          voci[metriche.lunghezza + 1] = metriche.dati[3];
        }
        metrics.data = voci;
      }
    }
    funzione sanitizeGlyph(sorgente, inizio sorgente, fine sorgente, destinazione, inizio destinazione, suggerimenti validi) {
      const glyphProfile = {
        lunghezza: 0,
        sizeOfInstructions: 0
      };
      se (sourceStart < 0 || sourceStart >= lunghezza sorgente || fine sorgente > lunghezza sorgente || fine sorgente - sourceStart <= 12) {
        restituisci glyphProfile;
      }
      const glyf = source.subarray(sourceStart, sourceEnd);
      const xMin = signedInt16(glyf[2], glyf[3]);
      const yMin =signedInt16(glyf[4], glyf[5]);
      const xMax = signedInt16(glyf[6], glyf[7]);
      const yMax = signedInt16(glyf[8], glyf[9]);
      se (xMin > xMax) {
        writeSignedInt16(glyf, 2, xMax);
        writeSignedInt16(glyf, 6, xMin);
      }
      se (yMin > yMax) {
        writeSignedInt16(glyf, 4, yMax);
        writeSignedInt16(glyf, 8, yMin);
      }
      const contoursCount = signedInt16(glyf[0], glyf[1]);
      se (contorniConteggio < 0) {
        se (contorniConteggio < -1) {
          restituisci glyphProfile;
        }
        dest.set(glyf, destStart);
        glyphProfile.length = glifo.lunghezza;
        restituisci glyphProfile;
      }
      lasciami,
        j = 10,
        flagsCount = 0;
      per (i = 0; i < contoursCount; i++) {
        const endPoint = glyf[j] << 8 | glyf[j + 1];
        flagsCount = endPoint + 1;
        j += 2;
      }
      istruzioni costantiInizio = j;
      istruzioni costantiLunghezza = glyf[j] << 8 | glyf[j + 1];
      glyphProfile.sizeOfInstructions = lunghezzaistruzioni;
      j += 2 + lunghezza istruzioni;
      istruzioni costantiEnd = j;
      lascia coordinateLunghezza = 0;
      per (i = 0; i < flagsCount; i++) {
        const flag = glyf[j++];
        se (flag & 0xc0) {
          glyf[j - 1] = flag & 0x3f;
        }
        lascia xLunghezza = 2;
        se (flag & 2) {
          xLunghezza = 1;
        } altrimenti se (flag & 16) {
          xLunghezza = 0;
        }
        lascia che yLength = 2;
        se (flag & 4) {
          yLunghezza = 1;
        } altrimenti se (flag & 32) {
          Lunghezzay = 0;
        }
        const xyLength = xLength + yLength;
        coordinateLunghezza += xyLunghezza;
        se (flag & 8) {
          const repeat = glyf[j++];
          se (ripeti === 0) {
            glifo[j - 1] ^= 8;
          }
          i += ripeti;
          coordinateLunghezza += ripeti * xyLunghezza;
        }
      }
      se (coordinateLunghezza === 0) {
        restituisci glyphProfile;
      }
      lascia glyphDataLength = j + coordinatesLength;
      se (glyphDataLength > glyf.length) {
        restituisci glyphProfile;
      }
      se (!suggerimentiValido && lunghezzaistruzioni > 0) {
        dest.set(glyf.subarray(0, istruzioniStart), destStart);
        dest.set([0, 0], destStart + instructionsStart);
        dest.set(glyf.subarray(instructionsEnd, glyphDataLength), destStart + instructionsStart + 2);
        glyphDataLength -= instructionsLength;
        se (glifo.lunghezza - glifoDataLength > 3) {
          glyphDataLength = glyphDataLength + 3 & ~3;
        }
        glyphProfile.length = glyphDataLength;
        restituisci glyphProfile;
      }
      se (glifo.lunghezza - glifoDataLength > 3) {
        glyphDataLength = glyphDataLength + 3 & ~3;
        dest.set(glyf.subarray(0, glyphDataLength), destStart);
        glyphProfile.length = glyphDataLength;
        restituisci glyphProfile;
      }
      dest.set(glyf, destStart);
      glyphProfile.length = glifo.lunghezza;
      restituisci glyphProfile;
    }
    funzione sanitizeHead(testa, numGlifi, lunghezzalocale) {
      const data = head.data;
      versione costante = int32(dati[0], dati[1], dati[2], dati[3]);
      se (versione >> 16 !== 1) {
        (0, _util.info)("Tentativo di correggere la versione non valida nella tabella principale: " + versione);
        dati[0] = 0;
        dati[1] = 1;
        dati[2] = 0;
        dati[3] = 0;
      }
      const indiceToLocFormat = int16(dati[50], dati[51]);
      se (indexToLocFormat < 0 || indexToLocFormat > 1) {
        (0, _util.info)("Tentativo di correggere indexToLocFormat non valido nella tabella principale: " + indexToLocFormat);
        const numGlyphsPlusOne = numGlyphs + 1;
        se (locaLength === numGlyphsPlusOne << 1) {
          dati[50] = 0;
          dati[51] = 0;
        } altrimenti se (locaLength === numGlyphsPlusOne << 2) {
          dati[50] = 0;
          dati[51] = 1;
        } altro {
          throw new _util.FormatError("Impossibile correggere indexToLocFormat: " + indexToLocFormat);
        }
      }
    }
    funzione sanitizeGlyphLocations(loca, glyf, numGlyphs, isGlyphLocationsLong, hintsValid, dupFirstEntry, maxSizeOfInstructions) {
      lascia itemSize, itemDecode, itemEncode;
      se (isGlyphLocationsLong) {
        dimensioneelemento = 4;
        itemDecode = funzione fontItemDecodeLong(dati, offset) {
          restituisci dati[offset] << 24 | dati[offset + 1] << 16 | dati[offset + 2] << 8 | dati[offset + 3];
        };
        itemEncode = funzione fontItemEncodeLong(dati, offset, valore) {
          dati[offset] = valore >>> 24 & 0xff;
          dati[offset + 1] = valore >> 16 & 0xff;
          dati[offset + 2] = valore >> 8 & 0xff;
          dati[offset + 3] = valore & 0xff;
        };
      } altro {
        dimensioneelemento = 2;
        itemDecode = funzione fontItemDecode(dati, offset) {
          restituisci dati[offset] << 9 | dati[offset + 1] << 1;
        };
        itemEncode = funzione fontItemEncode(dati, offset, valore) {
          dati[offset] = valore >> 9 & 0xff;
          dati[offset + 1] = valore >> 1 & 0xff;
        };
      }
      const numGlyphsOut = dupFirstEntry ? numGlyphs + 1 : numGlyphs;
      const locaDataSize = itemSize * (1 + numGlyphsOut);
      const locaData = new Uint8Array(locaDataSize);
      locaData.set(loca.data.subarray(0, locaDataSize));
      loca.data = locaData;
      const oldGlyfData = glyf.data;
      const oldGlyfDataLength = oldGlyfData.length;
      const newGlyfData = new Uint8Array(oldGlyfDataLength);
      siano i, j;
      const locaEntries = [];
      per (i = 0, j = 0; i < numGlifi + 1; i++, j += dimensioneelemento) {
        lascia offset = itemDecode(locaData, j);
        se (offset > oldGlyfDataLength) {
          offset = oldGlyfDataLength;
        }
        locaEntries.push({
          indice: i,
          offset,
          offset finale: 0
        });
      }
      locaEntries.sort((a, b) => {
        restituisci a.offset - b.offset;
      });
      per (i = 0; i < numGlifi; i++) {
        locaEntries[i].endOffset = locaEntries[i + 1].offset;
      }
      locaEntries.sort((a, b) => {
        restituisci a.indice - b.indice;
      });
      per (i = 0; i < numGlifi; i++) {
        costante {
          offset,
          offset finale
        } = locaEntries[i];
        se (offset !== 0 || endOffset !== 0) {
          rottura;
        }
        const nextOffset = locaEntries[i + 1].offset;
        se (nextOffset === 0) {
          continuare;
        }
        locaEntries[i].endOffset = nextOffset;
        rottura;
      }
      const missingGlyphs = Object.create(null);
      lascia writeOffset = 0;
      itemEncode(locaData, 0, writeOffset);
      per (i = 0, j = dimensioneelemento; i < numGlifi; i++, j += dimensioneelemento) {
        const glyphProfile = sanitizeGlyph(oldGlyfData, locaEntries[i].offset, locaEntries[i].endOffset, newGlyfData, writeOffset, hintsValid);
        const newLength = glyphProfile.length;
        se (nuovaLunghezza === 0) {
          missingGlyphs[i] = true;
        }
        se (glyphProfile.sizeOfInstructions > maxSizeOfInstructions) {
          maxSizeOfInstructions = glyphProfile.sizeOfInstructions;
        }
        writeOffset += newLength;
        itemEncode(locaData, j, writeOffset);
      }
      se (writeOffset === 0) {
        const simpleGlyph = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);
        per (i = 0, j = itemSize; i < numGlyphsOut; i++, j += itemSize) {
          itemEncode(locaData, j, simpleGlyph.length);
        }
        glyf.data = simpleGlyph;
      } altrimenti se (dupFirstEntry) {
        const firstEntryLength = itemDecode(locaData, itemSize);
        se (newGlyfData.length > firstEntryLength + writeOffset) {
          glyf.data = newGlyfData.subarray(0, firstEntryLength + writeOffset);
        } altro {
          glyf.data = new Uint8Array(firstEntryLength + writeOffset);
          glyf.data.set(newGlyfData.subarray(0, writeOffset));
        }
        glyf.data.set(newGlyfData.subarray(0, firstEntryLength), writeOffset);
        itemEncode(loca.data, locaData.length - itemSize, writeOffset + firstEntryLength);
      } altro {
        glyf.data = newGlyfData.subarray(0, writeOffset);
      }
      ritorno {
        Glifi mancanti,
        maxSizeOfInstructions
      };
    }
    funzione readPostScriptTable(post, propertiesObj, maxpNumGlyphs) {
      const start = (font.start || 0) + post.offset;
      font.pos = inizio;
      lunghezza costante = post.length,
        fine = inizio + lunghezza;
      const versione = font.getInt32();
      font.skip(28);
      lascia glyphNames;
      lascia valido = vero;
      lascia che io;
      switch (versione) {
        caso 0x00010000:
          glyphNames = _fonts_utils.MacStandardGlyphOrdering;
          rottura;
        caso 0x00020000:
          const numGlyphs = font.getUint16();
          se (numGlifi !== maxpNumGlifi) {
            valido = falso;
            rottura;
          }
          const glyphNameIndexes = [];
          per (i = 0; i < numGlifi; ++i) {
            indice costante = font.getUint16();
            se (indice >= 32768) {
              valido = falso;
              rottura;
            }
            glyphNameIndexes.push(indice);
          }
          se (!valido) {
            rottura;
          }
          const nomipersonalizzati = [],
            strBuf = [];
          mentre (font.pos < fine) {
            const stringLength = font.getByte();
            strBuf.length = lunghezzastringa;
            per (i = 0; i < lunghezzastringa; ++i) {
              strBuf[i] = String.fromCharCode(font.getByte());
            }
            customNames.push(strBuf.join(""));
          }
          glyphNames = [];
          per (i = 0; i < numGlifi; ++i) {
            const j = glyphNameIndexes[i];
            se (j < 258) {
              glyphNames.push(_fonts_utils.MacStandardGlyphOrdering[j]);
              continuare;
            }
            glyphNames.push(customNames[j - 258]);
          }
          rottura;
        caso 0x00030000:
          rottura;
        predefinito:
          (0, _util.warn)("Versione della tabella dei post sconosciuta/non supportata" + versione);
          valido = falso;
          se (propertiesObj.defaultEncoding) {
            glyphNames = propertiesObj.defaultEncoding;
          }
          rottura;
      }
      propertiesObj.glyphNames = glyphNames;
      ritorno valido;
    }
    funzione readNameTable(nameTable) {
      const start = (font.start || 0) + nameTable.offset;
      font.pos = inizio;
      nomi costanti = [[], []],
        record = [];
      lunghezza costante = nameTable.length,
        fine = inizio + lunghezza;
      formato costante = font.getUint16();
      const FORMAT_0_HEADER_LENGTH = 6;
      se (formato !== 0 || lunghezza < FORMAT_0_HEADER_LENGTH) {
        restituire [nomi, record];
      }
      const numRecords = font.getUint16();
      const stringsStart = font.getUint16();
      const NOME_LUNGHEZZA_REGISTRAZIONE = 12;
      sia i, ii;
      per (i = 0; i < numRecords && font.pos + NAME_RECORD_LENGTH <= end; i++) {
        costante r = {
          piattaforma: font.getUint16(),
          codifica: font.getUint16(),
          linguaggio: font.getUint16(),
          nome: font.getUint16(),
          lunghezza: font.getUint16(),
          offset: font.getUint16()
        };
        se (isMacNameRecord(r) || isWinNameRecord(r)) {
          record.push(r);
        }
      }
      per (i = 0, ii = lunghezza record; i < ii; i++) {
        record costante = record[i];
        se (lunghezza record <= 0) {
          continuare;
        }
        const pos = start + stringsStart + record.offset;
        se (pos + lunghezza record > fine) {
          continuare;
        }
        font.pos = pos;
        const nameIndex = record.name;
        se (record.codifica) {
          lascia str = "";
          per (lascia che j = 0, jj = lunghezza record; j < jj; j += 2) {
            str += String.fromCharCode(font.getUint16());
          }
          nomi[1][indicenome] = str;
        } altro {
          nomi[0][indicenome] = font.getString(lunghezza record);
        }
      }
      restituire [nomi, record];
    }
    const TTOpsStackDeltas = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, -1, -1, -2, 0, 0, -1, -1, -2];
    funzione sanitizeTTProgram(tabella, ttContext) {
      lascia dati = tabella.dati;
      sia i = 0,
        J,
        N,
        B,
        ID funzione,
        pc,
        lastEndf = 0,
        ultimaDeff = 0;
      pila costante = [];
      const callstack = [];
      funzioni costanti chiamate = [];
      lascia tooComplexToFollowFunctions = ttContext.tooComplexToFollowFunctions;
      lascia inFDEF = falso,
        se Livello = 0,
        inALTRIMENTI = 0;
      per (lascia che ii = lunghezza dati; i < ii;) {
        const op = data[i++];
        se (op === 0x40) {
          n = dati[i++];
          se (inFDEF || inELSE) {
            io += n;
          } altro {
            per (j = 0; j < n; j++) {
              stack.push(dati[i++]);
            }
          }
        } altrimenti se (op === 0x41) {
          n = dati[i++];
          se (inFDEF || inELSE) {
            io += n * 2;
          } altro {
            per (j = 0; j < n; j++) {
              b = dati[i++];
              stack.push(b << 8 | dati[i++]);
            }
          }
        } altrimenti se ((op & 0xf8) === 0xb0) {
          n = op - 0xb0 + 1;
          se (inFDEF || inELSE) {
            io += n;
          } altro {
            per (j = 0; j < n; j++) {
              stack.push(dati[i++]);
            }
          }
        } altrimenti se ((op & 0xf8) === 0xb8) {
          n = op - 0xb8 + 1;
          se (inFDEF || inELSE) {
            io += n * 2;
          } altro {
            per (j = 0; j < n; j++) {
              b = dati[i++];
              stack.push(b << 8 | dati[i++]);
            }
          }
        } altrimenti se (op === 0x2b && !tooComplexToFollowFunctions) {
          se (!inFDEF && !inELSE) {
            funcId = stack.at(-1);
            se (isNaN(funcId)) {
              (0, _util.info)("TT: CHIAMA stack vuoto (o voce non valida).");
            } altro {
              ttContext.functionsUsed[funcId] = true;
              se (funcId in ttContext.functionsStackDeltas) {
                const newStackLength = lunghezza.stack + ttContext.functionsStackDeltas[funcId];
                se (newStackLength < 0) {
                  (0, _util.warn)("TT: delta dello stack delle funzioni CALL non valido.");
                  ttContext.hintsValid = false;
                  ritorno;
                }
                lunghezza pila = nuovaLunghezzaStack;
              } altrimenti se (funcId in ttContext.functionsDefined && !functionsCalled.includes(funcId)) {
                callstack.push({
                  dati,
                  io,
                  stackTop: lunghezza pila - 1
                });
                funzioniChiamate.push(funcId);
                pc = ttContext.functionsDefined[funcId];
                se (!pc) {
                  (0, _util.warn)("TT: CALL funzione inesistente");
                  ttContext.hintsValid = false;
                  ritorno;
                }
                dati = pc.dati;
                i = pc.i;
              }
            }
          }
        } altrimenti se (op === 0x2c && !tooComplexToFollowFunctions) {
          se (inFDEF || inELSE) {
            (0, _util.warn)("TT: FDEF annidati non consentiti");
            tooComplexToFollowFunctions = true;
          }
          inFDEF = vero;
          ultimaDeff = i;
          funcId = stack.pop();
          ttContext.functionsDefined[funcId] = {
            dati,
            io
          };
        } altrimenti se (op === 0x2d) {
          se (inFDEF) {
            inFDEF = falso;
            lastEndf = i;
          } altro {
            pc = callstack.pop();
            se (!pc) {
              (0, _util.warn)("TT: stack errato di ENDF");
              ttContext.hintsValid = false;
              ritorno;
            }
            funcId = functionsCalled.pop();
            dati = pc.dati;
            i = pc.i;
            ttContext.functionsStackDeltas[funcId] = lunghezza stack - pc.stackTop;
          }
        } altrimenti se (op === 0x89) {
          se (inFDEF || inELSE) {
            (0, _util.warn)("TT: IDEF annidati non consentiti");
            tooComplexToFollowFunctions = true;
          }
          inFDEF = vero;
          ultimaDeff = i;
        } altrimenti se (op === 0x58) {
          ++seLivello;
        } altrimenti se (op === 0x1b) {
          inELSE = ifLevel;
        } altrimenti se (op === 0x59) {
          se (inALTRIMENTI === seLivello) {
            inALTRIMENTI = 0;
          }
          --seLivello;
        } altrimenti se (op === 0x1c) {
          se (!inFDEF && !inELSE) {
            offset costante = stack.at(-1);
            se (offset > 0) {
              i += offset - 1;
            }
          }
        }
        se (!inFDEF && !inELSE) {
          lascia stackDelta = 0;
          se (op <= 0x8e) {
            stackDelta = TTOpsStackDeltas[op];
          } altrimenti se (op >= 0xc0 && op <= 0xdf) {
            stackDelta = -1;
          } altrimenti se (op >= 0xe0) {
            stackDelta = -2;
          }
          se (op >= 0x71 && op <= 0x75) {
            n = stack.pop();
            se (!isNaN(n)) {
              stackDelta = -n * 2;
            }
          }
          while (stackDelta < 0 && lunghezza stack > 0) {
            pila.pop();
            stackDelta++;
          }
          mentre (stackDelta > 0) {
            pila.push(NaN);
            stackDelta--;
          }
        }
      }
      ttContext.tooComplexToFollowFunctions = tooComplexToFollowFunctions;
      contenuto costante = [dati];
      se (i > lunghezza dati) {
        contenuto.push(nuovo Uint8Array(i - lunghezza dati));
      }
      se (lastDeff > lastEndf) {
        (0, _util.warn)("TT: completamento di una funzione mancante tail");
        contenuto.push(nuovo Uint8Array([0x22, 0x2d]));
      }
      foldTTTable(tabella, contenuto);
    }
    funzione checkInvalidFunctions(ttContext, maxFunctionDefs) {
      se (ttContext.tooComplexToFollowFunctions) {
        ritorno;
      }
      se (ttContext.functionsDefined.length > maxFunctionDefs) {
        (0, _util.warn)("TT: sono state definite più funzioni del previsto");
        ttContext.hintsValid = false;
        ritorno;
      }
      per (lascia che j = 0, jj = ttContext.functionsUsed.length; j < jj; j++) {
        se (j > maxFunctionDefs) {
          (0, _util.warn)("TT: ID funzione non valido: " + j);
          ttContext.hintsValid = false;
          ritorno;
        }
        se (ttContext.functionsUsed[j] && !ttContext.functionsDefined[j]) {
          (0, _util.warn)("TT: funzione non definita: " + j);
          ttContext.hintsValid = false;
          ritorno;
        }
      }
    }
    funzione foldTTTable(tabella, contenuto) {
      se (lunghezza del contenuto > 1) {
        lascia nuovaLunghezza = 0;
        sia j, jj;
        per (j = 0, jj = lunghezza del contenuto; j < jj; j++) {
          nuovaLunghezza += contenuto[j].lunghezza;
        }
        nuovaLunghezza = nuovaLunghezza + 3 & ~3;
        risultato costante = nuovo Uint8Array(nuovaLunghezza);
        lascia pos = 0;
        per (j = 0, jj = lunghezza del contenuto; j < jj; j++) {
          risultato.set(contenuto[j], pos);
          pos += contenuto[j].lunghezza;
        }
        tabella.dati = risultato;
        table.length = newLength;
      }
    }
    funzione sanitizeTTPrograms(fpgm, prep, cvt, maxFunctionDefs) {
      const ttContext = {
        funzioniDefinite: [],
        funzioniUtilizzate: [],
        funzioniStackDeltas: [],
        tooComplexToFollowFunctions: falso,
        suggerimentiValido: vero
      };
      se (fpgm) {
        sanitizeTTProgram(fpgm, ttContext);
      }
      se (preparazione) {
        sanitizeTTProgram(prep, ttContext);
      }
      se (fpgm) {
        checkInvalidFunctions(ttContext, maxFunctionDefs);
      }
      se (cvt && cvt.length & 1) {
        const cvtData = new Uint8Array(cvt.length + 1);
        cvtData.set(cvt.data);
        cvt.data = cvtData;
      }
      restituisci ttContext.hintsValid;
    }
    font = nuovo _stream.Stream(nuovo Uint8Array(font.getBytes()));
    lascia intestazione, tabelle;
    se (isTrueTypeCollectionFile(font)) {
      const ttcData = readTrueTypeCollectionData(font, this.name);
      intestazione = ttcData.header;
      tabelle = ttcData.tables;
    } altro {
      intestazione = readOpenTypeHeader(font);
      tabelle = readTables(font, header.numTables);
    }
    lascia cff, cffFile;
    const isTrueType = !tables["CFF "];
    se (!isTrueType) {
      const isComposite = properties.composite && (properties.cidToGidMap?.length > 0 || !(properties.cMap instanceof _cmap.IdentityCMap));
      se (header.version === "OTTO" && !isComposite || !tables.head || !tables.hhea || !tables.maxp || !tables.post) {
        cffFile = new _stream.Stream(tables["CFF "].data);
        cff = new _cff_font.CFFFont(cffFile, proprietà);
        adjustWidths(proprietà);
        restituisci questo.convert(nome, cff, proprietà);
      }
      elimina tables.glyf;
      elimina tables.loca;
      elimina tables.fpgm;
      d elete tables.prep;
      elimina tabelle["cvt"];
      this.isOpenType = true;
    } altro {
      se (!tables.loca) {
        throw new _util.FormatError('La tabella "loca" richiesta non è stata trovata');
      }
      se (!tables.glyf) {
        (0, _util.warn)('La tabella "glyf" richiesta non è stata trovata. Si sta tentando di recuperarla.');
        tabelle.glyf = {
          tag: "glifo",
          dati: nuovo Uint8Array(0)
        };
      }
      this.isOpenType = false;
    }
    se (!tables.maxp) {
      throw new _util.FormatError('La tabella "maxp" richiesta non è stata trovata');
    }
    font.pos = (font.start || 0) + tables.maxp.offset;
    const versione = font.getInt32();
    const numGlyphs = font.getUint16();
    se (proprietà.scaleFactors?.length === numGlyphs && isTrueType) {
      costante {
        fattori di scala
      } = proprietà;
      const isGlyphLocationsLong = int16(tables.head.data[50], tables.head.data[51]);
      const glifi = new _glyf.GlyfTable({
        glyfTable: tabelle.glyf.dati,
        isGlyphLocationsLong,
        locaTable: tabelle.loca.data,
        numGlifi
      });
      glifi.scala(fattori di scala);
      costante {
        glifo,
        locale,
        isLocationLong
      } = glifi.scrivi();
      tabelle.glyf.dati = glyf;
      tabelle.locali.dati = locali;
      se (isLocationLong !== !!isGlyphLocationsLong) {
        tabelle.testa.dati[50] = 0;
        tables.head.data[51] = isLocationLong ? 1 : 0;
      }
      metriche costanti = tabelle.hmtx.dati;
      per (lascia che i = 0; i < numGlifi; i++) {
        costante j = 4 * i;
        const advanceWidth = Math.round(scaleFactors[i] * int16(metrics[j], metrics[j + 1]));
        metriche[j] = advanceWidth >> 8 & 0xff;
        metriche[j + 1] = advanceWidth & 0xff;
        const lsb = Math.round(scaleFactors[i] * signedInt16(metrics[j + 2], metrics[j + 3]));
        writeSignedInt16(metriche, j + 2, lsb);
      }
    }
    lascia numGlyphsOut = numGlyphs + 1;
    lascia dupFirstEntry = true;
    se (numGlyphsOut > 0xffff) {
      dupFirstEntry = false;
      numGlyphsOut = numGlyphs;
      (0, _util.warn)("Spazio insufficiente nei glifi per duplicare il primo glifo.");
    }
    lascia maxFunctionDefs = 0;
    lascia maxSizeOfInstructions = 0;
    se (versione >= 0x00010000 e tables.maxp.length >= 22) {
      font.pos += 8;
      const maxZones = font.getUint16();
      se (maxZones > 2) {
        tabelle.maxp.data[14] = 0;
        tabelle.maxp.data[15] = 2;
      }
      font.pos += 4;
      maxFunctionDefs = font.getUint16();
      font.pos += 4;
      maxSizeOfInstructions = font.getUint16();
    }
    tabelle.maxp.data[4] = numGlyphsOut >> 8;
    tables.maxp.data[5] = numGlyphsOut & 255;
    const hintsValid = sanitizeTTPrograms(tables.fpgm, tables.prep, tables["cvt "], maxFunctionDefs);
    se (!suggerimentiValido) {
      elimina tables.fpgm;
      elimina tables.prep;
      elimina tabelle["cvt"];
    }
    sanitizeMetrics(font, tables.hhea, tables.hmtx, tables.head, numGlyphsOut, dupFirstEntry);
    se (!tables.head) {
      throw new _util.FormatError('La tabella "head" richiesta non è stata trovata');
    }
    sanitizeHead(tables.head, numGlyphs, isTrueType ? tables.loca.length : 0);
    lascia missingGlyphs = Object.create(null);
    se (èTrueType) {
      const isGlyphLocationsLong = int16(tables.head.data[50], tables.head.data[51]);
      const glyphsInfo = sanitizeGlyphLocations(tables.loca, tables.glyf, numGlyphs, isGlyphLocationsLong, hintsValid, dupFirstEntry, maxSizeOfInstructions);
      missingGlyphs = glyphsInfo.missingGlyphs;
      se (versione >= 0x00010000 e tables.maxp.length >= 22) {
        tables.maxp.data[26] = glyphsInfo.maxSizeOfInstructions >> 8;
        tables.maxp.data[27] = glyphsInfo.maxSizeOfInstructions & 255;
      }
    }
    se (!tables.hhea) {
      throw new _util.FormatError('La tabella "hhea" richiesta non è stata trovata');
    }
    se (tables.hhea.data[10] === 0 && tables.hhea.data[11] === 0) {
      tabelle.hhea.data[10] = 0xff;
      tabelle.hhea.data[11] = 0xff;
    }
    const metricsOverride = {
      unitàPerEm: int16(tabelle.testa.dati[18], tabelle.testa.dati[19]),
      yMax: signedInt16(tables.head.data[42], tables.head.data[43]),
      yMin: signedInt16(tables.head.data[38], tables.head.data[39]),
      salita: signedInt16(tables.hhea.data[4], tables.hhea.data[5]),
      discesa: signedInt16(tables.hhea.data[6], tables.hhea.data[7]),
      lineGap: signedInt16(tables.hhea.data[8], tables.hhea.data[9])
    };
    this.ascent = metricsOverride.ascent / metricsOverride.unitsPerEm;
    this.descent = metricsOverride.descent / metricsOverride.unitsPerEm;
    this.lineGap = metricsOverride.lineGap / metricsOverride.unitsPerEm;
    se (this.cssFontInfo?.lineHeight) {
      this.lineHeight = this.cssFontInfo.metrics.lineHeight;
      this.lineGap = this.cssFontInfo.metrics.lineGap;
    } altro {
      this.lineHeight = this.ascent - this.descent + this.lineGap;
    }
    se (tabelle.post) {
      readPostScriptTable(tables.post, properties, numGlyphs);
    }
    tabelle.post = {
      tag: "post",
      dati: createPostTable(proprietà)
    };
    const charCodeToGlyphId = [];
    funzione hasGlyph(glyphId) {
      restituisci !missingGlyphs[glyphId];
    }
    se (proprietà.composito) {
      const cidToGidMap = proprietà.cidToGidMap || [];
      const isCidToGidMapEmpty = cidToGidMap.length === 0;
      proprietà.cMap.forEach(funzione (charCode, cid) {
        se (tipo di cid === "stringa") {
          cid = convertCidString(charCode, cid, true);
        }
        se (cid > 0xffff) {
          throw new _util.FormatError("La dimensione massima del CID è 65.535");
        }
        lascia glyphId = -1;
        se (isCidToGidMapEmpty) {
          glyphId = cid;
        } altrimenti se (cidToGidMap[cid] !== indefinito) {
          glyphId = cidToGidMap[cid];
        }
        se (glyphId >= 0 && glyphId < numGlyphs && hasGlyph(glyphId)) {
          charCodeToGlyphId[charCode] = glyphId;
        }
      });
    } altro {
      const cmapTable = readCmapTable(tables.cmap, font, this.isSymbolicFont, properties.hasEncoding);
      const cmapPlatformId = cmapTable.platformId;
      const cmapEncodingId = cmapTable.encodingId;
      const cmapMappings = cmapTable.mappings;
      lascia baseEncoding = [],
        forcePostTable = falso;
      se (properties.hasEncoding && (properties.baseEncodingName === "MacRomanEncoding" || properties.baseEncodingName === "WinAnsiEncoding")) {
        baseEncoding = (0, _encodings.getEncoding)(properties.baseEncodingName);
      }
      se (proprietà.hasEncoding && !this.isSymbolicFont && (cmapPlatformId === 3 && cmapEncodingId === 1 || cmapPlatformId === 1 && cmapEncodingId === 0)) {
        const glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
        per (lascia che charCode = 0; charCode < 256; charCode++) {
          lascia glyphName;
          se (this.differences[charCode] !== indefinito) {
            glyphName = this.differences[charCode];
          } altrimenti se (baseEncoding.length && baseEncoding[charCode] !== "") {
            glyphName = baseEncoding[charCode];
          } altro {
            glyphName = _encodings.StandardEncoding[charCode];
          }
          se (!glyphName) {
            continuare;
          }
          const standardGlyphName = (0, _fonts_utils.recoverGlyphName)(glyphName, glyphsUnicodeMap);
          lascia unicodeOrCharCode;
          se (cmapPlatformId === 3 e cmapEncodingId === 1) {
            unicodeOrCharCode = glyphsUnicodeMap[standardGlyphName];
          } altrimenti se (cmapPlatformId === 1 e cmapEncodingId === 0) {
            unicodeOrCharCode = _encodings.MacRomanEncoding.indexOf(standardGlyphName);
          }
          se (unicodeOrCharCode === indefinito) {
            se (!properties.glyphNames && properties.hasIncludedToUnicodeMap && !(this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap)) {
              const unicode = this.toUnicode.get(charCode);
              se (unicode) {
                unicodeOrCharCode = unicode.codePointAt(0);
              }
            }
            se (unicodeOrCharCode === indefinito) {
              continuare;
            }
          }
          per (mappatura costante di cmapMappings) {
            se (mapping.charCode !== unicodeOrCharCode) {
              continuare;
            }
            charCodeToGlyphId[charCode] = mapping.glyphId;
            rottura;
          }
        }
      } altrimenti se (cmapPlatformId === 0) {
        per (mappatura costante di cmapMappings) {
          charCodeToGlyphId[mapping.charCode] = mapping.glyphId;
        }
        forcePostTable = true;
      } altro {
        per (mappatura costante di cmapMappings) {
          lascia charCode = mapping.charCode;
          se (cmapPlatformId === 3 && charCode >= 0xf000 && charCode <= 0xf0ff) {
            charCode &= 0xff;
          }
          charCodeToGlyphId[charCode] = mapping.glyphId;
        }
      }
      se (proprietà.glifiNomi && (baseEncoding.length || questo.differenze.length)) {
        per (lascia che i = 0; i < 256; ++i) {
          se (!forcePostTable && charCodeToGlyphId[i] !== non definito) {
            continuare;
          }
          const glyphName = this.differences[i] || baseEncoding[i];
          se (!glyphName) {
            continuare;
          }
          const glyphId = properties.glyphNames.indexOf(glyphName);
          se (glyphId > 0 && hasGlyph(glyphId)) {
            charCodeToGlyphId[i] = glyphId;
          }
        }
      }
    }
    se (charCodeToGlyphId.length === 0) {
      charCodeToGlyphId[0] = 0;
    }
    lascia glyphZeroId = numGlyphsOut - 1;
    se (!dupFirstEntry) {
      glyphZeroId = 0;
    }
    se (!properties.cssFontInfo) {
      const newMapping = adjustMapping(charCodeToGlyphId, hasGlyph, glyphZeroId, this.toUnicode);
      this.toFontChar = newMapping.toFontChar;
      tabelle.cmap = {
        etichetta: "cmap",
        dati: createCmapTable(newMapping.charCodeToGlyphId, newMapping.toUnicodeExtraMap, numGlyphsOut)
      };
      se (!tables["OS/2"] || !validateOS2Table(tables["OS/2"], font)) {
        tabelle["OS/2"] = {
          etichetta: "OS/2",
          dati: createOS2Table(proprietà, newMapping.charCodeToGlyphId, metricsOverride)
        };
      }
    }
    se (!isTrueType) {
      Tentativo {
        cffFile = new _stream.Stream(tables["CFF "].data);
        const parser = new _cff_parser.CFFParser(cffFile, proprietà, _fonts_utils.SEAC_ANALYSIS_ENABLED);
        cff = parser.parse();
        cff.duplicateFirstGlyph();
        const compiler = new _cff_parser.CFFCompiler(cff);
        tabelle["CFF "].data = compiler.compile();
      } presa {
        (0, _util.warn)("Impossibile compilare il font " + properties.loadedName);
      }
    }
    se (!tables.name) {
      tabelle.nome = {
        tag: "nome",
        dati: createNameTable(this.name)
      };
    } altro {
      const [nomePrototipo, nomeRecord] = readNameTable(tables.name);
      tables.name.data = createNameTable(name, namePrototype);
      this.psName = namePrototype[0][6] || null;
      se (!proprietà.composito) {
        adjustTrueTypeToUnicode(proprietà, this.isSymbolicFont, nameRecords);
      }
    }
    const builder = new _opentype_file_builder.OpenTypeFileBuilder(header.version);
    per (const tableTag nelle tabelle) {
      builder.addTable(tableTag, tabelle[tableTag].data);
    }
    restituisci builder.toArray();
  }
  convert(fontName, font, proprietà) {
    proprietà.fixedPitch = false;
    se (proprietà.builtInEncoding) {
      adjustType1ToUnicode(proprietà, proprietà.builtInEncoding);
    }
    lascia glyphZeroId = 1;
    se (istanza del font _cff_font.CFFFont) {
      glyphZeroId = font.numGlyphs - 1;
    }
    const mapping = font.getGlyphMapping(proprietà);
    lascia newMapping = null;
    lascia che newCharCodeToGlyphId = mapping;
    lascia che toUnicodeExtraMap = null;
    se (!properties.cssFontInfo) {
      newMapping = adjustMapping(mapping, font.hasGlyphId.bind(font), glyphZeroId, this.toUnicode);
      this.toFontChar = newMapping.toFontChar;
      newCharCodeToGlyphId = newMapping.charCodeToGlyphId;
      toUnicodeExtraMap = newMapping.toUnicodeExtraMap;
    }
    const numGlyphs = font.numGlyphs;
    funzione getCharCodes(charCodeToGlyphId, glyphId) {
      lascia che charCodes = null;
      per (const charCode in charCodeToGlyphId) {
        se (glyphId === charCodeToGlyphId[charCode]) {
          (codicicarattere ||= []).push(codicecarattere | 0);
        }
      }
      restituisci charCodes;
    }
    funzione createCharCode(charCodeToGlyphId, glyphId) {
      per (const charCode in charCodeToGlyphId) {
        se (glyphId === charCodeToGlyphId[charCode]) {
          restituisci charCode | 0;
        }
      }
      newMapping.charCodeToGlyphId[newMapping.nextAvailableFontCharCode] = glyphId;
      restituisci newMapping.nextAvailableFontCharCode++;
    }
    const seacs = font.seacs;
    se (newMapping && _fonts_utils.SEAC_ANALYSIS_ENABLED && seacs?.length) {
      matrice costante = proprietà.fontMatrix || _util.FONT_IDENTITY_MATRIX;
      const charset = font.getCharset();
      const seacMap = Object.create(null);
      per (lascia glyphId in seacs) {
        glyphId |= 0;
        const seac = seacs[glyphId];
        const baseGlyphName = _encodings.StandardEncoding[seac[2]];
        const accentGlyphName = _encodings.StandardEncoding[seac[3]];
        const baseGlyphId = charset.indexOf(baseGlyphName);
        const accentGlyphId = charset.indexOf(accentGlyphName);
        se (baseGlyphId < 0 || accentGlyphId < 0) {
          continuare;
        }
        const accentOffset = {
          x: seac[0] * matrice[0] + seac[1] * matrice[2] + matrice[4],
          y: seac[0] * matrice[1] + seac[1] * matrice[3] + matrice[5]
        };
        const charCodes = getCharCodes(mapping, glyphId);
        se (!charCodes) {
          continuare;
        }
        per (const charCode di charCodes) {
          const charCodeToGlyphId = newMapping.charCodeToGlyphId;
          const baseFontCharCode = createCharCode(charCodeToGlyphId, baseGlyphId);
          const accentFontCharCode = createCharCode(charCodeToGlyphId, accentGlyphId);
          seacMap[charCode] = {
            baseFontCharCode,
            accentFontCharCode,
            accentoOffset
          };
        }
      }
      proprietà.seacMap = seacMap;
    }
    const unitsPerEm = 1 / (properties.fontMatrix || _util.FONT_IDENTITY_MATRIX)[0];
    const builder = new _opentype_file_builder.OpenTypeFileBuilder("\x4F\x54\x54\x4F");
    builder.addTable("CFF ", font.data);
    builder.addTable("OS/2", createOS2Table(proprietà, newCharCodeToGlyphId));
    builder.addTable("cmap", createCmapTable(newCharCodeToGlyphId, toUnicodeExtraMap, numGlyphs));
    builder.addTable("head", "\x00\x01\x00\x00" + "\x00\x00\x10\x00" + "\x00\x00\x00\x00" + "\x5F\x0F\x3C\xF5" + "\x00\x00" + safeString16(unitsPerEm) + "\x00\x00\x00\x00\x9e\x0b\x7e\x27" + "\x00\x00\x00\x00\x9e\x0b\x7e\x27" + "\x00\x00" + safeString16(properties.descent) + "\x0F\xFF" + safeString16(properties.ascent) + string16(properties.italicAngle ? 2 : 0) + "\x00\x11" + "\x00\x00" + "\x00\x00" + "\x00\x00");
    builder.addTable("hhea", "\x00\x01\x00\x00" + safeString16(properties.ascent) + safeString16(properties.descent) + "\x00\x00" + "\xFF\xFF" + "\x00\x00" + "\x00\x00" + "\x00\x00" + safeString16(properties.capHeight) + safeString16(Math.tan(properties.italicAngle) * properties.xHeight) + "\x00\x00" + "\x00\x00" + "\x00\x00" + "\x00\x00" + "\x00\x00" + "\x00\x00" + string16(numGlyphs));
    builder.addTable("hmtx", funzione fontFieldsHmtx() {
      const stringhe di caratteri = font.stringhe di caratteri;
      const cffWidths = font.cff ? font.cff.widths : null;
      lascia che hmtx = "\x00\x00\x00\x00";
      per (lascia che i = 1, ii = numGlifi; i < ii; i++) {
        lascia larghezza = 0;
        se (stringhe di caratteri) {
          const charstring = charstrings[i - 1];
          width = "larghezza" in charstring ? charstring.width : 0;
        } altrimenti se (cffWidths) {
          larghezza = Math.ceil(cffWidths[i] || 0);
        }
        hmtx += string16(larghezza) + string16(0);
      }
      restituisci hmtx;
    }());
    builder.addTable("maxp", "\x00\x00\x50\x00" + string16(numGlyphs));
    builder.addTable("nome", createNameTable(fontName));
    builder.addTable("post", createPostTable(proprietà));
    restituisci builder.toArray();
  }
  ottieni spaceWidth() {
    const possibleSpaceReplacements = ["spazio", "meno", "uno", "i", "I"];
    lascia larghezza;
    per (const glyphName di possibleSpaceReplacements) {
      se (glyphName in this.widths) {
        larghezza = this.widths[glyphName];
        rottura;
      }
      const glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
      const glyphUnicode = glyphsUnicodeMap[glyphName];
      lascia che charcode = 0;
      se (this.composite && this.cMap.contains(glyphUnicode)) {
        charcode = this.cMap.lookup(glyphUnicode);
        se (tipo di codice carattere === "stringa") {
          charcode = convertCidString(glyphUnicode, charcode);
        }
      }
      se (!charcode && this.toUnicode) {
        charcode = this.toUnicode.charCodeOf(glyphUnicode);
      }
      se (codice carattere <= 0) {
        charcode = glyphUnicode;
      }
      larghezza = this.widths[codice carattere];
      se (larghezza) {
        rottura;
      }
    }
    return (0, _util.shadow)(this, "spaceWidth", width || this.defaultWidth);
  }
  _charToGlyph(charcode, isSpace = false) {
    lascia che glyph = this._glyphCache[charcode];
    se (glifo?.isSpace === isSpace) {
      restituisci glifo;
    }
    lascia fontCharCode, larghezza, operatorListId;
    lascia widthCode = charcode;
    se (this.cMap?.contains(charcode)) {
      widthCode = this.cMap.lookup(charcode);
      se (tipo di larghezzaCodice === "stringa") {
        widthCode = convertCidString(charcode, widthCode);
      }
    }
    larghezza = this.widths[widthCode];
    se (tipo di larghezza !== "numero") {
      larghezza = this.defaultWidth;
    }
    const vmetric = this.vmetrics?.[widthCode];
    lascia unicode = this.toUnicode.get(charcode) || charcode;
    se (tipo di unicode === "numero") {
      unicode = String.fromCharCode(unicode);
    }
    lascia isInFont = this.toFontChar[charcode] !== indefinito;
    fontCharCode = this.toFontChar[codice carattere] || codice carattere;
    se (questo.filemancante) {
      const glyphName = this.differences[charcode] || this.defaultEncoding[charcode];
      if ((glyphName === ".notdef" || glyphName === "") && this.type === "Type1") {
        fontCharCode = 0x20;
      }
      fontCharCode = (0, _unicode.mapSpecialUnicodeValues)(fontCharCode);
    }
    se (questo.èType3Font) {
      operatorListId = fontCharCode;
    }
    lascia accento = null;
    se (this.seacMap?.[charcode]) {
      isInFont = true;
      const seac = this.seacMap[codice carattere];
      fontCharCode = seac.baseFontCharCode;
      accento = {
        fontChar: String.fromCodePoint(seac.accentFontCharCode),
        offset: seac.accentOffset
      };
    }
    lascia fontChar = "";
    se (tipo di fontCharCode === "numero") {
      se (fontCharCode <= 0x10ffff) {
        fontChar = String.fromCodePoint(fontCharCode);
      } altro {
        (0, _util.warn)(`charToGlyph - fontCharCode non valido: ${fontCharCode}`);
      }
    }
    glyph = new Glyph(charcode, fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont);
    restituisci questo._glyphCache[charcode] = glifo;
  }
  charsToGlyphs(caratteri) {
    lascia che i glifi = this._charsCache[chars];
    se (glifi) {
      restituisci glifi;
    }
    glifi = [];
    se (this.cMap) {
      const c = Object.create(null),
        ii = lunghezza caratteri;
      sia i = 0;
      mentre (i < ii) {
        this.cMap.readCharCode(caratteri, i, c);
        costante {
          codice di carattere,
          lunghezza
        } = c;
        i += lunghezza;
        const glyph = this._charToGlyph(charcode, length === 1 && chars.charCodeAt(i - 1) === 0x20);
        glifi.push(glifo);
      }
    } altro {
      per (lascia che i = 0, ii = lunghezza caratteri; i < ii; ++i) {
        const charcode = chars.charCodeAt(i);
        const glyph = this._charToGlyph(charcode, charcode === 0x20);
        glifi.push(glifo);
      }
    }
    restituisci questo._charsCache[chars] = glifi;
  }
  getCharPositions(caratteri) {
    posizioni costanti = [];
    se (this.cMap) {
      const c = Object.create(null);
      sia i = 0;
      while (i < lunghezza caratteri) {
        this.cMap.readCharCode(caratteri, i, c);
        lunghezza costante = c.length;
        posizioni.push([i, i + lunghezza]);
        i += lunghezza;
      }
    } altro {
      per (lascia che i = 0, ii = lunghezza caratteri; i < ii; ++i) {
        posizioni.push([i, i + 1]);
      }
    }
    posizioni di ritorno;
  }
  ottieni glyphCacheValues() {
    restituisci Object.values(this._glyphCache);
  }
  codificaStringa(str) {
    const buffer = [];
    const currentBuf = [];
    const hasCurrentBufErrors = () => buffers.length % 2 === 1;
    const getCharCode = this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap ? unicode => this.toUnicode.charCodeOf(unicode) : unicode => this.toUnicode.charCodeOf(String.fromCodePoint(unicode));
    per (lascia che i = 0, ii = str.length; i < ii; i++) {
      const unicode = str.codePointAt(i);
      se (unicode > 0xd7ff && (unicode < 0xe000 || unicode > 0xfffd)) {
        i++;
      }
      se (questo.inUnicode) {
        const charCode = getCharCode(unicode);
        se (codiceCarattere !== -1) {
          se (hasCurrentBufErrors()) {
            buffer.push(currentBuf.join(""));
            lunghezzaBuf.corrente = 0;
          }
          const charCodeLength = this.cMap ? this.cMap.getCharCodeLength(charCode) : 1;
          per (lascia che j = charCodeLength - 1; j >= 0; j--) {
            currentBuf.push(String.fromCharCode(charCode >> 8 * j & 0xff));
          }
          continuare;
        }
      }
      se (!hasCurrentBufErrors()) {
        buffer.push(currentBuf.join(""));
        lunghezzaBuf.corrente = 0;
      }
      currentBuf.push(String.fromCodePoint(unicode));
    }
    buffer.push(currentBuf.join(""));
    buffer di ritorno;
  }
}
esportazioni.Font = Carattere;
classe ErrorFont {
  costruttore(errore) {
    questo.errore = errore;
    this.loadedName = "g_font_error";
    this.missingFile = true;
  }
  charsToGlyphs() {
    ritorno [];
  }
  encodeString(caratteri) {
    ritorno [caratteri];
  }
  exportData(extraProperties = false) {
    ritorno {
      errore: questo.errore
    };
  }
}
esportazioni.ErrorFont = ErrorFont;

/***/ }),
/* 35 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
exports.CFFTopDict = exports.CFFStrings = exports.CFFStandardStrings = exports.CFFPrivateDict = exports.CFFParser = exports.CFFIndex = exports.CFFHeader = exports.CFFFDSelect = exports.CFFCompiler = exports.CFFCharset = exports.CFF = void 0;
var _util = __w_pdfjs_require__(2);
var _charsets = __w_pdfjs_require__(36);
var _encodings = __w_pdfjs_require__(37);
const MAX_SUBR_NESTING = 10;
const CFFStandardStrings = [".notdef", "spazio", "punto esclamativo", "quotedbl", "numero", "dollaro", "percentuale", "e commerciale", "quoteright", "parentesi a sinistra", "parentesi a destra", "asterisco", "più", "virgola", "trattino", "punto", "barra", "zero", "uno", "due", "tre", "quattro", "cinque", "sei", "sette", "otto", "nove", "due punti", "punto e virgola", "minore", "uguale", "maggiore", "domanda", "a", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "parentesi a sinistra", "barra rovesciata", "parentesi a destra", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "curency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark","Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresi", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresi", "Egrave", "Iacute", "Icircumflex", "Idieresi", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresi", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresi", "Ugrave", "Yacute", "Ydieresi", "Zcaron", "aacute", "acircumflex", "adieresi", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parentesi sinistra superiore", "parentesi destra superiore", "due leader doten", "uno leader doten", "zero oldstyle", "uno oldstyle", "due oldstyle", "tre oldstyle", "quattro oldstyle", "cinque oldstyle", "sei oldstyle", "sette oldstyle", "otto oldstyle", "nove oldstyle", "virgolasuperiore", "trequartisemdash", "puntosuperiore", "interrogazionepiccola", "asuperiore", "bsuperiore", "centosuperiore", "dsuperiore", "esuperiore", "isuperiore", "lsuperiore", "msuperiore", "nsuperiore", "osuperiore", "rsuperiore", "ssuperiore", "tsuperior", "ff", "ffi", "ffl", "parentesiinferioresinistra", "parentesiinferioredestra", "circonflessopiccolo", "trattinosuperiore", "Gravepiccolo", "Apiccolo", "Bpiccolo", "Cpiccolo", "Dpiccolo", "Epiccolo", "Fpiccolo", "Gpiccolo", "Hpiccolo", "Ipiccolo", "Jpiccolo", "Kpiccolo","Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "eveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "settesuperiore", "ottosuperiore", "novesuperiore", "zeroinferiore", "unoinferiore", "dueinferiore", "treinferiore", "quattroinferiore", "cinqueinferiore", "seiinferiore", "setteinferiore", "ottoinferiore", "noveinferiore", "centoinferiore", "dollaroinferiore", "periodoinferiore", "cominferiore", "Agravepiccolo", "Aacutepiccolo", "Acircumflexpiccolo", "Atildepiccolo", "Adieresipiccolo", "Aringpiccolo", "AEpiccolo", "Ccedillapiccolo", "Egravepiccolo", "Eacutepiccolo", "Ecircumflexpiccolo", "Edieresipiccolo", "Igravepiccolo", "Iacutepiccolo", "Icircumflexpiccolo", "Idieresipiccolo", "Ethpiccolo", "Ntildepiccolo", "Ogravepiccolo", "Oacutepiccolo", "Ocircumflexpiccolo", "Otildepiccolo", "Odieresipiccolo", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Nero", "Grassetto", "Libro", "Leggero", "Medio", "Normale", "Romano", "Semigrassetto"];"centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "eveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "seinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresismall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Nero", "Grassetto", "Libro", "Leggero", "Medio", "Normale", "Romano", "Semigrassetto"];"centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "eveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "seinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresismall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Nero", "Grassetto", "Libro", "Leggero", "Medio", "Normale", "Romano", "Semigrassetto"];"cinqueinferiore", "seiinferiore", "setteinferiore", "ottoinferiore", "noveinferiore", "centinferiore", "dollaroinferiore", "periodoinferiore", "cominferiore", "Agravepiccolo", "Aacutepiccolo", "Acircumflexpiccolo", "Atildepiccolo", "Adieresipiccolo", "Aringpiccolo", "AEpiccolo", "Ccedillapiccolo", "Egravepiccolo", "Eacutepiccolo", "Ecircumflexpiccolo", "Edieresipiccolo", "Igravepiccolo", "Iacutepiccolo", "Icircumflexpiccolo", "Idieresipiccolo", "Ethpiccolo", "Ntildepiccolo", "Ogravepiccolo", "Oacutepiccolo", "Ocircumflexpiccolo", "Otildepiccolo", "Odieresipiccolo", "OEpiccolo", "Oslashpiccolo", "Ugravepiccolo", "Uacutepiccolo", "Ucircumflexpiccolo", "Udieresipiccolo", "Yacutepiccolo", "Thornpiccolo", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Nero", "Grassetto", "Libro", "Leggero", "Medio", "Normale", "Romano", "Semigrassetto"];"cinqueinferiore", "seiinferiore", "setteinferiore", "ottoinferiore", "noveinferiore", "centinferiore", "dollaroinferiore", "periodoinferiore", "cominferiore", "Agravepiccolo", "Aacutepiccolo", "Acircumflexpiccolo", "Atildepiccolo", "Adieresipiccolo", "Aringpiccolo", "AEpiccolo", "Ccedillapiccolo", "Egravepiccolo", "Eacutepiccolo", "Ecircumflexpiccolo", "Edieresipiccolo", "Igravepiccolo", "Iacutepiccolo", "Icircumflexpiccolo", "Idieresipiccolo", "Ethpiccolo", "Ntildepiccolo", "Ogravepiccolo", "Oacutepiccolo", "Ocircumflexpiccolo", "Otildepiccolo", "Odieresipiccolo", "OEpiccolo", "Oslashpiccolo", "Ugravepiccolo", "Uacutepiccolo", "Ucircumflexpiccolo", "Udieresipiccolo", "Yacutepiccolo", "Thornpiccolo", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Nero", "Grassetto", "Libro", "Leggero", "Medio", "Normale", "Romano", "Semigrassetto"];
esportazioni.CFFStandardStrings = CFFStandardStrings;
const NUM_STANDARD_CFF_STRINGS = 391;
const CharstringValidationData = [null, {
  id: "hstem",
  minimo: 2,
  stackClearing: vero,
  stelo: vero
}, nullo, {
  id: "vstem",
  minimo: 2,
  stackClearing: vero,
  stelo: vero
}, {
  id: "vmoveto",
  minimo: 1,
  stackClearing: vero
}, {
  id: "rlineto",
  minimo: 2,
  resetStack: vero
}, {
  id: "hlineto",
  minimo: 1,
  resetStack: vero
}, {
  id: "vlineto",
  minimo: 1,
  resetStack: vero
}, {
  id: "rrcurveto",
  minimo: 6,
  resetStack: vero
}, nullo, {
  id: "callsubr",
  minimo: 1,
  undefStack: vero
}, {
  id: "ritorno",
  minimo: 0,
  undefStack: vero
}, nullo, nullo, {
  id: "endchar",
  minimo: 0,
  stackClearing: vero
}, nullo, nullo, nullo, {
  id: "hstemhm",
  minimo: 2,
  stackClearing: vero,
  stelo: vero
}, {
  id: "hintmask",
  minimo: 0,
  stackClearing: vero
}, {
  id: "cntrmask",
  minimo: 0,
  stackClearing: vero
}, {
  id: "rmoveto",
  minimo: 2,
  stackClearing: vero
}, {
  id: "hmoveto",
  minimo: 1,
  stackClearing: vero
}, {
  id: "vstemhm",
  minimo: 2,
  stackClearing: vero,
  stelo: vero
}, {
  id: "rcurveline",
  minimo: 8,
  resetStack: vero
}, {
  id: "rlinecurve",
  minimo: 8,
  resetStack: vero
}, {
  id: "vvcurveto",
  minimo: 4,
  resetStack: vero
}, {
  id: "hhcurveto",
  minimo: 4,
  resetStack: vero
}, nullo, {
  id: "callgsubr",
  minimo: 1,
  undefStack: vero
}, {
  id: "vhcurveto",
  minimo: 4,
  resetStack: vero
}, {
  id: "hvcurveto",
  minimo: 4,
  resetStack: vero
}];
const CharstringValidationData12 = [null, null, null, {
  id: "e",
  minimo: 2,
  Delta pila: -1
}, {
  id: "o",
  minimo: 2,
  Delta pila: -1
}, {
  id: "non",
  minimo: 1,
  stackDelta: 0
}, nullo, nullo, nullo, {
  id: "abs",
  minimo: 1,
  stackDelta: 0
}, {
  id: "aggiungi",
  minimo: 2,
  stackDelta: -1,
  stackFn(pila, indice) {
    pila[indice - 2] = pila[indice - 2] + pila[indice - 1];
  }
}, {
  id: "sub",
  minimo: 2,
  stackDelta: -1,
  stackFn(pila, indice) {
    pila[indice - 2] = pila[indice - 2] - pila[indice - 1];
  }
}, {
  id: "div",
  minimo: 2,
  stackDelta: -1,
  stackFn(pila, indice) {
    pila[indice - 2] = pila[indice - 2] / pila[indice - 1];
  }
}, nullo, {
  id: "neg",
  minimo: 1,
  stackDelta: 0,
  stackFn(pila, indice) {
    pila[indice - 1] = -pila[indice - 1];
  }
}, {
  id: "eq",
  minimo: 2,
  Delta pila: -1
}, nullo, nullo, {
  id: "goccia",
  minimo: 1,
  Delta pila: -1
}, nullo, {
  id: "mettere",
  minimo: 2,
  Delta pila: -2
}, {
  id: "ottenere",
  minimo: 1,
  stackDelta: 0
}, {
  id: "ifelse",
  minimo: 4,
  stackDelta: -3
}, {
  id: "casuale",
  minimo: 0,
  stackDelta: 1
}, {
  id: "mul",
  minimo: 2,
  stackDelta: -1,
  stackFn(pila, indice) {
    pila[indice - 2] = pila[indice - 2] * pila[indice - 1];
  }
}, nullo, {
  id: "sqrt",
  minimo: 1,
  stackDelta: 0
}, {
  id: "dup",
  minimo: 1,
  stackDelta: 1
}, {
  id: "scambio",
  minimo: 2,
  stackDelta: 0
}, {
  id: "indice",
  minimo: 2,
  stackDelta: 0
}, {
  id: "rotolo",
  minimo: 3,
  Delta pila: -2
}, nullo, nullo, nullo, {
  id: "hflex",
  minimo: 7,
  resetStack: vero
}, {
  id: "flessibile",
  minimo: 13,
  resetStack: vero
}, {
  ID: "hflex1",
  minimo: 9,
  resetStack: vero
}, {
  ID: "flex1",
  minuti: 11,
  resetStack: vero
}];
classe CFFParser {
  costruttore(file, proprietà, seacAnalysisEnabled) {
    questo.byte = file.getBytes();
    this.properties = proprietà;
    this.seacAnalysisEnabled = !!seacAnalysisEnabled;
  }
  analizzare() {
    const proprietà = this.properties;
    const cff = nuovo CFF();
    questo.cff = cff;
    const header = this.parseHeader();
    const nameIndex = this.parseIndex(header.endPos);
    const topDictIndex = this.parseIndex(nameIndex.endPos);
    const stringIndex = this.parseIndex(topDictIndex.endPos);
    const globalSubrIndex = this.parseIndex(stringIndex.endPos);
    const topDictParsed = this.parseDict(topDictIndex.obj.get(0));
    const topDict = this.createDict(CFFTopDict, topDictParsed, cff.strings);
    cff.header = header.obj;
    cff.names = this.parseNameIndex(nameIndex.obj);
    cff.strings = this.parseStringIndex(stringIndex.obj);
    cff.topDict = topDict;
    cff.globalSubrIndex = globalSubrIndex.obj;
    this.parsePrivateDict(cff.topDict);
    cff.isCIDFont = topDict.hasName("ROS");
    const charStringOffset = topDict.getByName("StringheCaratteri");
    const charStringIndex = this.parseIndex(charStringOffset).obj;
    const fontMatrix = topDict.getByName("FontMatrix");
    se (fontMatrix) {
      proprietà.fontMatrix = fontMatrix;
    }
    const fontBBox = topDict.getByName("FontBBox");
    se (fontBBox) {
      proprietà.ascesa = Math.max(fontBBox[3], fontBBox[1]);
      proprietà.discesa = Math.min(fontBBox[1], fontBBox[3]);
      proprietà.ascentScaled = true;
    }
    lascia charset, codifica;
    se (cff.isCIDFont) {
      const fdArrayIndex = this.parseIndex(topDict.getByName("FDArray")).obj;
      per (lascia che i = 0, ii = fdArrayIndex.count; i < ii; ++i) {
        const dictRaw = fdArrayIndex.get(i);
        const fontDict = this.createDict(CFFTopDict, this.parseDict(dictRaw), cff.strings);
        this.parsePrivateDict(fontDict);
        cff.fdArray.push(fontDict);
      }
      codifica = null;
      charset = this.parseCharsets(topDict.getByName("charset"), charStringIndex.count, cff.strings, true);
      cff.fdSelect = this.parseFDSelect(topDict.getByName("FDSelect"), charStringIndex.count);
    } altro {
      charset = this.parseCharsets(topDict.getByName("charset"), charStringIndex.count, cff.strings, false);
      codifica = this.parseEncoding(topDict.getByName("Codifica"), proprietà, cff.stringhe, charset.charset);
    }
    cff.charset = set di caratteri;
    cff.encoding = codifica;
    const charStringsAndSeacs = this.parseCharStrings({
      charStrings: charStringIndex,
      localSubrIndex: topDict.privateDict.subrsIndex,
      globalSubrIndex: globalSubrIndex.obj,
      fdSelect: cff.fdSelect,
      fdArray: cff.fdArray,
      privateDict: topDict.privateDict
    });
    cff.charStrings = charStringsAndSeacs.charStrings;
    cff.seacs = charStringsAndSeacs.seacs;
    cff.larghezze = charStringsAndSeacs.larghezze;
    restituisci cff;
  }
  analizza l'intestazione() {
    lascia byte = questo.byte;
    const bytesLength = byte.lunghezza;
    lascia offset = 0;
    while (offset < lunghezzabyte && byte[offset] !== 1) {
      ++spostamento;
    }
    se (offset >= lunghezzabyte) {
      throw new _util.FormatError("Intestazione CFF non valida");
    }
    se (offset !== 0) {
      (0, _util.info)("i dati cff vengono spostati");
      byte = byte.subarray(offset);
      questo.byte = byte;
    }
    const major = byte[0];
    const minore = byte[1];
    const hdrSize = byte[2];
    const offSize = byte[3];
    const header = new CFFHeader(major, minor, hdrSize, offSize);
    ritorno {
      obj: intestazione,
      endPos: hdrSize
    };
  }
  parseDict(dict) {
    lascia pos = 0;
    funzione parseOperand() {
      lascia valore = dict[pos++];
      se (valore === 30) {
        restituisci parseFloatOperand();
      } altrimenti se (valore === 28) {
        valore = dict[pos++];
        valore = (valore << 24 | dict[pos++] << 16) >> 16;
        valore di ritorno;
      } altrimenti se (valore === 29) {
        valore = dict[pos++];
        valore = valore << 8 | dict[pos++];
        valore = valore << 8 | dict[pos++];
        valore = valore << 8 | dict[pos++];
        valore di ritorno;
      } altrimenti se (valore >= 32 e valore <= 246) {
        valore di ritorno - 139;
      } altrimenti se (valore >= 247 e valore <= 250) {
        ritorno (valore - 247) * 256 + dict[pos++] + 108;
      } altrimenti se (valore >= 251 e valore <= 254) {
        ritorno -((valore - 251) * 256) - dict[pos++] - 108;
      }
      (0, _util.warn)('CFFParser_parseDict: "' + valore + '" è un comando riservato.');
      restituisci NaN;
    }
    funzione parseFloatOperand() {
      lascia str = "";
      costante eof = 15;
      const lookup = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"];
      lunghezza costante = dict.length;
      mentre (pos < lunghezza) {
        const b = dict[pos++];
        costante b1 = b >> 4;
        costante b2 = b & 15;
        se (b1 === eof) {
          rottura;
        }
        str += ricerca[b1];
        se (b2 === eof) {
          rottura;
        }
        str += ricerca[b2];
      }
      restituisci parseFloat(str);
    }
    lascia che gli operandi = [];
    voci costanti = [];
    posizione = 0;
    const end = dict.length;
    mentre (pos < fine) {
      lascia b = dict[pos];
      se (b <= 21) {
        se (b === 12) {
          b = b << 8 | dict[++pos];
        }
        voci.push([b, operandi]);
        operandi = [];
        ++posizione;
      } altro {
        operandi.push(parseOperand());
      }
    }
    voci di ritorno;
  }
  parseIndex(pos) {
    const cffIndex = nuovo CFFIndex();
    const byte = questo.byte;
    conteggio costante = byte[pos++] << 8 | byte[pos++];
    offset costanti = [];
    lascia fine = pos;
    sia i, ii;
    se (conta !== 0) {
      const offsetSize = byte[pos++];
      const startPos = pos + (count + 1) * offsetSize - 1;
      per (i = 0, ii = conteggio + 1; i < ii; ++i) {
        lascia offset = 0;
        per (lascia che j = 0; j < offsetSize; ++j) {
          spostamento <<= 8;
          offset += byte[pos++];
        }
        offsets.push(startPos + offset);
      }
      fine = offset[conteggio];
    }
    per (i = 0, ii = offset.lunghezza - 1; i < ii; ++i) {
      const offsetStart = offsets[i];
      const offsetEnd = offsets[i + 1];
      cffIndex.add(bytes.subarray(offsetStart, offsetEnd));
    }
    ritorno {
      oggetto: cffIndex,
      endPos: fine
    };
  }
  parseNameIndex(indice) {
    nomi costanti = [];
    per (lascia che i = 0, ii = indice.conteggio; i < ii; ++i) {
      const nome = indice.get(i);
      nomi.push((0, _util.bytesToString)(nome));
    }
    restituire i nomi;
  }
  parseStringIndex(indice) {
    stringhe costanti = nuove CFFStrings();
    per (lascia che i = 0, ii = indice.conteggio; i < ii; ++i) {
      dati costanti = indice.get(i);
      stringhe.add((0, _util.bytesToString)(dati));
    }
    restituire stringhe;
  }
  createDict(Tipo, dizionario, stringhe) {
    const cffDict = new Type(stringhe);
    per (const [chiave, valore] di dict) {
      cffDict.setByKey(chiave, valore);
    }
    restituisci cffDict;
  }
  parseCharString(stato, dati, localSubrIndex, globalSubrIndex) {
    se (!dati || stato.callDepth > MAX_SUBR_NESTING) {
      restituisci falso;
    }
    lascia che stackSize = stato.stackSize;
    const stack = stato.stack;
    lascia lunghezza = data.length;
    per (lascia che j = 0; j < lunghezza;) {
      valore costante = dati[j++];
      lascia che validationCommand = null;
      se (valore === 12) {
        const q = dati[j++];
        se (q === 0) {
          dati[j - 2] = 139;
          dati[j - 1] = 22;
          dimensione pila = 0;
        } altro {
          validationCommand = CharstringValidationData12[q];
        }
      } altrimenti se (valore === 28) {
        pila[dimensionepila] = (dati[j] << 24 | dati[j + 1] << 16) >> 16;
        j += 2;
        dimensione pila++;
      } altrimenti se (valore === 14) {
        se (stackSize >= 4) {
          dimensione pila -= 4;
          se (this.seacAnalysisEnabled) {
            stato.seac = stack.slice(dimensionestack, dimensionestack + 4);
            restituisci falso;
          }
        }
        validationCommand = CharstringValidationData[valore];
      } altrimenti se (valore >= 32 e valore <= 246) {
        stack[stackSize] = valore - 139;
        dimensione pila++;
      } altrimenti se (valore >= 247 e valore <= 254) {
        stack[stackSize] = valore < 251 ? (valore - 247 << 8) + dati[j] + 108 : -(valore - 251 << 8) - dati[j] - 108;
        j++;
        dimensione pila++;
      } altrimenti se (valore === 255) {
        stack[stackSize] = (data[j] << 24 | data[j + 1] << 16 | data[j + 2] << 8 | data[j + 3]) / 65536;
        j += 4;
        dimensione pila++;
      } altrimenti se (valore === 19 || valore === 20) {
        state.hints += stackSize >> 1;
        se (suggerimenti sullo stato === 0) {
          dati.copyWithin(j - 1, j, -1);
          j -= 1;
          lunghezza -= 1;
          continuare;
        }
        j += suggerimenti sullo stato + 7 >> 3;
        dimensione pila %= 2;
        validationCommand = CharstringValidationData[valore];
      } altrimenti se (valore === 10 || valore === 29) {
        const subrsIndex = valore === 10 ? localSubrIndex : globalSubrIndex;
        se (!subrsIndex) {
          validationCommand = CharstringValidationData[valore];
          (0, _util.warn)("SubrsIndex mancante per " + validationCommand.id);
          restituisci falso;
        }
        lascia che bias = 32768;
        se (subrsIndex.count < 1240) {
          bias = 107;
        } altrimenti se (subrsIndex.count < 33900) {
          bias = 1131;
        }
        const subrNumber = stack[--stackSize] + bias;
        se (subrNumber < 0 || subrNumber >= subrsIndex.count || isNaN(subrNumber)) {
          validationCommand = CharstringValidationData[valore];
          (0, _util.warn)("Sottoindice fuori dai limiti per " + validationCommand.id);
          restituisci falso;
        }
        stato.stackSize = stackSize;
        stato.callDepth++;
        const valid = this.parseCharString(state, subrsIndex.get(subrNumber), localSubrIndex, globalSubrIndex);
        se (!valido) {
          restituisci falso;
        }
        stato.callDepth--;
        stackSize = stato.stackSize;
        continuare;
      } altrimenti se (valore === 11) {
        stato.stackSize = stackSize;
        restituisci vero;
      } altrimenti se (valore === 0 && j === lunghezza dati) {
        dati[j - 1] = 14;
        validationCommand = CharstringValidationData[14];
      } altrimenti se (valore === 9) {
        dati.copyWithin(j - 1, j, -1);
        j -= 1;
        lunghezza -= 1;
        continuare;
      } altro {
        validationCommand = CharstringValidationData[valore];
      }
      se (comando di convalida) {
        se (validationCommand.stem) {
          state.hints += stackSize >> 1;
          se (valore === 3 || valore === 23) {
            stato.hasVStems = true;
          } altrimenti se (stato.hasVStems && (valore === 1 || valore === 18)) {
            (0, _util.warn)("I suggerimenti sullo stelo CFF sono nell'ordine sbagliato");
            dati[j - 1] = valore === 1 ? 3 : 23;
          }
        }
        se ("min" in validationCommand) {
          se (!state.undefStack && stackSize < validationCommand.min) {
            (0, _util.warn)("Parametri non sufficienti per " + validationCommand.id + "; effettivo: " + stackSize + ", previsto: " + validationCommand.min);
            se (stackSize === 0) {
              dati[j - 1] = 14;
              restituisci vero;
            }
            restituisci falso;
          }
        }
        se (stato.firstStackClearing && validationCommand.stackClearing) {
          stato.firstStackClearing = false;
          stackSize -= validationCommand.min;
          se (stackSize >= 2 && validationCommand.stem) {
            dimensione pila %= 2;
          } altrimenti se (stackSize > 1) {
            (0, _util.warn)("Troppi parametri trovati per il comando di cancellazione dello stack");
          }
          se (stackSize > 0) {
            stato.larghezza = stack[stackSize - 1];
          }
        }
        se ("stackDelta" in validationCommand) {
          se ("stackFn" in validationCommand) {
            validationCommand.stackFn(stack, stackSize);
          }
          stackSize += validationCommand.stackDelta;
        } altrimenti se (validationCommand.stackClearing) {
          dimensione pila = 0;
        } altrimenti se (validationCommand.resetStack) {
          dimensione pila = 0;
          stato.undefStack = false;
        } altrimenti se (validationCommand.undefStack) {
          dimensione pila = 0;
          stato.undefStack = true;
          stato.firstStackClearing = false;
        }
      }
    }
    se (lunghezza < lunghezza dati) {
      data.fill(14, lunghezza);
    }
    stato.stackSize = stackSize;
    restituisci vero;
  }
  parseCharStrings({
    stringhe di caratteri,
    localSubrIndex,
    globalSubrIndex,
    fdSeleziona,
    fdArray,
    Dizionario privato
  }) {
    const seacs = [];
    larghezze costanti = [];
    conteggio costante = charStrings.conteggio;
    per (lascia che i = 0; i < conta; i++) {
      const charstring = charStrings.get(i);
      stato costante = {
        Profondità chiamata: 0,
        dimensione pila: 0,
        pila: [],
        undefStack: vero,
        suggerimenti: 0,
        firstStackClearing: vero,
        seac: nullo,
        larghezza: nullo,
        hasVStems: falso
      };
      lascia valido = vero;
      lascia localSubrToUse = null;
      lascia privateDictToUse = privateDict;
      se (fdSelect && fdArray.length) {
        const fdIndex = fdSelect.getFDIndex(i);
        se (fdIndex === -1) {
          (0, _util.warn)("L'indice del glifo non è in fd select.");
          valido = falso;
        }
        se (fdIndex >= fdArray.length) {
          (0, _util.warn)("Indice fd non valido per l'indice del glifo.");
          valido = falso;
        }
        se (valido) {
          privateDictToUse = fdArray[fdIndex].privateDict;
          localSubrToUse = privateDictToUse.subrsIndex;
        }
      } altrimenti se (localSubrIndex) {
        localSubrToUse = localSubrIndex;
      }
      se (valido) {
        valido = this.parseCharString(stato, stringa di caratteri, localSubrToUse, globalSubrIndex);
      }
      se (larghezza stato !== null) {
        const nominalWidth = privateDictToUse.getByName("nominalWidthX");
        larghezze[i] = larghezza nominale + larghezza stato;
      } altro {
        const defaultWidth = privateDictToUse.getByName("defaultWidthX");
        larghezze[i] = defaultWidth;
      }
      se (stato.seac !== null) {
        seacs[i] = stato.seac;
      }
      se (!valido) {
        charStrings.set(i, new Uint8Array([14]));
      }
    }
    ritorno {
      stringhe di caratteri,
      seacs,
      larghezze
    };
  }
  dizionarioprivatovuoto(DizionarioParente) {
    const privateDict = this.createDict(CFFPrivateDict, [], parentDict.strings);
    parentDict.setByKey(18, [0, 0]);
    parentDict.privateDict = privateDict;
  }
  parsePrivateDict(parentDict) {
    se (!parentDict.hasName("Privato")) {
      this.emptyPrivateDictionary(parentDict);
      ritorno;
    }
    const privateOffset = parentDict.getByName("Privato");
    se (!Array.isArray(privateOffset) || privateOffset.length !== 2) {
      parentDict.removeByName("Privato");
      ritorno;
    }
    dimensione costante = privateOffset[0];
    offset costante = privateOffset[1];
    se (dimensione === 0 || offset >= this.bytes.length) {
      this.emptyPrivateDictionary(parentDict);
      ritorno;
    }
    const privateDictEnd = offset + dimensione;
    const dictData = this.bytes.subarray(offset, privateDictEnd);
    const dict = this.parseDict(dictData);
    const privateDict = this.createDict(CFFPrivateDict, dict, parentDict.strings);
    parentDict.privateDict = privateDict;
    se (privateDict.getByName("Fattore di espansione") === 0) {
      privateDict.setByName("Fattore di espansione", 0,06);
    }
    se (!privateDict.getByName("Subrs")) {
      ritorno;
    }
    const subrsOffset = privateDict.getByName("Subrs");
    const relativeOffset = offset + subrsOffset;
    se (subrsOffset === 0 || relativeOffset >= this.bytes.length) {
      this.emptyPrivateDictionary(parentDict);
      ritorno;
    }
    const subrsIndex = this.parseIndex(relativeOffset);
    privateDict.subrsIndex = subrsIndex.obj;
  }
  parseCharsets(pos, lunghezza, stringhe, cid) {
    se (pos === 0) {
      restituisce nuovo CFFCharset(true, CFFCharsetPredefinedTypes.ISO_ADOBE, _charsets.ISOAdobeCharset);
    } altrimenti se (pos === 1) {
      restituisci nuovo CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT, _charsets.ExpertCharset);
    } altrimenti se (pos === 2) {
      restituisce nuovo CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT_SUBSET, _charsets.ExpertSubsetCharset);
    }
    const byte = questo.byte;
    const inizio = pos;
    formato costante = byte[pos++];
    const charset = [cid ? 0 : ".notdef"];
    lascia id, conteggio, i;
    lunghezza -= 1;
    cambia (formato) {
      caso 0:
        per (i = 0; i < lunghezza; i++) {
          id = byte[pos++] << 8 | byte[pos++];
          charset.push(cid ? id : stringhe.get(id));
        }
        rottura;
      caso 1:
        while (charset.length <= length) {
          id = byte[pos++] << 8 | byte[pos++];
          conteggio = byte[pos++];
          per (i = 0; i <= conteggio; i++) {
            charset.push(cid ? id++ : strings.get(id++));
          }
        }
        rottura;
      caso 2:
        while (charset.length <= length) {
          id = byte[pos++] << 8 | byte[pos++];
          conteggio = byte[pos++] << 8 | byte[pos++];
          per (i = 0; i <= conteggio; i++) {
            charset.push(cid ? id++ : strings.get(id++));
          }
        }
        rottura;
      predefinito:
        throw new _util.FormatError("Formato del set di caratteri sconosciuto");
    }
    const end = pos;
    const raw = bytes.subarray(inizio, fine);
    restituisci nuovo CFFCharset(false, formato, charset, raw);
  }
  parseEncoding(pos, proprietà, stringhe, charset) {
    codifica costante = Object.create(null);
    const byte = questo.byte;
    lascia predefinito = falso;
    lascia il formato, i, ii;
    lascia raw = null;
    funzione readSupplement() {
      const supplementsCount = bytes[pos++];
      per (i = 0; i < conteggiosupplementi; i++) {
        codice costante = byte[pos++];
        const sid = (byte[pos++] << 8) + (byte[pos++] & 0xff);
        codifica[codice] = charset.indexOf(stringhe.get(sid));
      }
    }
    se (pos === 0 || pos === 1) {
      predefinito = vero;
      formato = pos;
      const baseEncoding = pos ? _encodings.ExpertEncoding : _encodings.StandardEncoding;
      per (i = 0, ii = charset.length; i < ii; i++) {
        indice costante = baseEncoding.indexOf(charset[i]);
        se (indice !== -1) {
          codifica[indice] = i;
        }
      }
    } altro {
      const dataStart = pos;
      formato = byte[pos++];
      cambia (formato e 0x7f) {
        caso 0:
          const glyphsCount = bytes[pos++];
          per (i = 1; i <= glyphsCount; i++) {
            codifica[byte[pos++]] = i;
          }
          rottura;
        caso 1:
          const rangesCount = byte[pos++];
          lascia gid = 1;
          per (i = 0; i < rangesCount; i++) {
            const inizio = byte[pos++];
            const left = byte[pos++];
            per (lascia che j = inizio; j <= inizio + sinistra; j++) {
              codifica[j] = gid++;
            }
          }
          rottura;
        predefinito:
          throw new _util.FormatError(`Formato di codifica sconosciuto: ${format} in CFF`);
      }
      const dataEnd = pos;
      se (formato & 0x80) {
        byte[dataStart] &= 0x7f;
        readSupplement();
      }
      raw = bytes.subarray(dataStart, dataEnd);
    }
    formato &= 0x7f;
    restituisci nuovo CFFEncoding(predefinito, formato, codifica, raw);
  }
  parseFDSelect(pos, lunghezza) {
    const byte = questo.byte;
    formato costante = byte[pos++];
    const fdSelect = [];
    lascia che io;
    cambia (formato) {
      caso 0:
        per (i = 0; i < lunghezza; ++i) {
          const id = byte[pos++];
          fdSelect.push(id);
        }
        rottura;
      caso 3:
        const rangesCount = byte[pos++] << 8 | byte[pos++];
        per (i = 0; i < rangesCount; ++i) {
          lascia primo = byte[pos++] << 8 | byte[pos++];
          se (i === 0 e primo !== 0) {
            (0, _util.warn)("parseFDSelect: il primo intervallo deve avere un primo GID di 0" + " -- tentativo di recupero.");
            primo = 0;
          }
          const fdIndex = byte[pos++];
          const next = byte[pos] << 8 | byte[pos + 1];
          per (lascia che j = primo; j < successivo; ++j) {
            fdSelect.push(fdIndex);
          }
        }
        posizione += 2;
        rottura;
      predefinito:
        throw new _util.FormatError(`parseFDSelect: Formato sconosciuto "${format}".`);
    }
    se (fdSelect.length !== lunghezza) {
      throw new _util.FormatError("parseFDSelect: dati del font non validi.");
    }
    restituisci nuovo CFFFDSelect(formato, fdSelect);
  }
}
esportazioni.CFFParser = CFFParser;
classe CFF {
  costruttore() {
    questo.intestazione = null;
    questo.nomi = [];
    this.topDict = null;
    this.strings = new CFFStrings();
    this.globalSubrIndex = null;
    this.encoding = null;
    questo.set di caratteri = null;
    this.charStrings = null;
    questo.fdArray = [];
    this.fdSelect = null;
    this.isCIDFont = false;
  }
  duplicateFirstGlyph() {
    se (this.charStrings.count >= 65535) {
      (0, _util.warn)("Spazio insufficiente nelle stringhe di caratteri per duplicare il primo glifo.");
      ritorno;
    }
    const glyphZero = this.charStrings.get(0);
    this.charStrings.add(glyphZero);
    se (questo.èCIDFont) {
      questo.fdSelect.fdSelect.push(questo.fdSelect.fdSelect[0]);
    }
  }
  haGlyphId(id) {
    se (id < 0 || id >= this.charStrings.count) {
      restituisci falso;
    }
    const glyph = this.charStrings.get(id);
    restituisci glyph.length > 0;
  }
}
esportazioni.CFF = CFF;
classe CFFHeader {
  costruttore(principale, minore, hdrSize, offSize) {
    questo.maggiore = maggiore;
    questo.minore = minore;
    this.hdrSize = hdrSize;
    this.offSize = offSize;
  }
}
esportazioni.CFFHeader = CFFHeader;
classe CFFStrings {
  costruttore() {
    questa.stringa = [];
  }
  ottieni(indice) {
    se (indice >= 0 e indice <= NUM_STANDARD_CFF_STRINGS - 1) {
      restituisci CFFStandardStrings[indice];
    }
    se (indice - NUM_STANDARD_CFF_STRINGS <= lunghezza_stringhe) {
      restituisci questo.stringhe[indice - NUM_STANDARD_CFF_STRINGS];
    }
    restituisci CFFStandardStrings[0];
  }
  getSID(str) {
    lascia indice = CFFStandardStrings.indexOf(str);
    se (indice !== -1) {
      indice di ritorno;
    }
    indice = this.strings.indexOf(str);
    se (indice !== -1) {
      restituisci indice + NUM_STANDARD_CFF_STRINGS;
    }
    restituisci -1;
  }
  aggiungi(valore) {
    this.strings.push(valore);
  }
  ottieni conteggio() {
    restituisci questa lunghezza delle stringhe;
  }
}
esportazioni.CFFStrings = CFFStrings;
classe CFFIndex {
  costruttore() {
    questo.oggetto = [];
    questa.lunghezza = 0;
  }
  aggiungi(dati) {
    questa.lunghezza += lunghezza.dati;
    questo.oggetti.push(dati);
  }
  set(indice, dati) {
    questa.lunghezza += lunghezza.dati - questo.oggetti[indice].lunghezza;
    questo.oggetti[indice] = dati;
  }
  ottieni(indice) {
    restituisci questo.oggetti[indice];
  }
  ottieni conteggio() {
    restituisci questa lunghezza degli oggetti;
  }
}
esportazioni.CFFIndex = CFFIndex;
classe CFFDict {
  costruttore(tabelle, stringhe) {
    this.keyToNameMap = tables.keyToNameMap;
    this.nameToKeyMap = tables.nameToKeyMap;
    questo.predefinito = tabelle.predefinite;
    questo.tipi = tabelle.tipi;
    questo.opcodes = tabelle.opcodes;
    questo.ordine = tabelle.ordine;
    questo.stringhe = stringhe;
    questo.valori = Object.create(null);
  }
  setByKey(chiave, valore) {
    se (!(chiave in this.keyToNameMap)) {
      restituisci falso;
    }
    se (valore.lunghezza === 0) {
      restituisci vero;
    }
    per (valore costante del valore) {
      se (isNaN(val)) {
        (0, _util.warn)(`Valore CFFDict non valido: "${value}" per la chiave "${key}".`);
        restituisci vero;
      }
    }
    const tipo = this.types[chiave];
    se (tipo === "num" || tipo === "sid" || tipo === "offset") {
      valore = valore[0];
    }
    questo.valori[chiave] = valore;
    restituisci vero;
  }
  setByName(nome, valore) {
    se (!(nome in this.nameToKeyMap)) {
      throw new _util.FormatError(`Nome del dizionario non valido "${name}"`);
    }
    questo.valori[questo.nomeToKeyMap[nome]] = valore;
  }
  hasName(nome) {
    restituisci this.nameToKeyMap[name] in this.values;
  }
  getByName(nome) {
    se (!(nome in this.nameToKeyMap)) {
      throw new _util.FormatError(`Nome del dizionario non valido ${name}"`);
    }
    const key = this.nameToKeyMap[nome];
    se (!(chiave in questo.valori)) {
      restituisci this.defaults[chiave];
    }
    restituisci questo.valori[chiave];
  }
  removeByName(nome) {
    elimina questo.valori[questo.nomeToKeyMap[nome]];
  }
  statico createTables(layout) {
    tabelle costanti = {
      keyToNameMap: {},
      nomeToKeyMap: {},
      valori predefiniti: {},
      tipi: {},
      codici operativi: {},
      ordine: []
    };
    per (voce costante del layout) {
      const key = Array.isArray(entry[0]) ? (entry[0][0] << 8) + entry[0][1] : entry[0];
      tables.keyToNameMap[chiave] = voce[1];
      tables.nameToKeyMap[entry[1]] = chiave;
      tabelle.tipi[chiave] = voce[2];
      tabelle.defaults[chiave] = voce[3];
      tabelle.opcodes[chiave] = Array.isArray(voce[0]) ? voce[0] : [voce[0]];
      tabelle.ordine.push(chiave);
    }
    tabelle di ritorno;
  }
}
const CFFTopDictLayout = [[[12, 30], "ROS", ["sid", "sid", "num"], null], [[12, 20], "SyntheticBase", "num", null], [0, "versione", "sid", null], [1, "Avviso", "sid", null], [[12, 0], "Copyright", "sid", null], [2, "FullName", "sid", null], [3, "FamilyName", "sid", null], [4, "Weight", "sid", null], [[12, 1], "isFixedPitch", "num", 0], [[12, 2], "ItalicAngle", "num", 0], [[12, 3], "UnderlinePosition", "num", -100], [[12, 4], "UnderlineThickness", "num", 50], [[12, 5], "PaintType", "num", 0], [[12, 6], "CharstringType", "num", 2], [[12, 7], "FontMatrix", ["num", "num", "num", "num", "num", "num"], [0.001, 0, 0, 0.001, 0, 0]], [13, "UniqueID", "num", null], [5, "FontBBox", ["num", "num", "num", "num"], [0, 0, 0, 0]], [[12, 8], "StrokeWidth", "num", 0], [14, "XUID", "array", null], [15, "charset", "offset", 0], [16, "Codifica", "offset", 0], [17, "StringheCaratteri", "offset", 0], [18, "Privato", ["offset", "offset"], null], [[12, 21], "PostScript", "sid", null], [[12, 22], "NomeFontBase", "sid", null], [[12, 23], "BlendFontBase", "delta", null], [[12, 31], "VersioneCIDFont", "num", 0], [[12, 32], "RevisioneCIDFont", "num", 0], [[12, 33], "TipoCIDFont", "num", 0], [[12, 34], "CountCIDCount", "num", 8720], [[12, 35], "BaseUID", "num", null], [[12, 37], "SelezioneFD", "offset", null], [[12, 36], "FDArray", "offset", null], [[12, 38], "FontName", "sid", null]];
classe CFFTopDict estende CFFDict {
  tabelle statiche get() {
    return (0, _util.shadow)(this, "tabelle", this.createTables(CFFTopDictLayout));
  }
  costruttore(stringhe) {
    super(CFFTopDict.tabelle, stringhe);
    this.privateDict = null;
  }
}
esportazioni.CFFTopDict = CFFTopDict;
const CFFPrivateDictLayout = [[6, "BlueValues", "delta", null], [7, "OtherBlues", "delta", null], [8, "FamilyBlues", "delta", null], [9, "FamilyOtherBlues", "delta", null], [[12, 9], "BlueScale", "num", 0,039625], [[12, 10], "BlueShift", "num", 7], [[12, 11], "BlueFuzz", "num", 1], [10, "StdHW", "num", null], [11, "StdVW", "num", null], [[12, 12], "StemSnapH", "delta", null], [[12, 13], "StemSnapV", "delta", null], [[12, 14], "ForceBold", "num", 0], [[12, 17], "LanguageGroup", "num", 0], [[12, 18], "ExpansionFactor", "num", 0,06], [[12, 19], "initialRandomSeed", "num", 0], [20, "defaultWidthX", "num", 0], [21, "nominalWidthX", "num", 0], [19, "Subrs", "offset", null]];
classe CFFPrivateDict estende CFFDict {
  tabelle statiche get() {
    return (0, _util.shadow)(this, "tabelle", this.createTables(CFFPrivateDictLayout));
  }
  costruttore(stringhe) {
    super(CFFPrivateDict.tables, stringhe);
    this.subrsIndex = null;
  }
}
esportazioni.CFFPrivateDict = CFFPrivateDict;
const CFFCharsetPredefinedTypes = {
  ISO_ADOBE: 0,
  ESPERTO: 1,
  EXPERT_SUBSET: 2
};
classe CFFCharset {
  costruttore(predefinito, formato, set di caratteri, raw) {
    this.predefined = predefinito;
    this.format = formato;
    questo.set di caratteri = set di caratteri;
    this.raw = grezzo;
  }
}
esportazioni.CFFCharset = CFFCharset;
classe CFFEncoding {
  costruttore(predefinito, formato, codifica, raw) {
    this.predefined = predefinito;
    this.format = formato;
    this.encoding = codifica;
    this.raw = grezzo;
  }
}
classe CFFFDFeleziona {
  costruttore(formato, fdSelect) {
    this.format = formato;
    questo.fdSelect = fdSelect;
  }
  getFDIndex(indiceglifo) {
    se (glyphIndex < 0 || glyphIndex >= this.fdSelect.length) {
      restituisci -1;
    }
    restituisci questo.fdSelect[glyphIndex];
  }
}
esportazioni.CFFFDSelect = CFFFDSelect;
classe CFFOffsetTracker {
  costruttore() {
    questo.offset = Object.create(null);
  }
  isTracking(chiave) {
    tasto di ritorno in this.offsets;
  }
  traccia(chiave, posizione) {
    se (chiave in this.offsets) {
      throw new _util.FormatError(`Già tracciamento della posizione di ${key}`);
    }
    this.offsets[key] = posizione;
  }
  offset(valore) {
    per (chiave costante in this.offsets) {
      this.offsets[chiave] += valore;
    }
  }
  setEntryLocation(chiave, valori, output) {
    se (!(chiave in questo.offset)) {
      throw new _util.FormatError(`Non viene tracciata la posizione di ${key}`);
    }
    const data = output.data;
    const dataOffset = this.offsets[chiave];
    dimensione costante = 5;
    per (lascia che i = 0, ii = valori.lunghezza; i < ii; ++i) {
      const offset0 = i * dimensione + dataOffset;
      const offset1 = offset0 + 1;
      const offset2 = offset0 + 2;
      const offset3 = offset0 + 3;
      const offset4 = offset0 + 4;
      se (dati[offset0] !== 0x1d || dati[offset1] !== 0 || dati[offset2] !== 0 || dati[offset3] !== 0 || dati[offset4] !== 0) {
        throw new _util.FormatError("scrittura su un offset che non è vuoto");
      }
      valore costante = valori[i];
      dati[offset0] = 0x1d;
      dati[offset1] = valore >> 24 & 0xff;
      dati[offset2] = valore >> 16 & 0xff;
      dati[offset3] = valore >> 8 & 0xff;
      dati[offset4] = valore & 0xff;
    }
  }
}
classe CFFCompiler {
  costruttore(cff) {
    questo.cff = cff;
  }
  compila() {
    const cff = this.cff;
    output costante = {
      dati: [],
      lunghezza: 0,
      aggiungi(dati) {
        Tentativo {
          questo.dati.push(...dati);
        } presa {
          questo.dato = questo.dato.concat(dati);
        }
        questa.lunghezza = questa.lunghezza.dati;
      }
    };
    const header = this.compileHeader(cff.header);
    output.add(intestazione);
    const nameIndex = this.compileNameIndex(cff.names);
    output.add(nomeIndice);
    se (cff.isCIDFont) {
      se (cff.topDict.hasName("FontMatrix")) {
        const base = cff.topDict.getByName("FontMatrix");
        cff.topDict.removeByName("FontMatrix");
        per (const subDict di cff.fdArray) {
          lascia matrice = base.slice(0);
          se (subDict.hasName("FontMatrix")) {
            matrice = _util.Util.transform(matrice, subDict.getByName("FontMatrix"));
          }
          subDict.setByName("FontMatrix", matrix);
        }
      }
    }
    const xuid = cff.topDict.getByName("XUID");
    se (xuid?.length > 16) {
      cff.topDict.removeByName("XUID");
    }
    cff.topDict.setByName("set di caratteri", 0);
    lascia compilato = this.compileTopDicts([cff.topDict], output.length, cff.isCIDFont);
    output.add(compilato.output);
    const topDictTracker = compiled.trackers[0];
    const stringIndex = this.compileStringIndex(cff.strings.strings);
    output.add(stringIndex);
    const globalSubrIndex = this.compileIndex(cff.globalSubrIndex);
    output.add(globalSubrIndex);
    se (cff.encoding && cff.topDict.hasName("Codifica")) {
      se (cff.encoding.predefined) {
        topDictTracker.setEntryLocation("Codifica", [cff.encoding.format], output);
      } altro {
        codifica costante = this.compileEncoding(cff.encoding);
        topDictTracker.setEntryLocation("Codifica", [output.length], output);
        output.add(codifica);
      }
    }
    const charset = this.compileCharset(cff.charset, cff.charStrings.count, cff.strings, cff.isCIDFont);
    topDictTracker.setEntryLocation("charset", [output.length], output);
    output.add(charset);
    const charStrings = this.compileCharStrings(cff.charStrings);
    topDictTracker.setEntryLocation("Stringhe di caratteri", [output.length], output);
    output.add(charStrings);
    se (cff.isCIDFont) {
      topDictTracker.setEntryLocation("FDSelect", [output.length], output);
      const fdSelect = this.compileFDSelect(cff.fdSelect);
      output.add(fdSelect);
      compilato = this.compileTopDicts(cff.fdArray, output.length, true);
      topDictTracker.setEntryLocation("FDArray", [output.length], output);
      output.add(compilato.output);
      const fontDictTrackers = compiled.trackers;
      this.compilePrivateDicts(cff.fdArray, fontDictTrackers, output);
    }
    this.compilePrivateDicts([cff.topDict], [topDictTracker], output);
    output.add([0]);
    restituisci output.data;
  }
  encodeNumber(valore) {
    se (Numero.èIntero(valore)) {
      restituisci this.encodeInteger(valore);
    }
    restituisci this.encodeFloat(valore);
  }
  statico ottieni EncodeFloatRegExp() {
    return (0, _util.shadow)(this, "EncodeFloatRegExp", /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/);
  }
  codificaFloat(num) {
    lascia valore = num.toString();
    const m = CFFCompiler.EncodeFloatRegExp.exec(valore);
    se (m) {
      const epsilon = parseFloat("1e" + ((m[2] ? +m[2] : 0) + m[1].length));
      valore = (Math.round(num * epsilon) / epsilon).toString();
    }
    lascia che i bocconcini = "";
    sia i, ii;
    per (i = 0, ii = valore.lunghezza; i < ii; ++i) {
      const a = valore[i];
      se (a === "e") {
        nibbles += valore[++i] === "-" ? "c" : "b";
      } altrimenti se (a === ".") {
        stuzzichini += "a";
      } altrimenti se (a === "-") {
        stuzzichini += "e";
      } altro {
        stuzzichini += a;
      }
    }
    nibbles += nibbles.length & 1 ? "f" : "ff";
    costante fuori = [30];
    per (i = 0, ii = nibbles.length; i < ii; i += 2) {
      out.push(parseInt(nibbles.substring(i, i + 2), 16));
    }
    tornare fuori;
  }
  encodeInteger(valore) {
    lascia il codice;
    se (valore >= -107 e valore <= 107) {
      codice = [valore + 139];
    } altrimenti se (valore >= 108 e valore <= 1131) {
      valore -= 108;
      codice = [(valore >> 8) + 247, valore & 0xff];
    } altrimenti se (valore >= -1131 e valore <= -108) {
      valore = -valore - 108;
      codice = [(valore >> 8) + 251, valore & 0xff];
    } altrimenti se (valore >= -32768 e valore <= 32767) {
      codice = [0x1c, valore >> 8 & 0xff, valore & 0xff];
    } altro {
      codice = [0x1d, valore >> 24 e 0xff, valore >> 16 e 0xff, valore >> 8 e 0xff, valore e 0xff];
    }
    codice di ritorno;
  }
  compileHeader(intestazione) {
    restituisci [intestazione.principale, intestazione.minore, 4, intestazione.offSize];
  }
  compileNameIndex(nomi) {
    const nameIndex = new CFFIndex();
    per (const nome dei nomi) {
      lunghezza costante = Math.min(nome.lunghezza, 127);
      lascia sanitizedName = new Array(length);
      per (lascia che j = 0; j < lunghezza; j++) {
        lascia che char = nome[j];
        se (char < "!" || char > "~" || char === "[" || char === "]" || char === "(" || char === ")" || char === "{" || char === "}" || char === "<" || char === ">" || char === "/" || char === "%") {
          carattere = "_";
        }
        Nomesanificato[j] = char;
      }
      NomeIgienizzato = NomeIgienizzato.join("");
      se (sanitizedName === "") {
        sanitizedName = "Nome_carattere_errato";
      }
      nameIndex.add((0, _util.stringToBytes)(sanitizedName));
    }
    restituisci this.compileIndex(nameIndex);
  }
  compileTopDicts(dicts, lunghezza, removeCidKeys) {
    const fontDictTrackers = [];
    lascia fdArrayIndex = new CFFIndex();
    per (const fontDict di dizionari) {
      se (rimuoviCidKeys) {
        fontDict.removeByName("CIDFontVers ion");
        fontDict.removeByName("CIDFontRevision");
        fontDict.removeByName("CIDFontType");
        fontDict.removeByName("CIDCount");
        fontDict.removeByName("UIDBase");
      }
      const fontDictTracker = new CFFOffsetTracker();
      const fontDictData = this.compileDict(fontDict, fontDictTracker);
      fontDictTrackers.push(fontDictTracker);
      fdArrayIndex.add(fontDictData);
      fontDictTracker.offset(lunghezza);
    }
    fdArrayIndex = this.compileIndex(fdArrayIndex, fontDictTrackers);
    ritorno {
      tracker: fontDictTrackers,
      output: fdArrayIndex
    };
  }
  compilePrivateDicts(dicts, tracker, output) {
    per (lascia che i = 0, ii = dicts.length; i < ii; ++i) {
      const fontDict = dicts[i];
      const privateDict = fontDict.privateDict;
      se (!privateDict || !fontDict.hasName("Privato")) {
        throw new _util.FormatError("Deve esserci un dizionario privato.");
      }
      const privateDictTracker = new CFFOffsetTracker();
      const privateDictData = this.compileDict(privateDict, privateDictTracker);
      lascia outputLength = output.length;
      privateDictTracker.offset(outputLength);
      se (!privateDictData.length) {
        lunghezzaoutput = 0;
      }
      trackers[i].setEntryLocation("Privato", [privateDictData.length, outputLength], output);
      output.add(privateDictData);
      se (privateDict.subrsIndex && privateDict.hasName("Subrs")) {
        const subrs = this.compileIndex(privateDict.subrsIndex);
        privateDictTracker.setEntryLocation("Subrs", [privateDictData.length], output);
        output.add(subrs);
      }
    }
  }
  compileDict(dict, offsetTracker) {
    costante fuori = [];
    per (chiave costante di dict.order) {
      se (!(chiave in dict.values)) {
        continuare;
      }
      lascia valori = dict.values[chiave];
      lascia tipi = dict.types[chiave];
      se (!Array.isArray(tipi)) {
        tipi = [tipi];
      }
      se (!Array.isArray(valori)) {
        valori = [valori];
      }
      se (valori.lunghezza === 0) {
        continuare;
      }
      per (lascia che j = 0, jj = tipi.lunghezza; j < jj; ++j) {
        const tipo = tipi[j];
        valore costante = valori[j];
        interruttore (tipo) {
          caso "num":
          caso "sid":
            out.push(...this.encodeNumber(value));
            rottura;
          caso "offset":
            const name = dict.keyToNameMap[chiave];
            se (!offsetTracker.isTracking(nome)) {
              offsetTracker.track(nome, lunghezza uscita);
            }
            out.push(0x1d, 0, 0, 0, 0);
            rottura;
          caso "array":
          caso "delta":
            out.push(...this.encodeNumber(value));
            per (lascia che k = 1, kk = valori.lunghezza; k < kk; ++k) {
              out.push(...this.encodeNumber(values[k]));
            }
            rottura;
          predefinito:
            throw new _util.FormatError(`Tipo di dati sconosciuto di ${type}`);
        }
      }
      out.push(...dict.opcodes[chiave]);
    }
    tornare fuori;
  }
  compileStringIndex(stringhe) {
    const stringIndex = new CFFIndex();
    per (stringa costante di stringhe) {
      stringIndex.add((0, _util.stringToBytes)(stringa));
    }
    restituisci this.compileIndex(stringIndex);
  }
  compileCharStrings(charStrings) {
    const charStringsIndex = new CFFIndex();
    per (lascia che i = 0; i < charStrings.count; i++) {
      const glyph = charStrings.get(i);
      se (glifo.lunghezza === 0) {
        charStringsIndex.add(new Uint8Array([0x8b, 0x0e]));
        continuare;
      }
      charStringsIndex.add(glifo);
    }
    restituisci this.compileIndex(charStringsIndex);
  }
  compileCharset(charset, numGlyphs, stringhe, isCIDFont) {
    lasciare uscire;
    const numGlyphsLessNotDef = numGlyphs - 1;
    se (isCIDFont) {
      fuori = nuovo Uint8Array([2, 0, 0, numGlyphsLessNotDef >> 8 & 0xff, numGlyphsLessNotDef & 0xff]);
    } altro {
      lunghezza costante = 1 + numGlyphsLessNotDef * 2;
      out = new Uint8Array(lunghezza);
      fuori[0] = 0;
      lascia charsetIndex = 0;
      const numCharsets = charset.charset.length;
      lascia avvisato = falso;
      per (lascia che i = 1; i < out.length; i += 2) {
        lascia sid = 0;
        se (charsetIndex < numCharsets) {
          const nome = charset.charset[charsetIndex++];
          sid = stringhe.getSID(nome);
          se (sid === -1) {
            lato = 0;
            se (!avvertito) {
              avvertito = vero;
              (0, _util.warn)(`Impossibile trovare ${name} nelle stringhe CFF`);
            }
          }
        }
        out[i] = sid >> 8 & 0xff;
        out[i + 1] = sid & 0xff;
      }
    }
    restituisci this.compileTypedArray(out);
  }
  compileEncoding(codifica) {
    restituisci this.compileTypedArray(encoding.raw);
  }
  compileFDSelect(fdSelect) {
    const format = fdSelect.format;
    lasciare uscire, io;
    cambia (formato) {
      caso 0:
        fuori = nuovo Uint8Array(1 + fdSelect.fdSelect.length);
        out[0] = formato;
        per (i = 0; i < fdSelect.fdSelect.length; i++) {
          out[i + 1] = fdSelect.fdSelect[i];
        }
        rottura;
      caso 3:
        const inizio = 0;
        lascia lastFD = fdSelect.fdSelect[0];
        const ranges = [formato, 0, 0, inizio >> 8 e 0xff, inizio e 0xff, lastFD];
        per (i = 1; i < fdSelect.fdSelect.length; i++) {
          const currentFD = fdSelect.fdSelect[i];
          se (FDcorrente !== ultimoFD) {
            ranges.push(i >> 8 & 0xff, i & 0xff, currentFD);
            ultimoFD = attualeFD;
          }
        }
        const numRanges = (ranges.length - 3) / 3;
        intervalli[1] = numIntervalli >> 8 & 0xff;
        intervalli[2] = numIntervalli & 0xff;
        intervalli.push(i >> 8 & 0xff, i & 0xff);
        fuori = nuovo Uint8Array(intervalli);
        rottura;
    }
    restituisci this.compileTypedArray(out);
  }
  compileTypedArray(dati) {
    restituisci Array.from(dati);
  }
  compileIndex(indice, tracker = []) {
    const oggetti = indice.oggetti;
    const count = oggetti.lunghezza;
    se (conteggio === 0) {
      ritorno [0, 0];
    }
    const data = [conteggio >> 8 & 0xff, conteggio & 0xff];
    lascia lastOffset = 1,
      io;
    per (i = 0; i < conteggio; ++i) {
      lastOffset += oggetti[i].lunghezza;
    }
    lascia offsetSize;
    se (ultimoOffset < 0x100) {
      offsetSize = 1;
    } altrimenti se (lastOffset < 0x10000) {
      offsetSize = 2;
    } altrimenti se (lastOffset < 0x1000000) {
      offsetSize = 3;
    } altro {
      offsetSize = 4;
    }
    dati.push(offsetSize);
    lascia relativeOffset = 1;
    per (i = 0; i < conteggio + 1; i++) {
      se (offsetSize === 1) {
        dati.push(offset relativo & 0xff);
      } altrimenti se (offsetSize === 2) {
        dati.push(offset relativo >> 8 & 0xff, offset relativo & 0xff);
      } altrimenti se (offsetSize === 3) {
        dati.push(offset relativo >> 16 e 0xff, offset relativo >> 8 e 0xff, offset relativo e 0xff);
      } altro {
        dati.push(relativeOffset >>> 24 & 0xff, relativeOffset >> 16 & 0xff, relativeOffset >> 8 & 0xff, relativeOffset & 0xff);
      }
      se (oggetti[i]) {
        relativeOffset += oggetti[i].lunghezza;
      }
    }
    per (i = 0; i < conteggio; i++) {
      se (trackers[i]) {
        trackers[i].offset(data.length);
      }
      dati.push(...oggetti[i]);
    }
    restituire i dati;
  }
}
esportazioni.CFFCompiler = CFFCompiler;

/***/ }),
/* 36 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
esportazioni.ISOAdobeCharset = esportazioni.ExpertSubsetCharset = esportazioni.ExpertCharset = void 0;
const ISOAdobeCharset = [".notdef", "spazio", "punto esclamativo", "quotedbl", "numero", "dollaro", "percentuale", "e commerciale", "quoteright", "parentesi a sinistra", "parentesi a destra", "asterisco", "più", "virgola", "trattino", "punto", "barra", "zero", "uno", "due", "tre", "quattro", "cinque", "sei", "sette", "otto", "nove", "due punti", "punto e virgola", "minore", "uguale", "maggiore", "domanda", "a", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "parentesi a sinistra", "barra rovesciata", "parentesi a destra", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "flowerin", "section", "curency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellissi", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth","mezzo", "piùmeno", "spina", "un quarto", "divide", "barra rotta", "grado", "spina", "tre quarti", "due superiori", "registrato", "meno", "eth", "moltiplica", "tre superiori", "copyright", "Aacute", "Acirconflesso", "Adieresi", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecirconflesso", "Edieresi", "Egrave", "Iacute", "Icirconflesso", "Idieresi", "Igrave", "Ntilde", "Oacute", "Ocirconflesso", "Odieresi", "Ograve", "Otilde", "Scaron", "Uacute", "Ucirconflesso", "Udieresi", "Ugrave", "Yacute", "Ydieresi", "Zcaron", "aacute", "acirconflesso", "adieresi", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"];"ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"];"ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"];
esportazioni.ISOAdobeCharset = ISOAdobeCharset;
const ExpertCharset = [".notdef", "spazio", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parentesi sinistra superiore", "parentesi destra superiore", "due punti leader", "uno punto leader", "virgola", "trattino", "punto", "frazione", "zerooldstyle", "unooldstyle", "dueoldstyle", "treoldstyle", "quattrooldstyle", "cinqueoldstyle", "seioldstyle", "setteoldstyle", "ottooldstyle", "noveoldstyle", "due punti", "punto e virgola", "virgolasuperiore", "trequartisemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parente inferiore sinistra", "parente inferiore destra", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "eveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior","quattroinferiore", "cinqueinferiore", "seiinferiore", "setteinferiore", "ottoinferiore", "noveinferiore", "centoinferiore", "dollaroinferiore", "periodoinferiore", "cominferiore", "Agravepiccolo", "Aacutepiccolo", "Acircumflexpiccolo", "Atildepiccolo", "Adieresipiccolo", "Aringpiccolo", "AEpiccolo", "Ccedillapiccolo", "Egravepiccolo", "Eacutepiccolo", "Ecircumflexpiccolo", "Edieresipiccolo", "Igravepiccolo", "Iacutepiccolo", "Icircumflexpiccolo", "Idieresipiccolo", "Ethpiccolo", "Ntildepiccolo", "Ogravepiccolo", "Oacutepiccolo", "Ocircumflexpiccolo", "Otildepiccolo", "Odieresipiccolo", "OEpiccolo", "Oslashpiccolo", "Ugravepiccolo", "Uacutepiccolo", "Ucircumflexpiccolo", "Udieresipiccolo", "Yacutepiccolo", "Thornsmall", "Ydieresissmall"];
esportazioni.ExpertCharset = ExpertCharset;
const ExpertSubsetCharset = [".notdef", "spazio", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "virgola", "trattino", "punto", "frazione", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "due punti", "punto e virgola", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parente inferiore sinistra", "parente inferiore destra", "trattino superiore", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "trattino inferiore", "un quarto", "un mezzo", "tre quarti", "un ottavo", "tre ottavi", "cinque ottavi", "sette ottavi", "un terzo", "due terzi", "zero superiore", "uno superiore", "due superiore", "tre superiore", "quattro superiore", "cinque superiore", "sei superiore", "sette superiore", "otto superiore", "nove superiore", "zero inferiore", "uno inferiore", "due inferiore", "tre inferiore", "quattro inferiore", "cinque inferiore", "sei inferiore", "sette inferiore", "otto inferiore", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"];
esportazioni.ExpertSubsetCharset = ExpertSubsetCharset;

/***/ }),
/* 37 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
exports.ZapfDingbatsEncoding = exports.WinAnsiEncoding = exports.SymbolSetEncoding = exports.StandardEncoding = exports.MacRomanEncoding = exports.ExpertEncoding = void 0;
esportazioni.getEncoding = getEncoding;
const ExpertEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "spazio", "punto esclamapiccolo", "Hungarumlautpiccolo", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parentesi sinistra superiore", "parentesi destra superiore", "due punti leader", "uno punto leader", "virgola", "trattino", "punto", "frazione", "zerooldstyle", "unooldstyle", "dueoldstyle", "treoldstyle", "quattrooldstyle", "cinqueoldstyle", "seioldstyle", "setteoldstyle", "ottooldstyle", "noveoldstyle", "due punti", "punto e virgola", "virgola superiore", "trequarti trattino", "punto superiore", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parentesiinferioresinistra", "", "parentesiinferioredestra", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "","", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "unquarto", "unametà", "trequarti", "questiondownsmall", "unottavo", "treottavi", "cinqueottavi", "setteottavi", "unterzo", "dueterzi", "", "", "zerosuperior", "unosuperior", "duesuperior", "tresuperior", "quattrosuperior", "cinquesuperior", "seisuperior", "settesuperior", "ottosuperior", "novesuperiore", "zeroinferiore", "unoinferiore", "dueinferiore", "treinferiore", "quattroinferiore", "cinqueinferiore", "seiinferiore", "setteinferiore", "ottoinferiore", "noveinferiore", "centoinferiore", "dollaroinferiore", "periodoinferiore", "cominferiore", "Agravepiccolo", "Aacutepiccolo", "Acircumflexpiccolo", "Atildepiccolo", "Adieresipiccolo", "Aringpiccolo", "AEpiccolo", "Ccedillapiccolo", "Egravepiccolo", "Eacutepiccolo", "Ecircumflexpiccolo", "Edieresipiccolo", "Igravepiccolo", "Iacutepiccolo", "Icircumflexpiccolo", "Idieresipiccolo", "Ethpiccolo", "Ntildepiccolo", "Ogravepiccolo", "Oacutepiccolo", "Ocircumflexpiccolo", "Otildepiccolo", "Odieresipiccolo", "OEpiccolo", "Oslashpiccolo", "Ugravepiccolo", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];"tre quarti", "questiondownsmall", "un ottavo", "tre ottavi", "cinque ottavi", "sette ottavi", "un terzo", "due terzi", "", "", "", "zerosuperior", "unosuperior", "duesuperior", "tresuperior", "quattrosuperior", "cinquesuperior", "seisuperior", "settesuperior", "ottosuperior", "novesuperior", "zeroinferior", "unoinferior", "dueinferior", "treinferior", "quattroinferior", "cinqueinferior", "seinferior", "setteinferior", "ottoinferior", "noveinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];"tre quarti", "questiondownsmall", "un ottavo", "tre ottavi", "cinque ottavi", "sette ottavi", "un terzo", "due terzi", "", "", "", "zerosuperior", "unosuperior", "duesuperior", "tresuperior", "quattrosuperior", "cinquesuperior", "seisuperior", "settesuperior", "ottosuperior", "novesuperior", "zeroinferior", "unoinferior", "dueinferior", "treinferior", "quattroinferior", "cinqueinferior", "seinferior", "setteinferior", "ottoinferior", "noveinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];"Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];"Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
esportazioni.ExpertEncoding = ExpertEncoding;
const MacExpertEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "spazio", "punto e virgola piccolo", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parentesi sinistra superiore", "parentesi destra superiore", "due punti leader", "uno dei due punti leader", "virgola", "trattino", "punto", "frazione", "zerooldstyle", "uno dei due punti leader", "due punti leader", "tre punti leader", "quattro punti leader", "cinque punti leader", "sei punti leader", "sette punti leader", "otto punti leader", "nove punti leader", "due punti", "punto e virgola", "", "tre quarti trattino", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "un quarto", "una metà", "tre quarti", "un ottavo", "tre ottavi", "cinque ottavi", "sette ottavi", "un terzo", "due terzi", "", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parente sinistra inferiore", "", "parente destra inferiore", "Circumflexsmall", "trattino inferiore", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall","Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sexinferior", "eightinferior", "eveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commaininferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "domandainbassopiccolo", "unoinferiore", "Lslashpiccolo", "", "", "", "", "", "", "Cedillapiccolo", "", "", "", "", "OEpiccolo", "figuredash", "hyphensuperior", "", "", "", "", "", "Ydieresispiccolo", "", "unosuperiore", "duesuperiore", "tresuperiore", "quattrosuperiore", "cinquesuperiore", "seisuperiore", "settesuperiore", "novesuperiore", "zerosuperiore", "", "esuperiore", "rsuperiore", "tsuperior", "", "", "isuperiore", "ssuperiore", "dsuperiore", "", "", "", "", "", "lsuperiore", "Ogonekpiccolo", "Brevepiccolo", "Macronpiccolo", "bsuperiore", "nsuperiore", "msuperiore", "virgolasuperiore", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""];"", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "evensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""];"", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "evensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""];"", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""];"", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""];
const MacRomanEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "spazio", "punto esclamativo", "quotedbl", "numero", "dollaro", "percentuale", "e commerciale", "virgolette singole", "parentesi a sinistra", "parentesi a destra", "asterisco", "più", "virgola", "trattino", "punto", "barra", "zero", "uno", "due", "tre", "quattro", "cinque", "sei", "sette", "otto", "nove", "due punti", "punto e virgola", "meno", "uguale", "maggiore", "domanda", "a", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "parentesi sinistra", "barra rovesciata", "parentesi destra", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresi", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph","germandbls", "registrato", "copyright", "marchio di fabbrica", "acuto", "dieresi", "notauguale", "AE", "Oslash", "infinito", "piùmeno", "menouguale", "maggioreuguale", "yen", "mu", "differenza parziale", "somma", "prodotto", "pi", "integrale", "ordfemminile", "ordmaschile", "Omega", "ae", "oslash", "domanda in basso", "esclamazione in basso", "logico non", "radicale", "fiorino", "approssimativamente uguale", "Delta", "guillemotsinistra", "guillemotdestra", "ellissi", "spazio", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "trattino", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "losanga", "ydieresi", "Ydieresi", "frazione", "valuta", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"];"losanga", "ydieresis", "Ydieresis", "frazione", "valuta", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acirconflesso", "Ecirconflesso", "Aacute", "Edieresis", "Egrave", "Iacute", "Icirconflesso", "Idieresis", "Igrave", "Oacute", "Ocirconflesso", "mela", "Ograve", "Uacute", "Ucirconflesso", "Ugrave", "dotlessi", "circonflesso", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"];"losanga", "ydieresis", "Ydieresis", "frazione", "valuta", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acirconflesso", "Ecirconflesso", "Aacute", "Edieresis", "Egrave", "Iacute", "Icirconflesso", "Idieresis", "Igrave", "Oacute", "Ocirconflesso", "mela", "Ograve", "Uacute", "Ucirconflesso", "Ugrave", "dotlessi", "circonflesso", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"];
esportazioni.MacRomanEncoding = MacRomanEncoding;
const StandardEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "spazio", "punto esclamativo", "quotedbl", "numero", "dollaro", "percentuale", "e commerciale", "quoteright", "parentesi sinistra", "parentesi destra", "asterisco", "più", "virgola", "trattino", "punto", "barra", "zero", "uno", "due", "tre", "quattro", "cinque", "sei", "sette", "otto", "nove", "due punti", "punto e virgola", "meno", "uguale", "maggiore", "domanda", "a", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "parentesi sinistra", "barra rovesciata", "parentesi destra", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "parentesi sinistra", "barra", "parentesi destra", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ", ... "frazione", "yen", "fiorino", "sezione", "valuta", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash","dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls", "", "", "", ""];
esportazioni.StandardEncoding = StandardEncoding;
const WinAnsiEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "spazio", "punto esclamativo", "quotedbl", "numero", "dollaro", "percentuale", "e commerciale", "virgolette singole", "parentesi a sinistra", "parentesi a destra", "asterisco", "più", "virgola", "trattino", "punto", "barra", "zero", "uno", "due", "tre", "quattro", "cinque", "sei", "sette", "otto", "nove", "due punti", "punto e virgola", "meno", "uguale", "maggiore", "domanda", "a", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen","brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "thresuperior", "acute", "mu", "paragrafo", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "un quarto", "mezzo", "tre quarti", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresi", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"];"Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"];"Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"];
esportazioni.WinAnsiEncoding = WinAnsiEncoding;
const SymbolSetEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "spazio", "punto esclamativo", "universale", "segno di numero", "esistenziale", "percentuale", "e commerciale", "tale che", "parentesi sinistra", "parentesi destra", "asterisco", "più", "virgola", "meno", "punto", "barra", "zero", "uno", "due", "tre", "quattro", "cinque", "sei", "sette", "otto", "nove", "due punti", "punto e virgola", "meno", "uguale", "maggiore", "domanda", "congruente", "Alfa", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minuto", "menouguale", "frazione", "infinito", "fiorino", "fiori", "diamante", "cuore","spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notqual", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""];"registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""];"registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""];
esportazioni.SymbolSetEncoding = SymbolSetEncoding;
const ZapfDingbatsEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "spazio", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129","a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191", ""];
esportazioni.ZapfDingbatsEncoding = ZapfDingbatsEncoding;
funzione getEncoding(encodingName) {
  switch (encodingName) {
    caso "WinAnsiEncoding":
      restituisci WinAnsiEncoding;
    caso "StandardEncoding":
      restituisci StandardEncoding;
    caso "MacRomanEncoding":
      restituisci MacRomanEncoding;
    caso "SymbolSetEncoding":
      restituisci SymbolSetEncoding;
    caso "ZapfDingbatsEncoding":
      restituisci ZapfDingbatsEncoding;
    caso "ExpertEncoding":
      restituisci ExpertEncoding;
    caso "MacExpertEncoding":
      restituisci MacExpertEncoding;
    predefinito:
      restituisci null;
  }
}

/***/ }),
/* 38 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
exports.SEAC_ANALYSIS_ENABLED = exports.MacStandardGlyphOrdering = exports.FontFlags = void 0;
esportazioni.normalizeFontName = normalizeFontName;
exports.recoverGlyphName = recoverGlyphName;
esportazioni.type1FontGlyphMapping = type1FontGlyphMapping;
var _encodings = __w_pdfjs_require__(37);
var _glyphlist = __w_pdfjs_require__(39);
var _unicode = __w_pdfjs_require__(40);
var _util = __w_pdfjs_require__(2);
const SEAC_ANALYSIS_ENABLED = true;
esportazioni.SEAC_ANALYSIS_ENABLED = SEAC_ANALYSIS_ENABLED;
const FontFlags = {
  Passo fisso: 1,
  Serif: 2,
  Simbolico: 4,
  Sceneggiatura: 8,
  Non simbolico: 32,
  Corsivo: 64,
  Tutto maiuscolo: 65536,
  Piccola capitalizzazione: 131072,
  ForceBold: 262144
};
esportazioni.FontFlags = FontFlags;
const MacStandardGlyphOrdering = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "commerciale", "quotesingle", "parentesi a sinistra", "parentesi a destra", "asterisk", "plus", "comma", "hyphen", "point", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresi", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product","pi", "integrale", "ordfemminile", "ordmaschile", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radicale", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellissi", "spazio non divisibile", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "trattino", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "losanga", "ydieresis", "Ydieresis", "frazione", "valuta", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "centrato sul periodo", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];"valuta", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];"valuta", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
esportazioni.MacStandardGlyphOrdering = MacStandardGlyphOrdering;
funzione recoverGlyphName(nome, glifiUnicodeMap) {
  se (glyphsUnicodeMap[nome] !== indefinito) {
    nome di ritorno;
  }
  const unicode = (0, _unicode.getUnicodeForGlyph)(nome, glifiUnicodeMap);
  se (unicode !== -1) {
    per (chiave costante in glyphsUnicodeMap) {
      se (glifiUnicodeMap[chiave] === unicode) {
        tasto di ritorno;
      }
    }
  }
  (0, _util.info)("Impossibile recuperare un nome di glifo standard per: " + name);
  nome di ritorno;
}
funzione type1FontGlyphMapping(proprietà, builtInEncoding, glyphNames) {
  const charCodeToGlyphId = Object.create(null);
  lascia glyphId, charCode, baseEncoding;
  const isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
  se (proprietà.isInternalFont) {
    baseEncoding = builtInEncoding;
    per (charCode = 0; charCode < baseEncoding.length; charCode++) {
      glyphId = glyphNames.indexOf(baseEncoding[charCode]);
      charCodeToGlyphId[charCode] = glyphId >= 0 ? glyphId : 0;
    }
  } altrimenti se (properties.baseEncodingName) {
    baseEncoding = (0, _encodings.getEncoding)(properties.baseEncodingName);
    per (charCode = 0; charCode < baseEncoding.length; charCode++) {
      glyphId = glyphNames.indexOf(baseEncoding[charCode]);
      charCodeToGlyphId[charCode] = glyphId >= 0 ? glyphId : 0;
    }
  } altrimenti se (isSymbolicFont) {
    per (charCode in builtInEncoding) {
      charCodeToGlyphId[charCode] = builtInEncoding[charCode];
    }
  } altro {
    baseEncoding = _encodings.StandardEncoding;
    per (charCode = 0; charCode < baseEncoding.length; charCode++) {
      glyphId = glyphNames.indexOf(baseEncoding[charCode]);
      charCodeToGlyphId[charCode] = glyphId >= 0 ? glyphId : 0;
    }
  }
  differenze costanti = proprietà.differenze;
  lascia glifiUnicodeMap;
  se (differenze) {
    per (charCode nelle differenze) {
      const glyphName = differences[charCode];
      glyphId = glyphNames.indexOf(glyphName);
      se (glyphId === -1) {
        se (!glifiUnicodeMap) {
          glifiUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
        }
        const standardGlyphName = recoverGlyphName(glyphName, glyphsUnicodeMap);
        se (standardGlyphName !== glyphName) {
          glyphId = glyphNames.indexOf(standardGlyphName);
        }
      }
      charCodeToGlyphId[charCode] = glyphId >= 0 ? glyphId : 0;
    }
  }
  restituisci charCodeToGlyphId;
}
funzione normalizeFontName(nome) {
  restituisci nome.replaceAll(/[,_]/g, "-").replaceAll(/\s/g, "");
}

/***/ }),
/* 39 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(esporta, "__esModule", ({
  valore: vero
}));
exports.getGlyphsUnicode = exports.getDingbatsGlyphsUnicode = void 0;
var _core_utils = __w_pdfjs_require__(3);
const getGlyphsUnicode = (0, _core_utils.getLookupTableFactory)(funzione (t) {
  tA = 0x0041;
  t.AE = 0x00c6;
  t.AEacute = 0x01fc;
  t.AEmacron = 0x01e2;
  t.AEsmall = 0xf7e6;
  t.Aacute = 0x00c1;
  t.Aacutesmall = 0xf7e1;
  t.Abreve = 0x0102;
  t.Abreveacute = 0x1eae;
  t.Abrevecirillico = 0x04d0;
  t.Abrevedotbelow = 0x1eb6;
  t.Abrevegrave = 0x1eb0;
  t.Abrevehookabove = 0x1eb2;
  t.Abrevetilde = 0x1eb4;
  t.Acaron = 0x01cd;
  t.Circle = 0x24b6;
  t.Circonflesso = 0x00c2;
  t.Acircumflexacute = 0x1ea4;
  t.Acircumflexdotbelow = 0x1eac;
  t.Acircumflexgrave = 0x1ea6;
  t.Acircumflexhookabove = 0x1ea8;
  t.Circumflexsmall = 0xf7e2;
  t.Acircumflextilde = 0x1eaa;
  t.Acuto = 0xf6c9;
  t.Acutesmall = 0xf7b4;
  t.Acirillico = 0x0410;
  t.Adblgrave = 0x0200;
  t.Adieresi = 0x00c4;
  t.Adieresiscyrillic = 0x04d2;
  t.Adieresismacron = 0x01de;
  t.Adieresissmall = 0xf7e4;
  t.Adotbelow = 0x1ea0;
  t.Adotmacron = 0x01e0;
  t.Agrave = 0x00c0;
  t.Agravesmall = 0xf7e0;
  t.Ahookabove = 0x1ea2;
  t.Aiecyrillic = 0x04d4;
  t.Ainvertedbreve = 0x0202;
  t.Alfa = 0x0391;
  t.Alphatonos = 0x0386;
  t.Amacron = 0x0100;
  t.Amonospazio = 0xff21;
  t.Aogonek = 0x0104;
  t.Aring = 0x00c5;
  t.Aringacute = 0x01fa;
  t.Aringbelow = 0x1e00;
  t.Aringsmall = 0xf7e5;
  t.Asmall = 0xf761;
  t.Atilde = 0x00c3;
  t.Atildesmall = 0xf7e3;
  t.Aybarmenian = 0x0531;
  tB = 0x0042;
  t.Bcerchio = 0x24b7;
  t.Bdotaccent = 0x1e02;
  t.Bdotbelow = 0x1e04;
  t.Becirillico = 0x0411;
  t.Benarmeniano = 0x0532;
  t.Beta = 0x0392;
  t.Bhook = 0x0181;
  t.Blinebelow = 0x1e06;
  t.Bmonospace = 0xff22;
  t.Brevesmall = 0xf6f4;
  t.Bsmall = 0xf762;
  t.Btopbar = 0x0182;
  tC = 0x0043;
  t.Caarmeniano = 0x053e;
  t.Cacute = 0x0106;
  t.Caron = 0xf6ca;
  t.Caronsmall = 0xf6f5;
  t.Ccaron = 0x010c;
  t.Ccedilla = 0x00c7;
  t.Ccedillaacute = 0x1e08;
  t.Ccedillasmall = 0xf7e7;
  t.Ccerchio = 0x24b8;
  t.Ccirconflesso = 0x0108;
  t.Cdot = 0x010a;
  t.Cdotaccent = 0x010a;
  t.Cedillasmall = 0xf7b8;
  t.Chaarmenian = 0x0549;
  t.Cheabkhasiancyrillic = 0x04bc;
  t.Checirillico = 0x0427;
  t.Chedescenderabkhasiancyrillic = 0x04be;
  t.Chedescendercyrillic = 0x04b6;
  t.Chedieresiscyrillic = 0x04f4;
  t.Cheharmenian = 0x0543;
  t.Chekhakassiancyrillic = 0x04cb;
  t.Cheverticalstrokecyrillic = 0x04b8;
  t.Chi = 0x03a7;
  t.Chook = 0x0187;
  t.Circonflessopiccolo = 0xf6f6;
  t.Cmonospace = 0xff23;
  t.Coarmeniano = 0x0551;
  t.Csmall = 0xf763;
  tD = 0x0044;
  t.DZ = 0x01f1;
  t.DZcaron = 0x01c4;
  t.Daarmenian = 0x0534;
  t.Dafrican = 0x0189;
  t.Dcaron = 0x010e;
  t.Dcedilla = 0x1e10;
  t.Dcerchio = 0x24b9;
  t.Dcirconflessionesotto = 0x1e12;
  t.Dcroat = 0x0110;
  t.Ddotaccent = 0x1e0a;
  t.Ddotbelow = 0x1e0c;
  t.Decirillico = 0x0414;
  t.Deicottico = 0x03ee;
  t.Delta = 0x2206;
  t.Deltagreek = 0x0394;
  t.Dhook = 0x018a;
  t.Dieresi = 0xf6cb;
  t.DieresisAcute = 0xf6cc;
  t.DieresisGrave = 0xf6cd;
  t.Dieresipiccola = 0xf7a8;
  t.Digammagreek = 0x03dc;
  t.Djecyrillic = 0x0402;
  t.Dlinebelow = 0x1e0e;
  t.Dmonospace = 0xff24;
  t.Dotaccentsmall = 0xf6f7;
  t.Dslash = 0x0110;
  t.Dpiccolo = 0xf764;
  t.Dtopbar = 0x018b;
  t.Dz = 0x01f2;
  t.Dzcaron = 0x01c5;
  t.Dzeabkhasiancyrillic = 0x04e0;
  t.Dzecyrillic = 0x0405;
  t.Dzhecyrillic = 0x040f;
  tE = 0x0045;
  t.Eacute = 0x00c9;
  t.Eacutesmall = 0xf7e9;
  t.Ebreve = 0x0114;
  t.Ecaron = 0x011a;
  t.Ecedillabreve = 0x1e1c;
  t.Echarmenian = 0x0535;
  t.Ecerchio = 0x24ba;
  t.Ecirconflesso = 0x00ca;
  t.Ecircumflexacute = 0x1ebe;
  t.Ecircumflexbelow = 0x1e18;
  t.Ecircumflexdotbelow = 0x1ec6;
  t.Ecircumflexgrave = 0x1ec0;
  t.Ecircumflexhookabove = 0x1ec2;
  t.Ecircumflexsmall = 0xf7ea;
  t.Ecircumflextilde = 0x1ec4;
  t.Ecirillico = 0x0404;
  t.Edblgrave = 0x0204;
  t.Edieresi = 0x00cb;
  t.Edieresissmall = 0xf7eb;
  t.Edot = 0x0116;
  t.Edotaccent = 0x0116;
  t.Edotbelow = 0x1eb8;
  t.Efcirillico = 0x0424;
  t.Egrave = 0x00c8;
  t.Egravesmall = 0xf7e8;
  t.Eharmeniano = 0x0537;
  t.Ehookabove = 0x1eba;
  t.Eightroman = 0x2167;
  t.Einvertedbreve = 0x0206;
  t.Eiotifiedcyrillic = 0x0464;
  t.Elcirillico = 0x041b;
  t.Elevenroman = 0x216a;
  t.Emacron = 0x0112;
  t.Emacronacute = 0x1e16;
  t.Emacrongrave = 0x1e14;
  t.Emcyrillic = 0x041c;
  t.Emonospazio = 0xff25;
  t.Cirillico = 0x041d;
  t.Endescendercyrillic = 0x04a2;
  t.Eng = 0x014a;
  t.Enghecyrillic = 0x04a4;
  t.Enhookcyrillic = 0x04c7;
  t.Eogonek = 0x0118;
  t.Eopen = 0x0190;
  t.Epsilon = 0x0395;
  t.Epsilontonos = 0x0388;
  t.Ercirillico = 0x0420;
  t.Invertito = 0x018e;
  t.Ereversedcyrillic = 0x042d;
  t.Escyrillic = 0x0421;
  t.Esdescendercyrillic = 0x04aa;
  t.Esh = 0x01a9;
  t.Esmall = 0xf765;
  t.Eta = 0x0397;
  t.Etarmenian = 0x0538;
  t.Etatonos = 0x0389;
  t.Eth = 0x00d0;
  t.Ethsmall = 0xf7f0;
  t.Etilde = 0x1ebc;
  t.Etildesotto = 0x1e1a;
  t.Euro = 0x20ac;
  t.Ezh = 0x01b7;
  t.Ezhcaron = 0x01ee;
  t.Ezhreversed = 0x01b8;
  tF = 0x0046;
  t.Fcerchio = 0x24bb;
  t.Fdotaccent = 0x1e1e;
  t.Feharmeniano = 0x0556;
  t.Feicottico = 0x03e4;
  t.Fhook = 0x0191;
  t.Fitacirillico = 0x0472;
  t.Fiveroman = 0x2164;
  t.Fmonospace = 0xff26;
  t.Fourroman = 0x2163;
  t.Fpiccolo = 0xf766;
  tG = 0x0047;
  t.GBsquare = 0x3387;
  t.Gacute = 0x01f4;
  t.Gamma = 0x0393;
  t.Gammaafrican = 0x0194;
  t.Gangiacoptic = 0x03ea;
  t.Gbreve = 0x011e;
  t.Gcaron = 0x01e6;
  t.Gcedilla = 0x0122;
  t.Gcircle = 0x24bc;
  t.Gcirconflesso = 0x011c;
  t.Gcommaaccent = 0x0122;
  t.Gdot = 0x0120;
  t.Gdotaccent = 0x0120;
  t.Gecirillico = 0x0413;
  t.Ghadarmeniano = 0x0542;
  t.Ghemiddlehookcyrillic = 0x0494;
  t.Ghestrokecyrillic = 0x0492;
  t.Gheupturncyrillic = 0x0490;
  t.Ghook = 0x0193;
  t.Gimarmenian = 0x0533;
  t.Gjecyrillic = 0x0403;
  t.Gmacron = 0x1e20;
  t.Gmonospace = 0xff27;
  t.Grave = 0xf6ce;
  t.Gravesmall = 0xf760;
  t.Gsmall = 0xf767;
  t.Gsmallhook = 0x029b;
  t.Gstroke = 0x01e4;
  tH = 0x0048;
  t.H18533 = 0x25cf;
  t.H18543 = 0x25aa;
  t.H18551 = 0x25ab;
  t.H22073 = 0x25a1;
  t.HPsquare = 0x33cb;
  t.Haabkhasiancyrillic = 0x04a8;
  t.Hadescendercyrillic = 0x04b2;
  t.Hardsigncyrillic = 0x042a;
  t.Hbar = 0x0126;
  t.Hbrevebelow = 0x1e2a;
  t.Hcedilla = 0x1e28;
  t.Hcerchio = 0x24bd;
  t.Hcirconflesso = 0x0124;
  t.Hdieresis = 0x1e26;
  t.Hdotaccent = 0x1e22;
  t.Hdotbelow = 0x1e24;
  t.Hmonospace = 0xff28;
  t.Hoarmenian = 0x0540;
  t.Horicoptic = 0x03e8;
  t.Hpiccolo = 0xf768;
  t.Hungarumlaut = 0xf6cf;
  t.Hungarumlautsmall = 0xf6f8;
  t.Hzquadrato = 0x3390;
  tI = 0x0049;
  t.IAcirillico = 0x042f;
  t.IJ = 0x0132;
  t.IUcirillico = 0x042e;
  t.Iacute = 0x00cd;
  t.Iacutesmall = 0xf7ed;
  t.Ibreve = 0x012c;
  t.Icaron = 0x01cf;
  t.Cerchio = 0x24be;
  t.Icirconflesso = 0x00ce;
  t.Icircumflexsmall = 0xf7ee;
  t.Cirillico = 0x0406;
  t.Idblgrave = 0x0208;
  t.Idieresi = 0x00cf;
  t.Idieresisacute = 0x1e2e;
  t.Idieresiscyrillic = 0x04e4;
  t.Idieresissmall = 0xf7ef;
  t.Idot = 0x0130;
  t.Idotaccent = 0x0130;
  t.Idotbelow = 0x1eca;
  t.Iebrevecyrillic = 0x04d6;
  t.Iecyrillic = 0x0415;
  t.Ifraktur = 0x2111;
  t.Igrave = 0x00cc;
  t.Igravesmall = 0xf7ec;
  t.Ihookabove = 0x1ec8;
  t.Cirillico = 0x0418;
  t.Iinvertedbreve = 0x020a;
  t.Iishortcyrillic = 0x0419;
  t.Imacron = 0x012a;
  t.Imacroncirillico = 0x04e2;
  t.Imonospazio = 0xff29;
  t.Iniarmenian = 0x053b;
  t.Iocyrillic = 0x0401;
  t.Iogonek = 0x012e;
  t.Iota = 0x0399;
  t.Iotaafrican = 0x0196;
  t.Iotadieresi = 0x03aa;
  t.Iotatonos = 0x038a;
  t.Ismall = 0xf769;
  t.Istroke = 0x0197;
  t.Itilde = 0x0128;
  t.Itildebelow = 0x1e2c;
  t.Izhitsacyrillic = 0x0474;
  t.Izhitsadblgravecyrillic = 0x0476;
  tJ = 0x004a;
  t.Jaarmenian = 0x0541;
  t.Jcircle = 0x24bf;
  t.Jcirconflesso = 0x0134;
  t.Jecyrillic = 0x0408;
  t.Jheharmenian = 0x054b;
  t.Jmonospace = 0xff2a;
  t.Jsmall = 0xf76a;
  tK = 0x004b;
  t.KBsquare = 0x3385;
  t.KKquadrato = 0x33cd;
  t.Kabashkircirillico = 0x04a0;
  t.Kacute = 0x1e30;
  t.Kacyrillic = 0x041a;
  t.Kadescendercyrillic = 0x049a;
  t.Kahookcyrillic = 0x04c3;
  t.Kappa = 0x039a;
  t.Kastrokecyrillic = 0x049e;
  t.Kaverticalstrokecyrillic = 0x049c;
  t.Kcaron = 0x01e8;
  t.Kcedilla = 0x0136;
  t.Kcerchio = 0x24c0;
  t.Kcommaaccent = 0x0136;
  t.Kdotbelow = 0x1e32;
  t.Keharmenian = 0x0554;
  t.Kenarmeniano = 0x053f;
  t.Khacyrillic = 0x0425;
  t.Kheicoptic = 0x03e6;
  t.Khook = 0x0198;
  t.Kjecyrillic = 0x040c;
  t.Klinebelow = 0x1e34;
  t.Kmonospazio = 0xff2b;
  t.Koppacyrillic = 0x0480;
  t.Koppagreek = 0x03de;
  t.Cirillico = 0x046e;
  t.Kpiccolo = 0xf76b;
  tL = 0x004c;
  t.LJ = 0x01c7;
  t.LL = 0xf6bf;
  t.Lacute = 0x0139;
  t.Lambda = 0x039b;
  t.Lcaron = 0x013d;
  t.Lcedilla = 0x013b;
  t.Lcerchio = 0x24c1;
  t.Lcirconflessosotto = 0x1e3c;
  t.Lcommaaccent = 0x013b;
  t.Ldot = 0x013f;
  t.Ldotaccent = 0x013f;
  t.Ldotbelow = 0x1e36;
  t.Ldotbelowmacron = 0x1e38;
  t.Liwnarmenian = 0x053c;
  t.Lj = 0x01c8;
  t.Ljecyrillic = 0x0409;
  t.Llinebelow = 0x1e3a;
  t.Lmonospazio = 0xff2c;
  t.Lslash = 0x0141;
  t.Lslashsmall = 0xf6f9;
  t.Lpiccolo = 0xf76c;
  tM = 0x004d;
  t.MBsquare = 0x3386;
  t.Macron = 0xf6d0;
  t.Macronsmall = 0xf7af;
  t.Macute = 0x1e3e;
  t.Mcircle = 0x24c2;
  t.Mdotaccent = 0x1e40;
  t.Mdotbelow = 0x1e42;
  t.Menarmeniano = 0x0544;
  t.Mmonospace = 0xff2d;
  t.Mpiccolo = 0xf76d;
  t.Mturned = 0x019c;
  t.Mu = 0x039c;
  tN = 0x004e;
  t.NJ = 0x01ca;
  t.Nacute = 0x0143;
  t.Ncaron = 0x0147;
  t.Ncedilla = 0x0145;
  t.Ncerchio = 0x24c3;
  t.Ncircumflexbelow = 0x1e4a;
  t.Naccentocomma = 0x0145;
  t.Ndotaccent = 0x1e44;
  t.Ndotbelow = 0x1e46;
  t.Nhookleft = 0x019d;
  t.Nineroman = 0x2168;
  t.Nj = 0x01cb;
  t.Njecyrillic = 0x040a;
  t.Nlinebelow = 0x1e48;
  t.Nmonospace = 0xff2e;
  t.Nowarmenian = 0x0546;
  t.Npiccolo = 0xf76e;
  t.Ntilde = 0x00d1;
  t.Ntildesmall = 0xf7f1;
  t.Nu = 0x039d;
  tO = 0x004f;
  t.OE = 0x0152;
  t.OEsmall = 0xf6fa;
  t.Oacute = 0x00d3;
  t.Oacutesmall = 0xf7f3;
  t.Obarredcyrillic = 0x04e8;
  t.Obarreddieresiscyrillic = 0x04ea;
  t.Obreve = 0x014e;
  t.Ocaron = 0x01d1;
  t.Ocenteredtilde = 0x019f;
  t.Ocerchio = 0x24c4;
  t.Ocirconflesso = 0x00d4;
  t.Ocirconflessoacuto = 0x1ed0;
  t.Ocircumflexdotbelow = 0x1ed8;
  t.Ocirconflesso = 0x1ed2;
  t.Ocircumflexhookabove = 0x1ed4;
  t.Ocirconflessopiccolo = 0xf7f4;
  t.Ocircumflextilde = 0x1ed6;
  t.Ocirillico = 0x041e;
  t.Odblacute = 0x0150;
  t.Odblgrave = 0x020c;
  t.Odieresi = 0x00d6;
  t.Odieresiscyrillic = 0x04e6;
  t.Odieresissmall = 0xf7f6;
  t.Odotbelow = 0x1ecc;
  t.Ogoneksmall = 0xf6fb;
  t.Ograve = 0x00d2;
  t.Ogravesmall = 0xf7f2;
  t.Oharmeniano = 0x0555;
  t.Ohm = 0x2126;
  t.Ohookabove = 0x1ece;
  t.Ohorn = 0x01a0;
  t.Ohornacute = 0x1eda;
  t.Ohorndotbelow = 0x1ee2;
  t.Ohorngrave = 0x1edc;
  t.Ohornhookabove = 0x1ede;
  t.Ohorntilde = 0x1ee0;
  t.Ohungarumlaut = 0x0150;
  t.Oi = 0x01a2;
  t.Oinvertedbreve = 0x020e;
  t.Omacron = 0x014c;
  t.Omacronacute = 0x1e52;
  t.Omacrongrave = 0x1e50;
  t.Omega = 0x2126;
  t.Omegacirillico = 0x0460;
  t.Omegagreco = 0x03a9;
  t.Omegaroundcyrillic = 0x047a;
  t.Omegatitlocirillico = 0x047c;
  t.Omegatonos = 0x038f;
  t.Omicron = 0x039f;
  t.Omicrontonos = 0x038c;
  t.Omonospazio = 0xff2f;
  t.Oneroman = 0x2160;
  t.Oogonek = 0x01ea;
  t.Oogonekmacron = 0x01ec;
  t.Oopen = 0x0186;
  t.Oslash = 0x00d8;
  t.Oslashacute = 0x01fe;
  t.Oslashsmall = 0xf7f8;
  t.Osmall = 0xf76f;
  t.Ostrokeacute = 0x01fe;
  t.Otcyrillic = 0x047e;
  t.Otilde = 0x00d5;
  t.Otildeacute = 0x1e4c;
  t.Otildedieresi = 0x1e4e;
  t.Otildesmall = 0xf7f5;
  tP = 0x0050;
  t.Pacute = 0x1e54;
  t.Pcircle = 0x24c5;
  t.Pdotaccent = 0x1e56;
  t.Pecirillico = 0x041f;
  t.Peharmeniano = 0x054a;
  t.Pemiddlehookcyrillic = 0x04a6;
  t.Phi = 0x03a6;
  t.Phook = 0x01a4;
  t.Pi = 0x03a0;
  t.Piwrarmenian = 0x0553;
  t.Pmonospace = 0xff30;
  t.Psi = 0x03a8;
  t.Psicyrillic = 0x0470;
  t.Psmall = 0xf770;
  tQ = 0x0051;
  t.Qcerchio = 0x24c6;
  t.Qmonospace = 0xff31;
  t.Qpiccolo = 0xf771;
  tR = 0x0052;
  t.Raarmenian = 0x054c;
  t.Racute = 0x0154;
  t.Rcaron = 0x0158;
  t.Rcedilla = 0x0156;
  t.Rcerchio = 0x24c7;
  t.Rcommaaccent = 0x0156;
  t.Rdblgrave = 0x0210;
  t.Rdotaccent = 0x1e58;
  t.Rdotbelow = 0x1e5a;
  t.Rdotbelowmacron = 0x1e5c;
  t.Reharmenian = 0x0550;
  t.Rfraktur = 0x211c;
  t.Rho = 0x03a1;
  t.Anello piccolo = 0xf6fc;
  t.Rinvertedbreve = 0x0212;
  t.Rlinebelow = 0x1e5e;
  t.Rmonospace = 0xff32;
  t.Rpiccolo = 0xf772;
  t.Rsmallinverted = 0x0281;
  t.Rsmallinvertedsuperior = 0x02b6;
  tS = 0x0053;
  t.SF010000 = 0x250c;
  t.SF020000 = 0x2514;
  t.SF030000 = 0x2510;
  t.SF040000 = 0x2518;
  t.SF050000 = 0x253c;
  t.SF060000 = 0x252c;
  t.SF070000 = 0x2534;
  t.SF080000 = 0x251c;
  t.SF090000 = 0x2524;
  t.SF100000 = 0x2500;
  t.SF110000 = 0x2502;
  t.SF190000 = 0x2561;
  t.SF200000 = 0x2562;
  t.SF210000 = 0x2556;
  t.SF220000 = 0x2555;
  t.SF230000 = 0x2563;
  t.SF240000 = 0x2551;
  t.SF250000 = 0x2557;
  t.SF260000 = 0x255d;
  t.SF270000 = 0x255c;
  t.SF280000 = 0x255b;
  t.SF360000 = 0x255e;
  t.SF370000 = 0x255f;
  t.SF380000 = 0x255a;
  t.SF390000 = 0x2554;
  t.SF400000 = 0x2569;
  t.SF410000 = 0x2566;
  t.SF420000 = 0x2560;
  t.SF430000 = 0x2550;
  t.SF440000 = 0x256c;
  t.SF450000 = 0x2567;
  t.SF460000 = 0x2568;
  t.SF470000 = 0x2564;
  t.SF480000 = 0x2565;
  t.SF490000 = 0x2559;
  t.SF500000 = 0x2558;
  t.SF510000 = 0x2552;
  t.SF520000 = 0x2553;
  t.SF530000 = 0x256b;
  t.SF540000 = 0x256a;
  t.Sacute = 0x015a;
  t.Sacutedotaccent = 0x1e64;
  t.Sampigreek = 0x03e0;
  t.Scaron = 0x0160;
  t.Scarondotaccent = 0x1e66;
  t.Scaronsmall = 0xf6fd;
  t.Scedilla = 0x015e;
  t.Schwa = 0x018f;
  t.Schwacyrillic = 0x04d8;
  t.Schwadieresiscyrillic = 0x04da;
  t.Scircle = 0x24c8;
  t.Scirconferenza = 0x015c;
  t.Scommaaccent = 0x0218;
  t.Sdotaccent = 0x1e60;
  t.Sdotbelow = 0x1e62;
  t.Sdotbelowdotaccent = 0x1e68;
  t.Seharmenian = 0x054d;
  t.Sevenroman = 0x2166;
  t.Shaarmenian = 0x0547;
  t.Shacyrillic = 0x0428;
  t.Shchacyrillic = 0x0429;
  t.Sheicoptic = 0x03e2;
  t.Shhacyrillic = 0x04ba;
  t.Shimacoptic = 0x03ec;
  t.Sigma = 0x03a3;
  t.Sixroman = 0x2165;
  t.Smonospace = 0xff33;
  t.Softsigncyrillic = 0x042c;
  t.Spiccolo = 0xf773;
  t.Stigmagreek = 0x03da;
  tT = 0x0054;
  t.Tau = 0x03a4;
  t.Tbar = 0x0166;
  t.Tcaron = 0x0164;
  t.Tcedilla = 0x0162;
  t.Tcerchio = 0x24c9;
  t.Tcirconflessionesotto = 0x1e70;
  t.Tcommaaccent = 0x0162;
  t.Tdotaccent = 0x1e6a;
  t.Tdotbelow = 0x1e6c;
  t.Tecyrillic = 0x0422;
  t.Tedescendercyrillic = 0x04ac;
  t.Tenroman = 0x2169;
  t.Tetsecirillico = 0x04b4;
  t.Theta = 0x0398;
  t.Thook = 0x01ac;
  t.Thorn = 0x00de;
  t.Thornsmall = 0xf7fe;
  t.Threeroman = 0x2162;
  t.Tildesmall = 0xf6fe;
  t.Tiwnarmenian = 0x054f;
  t.Tlinebelow = 0x1e6e;
  t.Tmonospazio = 0xff34;
  t.Toarmenian = 0x0539;
  t.Tonefive = 0x01bc;
  t.Tonesix = 0x0184;
  t.Tonetwo = 0x01a7;
  t.Tretroflexhook = 0x01ae;
  t.Tsecirillico = 0x0426;
  t.Cirillico = 0x040b;
  t.Tpiccolo = 0xf774;
  t.Dodicesimoromano = 0x216b;
  t.Tworoman = 0x2161;
  tU = 0x0055;
  t.Uacute = 0x00da;
  t.Uacutesmall = 0xf7fa;
  t.Ubreve = 0x016c;
  t.Ucaron = 0x01d3;
  t.Ucerchio = 0x24ca;
  t.Ucirconflesso = 0x00db;
  t.Ucircumflexbelow = 0x1e76;
  t.Ucircumflexsmall = 0xf7fb;
  t.Ucirillico = 0x0423;
  t.Udblacute = 0x0170;
  t.Udblgrave = 0x0214;
  t.Udieresis = 0x00dc;
  t.Udieresisacute = 0x01d7;
  t.Udieresisbelow = 0x1e72;
  t.Udieresiscaron = 0x01d9;
  t.Udieresiscyrillic = 0x04f0;
  t.Udieresisgrave = 0x01db;
  t.Udieresismacron = 0x01d5;
  t.Udieresissmall = 0xf7fc;
  t.Udotbelow = 0x1ee4;
  t.Ugrave = 0x00d9;
  t.Ugravesmall = 0xf7f9;
  t.Uhookabove = 0x1ee6;
  t.Uhorn = 0x01af;
  t.Uhornacute = 0x1ee8;
  t.Uhorndotbelow = 0x1ef0;
  t.Uhorngrave = 0x1eea;
  t.Uhornhookabove = 0x1eec;
  t.Uhorntilde = 0x1eee;
  t.Uhungarumlaut = 0x0170;
  t.Uhungarumlautcyrillic = 0x04f2;
  t.Uinvertedbreve = 0x0216;
  t.Ukcyrillic = 0x0478;
  t.Umacron = 0x016a;
  t.Umacroncirillico = 0x04ee;
  t.Umacrondieresi = 0x1e7a;
  t.Umonospazio = 0xff35;
  t.Uogonek = 0x0172;
  t.Upsilon = 0x03a5;
  t.Upsilon1 = 0x03d2;
  t.Upsilonacutehooksymbolgreek = 0x03d3;
  t.Upsilonafrican = 0x01b1;
  t.Ipsilondieresi = 0x03ab;
  t.Upsilondieresishooksymbolgreek = 0x03d4;
  t.Upsilonhooksymbol = 0x03d2;
  t.Upsilontonos = 0x038e;
  t.Uring = 0x016e;
  t.Ushortcyrillic = 0x040e;
  t.Usmall = 0xf775;
  t.Ustraightcyrillic = 0x04ae;
  t.Ustraightstrokecyrillic = 0x04b0;
  t.Utilde = 0x0168;
  t.Utildeacute = 0x1e78;
  t.Utildebelow = 0x1e74;
  tv = 0x0056;
  t.Vcerchio = 0x24cb;
  t.Vdotbelow = 0x1e7e;
  t.Vecirillico = 0x0412;
  t.Vewarmenian = 0x054e;
  t.Vhook = 0x01b2;
  t.Vmonospace = 0xff36;
  t.Voarmenian = 0x0548;
  t.Vpiccolo = 0xf776;
  t.Vtilde = 0x1e7c;
  tW = 0x0057;
  t.Wacute = 0x1e82;
  t.Wcircle = 0x24cc;
  t.Wcirconflesso = 0x0174;
  t.Wdieresis = 0x1e84;
  t.Wdotaccent = 0x1e86;
  t.Wdotbelow = 0x1e88;
  t.Wgrave = 0x1e80;
  t.Wmonospace = 0xff37;
  t.Wsmall = 0xf777;
  tX = 0x0058;
  t.Xcerchio = 0x24cd;
  t.Xdieresi = 0x1e8c;
  t.Xdotaccent = 0x1e8a;
  t.Xeharmenian = 0x053d;
  t.Xi = 0x039e;
  t.Xmonospace = 0xff38;
  t.Xsmall = 0xf778;
  tY = 0x0059;
  t.Yacute = 0x00dd;
  t.Yacutesmall = 0xf7fd;
  t.Yatcyrillic = 0x0462;
  t.Ycerchio = 0x24ce;
  t.Ycirconflesso = 0x0176;
  t.Ydieresis = 0x0178;
  t.Ydieresissmall = 0xf7ff;
  t.Ydotaccent = 0x1e8e;
  t.Ydotbelow = 0x1ef4;
  t.Yericyrillic = 0x042b;
  t.Yerudieresiscyrillic = 0x04f8;
  t.Ygrave = 0x1ef2;
  t.Yhook = 0x01b3;
  t.Yhookabove = 0x1ef6;
  t.Yiarmenian = 0x0545;
  t.Yicyrillic = 0x0407;
  t.Yiwnarmenian = 0x0552;
  t.Ymonospace = 0xff39;
  t.Ypiccolo = 0xf779;
  t.Ytilde = 0x1ef8;
  t.Yusbigcyrillic = 0x046a;
  t.Yusbigiotifiedcyrillic = 0x046c;
  t.Yuslittlecyrillic = 0x0466;
  t.Yuslittleiotifiedcyrillic = 0x0468;
  tZ = 0x005a;
  t.Zaarmenian = 0x0536;
  t.Zacute = 0x0179;
  t.Zcaron = 0x017d;
  t.Zcaronsmall = 0xf6ff;
  t.Zcircle = 0x24cf;
  t.Zcirconflesso = 0x1e90;
  t.Zdot = 0x017b;
  t.Zdotaccent = 0x017b;
  t.Zdotbelow = 0x1e92;
  t.Zecyrillic = 0x0417;
  t.Zedescendercyrillic = 0x0498;
  t.Zedieresiscyrillic = 0x04de;
  t.Zeta = 0x0396;
  t.Zhearmenian = 0x053a;
  t.Zhebrevecyrillic = 0x04c1;
  t.Zhecyrillic = 0x0416;
  t.Zhedescendercyrillic = 0x0496;
  t.Zhedieresiscyrillic = 0x04dc;
  t.Zlinebelow = 0x1e94;
  t.Zmonospazio = 0xff3a;
  t.Zpiccolo = 0xf77a;
  t.Zstroke = 0x01b5;
  ta = 0x0061;
  t.aabengali = 0x0986;
  t.aacute = 0x00e1;
  t.aadeva = 0x0906;
  t.aagujarati = 0x0a86;
  t.aagurmukhi = 0x0a06;
  t.aamatragurmukhi = 0x0a3e;
  t.aarusquare = 0x3303;
  t.aavowelsignbengali = 0x09be;
  t.aavowelsigndeva = 0x093e;
  t.aavowelsigngujarati = 0x0abe;
  t.abbreviationmarkarmenian = 0x055f;
  t.abbreviationsigndeva = 0x0970;
  t.abengali = 0x0985;
  t.abopomofo = 0x311a;
  t.abreve = 0x0103;
  t.abreveacute = 0x1eaf;
  t.abrevecyrillic = 0x04d1;
  t.abrevedotbelow = 0x1eb7;
  t.abrevegrave = 0x1eb1;
  t.abrevehookabove = 0x1eb3;
  t.abrevetilde = 0x1eb5;
  t.acaron = 0x01ce;
  t.cerchio = 0x24d0;
  t.circonflesso = 0x00e2;
  t.acircumflexacute = 0x1ea5;
  t.acircumflexdotbelow = 0x1ead;
  t.acircumflexgrave = 0x1ea7;
  t.acircumflexhookabove = 0x1ea9;
  t.acircumflextilde = 0x1eab;
  t.acuto = 0x00b4;
  t.acutebelowcmb = 0x0317;
  t.acutecmb = 0x0301;
  t.acutecomb = 0x0301;
  t.acutedeva = 0x0954;
  t.acutelowmod = 0x02cf;
  t.acutetonecmb = 0x0341;
  t.acirillico = 0x0430;
  t.adblgrave = 0x0201;
  t.addakgurmukhi = 0x0a71;
  t.adeva = 0x0905;
  t.adieresi = 0x00e4;
  t.adieresiscyrillic = 0x04d3;
  t.adieresismacron = 0x01df;
  t.adotbelow = 0x1ea1;
  t.adotmacron = 0x01e1;
  t.ae = 0x00e6;
  t.aeacute = 0x01fd;
  t.aekorean = 0x3150;
  t.aemacron = 0x01e3;
  t.afii00208 = 0x2015;
  t.afii08941 = 0x20a4;
  t.afii10017 = 0x0410;
  t.afii10018 = 0x0411;
  t.afii10019 = 0x0412;
  t.afii10020 = 0x0413;
  t.afii10021 = 0x0414;
  t.afii10022 = 0x0415;
  t.afii10023 = 0x0401;
  t.afii10024 = 0x0416;
  t.afii10025 = 0x0417;
  t.afii10026 = 0x0418;
  t.afii10027 = 0x0419;
  t.afii10028 = 0x041a;
  t.afii10029 = 0x041b;
  t.afii10030 = 0x041c;
  t.afii10031 = 0x041d;
  t.afii10032 = 0x041e;
  t.afii10033 = 0x041f;
  t.afii10034 = 0x0420;
  t.afii10035 = 0x0421;
  t.afii10036 = 0x0422;
  t.afii10037 = 0x0423;
  t.afii10038 = 0x0424;
  t.afii10039 = 0x0425;
  t.afii10040 = 0x0426;
  t.afii10041 = 0x0427;
  t.afii10042 = 0x0428;
  t.afii10043 = 0x0429;
  t.afii10044 = 0x042a;
  t.afii10045 = 0x042b;
  t.afii10046 = 0x042c;
  t.afii10047 = 0x042d;
  t.afii10048 = 0x042e;
  t.afii10049 = 0x042f;
  t.afii10050 = 0x0490;
  t.afii10051 = 0x0402;
  t.afii10052 = 0x0403;
  t.afii10053 = 0x0404;
  t.afii10054 = 0x0405;
  t.afii10055 = 0x0406;
  t.afii10056 = 0x0407;
  t.afii10057 = 0x0408;
  t.afii10058 = 0x0409;
  t.afii10059 = 0x040a;
  t.afii10060 = 0x040b;
  t.afii10061 = 0x040c;
  t.afii10062 = 0x040e;
  t.afii10063 = 0xf6c4;
  t.afii10064 = 0xf6c5;
  t.afii10065 = 0x0430;
  t.afii10066 = 0x0431;
  t.afii10067 = 0x0432;
  t.afii10068 = 0x0433;
  t.afii10069 = 0x0434;
  t.afii10070 = 0x0435;
  t.afii10071 = 0x0451;
  t.afii10072 = 0x0436;
  t.afii10073 = 0x0437;
  t.afii10074 = 0x0438;
  t.afii10075 = 0x0439;
  t.afii10076 = 0x043a;
  t.afii10077 = 0x043b;
  t.afii10078 = 0x043c;
  t.afii10079 = 0x043d;
  t.afii10080 = 0x043e;
  t.afii10081 = 0x043f;
  t.afii10082 = 0x0440;
  t.afii10083 = 0x0441;
  t.afii10084 = 0x0442;
  t.afii10085 = 0x0443;
  t.afii10086 = 0x0444;
  t.afii10087 = 0x0445;
  t.afii10088 = 0x0446;
  t.afii10089 = 0x0447;
  t.afii10090 = 0x0448;
  t.afii10091 = 0x0449;
  t.afii10092 = 0x044a;
  t.afii10093 = 0x044b;
  t.afii10094 = 0x044c;
  t.afii10095 = 0x044d;
  t.afii10096 = 0x044e;
  t.afii10097 = 0x044f;
  t.afii10098 = 0x0491;
  t.afii10099 = 0x0452;
  t.afii10100 = 0x0453;
  t.afii10101 = 0x0454;
  t.afii10102 = 0x0455;
  t.afii10103 = 0x0456;
  t.afii10104 = 0x0457;
  t.afii10105 = 0x0458;
  t.afii10106 = 0x0459;
  t.afii10107 = 0x045a;
  t.afii10108 = 0x045b;
  t.afii10109 = 0x045c;
  t.afii10110 = 0x045e;
  t.afii10145 = 0x040f;
  t.afii10146 = 0x0462;
  t.afii10147 = 0x0472;
  t.afii10148 = 0x0474;
  t.afii10192 = 0xf6c6;
  t.afii10193 = 0x045f;
  t.afii10194 = 0x0463;
  t.afii10195 = 0x0473;
  t.afii10196 = 0x0475;
  t.afii10831 = 0xf6c7;
  t.afii10832 = 0xf6c8;
  t.afii10846 = 0x04d9;
  t.afii299 = 0x200e;
  t.afii300 = 0x200f;
  t.afii301 = 0x200d;
  t.afii57381 = 0x066a;
  t.afii57388 = 0x060c;
  t.afii57392 = 0x0660;
  t.afii57393 = 0x0661;
  t.afii57394 = 0x0662;
  t.afii57395 = 0x0663;
  t.afii57396 = 0x0664;
  t.afii57397 = 0x0665;
  t.afii57398 = 0x0666;
  t.afii57399 = 0x0667;
  t.afii57400 = 0x0668;
  t.afii57401 = 0x0669;
  t.afii57403 = 0x061b;
  t.afii57407 = 0x061f;
  t.afii57409 = 0x0621;
  t.afii57410 = 0x0622;
  t.afii57411 = 0x0623;
  t.afii57412 = 0x0624;
  t.afii57413 = 0x0625;
  t.afii57414 = 0x0626;
  t.afii57415 = 0x0627;
  t.afii57416 = 0x0628;
  t.afii57417 = 0x0629;
  t.afii57418 = 0x062a;
  t.afii57419 = 0x062b;
  t.afii57420 = 0x062c;
  t.afii57421 = 0x062d;
  t.afii57422 = 0x062e;
  t.afii57423 = 0x062f;
  t.afii57424 = 0x0630;
  t.afii57425 = 0x0631;
  t.afii57426 = 0x0632;
  t.afii57427 = 0x0633;
  t.afii57428 = 0x0634;
  t.afii57429 = 0x0635;
  t.afii57430 = 0x0636;
  t.afii57431 = 0x0637;
  t.afii57432 = 0x0638;
  t.afii57433 = 0x0639;
  t.afii57434 = 0x063a;
  t.afii57440 = 0x0640;
  t.afii57441 = 0x0641;
  t.afii57442 = 0x0642;
  t.afii57443 = 0x0643;
  t.afii57444 = 0x0644;
  t.afii57445 = 0x0645;
  t.afii57446 = 0x0646;
  t.afii57448 = 0x0648;
  t.afii57449 = 0x0649;
  t.afii57450 = 0x064a;
  t.afii57451 = 0x064b;
  t.afii57452 = 0x064c;
  t.afii57453 = 0x064d;
  t.afii57454 = 0x064e;
  t.afii57455 = 0x064f;
  t.afii57456 = 0x0650;
  t.afii57457 = 0x0651;
  t.afii57458 = 0x0652;
  t.afii57470 = 0x0647;
  t.afii57505 = 0x06a4;
  t.afii57506 = 0x067e;
  t.afii57507 = 0x0686;
  t.afii57508 = 0x0698;
  t.afii57509 = 0x06af;
  t.afii57511 = 0x0679;
  t.afii57512 = 0x0688;
  t.afii57513 = 0x0691;
  t.afii57514 = 0x06ba;
  t.afii57519 = 0x06d2;
  t.afii57534 = 0x06d5;
  t.afii57636 = 0x20aa;
  t.afii57645 = 0x05be;
  t.afii57658 = 0x05c3;
  t.afii57664 = 0x05d0;
  t.afii57665 = 0x05d1;
  t.afii57666 = 0x05d2;
  t.afii57667 = 0x05d3;
  t.afii57668 = 0x05d4;
  t.afii57669 = 0x05d5;
  t.afii57670 = 0x05d6;
  t.afii57671 = 0x05d7;
  t.afii57672 = 0x05d8;
  t.afii57673 = 0x05d9;
  t.afii57674 = 0x05da;
  t.afii57675 = 0x05db;
  t.afii57676 = 0x05dc;
  t.afii57677 = 0x05dd;
  t.afii57678 = 0x05de;
  t.afii57679 = 0x05df;
  t.afii57680 = 0x05e0;
  t.afii57681 = 0x05e1;
  t.afii57682 = 0x05e2;
  t.afii57683 = 0x05e3;
  t.afii57684 = 0x05e4;
  t.afii57685 = 0x05e5;
  t.afii57686 = 0x05e6;
  t.afii57687 = 0x05e7;
  t.afii57688 = 0x05e8;
  t.afii57689 = 0x05e9;
  t.afii57690 = 0x05ea;
  t.afii57694 = 0xfb2a;
  t.afii57695 = 0xfb2b;
  t.afii57700 = 0xfb4b;
  t.afii57705 = 0xfb1f;
  t.afii57716 = 0x05f0;
  t.afii57717 = 0x05f1;
  t.afii57718 = 0x05f2;
  t.afii57723 = 0xfb35;
  t.afii57793 = 0x05b4;
  t.afii57794 = 0x05b5;
  t.afii57795 = 0x05b6;
  t.afii57796 = 0x05bb;
  t.afii57797 = 0x05b8;
  t.afii57798 = 0x05b7;
  t.afii57799 = 0x05b0;
  t.afii57800 = 0x05b2;
  t.afii57801 = 0x05b1;
  t.afii57802 = 0x05b3;
  t.afii57803 = 0x05c2;
  t.afii57804 = 0x05c1;
  t.afii57806 = 0x05b9;
  t.afii57807 = 0x05bc;
  t.afii57839 = 0x05bd;
  t.afii57841 = 0x05bf;
  t.afii57842 = 0x05c0;
  t.afii57929 = 0x02bc;
  t.afii61248 = 0x2105;
  t.afii61289 = 0x2113;
  t.afii61352 = 0x2116;
  t.afii61573 = 0x202c;
  t.afii61574 = 0x202d;
  t.afii61575 = 0x202e;
  t.afii61664 = 0x200c;
  t.afii63167 = 0x066d;
  t.afii64937 = 0x02bd;
  t.agrave = 0x00e0;
  t.agujarati = 0x0a85;
  t.agurmukhi = 0x0a05;
  t.ahiragana = 0x3042;
  t.ahookabove = 0x1ea3;
  t.aibengali = 0x0990;
  t.aibopomofo = 0x311e;
  t.aideva = 0x0910;
  t.aiecyrillic = 0x04d5;
  t.aigujarati = 0x0a90;
  t.aigurmukhi = 0x0a10;
  t.aimatragurmukhi = 0x0a48;
  t.ainarabic = 0x0639;
  t.ainfinalarabic = 0xfeca;
  t.aininitialarabic = 0xfecb;
  t.ainmedialarabic = 0xfecc;
  t.ainvertedbreve = 0x0203;
  t.aivowelsignbengali = 0x09c8;
  t.aivowelsigndeva = 0x0948;
  t.aivowelsigngujarati = 0x0ac8;
  t.akatakana = 0x30a2;
  t.akatakanahalfwidth = 0xff71;
  t.akorean = 0x314f;
  t.alef = 0x05d0;
  t.alefarabic = 0x0627;
  t.alefdageshhebrew = 0xfb30;
  t.aleffinalarabic = 0xfe8e;
  t.alefhamzaabovearabic = 0x0623;
  t.alefhamzaabovefinalarabic = 0xfe84;
  t.alefhamzabelowarabic = 0x0625;
  t.alefhamzabelowfinalarabic = 0xfe88;
  t.alefhebrew = 0x05d0;
  t.aleflamedhebrew = 0xfb4f;
  t.alefmaddaabovearabic = 0x0622;
  t.alefmaddaabovefinalarabic = 0xfe82;
  t.alefmaksuraarabic = 0x0649;
  t.alefmaksurafinalarabic = 0xfef0;
  t.alefmaksurainitialarabic = 0xfef3;
  t.alefmaksuramedialarabic = 0xfef4;
  t.alefpatahhebrew = 0xfb2e;
  t.alefqamatshebrew = 0xfb2f;
  t.aleph = 0x2135;
  t.allequal = 0x224c;
  t.alfa = 0x03b1;
  t.alphatonos = 0x03ac;
  t.amacron = 0x0101;
  t.monospazio = 0xff41;
  t.e commerciale = 0x0026;
  t.ampersandmonospace = 0xff06;
  t.ampersandsmall = 0xf726;
  t.amsquare = 0x33c2;
  t.anbopomofo = 0x3122;
  t.angbopomofo = 0x3124;
  t.angbracketleft = 0x3008;
  t.angbracketright = 0x3009;
  t.angkhankhuthai = 0x0e5a;
  t.angolo = 0x2220;
  t.anglebracketleft = 0x3008;
  t.anglebracketleftvertical = 0xfe3f;
  t.anglebracketright = 0x3009;
  t.anglebracketrightvertical = 0xfe40;
  t.angolo sinistro = 0x2329;
  t.angolodestro = 0x232a;
  t.angstrom = 0x212b;
  t.anoteleia = 0x0387;
  t.anudattadeva = 0x0952;
  t.anusvarabengali = 0x0982;
  t.anusvaradeva = 0x0902;
  t.anusvaragujarati = 0x0a82;
  t.aogonek = 0x0105;
  t.apaatosquare = 0x3300;
  t.apparen = 0x249c;
  t.apostrophearmenian = 0x055a;
  t.apostrophemod = 0x02bc;
  t.mela = 0xf8ff;
  t.approaches = 0x2250;
  t.approxequal = 0x2248;
  t.approxequalorimage = 0x2252;
  t.approssimativamenteuguale = 0x2245;
  t.araeaekorean = 0x318e;
  t.araeakorean = 0x318d;
  t.arco = 0x2312;
  t.arighthalfring = 0x1e9a;
  t.aring = 0x00e5;
  t.aringacute = 0x01fb;
  t.aringbelow = 0x1e01;
  t.arrowboth = 0x2194;
  t.arrowdashdown = 0x21e3;
  t.arrowdashleft = 0x21e0;
  t.arrowdashright = 0x21e2;
  t.arrowdashup = 0x21e1;
  t.arrowdblboth = 0x21d4;
  t.arrowdbldown = 0x21d3;
  t.arrowdblleft = 0x21d0;
  t.arrowdblright = 0x21d2;
  t.arrowdblup = 0x21d1;
  t.arrowdown = 0x2193;
  t.arrowdownleft = 0x2199;
  t.arrowdownright = 0x2198;
  t.arrowdownwhite = 0x21e9;
  t.arrowheaddownmod = 0x 02c5;
  t.arrowheadleftmod = 0x02c2;
  t.arrowheadrightmod = 0x02c3;
  t.arrowheadupmod = 0x02c4;
  t.arrowhorizex = 0xf8e7;
  t.arrowleft = 0x2190;
  t.arrowleftdbl = 0x21d0;
  t.arrowleftdblstroke = 0x21cd;
  t.frecciasinistradestra = 0x21c6;
  t.arrowleftwhite = 0x21e6;
  t.arrowright = 0x2192;
  t.arrowrightdblstroke = 0x21cf;
  t.arrowrightheavy = 0x279e;
  t.arrowrightoverleft = 0x21c4;
  t.arrowrightwhite = 0x21e8;
  t.arrowtableft = 0x21e4;
  t.arrowtabright = 0x21e5;
  t.arrowup = 0x2191;
  t.arrowupdn = 0x2195;
  t.arrowupdnbse = 0x21a8;
  t.arrowupdownbase = 0x21a8;
  t.arrowupleft = 0x2196;
  t.arrowupleftofdown = 0x21c5;
  t.arrowupright = 0x2197;
  t.arrowupwhite = 0x21e7;
  t.verticefreccia = 0xf8e6;
  t.asciicircum = 0x005e;
  t.asciicircummonospace = 0xff3e;
  t.asciitilde = 0x007e;
  t.asciitildemonospace = 0xff5e;
  t.ascript = 0x0251;
  t.ascriptturned = 0x0252;
  t.asmallhiragana = 0x3041;
  t.asmallkatakana = 0x30a1;
  t.asmallkatakanahalfwidth = 0xff67;
  t.asterisco = 0x002a;
  t.asteriskaltonearabic = 0x066d;
  t.asteriscocarabico = 0x066d;
  t.asteriskmath = 0x2217;
  t.asteriskmonospace = 0xff0a;
  t.asterisksmall = 0xfe61;
  t.asterismo = 0x2042;
  t.asuperior = 0xf6e9;
  t.asintoticamenteuguale = 0x2243;
  t.at = 0x0040;
  t.atilde = 0x00e3;
  t.atmonospace = 0xff20;
  t.atsmall = 0xfe6b;
  t.aturned = 0x0250;
  t.aubengali = 0x0994;
  t.aubopomofo = 0x3120;
  t.audeva = 0x0914;
  t.augujarati = 0x0a94;
  t.augurmukhi = 0x0a14;
  t.aulengthmarkbengali = 0x09d7;
  t.aumatragurmukhi = 0x0a4c;
  t.auvowelsignbengali = 0x09cc;
  t.auvowelsigndeva = 0x094c;
  t.auvowelsigngujarati = 0x0acc;
  t.avagrahadeva = 0x093d;
  t.aybarmenian = 0x0561;
  t.ayin = 0x05e2;
  t.ayinaltonehebrew = 0xfb20;
  t.ayinhebrew = 0x05e2;
  tb = 0x0062;
  t.babengali = 0x09ac;
  t.barra rovesciata = 0x005c;
  t.backslashmonospace = 0xff3c;
  t.badeva = 0x092c;
  t.bagujarati = 0x0aac;
  t.bagurmukhi = 0x0a2c;
  t.bahiragana = 0x3070;
  t.bahtthai = 0x0e3f;
  t.bakatakana = 0x30d0;
  t.bar = 0x007c;
  t.barmonospace = 0xff5c;
  t.bbopomofo = 0x3105;
  t.bcerchio = 0x24d1;
  t.bdotaccent = 0x1e03;
  t.bdotbelow = 0x1e05;
  t.beamedsixteenthnotes = 0x266c;
  t.perché = 0x2235;
  t.becirillico = 0x0431;
  t.beharabic = 0x0628;
  t.behfinalarabic = 0xfe90;
  t.behinitialarabic = 0xfe91;
  t.behiragana = 0x3079;
  t.behmedialarabic = 0xfe92;
  t.behmeeminitialarabic = 0xfc9f;
  t.behmeemisolatedarabic = 0xfc08;
  t.behnoonfinalarabic = 0xfc6d;
  t.bekatakana = 0x30d9;
  t.benarmeniano = 0x0562;
  t.bet = 0x05d1;
  t.beta = 0x03b2;
  t.betasymbolgreek = 0x03d0;
  t.betdagesh = 0xfb31;
  t.betdageshhebrew = 0xfb31;
  t.bethebrew = 0x05d1;
  t.betrafehebrew = 0xfb4c;
  t.bhabengali = 0x09ad;
  t.bhadeva = 0x092d;
  t.bhagujarati = 0x0aad;
  t.bhagurmukhi = 0x0a2d;
  t.bhook = 0x0253;
  t.bihiragana = 0x3073;
  t.bikatakana = 0x30d3;
  t.bilabialclick = 0x0298;
  t.bindigurmukhi = 0x0a02;
  t.birusquare = 0x3331;
  t.blackcircle = 0x25cf;
  t.diamantenero = 0x25c6;
  t.blackdownpointingtriangle = 0x25bc;
  t.blackleftpointingpointer = 0x25c4;
  t.triangolochepuntaasinistranero = 0x25c0;
  t.blacklenticularbracketleft = 0x3010;
  t.blacklenticularbracketleftvertical = 0xfe3b;
  t.blacklenticularbracketright = 0x3011;
  t.blacklenticularbracketrightvertical = 0xfe3c;
  t.triangoloinferioresinistro nero = 0x25e3;
  t.triangoloinferioredestronero = 0x25e2;
  t.rettangolo nero = 0x25ac;
  t.blackrightpointingpointer = 0x25ba;
  t.triangolochepuntaadestranero = 0x25b6;
  t.blacksmallsquare = 0x25aa;
  t.blacksmilingface = 0x263b;
  t.quadratonero = 0x25a0;
  t.blackstar = 0x2605;
  t.triangolosuperioresinistronero = 0x25e4;
  t.triangolosuperioredestro nero = 0x25e5;
  t.blackuppointingsmalltriangle = 0x25b4;
  t.blackuppointingtriangle = 0x25b2;
  t.vuoto = 0x2423;
  t.blinebelow = 0x1e07;
  t.blocco = 0x2588;
  t.bmonospace = 0xff42;
  t.bobaimaithai = 0x0e1a;
  t.bohiragana = 0x307c;
  t.bokatakana = 0x30dc;
  t.bparen = 0x249d;
  t.bqsquare = 0x33c3;
  t.braceex = 0xf8f4;
  t.braceleft = 0x007b;
  t.braceleftbt = 0xf8f3;
  t.braceleftmid = 0xf8f2;
  t.braceleftmonospace = 0xff5b;
  t.braceleftsmall = 0xfe5b;
  t.bracelefttp = 0xf8f1;
  t.braceleftvertical = 0xfe37;
  t.braceright = 0x007d;
  t.bracerightbt = 0xf8fe;
  t.bracerightmid = 0xf8fd;
  t.bracerightmonospace = 0xff5d;
  t.bracerightsmall = 0xfe5c;
  t.bracerighttp = 0xf8fc;
  t.bracerightvertical = 0xfe38;
  t.bracketleft = 0x005b;
  t.bracketleftbt = 0xf8f0;
  t.bracketleftex = 0xf8ef;
  t.bracketleftmonospace = 0xff3b;
  t.bracketlefttp = 0xf8ee;
  t.bracketright = 0x005d;
  t.bracketrightbt = 0xf8fb;
  t.bracketrightex = 0xf8fa;
  t.bracketrightmonospace = 0xff3d;
  t.bracketrighttp = 0xf8f9;
  t.breve = 0x02d8;
  t.brevebelowcmb = 0x032e;
  t.brevecmb = 0x0306;
  t.breveinvertedbelowcmb = 0x032f;
  t.breveinvertedcmb = 0x0311;
  t.breveinverteddoublecmb = 0x0361;
  t.bridgebelowcmb = 0x032a;
  t.bridgeinvertedbelowcmb = 0x033a;
  t.barra rotta = 0x00a6;
  t.bstroke = 0x0180;
  t.bsuperior = 0xf6ea;
  t.btopbar = 0x0183;
  t.buhiragana = 0x3076;
  t.bukatakana = 0x30d6;
  t.bullet = 0x2022;
  t.bulletinverse = 0x25d8;
  t.bulletoperator = 0x2219;
  t.bullseye = 0x25ce;
  tc = 0x0063;
  t.caarmenian = 0x056e;
  t.cabengali = 0x099a;
  t.cacute = 0x0107;
  t.cadeva = 0x091a;
  t.cagujarati = 0x0a9a;
  t.cagurmukhi = 0x0a1a;
  t.calsquare = 0x3388;
  t.candrabindubengali = 0x0981;
  t.candrabinducmb = 0x0310;
  t.candrabindudeva = 0x0901;
  t.candrabindugujarati = 0x0a81;
  t.capslock = 0x21ea;
  t.careof = 0x2105;
  t.caron = 0x02c7;
  t.caronbelowcmb = 0x032c;
  t.caroncmb = 0x030c;
  t.carriagereturn = 0x21b5;
  t.cbopomofo = 0x3118;
  t.ccaron = 0x010d;
  t.ccedilla = 0x00e7;
  t.ccedillaacute = 0x1e09;
  t.cerchio = 0x24d2;
  t.ccirconflesso = 0x0109;
  t.ccurl = 0x0255;
  t.cdot = 0x010b;
  t.cdotaccent = 0x010b;
  t.cdsquare = 0x33c5;
  t.cediglia = 0x00b8;
  t.cedillacmb = 0x0327;
  t.cent = 0x00a2;
  t.centigradi = 0x2103;
  t.centinferiore = 0xf6df;
  t.centmonospace = 0xffe0;
  t.centoldstyle = 0xf7a2;
  t.centsuperior = 0xf6e0;
  t.chaarmenian = 0x0579;
  t.chabengali = 0x099b;
  t.chadeva = 0x091b;
  t.chagujarati = 0x0a9b;
  t.chagurmukhi = 0x0a1b;
  t.chbopomofo = 0x3114;
  t.cheabkhasiancyrillic = 0x04bd;
  t.segno di spunta = 0x2713;
  t.checirillico = 0x0447;
  t.chedescenderabkhasiancyrillic = 0x04bf;
  t.chedescendercyrillic = 0x04b7;
  t.chederesiscyrillic = 0x04f5;
  t.cheharmenian = 0x0573;
  t.chekhakassiancyrillic = 0x04cc;
  t.cheverticalstrokecyrillic = 0x04b9;
  t.chi = 0x03c7;
  t.chieuchacirclekorean = 0x3277;
  t.chieuchaparenkorean = 0x3217;
  t.chieuchcirclekorean = 0x3269;
  t.chieuchkorean = 0x314a;
  t.chieuchparenkorean = 0x3209;
  t.chochangthai = 0x0e0a;
  t.chochanthai = 0x0e08;
  t.chochingthai = 0x0e09;
  t.chochoethai = 0x0e0c;
  t.chook = 0x0188;
  t.cieucacirclekorean = 0x3276;
  t.cieucaparenkorean = 0x3216;
  t.cieuccirclekorean = 0x3268;
  t.cieuckorean = 0x3148;
  t.cieucparenkorean = 0x3208;
  t.cieucuparenkorean = 0x321c;
  t.cerchio = 0x25cb;
  t.circlecopyrt = 0x00a9;
  t.circlemultiply = 0x2297;
  t.circleot = 0x2299;
  t.circleplus = 0x2295;
  t.circlepostalmark = 0x3036;
  t.cerchioconmezzonero sinistro = 0x25d0;
  t.cerchioconmezzonerodestro = 0x25d1;
  t.circonflesso = 0x02c6;
  t.circumflexbelowcmb = 0x032d;
  t.circumflexcmb = 0x0302;
  t.clear = 0x2327;
  t.clickalveolare = 0x01c2;
  t.clickdental = 0x01c0;
  t.clicklateral = 0x01c1;
  t.clickretroflex = 0x01c3;
  t.club = 0x2663;
  t.clubsuitblack = 0x2663;
  t.clubsuitwhite = 0x2667;
  t.cmcubedsquare = 0x33a4;
  t.cmonospace = 0xff43;
  t.cmsquaredsquare = 0x33a0;
  t.coarmenian = 0x0581;
  t.due punti = 0x003a;
  t.colonmonetary = 0x20a1;
  t.colonmonospace = 0xff1a;
  t.colonsign = 0x20a1;
  t.colonsmall = 0xfe55;
  t.colontriangularhalfmod = 0x02d1;
  t.colontriangularmod = 0x02d0;
  t.virgola = 0x002c;
  t.commaabovecmb = 0x0313;
  t.commaaboverightcmb = 0x0315;
  t.commaaccent = 0xf6c3;
  t.commaarabic = 0x060c;
  t.commaarmenian = 0x055d;
  t.commainferior = 0xf6e1;
  t.commamonospace = 0xff0c;
  t.commareversedabovecmb = 0x0314;
  t.commareversedmod = 0x02bd;
  t.commasmall = 0xfe50;
  t.commasuperior = 0xf6e2;
  t.commaturnedabovecmb = 0x0312;
  t.commaturnedmod = 0x02bb;
  t.bussola = 0x263c;
  t.congruente = 0x2245;
  t.integrale di contorno = 0x222e;
  t.controllo = 0x2303;
  t.controlACK = 0x0006;
  t.controlBEL = 0x0007;
  t.controlBS = 0x0008;
  t.controlCAN = 0x0018;
  t.controlCR = 0x000d;
  t.controlDC1 = 0x0011;
  t.controlDC2 = 0x0012;
  t.controlDC3 = 0x0013;
  t.controlDC4 = 0x0014;
  t.controlDEL = 0x007f;
  t.controlDLE = 0x0010;
  t.controlEM = 0x0019;
  t.controlENQ = 0x0005;
  t.controlEOT = 0x0004;
  t.controlESC = 0x001b;
  t.controlETB = 0x0017;
  t.controlETX = 0x0003;
  t.controlFF = 0x000c;
  t.controlFS = 0x001c;
  t.controlGS = 0x001d;
  t.controlHT = 0x0009;
  t.controlLF = 0x000a;
  t.controlNAK = 0x0015;
  t.controlNULL = 0x0000;
  t.controlRS = 0x001e;
  t.controlSI = 0x000f;
  t.controlSO = 0x000e;
  t.controlSOT = 0x0002;
  t.controlSTX = 0x0001;
  t.controlSUB = 0x001a;
  t.controlSYN = 0x0016;
  t.controlUS = 0x001f;
  t.controlVT = 0x000b;
  t.copyright = 0x00a9;
  t.copyrightsans = 0xf8e9;
  t.copyrightserif = 0xf6d9;
  t.cornerbracketleft = 0x300c;
  t.cornerbracketlefthalfwidth = 0xff62;
  t.cornerbracketleftvertical = 0xfe41;
  t.cornerbracketright = 0x300d;
  t.cornerbracketrighthalfwidth = 0xff63;
  t.cornerbracketrightvertical = 0xfe42;
  t.corporationsquare = 0x337f;
  t.coquadrato = 0x33c7;
  t.coverkgsquare = 0x33c6;
  t.cparen = 0x249e;
  t.cruzeiro = 0x20a2;
  t.cstretched = 0x0297;
  t.curlyand = 0x22cf;
  t.curlyor = 0x22ce;
  t.valuta = 0x00a4;
  t.cyrBreve = 0xf6d1;
  t.cyrFlex = 0xf6d2;
  t.cyrbreve = 0xf6d4;
  t.cyrflex = 0xf6d5;
  td = 0x0064;
  t.daarmenian = 0x0564;
  t.dabengali = 0x09a6;
  t.dadarabic = 0x0636;
  t.dadeva = 0x0926;
  t.dadfinalarabic = 0xfebe;
  t.dadinitialarabic = 0xfebf;
  t.dadmedialarabic = 0xfec0;
  t.dagesh = 0x05bc;
  t.dageshhebrew = 0x05bc;
  t.pugnale = 0x2020;
  t.daggerdbl = 0x2021;
  t.dagujarati = 0x0aa6;
  t.dagurmukhi = 0x0a26;
  t.dahiragana = 0x3060;
  t.dakatakana = 0x30c0;
  t.dalarabo = 0x062f;
  t.dalet = 0x05d3;
  t.daletdagesh = 0xfb33;
  t.daletdageshhebrew = 0xfb33;
  t.dalethebrew = 0x05d3;
  t.dalfinalarabic = 0xfeaa;
  t.dammaarabic = 0x064f;
  t.dammalowarabic = 0x064f;
  t.dammatanaltonneaarabo = 0x064c;
  t.dammatanarabic = 0x064c;
  t.danda = 0x0964;
  t.dargahebrew = 0x05a7;
  t.dargalefthebrew = 0x05a7;
  t.dasiapneumatacyrilliccmb = 0x0485;
  t.dblGrave = 0xf6d3;
  t.dblanglebracketleft = 0x300a;
  t.dblanglebracketleftvertical = 0xfe3d;
  t.dblanglebracketright = 0x300b;
  t.dblanglebracketrightvertical = 0xfe3e;
  t.dblarchinvertedbelowcmb = 0x032b;
  t.dblarowleft = 0x21d4;
  t.dblarrowright = 0x21d2;
  t.dbldanda = 0x0965;
  t.dblgrave = 0xf6d6;
  t.dblgravecmb = 0x030f;
  t.dblintegral = 0x222c;
  t.dbllowline = 0x2017;
  t.dbllowlinecmb = 0x0333;
  t.dbloverlinecmb = 0x033f;
  t.dblprimemod = 0x02ba;
  t.dblverticalbar = 0x2016;
  t.dblverticallineabovecmb = 0x030e;
  t.dbopomofo = 0x3109;
  t.dbsquare = 0x33c8;
  t.dcaron = 0x010f;
  t.dcedilla = 0x1e11;
  t.dcircle = 0x24d3;
  t.dcircumflexbelow = 0x1e13;
  t.dcroat = 0x0111;
  t.ddabengali = 0x09a1;
  t.ddadeva = 0x0921;
  t.ddagujarati = 0x0aa1;
  t.ddagurmukhi = 0x0a21;
  t.ddalarabo = 0x0688;
  t.ddalfinalarabic = 0xfb89;
  t.dddhadeva = 0x095c;
  t.ddhabengali = 0x09a2;
  t.ddhadeva = 0x0922;
  t.ddhagujarati = 0x0aa2;
  t.ddhagurmukhi = 0x0a22;
  t.ddotaccent = 0x1e0b;
  t.ddotbelow = 0x1e0d;
  t.separatoredecimalearabo = 0x066b;
  t.separatoredecimalepersiano = 0x066b;
  t.decirillico = 0x0434;
  t.grado = 0x00b0;
  t.dehihebrew = 0x05ad;
  t.dehiragana = 0x3067;
  t.deicottico = 0x03ef;
  t.dekatakana = 0x30c7;
  t.deleteleft = 0x232b;
  t.deleteright = 0x2326;
  t.delta = 0x03b4;
  t.deltaturned = 0x018d;
  t.denominatorminusonenumeratorbengali = 0x09f8;
  t.dezh = 0x02a4;
  t.dhabengali = 0x09a7;
  t.dhadeva = 0x0927;
  t.dhagujarati = 0x0aa7;
  t.dhagurmukhi = 0x0a27;
  t.dhook = 0x0257;
  t.dialytikatonos = 0x0385;
  t.dialytikatonoscmb = 0x0344;
  t.diamante = 0x2666;
  t.diamondsuitwhite = 0x2662;
  t.dieresi = 0x00a8;
  t.dieresisacute = 0xf6d7;
  t.dieresisbelowcmb = 0x0324;
  t.dieresiscmb = 0x0308;
  t.dieresisgrave = 0xf6d8;
  t.dieresistonos = 0x0385;
  t.dihiragana = 0x3062;
  t.dikatakana = 0x30c2;
  t.dittomark = 0x3003;
  t.divide = 0x00f7;
  t.divide = 0x2223;
  t.divisionslash = 0x2215;
  t.djecyrillic = 0x0452;
  t.dkshade = 0x2593;
  t.dlinebelow = 0x1e0f;
  t.dlsquare = 0x3397;
  t.dmacron = 0x0111;
  t.dmonospace = 0xff44;
  t.dnblock = 0x2584;
  t.dochadathai = 0x0e0e;
  t.dodekthai = 0x0e14;
  t.dohiragana = 0x3069;
  t.dokatakana = 0x30c9;
  t.dollaro = 0x0024;
  t.dollarinferior = 0xf6e3;
  t.dollarmonospace = 0xff04;
  t.dollaroldstyle = 0xf724;
  t.dollarsmall = 0xfe69;
  t.dollarsuperior = 0xf6e4;
  t.dong = 0x20ab;
  t.dorusquare = 0x3326;
  t.dotaccent = 0x02d9;
  t.dotaccentcmb = 0x0307;
  t.dotbelowcmb = 0x0323;
  t.dotbelowcomb = 0x0323;
  t.dotkatakana = 0x30fb;
  t.dotlessi = 0x0131;
  t.dotlessj = 0xf6be;
  t.dotlessjstrokehook = 0x0284;
  t.dotmath = 0x22c5;
  t.dottedcircle = 0x25cc;
  t.doubleyodpatah = 0xfb1f;
  t.doubleyodpatahhebrew = 0xfb1f;
  t.downtackbelowcmb = 0x031e;
  t.downtackmod = 0x02d5;
  t.dparen = 0x249f;
  t.dsuperior = 0xf6eb;
  t.dtail = 0x0256;
  t.dtopbar = 0x018c;
  t.duhiragana = 0x3065;
  t.dukatakana = 0x30c5;
  t.dz = 0x01f3;
  t.dzaltone = 0x02a3;
  t.dzcaron = 0x01c6;
  t.dzcurl = 0x02a5;
  t.dzeabkhasiancyrillic = 0x04e1;
  t.dzecyrillic = 0x0455;
  t.dzhecyrillic = 0x045f;
  te = 0x0065;
  t.eacute = 0x00e9;
  t.terra = 0x2641;
  t.ebengali = 0x098f;
  t.ebopomofo = 0x311c;
  t.ebreve = 0x0115;
  t.ecandradeva = 0x090d;
  t.ecandragujarati = 0x0a8d;
  t.ecandravowelsigndeva = 0x0945;
  t.ecandravowelsigngujarati = 0x0ac5;
  t.ecaron = 0x011b;
  t.ecedillabreve = 0x1e1d;
  t.echarmenian = 0x0565;
  t.echyiwnarmenian = 0x0587;
  t.cerchio = 0x24d4;
  t.ecirconflesso = 0x00ea;
  t.ecircumflexacute = 0x1ebf;
  t.ecircumflexbelow = 0x1e19;
  t.ecircumflexdotbelow = 0x1ec7;
  t.ecircumflexgrave = 0x1ec1;
  t.ecircumflexhookabove = 0x1ec3;
  t.ecircumflextilde = 0x1ec5;
  t.cirillico = 0x0454;
  t.edblgrave = 0x0205;
  t.edeva = 0x090f;
  t.edieresi = 0x00eb;
  t.edot = 0x0117;
  t.edotaccent = 0x0117;
  t.edotbelow = 0x1eb9;
  t.eegurmukhi = 0x0a0f;
  t.eematragurmukhi = 0x0a47;
  t.efcyrillic = 0x0444;
  t.egrave = 0x00e8;
  t.egujarati = 0x0a8f;
  t.eharmenian = 0x0567;
  t.ehbopomofo = 0x311d;
  t.ehiragana = 0x3048;
  t.ehookabove = 0x1ebb;
  t.eibopomofo = 0x311f;
  t.otto = 0x0038;
  t.eightarabic = 0x0668;
  t.eightbengali = 0x09ee;
  t.ottocerchio = 0x2467;
  t.eightcircleinversesansserif = 0x2791;
  t.eightdeva = 0x096e;
  t.diciottocerchi = 0x2471;
  t.diciottoparen = 0x2485;
  t.diciottoperiodo = 0x2499;
  t.eightgujarati = 0x0aee;
  t.eightgurmukhi = 0x0a6e;
  t.eighthackarabic = 0x0668;
  t.eighthangzhou = 0x3028;
  t.eighthnotebeamed = 0x266b;
  t.eightideographicparen = 0x3227;
  t.eightinferior = 0x2088;
  t.eightmonospace = 0xff18;
  t.eightoldstyle = 0xf738;
  t.eightparen = 0x247b;
  t.ottoperiodo = 0x248f;
  t.ottopersiano = 0x06f8;
  t.eightroman = 0x2177;
  t.eightsuperior = 0x2078;
  t.eightthai = 0x0e58;
  t.einvertedbreve = 0x0207;
  t.eiotifiedcyrillic = 0x0465;
  t.ekatakana = 0x30a8;
  t.ekatakanahalfwidth = 0xff74;
  t.ekonkargurmukhi = 0x0a74;
  t.ekorean = 0x3154;
  t.elcyrillic = 0x043b;
  t.elemento = 0x2208;
  t.elevencircle = 0x246a;
  t.elevenparen = 0x247e;
  t.elevenperiod = 0x2492;
  t.elevenroman = 0x217a;
  t.ellissi = 0x2026;
  t.ellipsisvertical = 0x22ee;
  t.emacron = 0x0113;
  t.emacronacute = 0x1e17;
  t.emacrongrave = 0x1e15;
  t.emcyrillic = 0x043c;
  t.trattino = 0x2014;
  t.emdashvertical = 0xfe31;
  t.emonospace = 0xff45;
  t.emphasismarkarmenian = 0x055b;
  t.set vuoto = 0x2205;
  t.enbopomofo = 0x3123;
  t.encyrillic = 0x043d;
  t.endash = 0x2013;
  t.endashvertical = 0xfe32;
  t.endescendercyrillic = 0x04a3;
  t.eng = 0x014b;
  t.engbopomofo = 0x3125;
  t.enghecyrillic = 0x04a5;
  t.enhookcyrillic = 0x04c8;
  t.enspace = 0x2002;
  t.eogonek = 0x0119;
  t.eocoreano = 0x3153;
  t.eopen = 0x025b;
  t.eopenclosed = 0x029a;
  t.eopenreversed = 0x025c;
  t.eopenreversedclosed = 0x025e;
  t.eopenreversedhook = 0x025d;
  t.eparen = 0x24a0;
  t.epsilon = 0x03b5;
  t.epsilontonos = 0x03ad;
  t.uguale = 0x003d;
  t.equalmonospace = 0xff1d;
  t.equalsmall = 0xfe66;
  t.equalsuperior = 0x207c;
  t.equivalenza = 0x2261;
  t.erbopomofo = 0x3126;
  t.ercyrillic = 0x0440;
  t.ereversed = 0x0258;
  t.ereversedcyrillic = 0x044d;
  t.escyrillic = 0x0441;
  t.esdescendercyrillic = 0x04ab;
  t.esh = 0x0283;
  t.eshcurl = 0x0286;
  t.eshortdeva = 0x090e;
  t.eshortvowelsigndeva = 0x0946;
  t.eshreversedloop = 0x01aa;
  t.eshsquatreversed = 0x0285;
  t.esmallhiragana = 0x3047;
  t.esmallkatakana = 0x30a7;
  t.esmallkatakanahalfwidth = 0xff6a;
  t.stima = 0x212e;
  t.esuperior = 0xf6ec;
  t.eta = 0x03b7;
  t.etarmenian = 0x0568;
  t.etatonos = 0x03ae;
  t.eth = 0x00f0;
  t.etilde = 0x1ebd;
  t.etildebelow = 0x1e1b;
  t.etnahtafoukhhebrew = 0x0591;
  t.etnahtafoukhlefthebrew = 0x0591;
  t.etnahtahebrew = 0x0591;
  t.etnahtalefthebrew = 0x0591;
  t.restituito = 0x01dd;
  t.eukorean = 0x3161;
  t.euro = 0x20ac;
  t.evowelsignbengali = 0x09c7;
  t.evowelsigndeva = 0x0947;
  t.evowelsigngujarati = 0x0ac7;
  t.esclamazione = 0x0021;
  t.esclamarmenian = 0x055c;
  t.exclamdbl = 0x203c;
  t.esclamazionegiù = 0x00a1;
  t.exclamdownsmall = 0xf7a1;
  t.exclammonospace = 0xff01;
  t.exclamsmall = 0xf721;
  t.esistenziale = 0x2203;
  t.ezh = 0x0292;
  t.ezhcaron = 0x01ef;
  t.ezhcurl = 0x0293;
  t.ezhreversed = 0x01b9;
  t.ezhtail = 0x01ba;
  tf = 0x0066;
  t.fadeva = 0x095e;
  t.fagurmukhi = 0x0a5e;
  t.fahrenheit = 0x2109;
  t.fathaarabic = 0x064e;
  t.fathalowarabic = 0x064e;
  t.fathatanarabic = 0x064b;
  t.fbopomofo = 0x3108;
  t.fcircle = 0x24d5;
  t.fdotaccent = 0x1e1f;
  t.feharabic = 0x0641;
  t.feharmeniano = 0x0586;
  t.fehfinalarabic = 0xfed2;
  t.fehinitialarabic = 0xfed3;
  t.fehmedialarabic = 0xfed4;
  t.feicottico = 0x03e5;
  t.femmina = 0x2640;
  t.ff = 0xfb00;
  t.f_f = 0xfb00;
  t.ffi = 0xfb03;
  t.f_f_i = 0xfb03;
  t.ffl = 0xfb04;
  t.f_f_l = 0xfb04;
  t.fi = 0xfb01;
  t.f_i = 0xfb01;
  t.quindicicerchi = 0x246e;
  t.fifteenparen = 0x2482;
  t.quindiciperiodo = 0x2496;
  t.figuredash = 0x2012;
  t.filledbox = 0x25a0;
  t.filledrect = 0x25ac;
  t.finalkaf = 0x05da;
  t.finalkafdagesh = 0xfb3a;
  t.finalkafdageshhebrew = 0xfb3a;
  t.finalkafhebrew = 0x05da;
  t.finalmem = 0x05dd;
  t.finalmemhebrew = 0x05dd;
  t.finalnun = 0x05df;
  t.finalnunhebrew = 0x05df;
  t.finalpe = 0x05e3;
  t.finalpehebrew = 0x05e3;
  t.finaltsadi = 0x05e5;
  t.finaltsadihebrew = 0x05e5;
  t.firsttonechinese = 0x02c9;
  t.fisheye = 0x25c9;
  t.fitacirillico = 0x0473;
  t.cinque = 0x0035;
  t.fivearabic = 0x0665;
  t.fivebengali = 0x09eb;
  t.fivecircle = 0x2464;
  t.fivecircleinversesansserif = 0x278e;
  t.fivedeva = 0x096b;
  t.cinqueottavi = 0x215d;
  t.fivegujarati = 0x0aeb;
  t.fivegurmukhi = 0x0a6b;
  t.fivehackarabic = 0x0665;
  t.fivehangzhou = 0x3025;
  t.fiveideographicparen = 0x3224;
  t.fiveinferior = 0x2085;
  t.fivemonospace = 0xff15;
  t.fiveoldstyle = 0xf735;
  t.fiveparen = 0x2478;
  t.fiveperiod = 0x248c;
  t.fivepersian = 0x06f5;
  t.fiveroman = 0x2174;
  t.fivesuperior = 0x2075;
  t.fivethai = 0x0e55;
  t.fl = 0xfb02;
  t.f_l = 0xfb02;
  t.florin = 0x0192;
  t.fmonospace = 0xff46;
  t.fmsquare = 0x3399;
  t.fofanthai = 0x0e1f;
  t.fofathai = 0x0e1d;
  t.fongmanthai = 0x0e4f;
  t.forall = 0x2200;
  t.quattro = 0x0034;
  t.fourarabic = 0x0664;
  t.fourbengali = 0x09ea;
  t.quattrocerchi = 0x2463;
  t.fourcircleinversesansserif = 0x278d;
  t.fourdeva = 0x096a;
  t.fourgujarati = 0x0aea;
  t.fourgurmukhi = 0x0a6a;
  t.fourhackarabic = 0x0664;
  t.fourhangzhou = 0x3024;
  t.fourideographicparen = 0x3223;
  t.quattroinferiore = 0x2084;
  t.fourmonospace = 0xff14;
  t.fournumeratorbengali = 0x09f7;
  t.fouroldstyle = 0xf734;
  t.fourparen = 0x2477;
  t.quattroperiodi = 0x248b;
  t.quattropersiano = 0x06f4;
  t.fourroman = 0x2173;
  t.foursuperior = 0x2074;
  t.quattordicicerchi = 0x246d;
  t.quattordicipareti = 0x2481;
  t.quattordiciperiodi = 0x2495;
  t.fourthai = 0x0e54;
  t.fourthtonechinese = 0x02cb;
  t.fparen = 0x24a1;
  t.frazione = 0x2044;
  t.franco = 0x20a3;
  tg = 0x0067;
  t.gabengali = 0x0997;
  t.gacute = 0x01f5;
  t.gadeva = 0x0917;
  t.gafarabic = 0x06af;
  t.gaffinalarabic = 0xfb93;
  t.gafinitialarabic = 0xfb94;
  t.gafmedialarabic = 0xfb95;
  t.gagujarati = 0x0a97;
  t.gagurmukhi = 0x0a17;
  t.gahiragana = 0x304c;
  t.gakatakana = 0x30ac;
  t.gamma = 0x03b3;
  t.gammalatinsmall = 0x0263;
  t.gammasuperiore = 0x02e0;
  t.gangiacottico = 0x03eb;
  t.gbopomofo = 0x310d;
  t.gbreve = 0x011f;
  t.gcaron = 0x01e7;
  t.gcedilla = 0x0123;
  t.gcircle = 0x24d6;
  t.gcirconflesso = 0x011d;
  t.gcommaaccent = 0x0123;
  t.gdot = 0x0121;
  t.gdotaccent = 0x0121;
  t.gecyrillic = 0x0433;
  t.gehiragana = 0x3052;
  t.gekatakana = 0x30b2;
  t.geometricamenteuguale = 0x2251;
  t.gereshaccenthebrew = 0x059c;
  t.gereshhebrew = 0x05f3;
  t.gereshmuqdamhebrew = 0x059d;
  t.germandbls = 0x00df;
  t.gershayimaccenthebrew = 0x059e;
  t.gershayimhebrew = 0x05f4;
  t.getamark = 0x3013;
  t.ghabengali = 0x0998;
  t.ghadarmenian = 0x0572;
  t.ghadeva = 0x0918;
  t.ghagujarati = 0x0a98;
  t.ghagurmukhi = 0x0a18;
  t.ghainarabic = 0x063a;
  t.ghainfinalarabic = 0xfece;
  t.ghaininitialarabic = 0xfecf;
  t.ghainmedialarabic = 0xfed0;
  t.ghemiddlehookcyrillic = 0x0495;
  t.ghestrokecyrillic = 0x0493;
  t.gheupturncyrillic = 0x0491;
  t.ghhadeva = 0x095a;
  t.ghhagurmukhi = 0x0a5a;
  t.ghook = 0x0260;
  t.ghzsquare = 0x3393;
  t.gihiragana = 0x304e;
  t.gikatakana = 0x30ae;
  t.gimarmenian = 0x0563;
  t.gimel = 0x05d2;
  t.gimeldagesh = 0xfb32;
  t.gimeldageshhebrew = 0xfb32;
  t.gimelhebrew = 0x05d2;
  t.gjecyrillic = 0x0453;
  t.glottalinvertedstroke = 0x01be;
  t.glottalstop = 0x0294;
  t.glottalstopinverted = 0x0296;
  t.glottalstopmod = 0x02c0;
  t.glottalstopreversed = 0x0295;
  t.glottalstopreversedmod = 0x02c1;
  t.glottalstopreversedsuperior = 0x02e4;
  t.glottalstopstroke = 0x02a1;
  t.glottalstopstrokereversed = 0x02a2;
  t.gmacron = 0x1e21;
  t.gmonospace = 0xff47;
  t.gohiragana = 0x3054;
  t.gokatakana = 0x30b4;
  t.gparen = 0x24a2;
  t.gpasquare = 0x33ac;
  t.gradiente = 0x2207;
  t.grave = 0x0060;
  t.gravebelowcmb = 0x0316;
  t.gravecmb = 0x0300;
  t.gravecomb = 0x0300;
  t.gravedeva = 0x0953;
  t.gravelowmod = 0x02ce;
  t.gravemonospace = 0xff40;
  t.gravetonecmb = 0x0340;
  t.maggiore = 0x003e;
  t.maggioreuguale = 0x2265;
  t.greaterequalorless = 0x22db;
  t.greatermonospace = 0xff1e;
  t.maggioreequivalente = 0x2273;
  t.piùgrandeomeno = 0x2277;
  t.maggiorepiùuguale = 0x2267;
  t.piùgrandepiccolo = 0xfe65;
  t.gscript = 0x0261;
  t.gstroke = 0x01e5;
  t.guhiragana = 0x3050;
  t.guillemotleft = 0x00ab;
  t.guillemotright = 0x00bb;
  t.guilsinglleft = 0x2039;
  t.guilsinglright = 0x203a;
  t.gukatakana = 0x30b0;
  t.guramusquare = 0x3318;
  t.gysquare = 0x33c9;
  th = 0x0068;
  t.haabkhasiancyrillic = 0x04a9;
  t.haaltonearabic = 0x06c1;
  t.habengali = 0x09b9;
  t.hadescendercyrillic = 0x04b3;
  t.hadeva = 0x0939;
  t.hagujarati = 0x0ab9;
  t.hagurmukhi = 0x0a39;
  t.haharabic = 0x062d;
  t.hahfinalarabic = 0xfea2;
  t.hahinitialarabic = 0xfea3;
  t.hahiragana = 0x306f;
  t.hahmedialarabic = 0xfea4;
  t.haitusquare = 0x332a;
  t.hakatakana = 0x30cf;
  t.hakatakanahalfwidth = 0xff8a;
  t.halantgurmukhi = 0x0a4d;
  t.hamzaarabic = 0x0621;
  t.hamzalowarabic = 0x0621;
  t.hangulfiller = 0x3164;
  t.hardsigncyrillic = 0x044a;
  t.harpoonleftbarbup = 0x21bc;
  t.harpoonrightbarbup = 0x21c0;
  t.hasquare = 0x33ca;
  t.hatafpatah = 0x05b2;
  t.hatafpatah16 = 0x05b2;
  t.hatafpatah23 = 0x05b2;
  t.hatafpatah2f = 0x05b2;
  t.hatafpatahhebrew = 0x05b2;
  t.hatafpatahnarrowhebrew = 0x05b2;
  t.hatafpatahquarterhebrew = 0x05b2;
  t.hatafpatahwidehebrew = 0x05b2;
  t.hatafqamats = 0x05b3;
  t.hatafqamats1b = 0x05b3;
  t.hatafqamats28 = 0x05b3;
  t.hatafqamats34 = 0x05b3;
  t.hatafqamatshebrew = 0x05b3;
  t.hatafqamatsnarrowhebrew = 0x05b3;
  t.hatafqamatsquarterhebrew = 0x05b3;
  t.hatafqamatswidehebrew = 0x05b3;
  t.hatafsegol = 0x05b1;
  t.hatafsegol17 = 0x05b1;
  t.hatafsegol24 = 0x05b1;
  t.hatafsegol30 = 0x05b1;
  t.hatafsegolhebrew = 0x05b1;
  t.hatafsegolnarrowhebrew = 0x05b1;
  t.hatafsegolquarterhebrew = 0x05b1;
  t.hatafsegolwidehebrew = 0x05b1;
  t.hbar = 0x0127;
  t.hbopomofo = 0x310f;
  t.hbrevebelow = 0x1e2b;
  t.hcedilla = 0x1e29;
  t.hcircle = 0x24d7;
  t.hcirconflesso = 0x0125;
  t.hdieresis = 0x1e27;
  t.hdotaccent = 0x1e23;
  t.hdotbelow = 0x1e25;
  lui = 0x05d4;
  t.cuore = 0x2665;
  t.heartsuitblack = 0x2665;
  t.cuorevestitobianco = 0x2661;
  t.hedagesh = 0xfb34;
  t.hedageshhebrew = 0xfb34;
  t.hehaltonearabic = 0x06c1;
  t.heharabic = 0x0647;
  t.hehebrew = 0x05d4;
  t.hehfinalaltonearabic = 0xfba7;
  t.hehfinalalttwoarabic = 0xfeea;
  t.hehfinalarabic = 0xfeea;
  t.hehhamzaabovefinalarabic = 0xfba5;
  t.hehhamzaaboveisolatedarabic = 0xfba4;
  t.hehinitialaltonearabic = 0xfba8;
  t.hehinitialarabic = 0xfeeb;
  t.hehiragana = 0x3078;
  t.hehmedialaltonearabic = 0xfba9;
  t.hehmedialarabic = 0xfeec;
  t.heiseierasquare = 0x337b;
  t.hekatakana = 0x30d8;
  t.hekatakanahalfwidth = 0xff8d;
  t.hekutaarusquare = 0x3336;
  t.henghook = 0x0267;
  t.herutusquad = 0x3339;
  t.het = 0x05d7;
  t.hethebrew = 0x05d7;
  t.hhook = 0x0266;
  t.hhooksuperior = 0x02b1;
  t.hieuhacirclekorean = 0x327b;
  t.hieuhaparenkorean = 0x321b;
  t.hieuhcirclekorean = 0x326d;
  t.hieuhkorean = 0x314e;
  t.hieuhparenkorean = 0x320d;
  t.hihiragana = 0x3072;
  t.hikatakana = 0x30d2;
  t.hikatakanahalfwidth = 0xff8b;
  t.hiriq = 0x05b4;
  t.hiriq14 = 0x05b4;
  t.hiriq21 = 0x05b4;
  t.hiriq2d = 0x05b4;
  t.hiriqhebrew = 0x05b4;
  t.hiriqnarrowhebrew = 0x05b4;
  t.hiriqquarterhebrew = 0x05b4;
  t.hiriqwidehebrew = 0x05b4;
  t.hlinebelow = 0x1e96;
  t.hmonospace = 0xff48;
  t.hoarmenian = 0x0570;
  t.hohipthai = 0x0e2b;
  t.hohiragana = 0x307b;
  t.hokatakana = 0x30db;
  t.hokatakanahalfwidth = 0xff8e;
  t.holam = 0x05b9;
  t.holam19 = 0x05b9;
  t.holam26 = 0x05b9;
  t.holam32 = 0x05b9;
  t.holamhebrew = 0x05b9;
  t.holamnarrowhebrew = 0x05b9;
  t.holamquarterhebrew = 0x05b9;
  t.holamwidehebrew = 0x05b9;
  t.honokhukthai = 0x0e2e;
  t.hookabovecomb = 0x0309;
  t.hookcmb = 0x0309;
  t.hookpalatalizedbelowcmb = 0x0321;
  t.hookretroflexbelowcmb = 0x0322;
  t.hoonsquare = 0x3342;
  t.horicoptic = 0x03e9;
  t.barra orizzontale = 0x2015;
  t.horncmb = 0x031b;
  t.sorgenti termali = 0x2668;
  t.casa = 0x2302;
  t.hparen = 0x24a3;
  t.hsuperior = 0x02b0;
  t.hturned = 0x0265;
  t.huhiragana = 0x3075;
  t.huiitosquare = 0x3333;
  t.hukatakana = 0x30d5;
  t.hukatakanahalfwidth = 0xff8c;
  t.hungarumlaut = 0x02dd;
  t.hungarumlautcmb = 0x030b;
  t.hv = 0x0195;
  trattino = 0x002d;
  t.trattinoinferiore = 0xf6e5;
  t.trattinomonospazio = 0xff0d;
  t.trattinopiccolo = 0xfe63;
  t.trattinosuperiore = 0xf6e6;
  t.trattinodue = 0x2010;
  ti = 0x0069;
  t.iacute = 0x00ed;
  t.iacirillico = 0x044f;
  t.ibengali = 0x0987;
  t.ibopomofo = 0x3127;
  t.ibreve = 0x012d;
  t.icaron = 0x01d0;
  t.icircle = 0x24d8;
  t.icirconflesso = 0x00ee;
  t.cirillico = 0x0456;
  t.idblgrave = 0x0209;
  t.ideographearthcircle = 0x328f;
  t.ideographfirecircle = 0x328b;
  t.ideographicallianceparen = 0x323f;
  t.ideographiccallparen = 0x323a;
  t.ideographiccentrecircle = 0x32a5;
  t.ideographicclose = 0x3006;
  t.virgola ideografica = 0x3001;
  t.ideographiccommaleft = 0xff64;
  t.ideographiccongratulationparen = 0x3237;
  t.ideographiccorrectcircle = 0x32a3;
  t.ideographicearthparen = 0x322f;
  t.ideographicenterpriseparen = 0x323d;
  t.ideographicexcellentcircle = 0x329d;
  t.ideographicfestivalparen = 0x3240;
  t.ideographicfinancialcircle = 0x3296;
  t.ideographicfinancialparen = 0x3236;
  t.ideographicfireparen = 0x322b;
  t.ideographichaveparen = 0x3232;
  t.ideographichighcircle = 0x32a4;
  t.ideographiciterationmark = 0x3005;
  t.ideographiclaborcircle = 0x3298;
  t.ideographiclaborparen = 0x3238;
  t.ideographicleftcircle = 0x32a7;
  t.ideographiclowcircle = 0x32a6;
  t.ideographicmedicinecircle = 0x32a9;
  t.ideographicmetalparen = 0x322e;
  t.ideographicmoonparen = 0x322a;
  t.ideographicnameparen = 0x3234;
  t.periodoideografico = 0x3002;
  t.ideographicprintcircle = 0x329e;
  t.ideographicreachparen = 0x3243;
  t.ideographicrepresentparen = 0x3239;
  t.ideographicresourceparen = 0x323e;
  t.ideographicrightcircle = 0x32a8;
  t.ideographicsecretcircle = 0x3299;
  t.ideographicselfparen = 0x3242;
  t.ideographicsocietyparen = 0x3233;
  t.spazioideografico = 0x3000;
  t.ideographicspecialparen = 0x3235;
  t.ideographicstockparen = 0x3231;
  t.ideographicstudyparen = 0x323b;
  t.ideographicsunparen = 0x3230;
  t.ideographicsuperviseparen = 0x323c;
  t.ideographicwaterparen = 0x322c;
  t.ideographicwoodparen = 0x322d;
  t.ideographiczero = 0x3007;
  t.ideographmetalcircle = 0x328e;
  t.ideographmooncircle = 0x328a;
  t.ideographnamecircle = 0x3294;
  t.ideographsuncircle = 0x3290;
  t.ideographwatercircle = 0x328c;
  t.ideographwoodcircle = 0x328d;
  t.ideva = 0x0907;
  t.idieresi = 0x00ef;
  t.idieresisacute = 0x1e2f;
  t.idieresiscyrillic = 0x04e5;
  t.idotbelow = 0x1ecb;
  t.iebrevecyrillic = 0x04d7;
  t.iecyrillic = 0x0435;
  t.ieungacirclekorean = 0x3275;
  t.ieungaparenkorean = 0x3215;
  t.ieungcirclekorean = 0x3267;
  t.ieungkorean = 0x3147;
  t.ieungparenkorean = 0x3207;
  t.igrave = 0x00ec;
  t.igujarati = 0x0a87;
  t.igurmukhi = 0x0a07;
  t.ihiragana = 0x3044;
  t.ihookabove = 0x1ec9;
  t.iibengali = 0x0988;
  t.iicyrillic = 0x0438;
  t.iideva = 0x0908;
  t.iigujarati = 0x0a88;
  t.iigurmukhi = 0x0a08;
  t.iimatragurmukhi = 0x0a40;
  t.iinvertedbreve = 0x020b;
  t.iishortcyrillic = 0x0439;
  t.iivowelsignbengali = 0x09c0;
  t.iivowelsigndeva = 0x0940;
  t.iivowelsigngujarati = 0x0ac0;
  t.ij = 0x0133;
  t.ikatakana = 0x30a4;
  t.ikatakanahalfwidth = 0xff72;
  t.icoreano = 0x3163;
  t.ilde = 0x02dc;
  t.iluyhebrew = 0x05ac;
  t.imacron = 0x012b;
  t.imacroncirillico = 0x04e3;
  t.imageorapproximatelyequal = 0x2253;
  t.imatragurmukhi = 0x0a3f;
  t.imonospazio = 0xff49;
  t.incremento = 0x2206;
  t.infinito = 0x221e;
  t.iniarmenian = 0x056b;
  t.integrale = 0x222b;
  t.integralbottom = 0x2321;
  t.integralbt = 0x2321;
  t.integralex = 0xf8f5;
  t.integraltop = 0x2320;
  t.integraltp = 0x2320;
  t.intersezione = 0x2229;
  t.intisquare = 0x3305;
  t.invbullet = 0x25d8;
  t.invcircle = 0x25d9;
  t.invsmileface = 0x263b;
  t.iocirillico = 0x0451;
  t.iogonek = 0x012f;
  t.iota = 0x03b9;
  t.iotadieresi = 0x03ca;
  t.iotadieresistonos = 0x0390;
  t.iotalatina = 0x0269;
  t.iotatonos = 0x03af;
  t.iparen = 0x24a4;
  t.irigurmukhi = 0x0a72;
  t.ismallhiragana = 0x3043;
  t.ismallkatakana = 0x30a3;
  t.ismallkatakanahalfwidth = 0xff68;
  t.issharbengali = 0x09fa;
  t.istroke = 0x0268;
  t.isuperior = 0xf6ed;
  t.iterazionehiragana = 0x309d;
  t.iterazionekatakana = 0x30fd;
  t.itilde = 0x0129;
  t.itildebelow = 0x1e2d;
  t.iubopomofo = 0x3129;
  t.iucyrillic = 0x044e;
  t.ivowelsignbengali = 0x09bf;
  t.ivowelsigndeva = 0x093f;
  t.ivowelsigngujarati = 0x0abf;
  t.izhitsacyrillic = 0x0475;
  t.izhitsadblgravecyrillic = 0x0477;
  tj = 0x006a;
  t.jaarmenian = 0x0571;
  t.jabengali = 0x099c;
  t.jadeva = 0x091c;
  t.jagujarati = 0x0a9c;
  t.jagurmukhi = 0x0a1c;
  t.jbopomofo = 0x3110;
  t.jcaron = 0x01f0;
  t.jcircle = 0x24d9;
  t.jcircumflex = 0x0135;
  t.jcrossedtail = 0x029d;
  t.jdotlessstroke = 0x025f;
  t.jecyrillic = 0x0458;
  t.jeemarabic = 0x062c;
  t.jeemfinalarabic = 0xfe9e;
  t.jeeminitialarabic = 0xfe9f;
  t.jeemmedialarabic = 0xfea0;
  t.jeharabic = 0x0698;
  t.jehfinalarabic = 0xfb8b;
  t.jhabengali = 0x099d;
  t.jhadeva = 0x091d;
  t.jhagujarati = 0x0a9d;
  t.jhagurmukhi = 0x0a1d;
  t.jheharmenian = 0x057b;
  t.jis = 0x3004;
  t.jmonospace = 0xff4a;
  t.jparen = 0x24a5;
  t.jsuperior = 0x02b2;
  tk = 0x006b;
  t.kabashkircirillico = 0x04a1;
  t.kabengali = 0x0995;
  t.kacute = 0x1e31;
  t.kacyrillic = 0x043a;
  t.kadescendercyrillic = 0x049b;
  t.kadeva = 0x0915;
  t.kaf = 0x05db;
  t.kafarabic = 0x0643;
  t.kafdagesh = 0xfb3b;
  t.kafdageshhebrew = 0xfb3b;
  t.kaffinalarabic = 0xfeda;
  t.kafhebrew = 0x05db;
  t.kafinitialarabic = 0xfedb;
  t.kafmedialarabic = 0xfedc;
  t.kafrafehebrew = 0xfb4d;
  t.kagujarati = 0x0a95;
  t.kagurmukhi = 0x0a15;
  t.kahiragana = 0x304b;
  t.kahookcyrillic = 0x04c4;
  t.kakatakana = 0x30ab;
  t.kakatakanahalfwidth = 0xff76;
  t.kappa = 0x03ba;
  t.kappasymbolgreek = 0x03f0;
  t.kapyeounmieumkorean = 0x3171;
  t.kapyeounphieuphkorean = 0x3184;
  t.kapyeounpieupkorean = 0x3178;
  t.kapyeounssangpieupkorean = 0x3179;
  t.karoriisquare = 0x330d;
  t.kashidaautoarabic = 0x0640;
  t.kashidaautonosidebearingarabic = 0x0640;
  t.kasmallkatakana = 0x30f5;
  t.kasquare = 0x3384;
  t.kasraarabic = 0x0650;
  t.kasratanarabic = 0x064d;
  t.kastrokecyrillic = 0x049f;
  t.katahiraprolongmarkhalfwidth = 0xff70;
  t.kaverticalstrokecyrillic = 0x049d;
  t.kbopomofo = 0x310e;
  t.kcalsquare = 0x3389;
  t.kcaron = 0x01e9;
  t.kcedilla = 0x0137;
  t.kcircle = 0x24da;
  t.kcommaaccent = 0x0137;
  t.kdotbelow = 0x1e33;
  t.keharmenian = 0x0584;
  t.kehiragana = 0x3051;
  t.kekatakana = 0x30b1;
  t.kekatakanahalfwidth = 0xff79;
  t.kenarmenian = 0x056f;
  t.kesmallkatakana = 0x30f6;
  t.kgreenlandic = 0x0138;
  t.khabengali = 0x0996;
  t.khacyrillic = 0x0445;
  t.khadeva = 0x0916;
  t.khagujarati = 0x0a96;
  t.khagurmukhi = 0x0a16;
  t.khaharabic = 0x062e;
  t.khahfinalarabic = 0xfea6;
  t.khahinitialarabic = 0xfea7;
  t.khahmedialarabic = 0xfea8;
  t.kheicottico = 0x03e7;
  t.khhadeva = 0x0959;
  t.khhagurmukhi = 0x0a59;
  t.khieukhacirclekorean = 0x3278;
  t.khieukhaparenkorean = 0x3218;
  t.khieukhcirclekorean = 0x326a;
  t.khieukhkorean = 0x314b;
  t.khieukhparenkorean = 0x320a;
  t.khokhaithai = 0x0e02;
  t.khokhonthai = 0x0e05;
  t.khokhuatthai = 0x0e03;
  t.khokhwaithai = 0x0e04;
  t.khomutthai = 0x0e5b;
  t.khook = 0x0199;
  t.khorakhangthai = 0x0e06;
  t.khzsquare = 0x3391;
  t.kihiragana = 0x304d;
  t.kikatakana = 0x30ad;
  t.kikatakanahalfwidth = 0xff77;
  t.kiroguramusquare = 0x3315;
  t.kiromeetorusquare = 0x3316;
  t.kirosquare = 0x3314;
  t.kiyeokacirclekorean = 0x326e;
  t.kiyeokaparenkorean = 0x320e;
  t.kiyeokcirclekorean = 0x3260;
  t.kiyeokkorean = 0x3131;
  t.kiyeokparenkorean = 0x3200;
  t.kiyeoksioskorean = 0x3133;
  t.kjecyrillic = 0x045c;
  t.klinebelow = 0x1e35;
  t.klsquare = 0x3398;
  t.kmcubedsquare = 0x33a6;
  t.kmonospace = 0xff4b;
  t.kmquadratoquadrato = 0x33a2;
  t.kohiragana = 0x3053;
  t.kohmquadrato = 0x33c0;
  t.kokaithai = 0x0e01;
  t.kokatakana = 0x30b3;
  t.kokatakanahalfwidth = 0xff7a;
  t.kooposquare = 0x331e;
  t.koppacyrillic = 0x0481;
  t.koreanstandardsymbol = 0x327f;
  t.koroniscmb = 0x0343;
  t.kparen = 0x24a6;
  t.kpasquare = 0x33aa;
  t.cirillico = 0x046f;
  t.ktsquare = 0x33cf;
  t.kturned = 0x029e;
  t.kuhiragana = 0x304f;
  t.kukatakana = 0x30af;
  t.kukatakanahalfwidth = 0xff78;
  t.kvsquare = 0x33b8;
  t.kwquadrato = 0x33be;
  tl = 0x006c;
  t.labengali = 0x09b2;
  t.lacute = 0x013a;
  t.ladeva = 0x0932;
  t.lagujarati = 0x0ab2;
  t.lagurmukhi = 0x0a32;
  t.lakkhangyaothai = 0x0e45;
  t.lamaleffinalarabic = 0xfefc;
  t.lamalefhamzaabovefinalarabic = 0xfef8;
  t.lamalefhamzaaboveisolatedarabic = 0xfef7;
  t.lamalefhamzabelowfinalarabic = 0xfefa;
  t.lamalefhamzabelowisolatedarabic = 0xfef9;
  t.lamalefisolatedarabic = 0xfefb;
  t.lamalefmaddaabovefinalarabic = 0xfef6;
  t.lamalefmaddaaboveisolatedarabic = 0xfef5;
  t.lamarabic = 0x0644;
  t.lambda = 0x03bb;
  t.lambdastroke = 0x019b;
  t.lamed = 0x05dc;
  t.lameddagesh = 0xfb3c;
  t.lameddageshhebrew = 0xfb3c;
  t.lamedhebrew = 0x05dc;
  t.lamfinalarabic = 0xfede;
  t.lamhahinitialarabic = 0xfcca;
  t.laminitialarabic = 0xfedf;
  t.lamjeeminitialarabic = 0xfcc9;
  t.lamkhahinitialarabic = 0xfccb;
  t.lamlamhehisolatedarabic = 0xfdf2;
  t.lammedialarabic = 0xfee0;
  t.lammeemhahinitialarabo = 0xfd88;
  t.lammeeminitialarabo = 0xfccc;
  t.largecircle = 0x25ef;
  t.lbar = 0x019a;
  t.lbelt = 0x026c;
  t.lbopomofo = 0x310c;
  t.lcaron = 0x013e;
  t.lcedilla = 0x013c;
  t.lcircle = 0x24db;
  t.lcircumflexbelow = 0x1e3d;
  t.lcommaaccent = 0x013c;
  t.ldot = 0x0140;
  t.ldotaccent = 0x0140;
  t.ldotbelow = 0x1e37;
  t.ldotbelowmacron = 0x1e39;
  t.lefttangleabovecmb = 0x031a;
  t.lefttackbelowcmb = 0x0318;
  t.less = 0x003c;
  t.lessequal = 0x2264;
  t.menougualemaggiore = 0x22da;
  t.lessmonospace = 0xff1c;
  t.lessorequivalent = 0x2272;
  t.minoremaggiore = 0x2276;
  t.meno uguale = 0x2266;
  t.lesssmall = 0xfe64;
  t.lezh = 0x026e;
  t.lfblock = 0x258c;
  t.lhookretroflex = 0x026d;
  t.lira = 0x20a4;
  t.liwnarmenian = 0x056c;
  t.lj = 0x01c9;
  t.ljecyrillic = 0x0459;
  t.ll = 0xf6c0;
  t.lladeva = 0x0933;
  t.llagujarati = 0x0ab3;
  t.llinebelow = 0x1e3b;
  t.llladeva = 0x0934;
  t.llvocalicbengali = 0x09e1;
  t.llvocalicdeva = 0x0961;
  t.llvocalicvowelsignbengali = 0x09e3;
  t.llvocalicvowelsigndeva = 0x0963;
  t.lmiddletilde = 0x026b;
  t.lmonospace = 0xff4c;
  t.lmsquare = 0x33d0;
  t.lochulathai = 0x0e2c;
  t.logico e = 0x2227;
  t.logicalnot = 0x00ac;
  t.logicalnotreversed = 0x2310;
  t.logicalor = 0x2228;
  t.lolingthai = 0x0e25;
  t.longs = 0x017f;
  t.lowlinecenterline = 0xfe4e;
  t.lowlinecmb = 0x0332;
  t.lowlinedadashed = 0xfe4d;
  t.losanga = 0x25ca;
  t.lparen = 0x24a7;
  t.lslash = 0x0142;
  t.lsquare = 0x2113;
  t.lsuperior = 0xf6ee;
  t.ltshade = 0x2591;
  t.luthai = 0x0e26;
  t.lvocalicbengali = 0x098c;
  t.lvocalicdeva = 0x090c;
  t.lvocalicvowelsignbengali = 0x09e2;
  t.lvocalicvowelsigndeva = 0x0962;
  t.lxquadrato = 0x33d3;
  tm = 0x006d;
  t.mabengali = 0x09ae;
  t.macron = 0x00af;
  t.macronbelowcmb = 0x0331;
  t.macroncmb = 0x0304;
  t.macronlowmod = 0x02cd;
  t.macronmonospace = 0xffe3;
  t.macute = 0x1e3f;
  t.madeva = 0x092e;
  t.magujarati = 0x0aae;
  t.magurmukhi = 0x0a2e;
  t.mahapakhhebrew = 0x05a4;
  t.mahapakhlefthebrew = 0x05a4;
  t.mahiragana = 0x307e;
  t.maichattawalowleftthai = 0xf895;
  t.maichattawalowrightthai = 0xf894;
  t.maichattawathai = 0x0e4b;
  t.maichattawaupperleftthai = 0xf893;
  t.maieklowleftthai = 0xf88c;
  t.maieklowrightthai = 0xf88b;
  t.maiekthai = 0x0e48;
  t.maiekupperleftthai = 0xf88a;
  t.maihanakatleftthai = 0xf884;
  t.maihanakatthai = 0x0e31;
  t.maitaikhuleftthai = 0xf889;
  t.maitaikhuthai = 0x0e47;
  t.maitholowleftthai = 0xf88f;
  t.maitholowrightthai = 0xf88e;
  t.maithothai = 0x0e49;
  t.maithoupperleftthai = 0xf88d;
  t.maitrilowleftthai = 0xf892;
  t.maitrilowrightthai = 0xf891;
  t.maitrithai = 0x0e4a;
  t.maitriupperleftthai = 0xf890;
  t.maiyamokthai = 0x0e46;
  t.makatakana = 0x30de;
  t.makatakanahalfwidth = 0xff8f;
  t.maschio = 0x2642;
  t.mansyonsquare = 0x3347;
  t.maqafhebrew = 0x05be;
  t.mars = 0x2642;
  t.masoracirclehebrew = 0x05af;
  t.masquare = 0x3383;
  t.mbopomofo = 0x3107;
  t.mbsquare = 0x33d4;
  t.mcircle = 0x24dc;
  t.mcubedsquare = 0x33a5;
  t.mdotaccent = 0x1e41;
  t.mdotbelow = 0x1e43;
  t.meemarabic = 0x0645;
  t.meemfinalarabic = 0xfee2;
  t.meeminitialarabic = 0xfee3;
  t.meemmedialarabic = 0xfee4;
  t.meemmeeminitialarabic = 0xfcd1;
  t.meemmeemisolatedarabic = 0xfc48;
  t.meetorusquare = 0x334d;
  t.mehiragana = 0x3081;
  t.meizierasquare = 0x337e;
  t.mekatakana = 0x30e1;
  t.mekatakanahalfwidth = 0xff92;
  t.mem = 0x05de;
  t.memdagesh = 0xfb3e;
  t.memdageshhebrew = 0xfb3e;
  t.memhebrew = 0x05de;
  t.menarmenian = 0x0574;
  t.merkhahebrew = 0x05a5;
  t.merkhakefulahebrew = 0x05a6;
  t.merkhakefulalefthebrew = 0x05a6;
  t.merkhalefthebrew = 0x05a5;
  t.mhook = 0x0271;
  t.mhzsquare = 0x3392;
  t.middledotkatakanahalfwidth = 0xff65;
  t.middot = 0x00b7;
  t.mieumacirclekorean = 0x3272;
  t.mieumaparenkorean = 0x3212;
  t.mieumcirclekorean = 0x3264;
  t.mieumkorean = 0x3141;
  t.mieumpansioskorean = 0x3170;
  t.mieumparenkorean = 0x3204;
  t.mieumpieupkorean = 0x316e;
  t.mieumsioskorean = 0x316f;
  t.mihiragana = 0x307f;
  t.mikatakana = 0x30df;
  t.mikatakanahalfwidth = 0xff90;
  t.meno = 0x2212;
  t.menosottocmb = 0x0320;
  t.minuscircle = 0x2296;
  t.minusmod = 0x02d7;
  t.menopiù = 0x2213;
  t.minuto = 0x2032;
  t.miribaarusquare = 0x334a;
  t.mirisquare = 0x3349;
  t.mlonglegturned = 0x0270;
  t.mlsquare = 0x3396;
  t.mmcubedsquare = 0x33a3;
  t.mmonospace = 0xff4d;
  t.mmsquaredsquare = 0x339f;
  t.mohiragana = 0x3082;
  t.mohmquadrato = 0x33c1;
  t.mokatakana = 0x30e2;
  t.mokatakanahalfwidth = 0xff93;
  t.molquadrato = 0x33d6;
  t.momathai = 0x0e21;
  t.moverssquare = 0x33a7;
  t.moverssquaredsquare = 0x33a8;
  t.mparen = 0x24a8;
  t.mpasquare = 0x33ab;
  t.mssquare = 0x33b3;
  t.msuperior = 0xf6ef;
  t.mturned = 0x026f;
  t.mu = 0x00b5;
  t.mu1 = 0x00b5;
  t.muasquare = 0x3382;
  t.moltopiùgrande = 0x226b;
  t.muchless = 0x226a;
  t.mufsquare = 0x338c;
  t.mugreek = 0x03bc;
  t.mugsquare = 0x338d;
  t.muhiragana = 0x3080;
  t.mukatakana = 0x30e0;
  t.mukatakanahalfwidth = 0xff91;
  t.mulsquare = 0x3395;
  t.moltiplica = 0x00d7;
  t.mumsquare = 0x339b;
  t.munahhebrew = 0x05a3;
  t.munahlefthebrew = 0x05a3;
  t.notamusicale = 0x266a;
  t.musicalnotedbl = 0x266b;
  t.musicflatsign = 0x266d;
  t.musicsharpsign = 0x266f;
  t.mussquare = 0x33b2;
  t.muvsquare = 0x33b6;
  t.muwsquare = 0x33bc;
  t.mvmegasquare = 0x33b9;
  t.mvsquare = 0x33b7;
  t.mwmegasquare = 0x33bf;
  t.mwsquare = 0x33bd;
  tn = 0x006e;
  t.nabengali = 0x09a8;
  t.nabla = 0x2207;
  t.nacute = 0x0144;
  t.nadeva = 0x0928;
  t.nagujarati = 0x0aa8;
  t.nagurmukhi = 0x0a28;
  t.nahiragana = 0x306a;
  t.nakatakana = 0x30ca;
  t.nakatakanahalfwidth = 0xff85;
  t.napostrofo = 0x0149;
  t.nasquare = 0x3381;
  t.nbopomofo = 0x310b;
  t.nbspace = 0x00a0;
  t.ncaron = 0x0148;
  t.ncedilla = 0x0146;
  t.cerchio = 0x24dd;
  t.ncircumflexbelow = 0x1e4b;
  t.ncommaaccent = 0x0146;
  t.ndotaccent = 0x1e45;
  t.ndotbelow = 0x1e47;
  t.nehiragana = 0x306d;
  t.nekatakana = 0x30cd;
  t.nekatakanahalfwidth = 0xff88;
  t.newsheqelsign = 0x20aa;
  t.nfsquare = 0x338b;
  t.ngabengali = 0x0999;
  t.ngadeva = 0x0919;
  t.ngagujarati = 0x0a99;
  t.ngagurmukhi = 0x0a19;
  t.ngonguthai = 0x0e07;
  t.nhiragana = 0x3093;
  t.nhookleft = 0x0272;
  t.nhookretroflex = 0x0273;
  t.nieunacirclekorean = 0x326f;
  t.nieunaparenkorean = 0x320f;
  t.nieuncieuckorean = 0x3135;
  t.nieuncirclekorean = 0x3261;
  t.nieunhieuhkorean = 0x3136;
  t.nieunkorean = 0x3134;
  t.nieunpansioskorean = 0x3168;
  t.nieunparenkorean = 0x3201;
  t.nieunsioskorean = 0x3167;
  t.nieuntikeutkorean = 0x3166;
  t.nihiragana = 0x306b;
  t.nikatakana = 0x30cb;
  t.nikatakanahalfwidth = 0xff86;
  t.nikhahitleftthai = 0xf899;
  t.nikhahitthai = 0x0e4d;
  t.nine = 0x0039;
  t.ninearabic = 0x0669;
  t.ninebengali = 0x09ef;
  t.novecerchi = 0x2468;
  t.ninecircleinversesansserif = 0x2792;
  t.ninedeva = 0x096f;
  t.ninegujarati = 0x0aef;
  t.ninegurmukhi = 0x0a6f;
  t.ninehackarabic = 0x0669;
  t.ninehangzhou = 0x3029;
  t.nineideographicparen = 0x3228;
  t.nineinferior = 0x2089;
  t.ninemonospace = 0xff19;
  t.nineoldstyle = 0xf739;
  t.nineparen = 0x247c;
  t.nineperiod = 0x2490;
  t.ninepersian = 0x06f9;
  t.nineroman = 0x2178;
  t.ninesuperior = 0x2079;
  t.nineteencircle = 0x2472;
  t.nineteenparen = 0x2486;
  t.diciannoveperiodo = 0x249a;
  t.ninethai = 0x0e59;
  t.nj = 0x01cc;
  t.njecyrillic = 0x045a;
  t.nkatakana = 0x30f3;
  t.nkatakanahalfwidth = 0xff9d;
  t.nlegrightlong = 0x019e;
  t.nlinebelow = 0x1e49;
  t.nmonospace = 0xff4e;
  t.nmquadrato = 0x339a;
  t.nnabengali = 0x09a3;
  t.nnadeva = 0x0923;
  t.nnagujarati = 0x0aa3;
  t.nnagurmukhi = 0x0a23;
  t.nnmadeva = 0x0929;
  t.nohiragana = 0x306e;
  t.nokatakana = 0x30ce;
  t.nokatakanahalfwidth = 0xff89;
  t.spazio non divisibile = 0x00a0;
  t.nonenthai = 0x0e13;
  t.nonuthai = 0x0e19;
  t.noonarabic = 0x0646;
  t.noonfinalarabic = 0xfee6;
  t.noonghunnaarabic = 0x06ba;
  t.noonghunnafinalarabic = 0xfb9f;
  t.nooninitialarabic = 0xfee7;
  t.noonjeeminitialarabic = 0xfcd2;
  t.noonjeemisolatedarabic = 0xfc4b;
  t.noonmedialarabic = 0xfee8;
  t.noonmeeminitialarabic = 0xfcd5;
  t.noonmeemisolatedarabic = 0xfc4e;
  t.noonnoonfinalarabic = 0xfc8d;
  t.notcontains = 0x220c;
  t.notelement = 0x2209;
  t.notelementof = 0x2209;
  t.notequal = 0x2260;
  t.nonmaggiore = 0x226f;
  t.nonmaggioreuguale = 0x2271;
  t.nonpiùgrandenémeno = 0x2279;
  t.nonidentico = 0x2262;
  t.notless = 0x226e;
  t.notlessnorequal = 0x2270;
  t.notparallel = 0x2226;
  t.notprecedes = 0x2280;
  t.notsubset = 0x2284;
  t.notsucceeds = 0x2281;
  t.notsuperset = 0x2285;
  t.nowarmenian = 0x0576;
  t.nparen = 0x24a9;
  t.nsquadrato = 0x33b1;
  t.nsuperiore = 0x207f;
  t.ntilde = 0x00f1;
  t.nu = 0x03bd;
  t.nuhiragana = 0x306c;
  t.nukatakana = 0x30cc;
  t.nukatakanahalfwidth = 0xff87;
  t.nuktabengali = 0x09bc;
  t.nuktadeva = 0x093c;
  t.nuktagujarati = 0x0abc;
  t.nuktagurmukhi = 0x0a3c;
  t.numero = 0x0023;
  t.numbersignmonospace = 0xff03;
  t.numbersignsmall = 0xfe5f;
  t.numeralsigngreek = 0x0374;
  t.numeralsignlowergreek = 0x0375;
  t.numero = 0x2116;
  t.nun = 0x05e0;
  t.nundagesh = 0xfb40;
  t.nundageshhebrew = 0xfb40;
  t.nunhebrew = 0x05e0;
  t.nvsquare = 0x33b5;
  t.nwquadrato = 0x33bb;
  t.nyabengali = 0x099e;
  t.nyadeva = 0x091e;
  t.nyagujarati = 0x0a9e;
  t.nyagurmukhi = 0x0a1e;
  a = 0x006f;
  t.oacute = 0x00f3;
  t.oangthai = 0x0e2d;
  t.obarred = 0x0275;
  t.obarredcyrillic = 0x04e9;
  t.obarreddieresiscyrillic = 0x04eb;
  t.obengali = 0x0993;
  t.obopomofo = 0x311b;
  t.obreve = 0x014f;
  t.ocandradeva = 0x0911;
  t.ocandragujarati = 0x0a91;
  t.ocandravowelsigndeva = 0x0949;
  t.ocandravowelsigngujarati = 0x0ac9;
  t.ocaron = 0x01d2;
  t.ocircle = 0x24de;
  t.ocirconflesso = 0x00f4;
  t.ocirconflessoacuto = 0x1ed1;
  t.ocircumflexdotbelow = 0x1ed9;
  t.ocircumflexgrave = 0x1ed3;
  t.ocircumflexhookabove = 0x1ed5;
  t.ocircumflextilde = 0x1ed7;
  t.ocirillico = 0x043e;
  t.odblacute = 0x0151;
  t.odblgrave = 0x020d;
  t.odeva = 0x0913;
  t.odieresi = 0x00f6;
  t.odieresiscyrillic = 0x04e7;
  t.odotbelow = 0x1ecd;
  t.oe = 0x0153;
  t.oekorean = 0x315a;
  t.ogonek = 0x02db;
  t.ogonekcmb = 0x0328;
  t.ograve = 0x00f2;
  t.ogujarati = 0x0a93;
  t.oharmeniano = 0x0585;
  t.ohiragana = 0x304a;
  t.ohookabove = 0x1ecf;
  t.ohorn = 0x01a1;
  t.ohornacute = 0x1edb;
  t.ohorndotbelow = 0x1ee3;
  t.ohorngrave = 0x1edd;
  t.ohornhookabove = 0x1edf;
  t.ohorntilde = 0x1ee1;
  t.ohungarumlaut = 0x0151;
  t.oi = 0x01a3;
  t.oinvertedbreve = 0x020f;
  t.okatakana = 0x30aa;
  t.okatakanahalfwidth = 0xff75;
  t.ocoreano = 0x3157;
  t.olehebrew = 0x05ab;
  t.omacron = 0x014d;
  t.omacronacute = 0x1e53;
  t.omacrongrave = 0x1e51;
  t.omdeva = 0x0950;
  t.omega = 0x03c9;
  t.omega1 = 0x03d6;
  t.omegacirillico = 0x0461;
  t.omegalatinclosed = 0x0277;
  t.omegaroundcyrillic = 0x047b;
  t.omegatitlocirillico = 0x047d;
  t.omegatonos = 0x03ce;
  t.omgujarati = 0x0ad0;
  t.omicron = 0x03bf;
  t.omicrontonos = 0x03cc;
  t.omonospazio = 0xff4f;
  t.uno = 0x0031;
  t.onearabic = 0x0661;
  t.onebengali = 0x09e7;
  t.onecircle = 0x2460;
  t.ocirculceinversesansserif = 0x278a;
  t.onedeva = 0x0967;
  t.onedotenleader = 0x2024;
  t.un ottavo = 0x215b;
  t.onefitted = 0xf6dc;
  t.onegujarati = 0x0ae7;
  t.onegurmukhi = 0x0a67;
  t.onehackarabic = 0x0661;
  t.mezzo = 0x00bd;
  t.onehangzhou = 0x3021;
  t.oneideographicparen = 0x3220;
  t.oneinferior = 0x2081;
  t.onemonospace = 0xff11;
  t.onenumeratorbengali = 0x09f4;
  t.oneoldstyle = 0xf731;
  t.oneparen = 0x2474;
  t.unperiodo = 0x2488;
  t.onepersian = 0x06f1;
  t.unquarto = 0x00bc;
  t.oneroman = 0x2170;
  t.onesuperior = 0x00b9;
  t.onethai = 0x0e51;
  t.un terzo = 0x2153;
  t.oogonek = 0x01eb;
  t.oogonekmacron = 0x01ed;
  t.oogurmukhi = 0x0a13;
  t.oomatragurmukhi = 0x0a4b;
  t.oopen = 0x0254;
  t.paren = 0x24aa;
  t.openbullet = 0x25e6;
  t.opzione = 0x2325;
  t.ordfeminine = 0x00aa;
  t.ordmasculine = 0x00ba;
  t.ortogonale = 0x221f;
  t.oshortdeva = 0x0912;
  t.oshortvowelsigndeva = 0x094a;
  t.oslash = 0x00f8;
  t.oslashacute = 0x01ff;
  t.osmallhiragana = 0x3049;
  t.osmallkatakana = 0x30a9;
  t.osmallkatakanahalfwidth = 0xff6b;
  t.ostrokeacute = 0x01ff;
  t.osuperiore = 0xf6f0;
  t.otcyrillic = 0x047f;
  t.otilde = 0x00f5;
  t.otildeacute = 0x1e4d;
  t.otildederesi = 0x1e4f;
  t.oubopomofo = 0x3121;
  t.overline = 0x203e;
  t.overlinecenterline = 0xfe4a;
  t.overlinecmb = 0x0305;
  t.overlinededished = 0xfe49;
  t.overlinedblwavy = 0xfe4c;
  t.overlinewavy = 0xfe4b;
  t.overscore = 0x00af;
  t.ovowelsignbengali = 0x09cb;
  t.ovowelsigndeva = 0x094b;
  t.ovowelsigngujarati = 0x0acb;
  tp = 0x0070;
  t.paampssquare = 0x3380;
  t.paasentosquare = 0x332b;
  t.pabengali = 0x09aa;
  t.pacute = 0x1e55;
  t.padeva = 0x092a;
  t.pagedown = 0x21df;
  t.pageup = 0x21de;
  t.pagujarati = 0x0aaa;
  t.pagurmukhi = 0x0a2a;
  t.pahiragana = 0x3071;
  t.paiyannoithai = 0x0e2f;
  t.pakatakana = 0x30d1;
  t.palatalizzazionecyrilliccmb = 0x0484;
  t.palochkacyrillic = 0x04c0;
  t.pansioskorean = 0x317f;
  t.paragrafo = 0x00b6;
  t.parallelo = 0x2225;
  t.parentesi sinistra = 0x0028;
  t.parenleftaltoneaarabo = 0xfd3e;
  t.parenteleftbt = 0xf8ed;
  t.parenleftex = 0xf8ec;
  t.parenleftinferior = 0x208d;
  t.parenleftmonospace = 0xff08;
  t.parentesi sinistra piccola = 0xfe59;
  t.parenleftsuperior = 0x207d;
  t.parenlefttp = 0xf8eb;
  t.parentesinistraverticale = 0xfe35;
  t.parente destra = 0x0029;
  t.parentesidestraaltonearabica = 0xfd3f;
  t.parenterightbt = 0xf8f8;
  t.parentesi destra = 0xf8f7;
  t.parenteinferiore = 0x208e;
  t.parenrightmonospace = 0xff09;
  t.parentesi destrapiccola = 0xfe5a;
  t.parenrightsuperior = 0x207e;
  t.parente destratp = 0xf8f6;
  t.parente destra verticale = 0xfe36;
  t.diff parziale = 0x2202;
  t.paseqhebrew = 0x05c0;
  t.pashtahebrew = 0x0599;
  t.pasquare = 0x33a9;
  t.patah = 0x05b7;
  t.patah11 = 0x05b7;
  t.patah1d = 0x05b7;
  t.patah2a = 0x05b7;
  t.patahhebrew = 0x05b7;
  t.patahnarrowhebrew = 0x05b7;
  t.patahquarterhebrew = 0x05b7;
  t.patahwidehebrew = 0x05b7;
  t.pazerhebrew = 0x05a1;
  t.pbopomofo = 0x3106;
  t.pcircle = 0x24df;
  t.pdotaccent = 0x1e57;
  t.pe = 0x05e4;
  t.pecirillico = 0x043f;
  t.pedagesh = 0xfb44;
  t.pedageshhebrew = 0xfb44;
  t.peezisquare = 0x333b;
  t.pefinaldageshhebrew = 0xfb43;
  t.peharabic = 0x067e;
  t.peharmenian = 0x057a;
  t.pehebrew = 0x05e4;
  t.pehfinalarabic = 0xfb57;
  t.pehinitialarabic = 0xfb58;
  t.pehiragana = 0x307a;
  t.pehmedialarabic = 0xfb59;
  t.pekatakana = 0x30da;
  t.pemiddlehookcyrillic = 0x04a7;
  t.perafehebrew = 0xfb4e;
  t.percentuale = 0x0025;
  t.percentualearabica = 0x066a;
  t.percentualemonospazio = 0xff05;
  t.percentualepiccola = 0xfe6a;
  t.periodo = 0x002e;
  t.periodarmenian = 0x0589;
  t.periodocentrato = 0x00b7;
  t.periodomezzalarghezza = 0xff61;
  t.periodinferiore = 0xf6e7;
  t.periodomonospazio = 0xff0e;
  t.periodsmall = 0xfe52;
  t.periodosuperiore = 0xf6e8;
  t.perispomenigreekcmb = 0x0342;
  t.perpendicolare = 0x22a5;
  t.permille = 0x2030;
  t.peseta = 0x20a7;
  t.pfsquare = 0x338a;
  t.phabengali = 0x09ab;
  t.phadeva = 0x092b;
  t.phagujarati = 0x0aab;
  t.phagurmukhi = 0x0a2b;
  t.phi = 0x03c6;
  t.phi1 = 0x03d5;
  t.phieuphacirclekorean = 0x327a;
  t.phieuphaparenkorean = 0x321a;
  t.phieuphcirclekorean = 0x326c;
  t.phieuphkorean = 0x314d;
  t.phieuphparenkorean = 0x320c;
  t.philatin = 0x0278;
  t.phinthuthai = 0x0e3a;
  t.phisymbolgreek = 0x03d5;
  t.phook = 0x01a5;
  t.phophanthai = 0x0e1e;
  t.phophungthai = 0x0e1c;
  t.phosamphaothai = 0x0e20;
  t.pi = 0x03c0;
  t.pieupacirclekorean = 0x3273;
  t.pieupaparenkorean = 0x3213;
  t.pieupcieuckorean = 0x3176;
  t.pieupcirclekorean = 0x3265;
  t.pieupkiyeokkorean = 0x3172;
  t.pieupkorean = 0x3142;
  t.pieupparenkorean = 0x3205;
  t.pieupsioskiyeokkorean = 0x3174;
  t.pieupsioskorean = 0x3144;
  t.pieupsiostikeutkorean = 0x3175;
  t.pieupthieuthkorean = 0x3177;
  t.pieuptikeutkorean = 0x3173;
  t.pihiragana = 0x3074;
  t.pikatakana = 0x30d4;
  t.pisymbolgreek = 0x03d6;
  t.piwrarmenian = 0x0583;
  t.planckover2pi = 0x210f;
  t.planckover2pi1 = 0x210f;
  t.plus = 0x002b;
  t.plusbelowcmb = 0x031f;
  t.pluscircle = 0x2295;
  t.piùmeno = 0x00b1;
  t.plusmod = 0x02d6;
  t.plusmonospace = 0xff0b;
  t.plussmall = 0xfe62;
  t.plussuperior = 0x207a;
  t.pmonospace = 0xff50;
  t.pmsquare = 0x33d8;
  t.pohiragana = 0x307d;
  t.pointingindexdownwhite = 0x261f;
  t.pointingindexleftwhite = 0x261c;
  t.pointingindexrightwhite = 0x261e;
  t.pointingindexupwhite = 0x261d;
  t.pokatakana = 0x30dd;
  t.poplatai = 0x0e1b;
  t.timbro postale = 0x3012;
  t.postalmarkface = 0x3020;
  t.pparen = 0x24ab;
  t.precede = 0x227a;
  t.prescrizione = 0x211e;
  t.primemod = 0x02b9;
  t.primereversed = 0x2035;
  t.prodotto = 0x220f;
  t.proiettivo = 0x2305;
  t.prolongedkana = 0x30fc;
  t.elica = 0x2318;
  t.propersubset = 0x2282;
  t.propersuperset = 0x2283;
  t.proporzione = 0x2237;
  t.proporzionale = 0x221d;
  t.psi = 0x03c8;
  t.psicirillico = 0x0471;
  t.psilipneumatacyrilliccmb = 0x0486;
  t.pssquare = 0x33b0;
  t.puhiragana = 0x3077;
  t.pukatakana = 0x30d7;
  t.pvsquare = 0x33b4;
  t.pwsquare = 0x33ba;
  tq = 0x0071;
  t.qadeva = 0x0958;
  t.qadmahebrew = 0x05a8;
  t.qafarabic = 0x0642;
  t.qaffinalarabic = 0xfed6;
  t.qafinitialarabic = 0xfed7;
  t.qafmedialarabic = 0xfed8;
  t.qamats = 0x05b8;
  t.qamats10 = 0x05b8;
  t.qamats1a = 0x05b8;
  t.qamats1c = 0x05b8;
  t.qamats27 = 0x05b8;
  t.qamats29 = 0x05b8;
  t.qamats33 = 0x05b8;
  t.qamatsde = 0x05b8;
  t.qamatshebrew = 0x05b8;
  t.qamatsnarrowhebrew = 0x05b8;
  t.qamatsqatanhebrew = 0x05b8;
  t.qamatsqatannarrowhebrew = 0x05b8;
  t.qamatsqatanquarterhebrew = 0x05b8;
  t.qamatsqatanwidehebrew = 0x05b8;
  t.qamatsquarterhebrew = 0x05b8;
  t.qamatswidehebrew = 0x05b8;
  t.qarneyparahebrew = 0x059f;
  t.qbopomofo = 0x3111;
  t.qcircle = 0x24e0;
  t.qhook = 0x02a0;
  t.qmonospace = 0xff51;
  t.qof = 0x05e7;
  t.qofdagesh = 0xfb47;
  t.qofdageshhebrew = 0xfb47;
  t.qofhebrew = 0x05e7;
  t.qparen = 0x24ac;
  t.quartina = 0x2669;
  t.qubuts = 0x05bb;
  t.qubuts18 = 0x05bb;
  t.qubuts25 = 0x05bb;
  t.qubuts31 = 0x05bb;
  t.qubutshebrew = 0x05bb;
  t.qubutsnarrowhebrew = 0x05bb;
  t.qubutsquarterhebrew = 0x05bb;
  t.qubutswidehebrew = 0x05bb;
  t.domanda = 0x003f;
  t.questionarabic = 0x061f;
  t.questionarmenian = 0x055e;
  t.questiondown = 0x00bf;
  t.questiondownsmall = 0xf7bf;
  t.questiongreek = 0x037e;
  t.questionmonospace = 0xff1f;
  t.questionsmall = 0xf73f;
  t.quotedbl = 0x0022;
  t.quotedblbase = 0x201e;
  t.quotedblleft = 0x201c;
  t.quotedblmonospace = 0xff02;
  t.quotedblprime = 0x301e;
  t.quotedblprimereversed = 0x301d;
  t.quotedblright = 0x201d;
  t.quoteleft = 0x2018;
  t.quoteleftreversed = 0x201b;
  t.quotereversed = 0x201b;
  t.quoteright = 0x2019;
  t.quoterightn = 0x0149;
  t.quotesinglbase = 0x201a;
  t.quotesingle = 0x0027;
  t.quotesinglemonospace = 0xff07;
  tr = 0x0072;
  t.raarmenian = 0x057c;
  t.rabengali = 0x09b0;
  t.racute = 0x0155;
  t.radeva = 0x0930;
  t.radicale = 0x221a;
  t.radicalex = 0xf8e5;
  t.radoverssquare = 0x33ae;
  t.radoverssquaredsquare = 0x33af;
  t.radsquare = 0x33ad;
  t.rafe = 0x05bf;
  t.rafehebrew = 0x05bf;
  t.ragujarati = 0x0ab0;
  t.ragurmukhi = 0x0a30;
  t.rahiragana = 0x3089;
  t.rakatakana = 0x30e9;
  t.rakatakanahalfwidth = 0xff97;
  t.ralowerdiagonalbengali = 0x09f1;
  t.ramiddlediagonalbengali = 0x09f0;
  t.ramshorn = 0x0264;
  t.rapporto = 0x2236;
  t.rbopomofo = 0x3116;
  t.rcaron = 0x0159;
  t.rcedilla = 0x0157;
  t.cerchio = 0x24e1;
  t.rcommaaccent = 0x0157;
  t.rdblgrave = 0x0211;
  t.rdotaccent = 0x1e59;
  t.rdotbelow = 0x1e5b;
  t.rdotbelowmacron = 0x1e5d;
  t.referencemark = 0x203b;
  t.reflexsubset = 0x2286;
  t.reflexsuperset = 0x2287;
  t.registrato = 0x00ae;
  t.registersans = 0xf8e8;
  t.registerserif = 0xf6da;
  t.reharabic = 0x0631;
  t.reharmenian = 0x0580;
  t.rehfinalarabic = 0xfeae;
  t.rehiragana = 0x308c;
  t.rekatakana = 0x30ec;
  t.rekatakanahalfwidth = 0xff9a;
  t.resh = 0x05e8;
  t.reshdageshhebrew = 0xfb48;
  t.reshhebrew = 0x05e8;
  t.reversedtilde = 0x223d;
  t.reviahebrew = 0x0597;
  t.reviamugrashhebrew = 0x0597;
  t.revlogicalnot = 0x2310;
  t.rfishhook = 0x027e;
  t.rfishhookreversed = 0x027f;
  t.rhabengali = 0x09dd;
  t.rhadeva = 0x095d;
  t.rho = 0x03c1;
  t.rhook = 0x027d;
  t.rhookturned = 0x027b;
  t.rhookturnedsuperior = 0x02b5;
  t.rhosymbolgreek = 0x03f1;
  t.rhotichookmod = 0x02de;
  t.rieulacirclekorean = 0x3271;
  t.rieulaparenkorean = 0x3211;
  t.rieulcirclekorean = 0x3263;
  t.rieulhieuhkorean = 0x3140;
  t.rieulkiyeokkorean = 0x313a;
  t.rieulkiyeoksioskoreano = 0x3169;
  t.rieulkorean = 0x3139;
  t.rieulmieumkorean = 0x313b;
  t.rieulpansioskorean = 0x316c;
  t.rieulparenkorean = 0x3203;
  t.rieulphieuphkorean = 0x313f;
  t.rieulpieupkorean = 0x313c;
  t.rieulpieupsioskorean = 0x316b;
  t.rieulsioskorean = 0x313d;
  t.rieulthieuthkorean = 0x313e;
  t.rieultikeutkorean = 0x316a;
  t.rieulyeorinhieuhkorean = 0x316d;
  t.angolo retto = 0x221f;
  t.righttackbelowcmb = 0x0319;
  t.triangolodestro = 0x22bf;
  t.rihiragana = 0x308a;
  t.rikatakana = 0x30ea;
  t.rikatakanahalfwidth = 0xff98;
  t.anello = 0x02da;
  t.ringbelowcmb = 0x0325;
  t.ringcmb = 0x030a;
  t.ringhalfleft = 0x02bf;
  t.ringhalflettarmenian = 0x0559;
  t.ringhalfleftbelowcmb = 0x031c;
  t.anellomezzosinistracentrato = 0x02d3;
  t.ringhalfright = 0x02be;
  t.ringhalfrightbelowcmb = 0x0339;
  t.anelloa metàdestracentrato = 0x02d2;
  t.rinvertedbreve = 0x0213;
  t.rittorusquare = 0x3351;
  t.rlinebelow = 0x1e5f;
  t.rlongleg = 0x027c;
  t.rlonglegturned = 0x027a;
  t.rmonospace = 0xff52;
  t.rohiragana = 0x308d;
  t.rokatakana = 0x30ed;
  t.rokatakanahalfwidth = 0xff9b;
  t.roruathai = 0x0e23;
  t.rparen = 0x24ad;
  t.rrabengali = 0x09dc;
  t.rradeva = 0x0931;
  t.rragurmukhi = 0x0a5c;
  t.rreharabic = 0x0691;
  t.rrehfinalarabic = 0xfb8d;
  t.rrvocalicbengali = 0x09e0;
  t.rrvocalicdeva = 0x0960;
  t.rrvocalicgujarati = 0x0ae0;
  t.rrvocalicvowelsignbengali = 0x09c4;
  t.rrvocalicvowelsigndeva = 0x0944;
  t.rrvocalicvowelsigngujarati = 0x0ac4;
  t.rsuperior = 0xf6f1;
  t.rtblock = 0x2590;
  t.rturned = 0x0279;
  t.rturnedsuperior = 0x02b4;
  t.ruhiragana = 0x308b;
  t.rukatakana = 0x30eb;
  t.rukatakanahalfwidth = 0xff99;
  t.rupeemarkbengali = 0x09f2;
  t.rupeesignbengali = 0x09f3;
  t.rupiah = 0xf6dd;
  t.ruthai = 0x0e24;
  t.rvocalicbengali = 0x098b;
  t.rvocalicdeva = 0x090b;
  t.rvocalicgujarati = 0x0a8b;
  t.rvocalicvowelsignbengali = 0x09c3;
  t.rvocalicvowelsigndeva = 0x0943;
  t.rvocalicvowelsigngujarati = 0x0ac3;
  ts = 0x0073;
  t.sabengali = 0x09b8;
  t.sacute = 0x015b;
  t.sacutedotaccent = 0x1e65;
  t.sadarabic = 0x0635;
  t.sadeva = 0x0938;
  t.sadfinalarabic = 0xfeba;
  t.sadinitialarabic = 0xfebb;
  t.sadmedialarabic = 0xfebc;
  t.sagujarati = 0x0ab8;
  t.sagurmukhi = 0x0a38;
  t.sahiragana = 0x3055;
  t.sakatakana = 0x30b5;
  t.sakatakanahalfwidth = 0xff7b;
  t.sallallahoualayhewasallamarabic = 0xfdfa;
  t.samekh = 0x05e1;
  t.samekhdagesh = 0xfb41;
  t.samekhdageshhebrew = 0xfb41;
  t.samekhhebrew = 0x05e1;
  t.saraaathai = 0x0e32;
  t.saraaethai = 0x0e41;
  t.saraaimaimalaithai = 0x0e44;
  t.saraaimaimuanthai = 0x0e43;
  t.saraamthai = 0x0e33;
  t.saraathai = 0x0e30;
  t.saraethai = 0x0e40;
  t.saraiileftthai = 0xf886;
  t.saraiithai = 0x0e35;
  t.saraileftthai = 0xf885;
  t.saraithai = 0x0e34;
  t.saraothai = 0x0e42;
  t.saraueeleftthai = 0xf888;
  t.saraueethai = 0x0e37;
  t.saraueleftthai = 0xf887;
  t.sarauethai = 0x0e36;
  t.sarauthai = 0x0e38;
  t.sarauuthai = 0x0e39;
  t.sbopomofo = 0x3119;
  t.scaron = 0x0161;
  t.scarondotaccent = 0x1e67;
  t.scedilla = 0x015f;
  t.schwa = 0x0259;
  t.schwacyrillic = 0x04d9;
  t.schwadieresiscyrillic = 0x04db;
  t.schwahook = 0x025a;
  t.cerchio = 0x24e2;
  t.circonflesso = 0x015d;
  t.scommaaccent = 0x0219;
  t.sdotaccent = 0x1e61;
  t.sdotbelow = 0x1e63;
  t.sdotbelowdotaccent = 0x1e69;
  t.seagullbelowcmb = 0x033c;
  t.secondo = 0x2033;
  t.secondtonechinese = 0x02ca;
  t.sezione = 0x00a7;
  t.seenarabic = 0x0633;
  t.seenfinalarabic = 0xfeb2;
  t.seeninitialarabic = 0xfeb3;
  t.seenmedialarabic = 0xfeb4;
  t.segol = 0x05b6;
  t.segol13 = 0x05b6;
  t.segol1f = 0x05b6;
  t.segol2c = 0x05b6;
  t.segolhebrew = 0x05b6;
  t.segolnarrowhebrew = 0x05b6;
  t.segolquarterhebrew = 0x05b6;
  t.segoltahebrew = 0x0592;
  t.segolwidehebrew = 0x05b6;
  t.seharmenian = 0x057d;
  t.sehiragana = 0x305b;
  t.sekatakana = 0x30bb;
  t.sekatakanahalfwidth = 0xff7e;
  t.punto e virgola = 0x003b;
  t.semicolonarabo = 0x061b;
  t.punto e virgola monospazio = 0xff1b;
  t.punto e virgola piccolo = 0xfe54;
  t.semivoicedmarkkana = 0x309c;
  t.semivoicedmarkkanahalfwidth = 0xff9f;
  t.sentisquare = 0x3322;
  t.sentosquare = 0x3323;
  t.sette = 0x0037;
  t.sevenarabic = 0x0667;
  t.sevenbengali = 0x09ed;
  t.sevencircle = 0x2466;
  t.sevencircleinversesansserif = 0x2790;
  t.sevendeva = 0x096d;
  t.setteottavi = 0x215e;
  t.sevengujarati = 0x0aed;
  t.sevengurmukhi = 0x0a6d;
  t.sevenhackarabic = 0x0667;
  t.sevenhangzhou = 0x3027;
  t.sevenideographicparen = 0x3226;
  t.seveninferior = 0x2087;
  t.sevenmonospace = 0xff17;
  t.sevenoldstyle = 0xf737;
  t.sevenparen = 0x247a;
  t.sevenperiod = 0x248e;
  t.sevenpersian = 0x06f7;
  t.sevenroman = 0x2176;
  t.sevensuperior = 0x2077;
  t.diciassettecerchi = 0x2470;
  t.seventeenparen = 0x2484;
  t.diciassetteperiodo = 0x2498;
  t.seventhai = 0x0e57;
  t.sfthyphen = 0x00ad;
  t.shaarmenian = 0x0577;
  t.shabengali = 0x09b6;
  t.shacyrillic = 0x0448;
  t.shaddaarabic = 0x0651;
  t.shaddadammaarabic = 0xfc61;
  t.shaddadammatanaarabo = 0xfc5e;
  t.shaddafathaarabic = 0xfc60;
  t.shaddakasraarabic = 0xfc62;
  t.shaddakasratanarabic = 0xfc5f;
  t.ombra = 0x2592;
  t.shadedark = 0x2593;
  t.ombraluce = 0x2591;
  t.shademedium = 0x2592;
  t.shadeva = 0x0936;
  t.shagujarati = 0x0ab6;
  t.shagurmukhi = 0x0a36;
  t.shalshelethebrew = 0x0593;
  t.shbopomofo = 0x3115;
  t.shchacyrillic = 0x0449;
  t.sheenarabic = 0x0634;
  t.sheenfinalarabic = 0xfeb6;
  t.sheeninitialarabic = 0xfeb7;
  t.sheenmedialarabic = 0xfeb8;
  t.sheicoptic = 0x03e3;
  t.sheqel = 0x20aa;
  t.sheqelhebrew = 0x20aa;
  t.sheva = 0x05b0;
  t.sheva115 = 0x05b0;
  t.sheva15 = 0x05b0;
  t.sheva22 = 0x05b0;
  t.sheva2e = 0x05b0;
  t.shevahebrew = 0x05b0;
  t.shevanarrowhebrew = 0x05b0;
  t.shevaquarterhebrew = 0x05b0;
  t.shevawidehebrew = 0x05b0;
  t.shhacyrillic = 0x04bb;
  t.shimacoptic = 0x03ed;
  t.shin = 0x05e9;
  t.shindagesh = 0xfb49;
  t.shindageshhebrew = 0xfb49;
  t.shindageshshindot = 0xfb2c;
  t.shindageshshindothebrew = 0xfb2c;
  t.shindageshsindot = 0xfb2d;
  t.shindageshsindothebrew = 0xfb2d;
  t.shindothebrew = 0x05c1;
  t.shinhebrew = 0x05e9;
  t.shinshindot = 0xfb2a;
  t.shinshindothebrew = 0xfb2a;
  t.shinsindot = 0xfb2b;
  t.shinsindothebrew = 0xfb2b;
  t.shook = 0x0282;
  t.sigma = 0x03c3;
  t.sigma1 = 0x03c2;
  t.sigmafinale = 0x03c2;
  t.sigmalunatesymbolgreek = 0x03f2;
  t.sihiragana = 0x3057;
  t.sikatakana = 0x30b7;
  t.sikatakanahalfwidth = 0xff7c;
  t.siluqhebrew = 0x05bd;
  t.siluqlefthebrew = 0x05bd;
  t.simile = 0x223c;
  t.sindothebrew = 0x05c2;
  t.siosacirclekorean = 0x3274;
  t.siosaparenkorean = 0x3214;
  t.sioscieuckorean = 0x317e;
  t.sioscirclekorean = 0x3266;
  t.sioskiyeokkorean = 0x317a;
  t.sioskorean = 0x3145;
  t.siosnieunkorean = 0x317b;
  t.siosparenkorean = 0x3206;
  t.siospieupkorean = 0x317d;
  t.siostikeutkorean = 0x317c;
  t.sei = 0x0036;
  t.sixarabic = 0x0666;
  t.sixbengali = 0x09ec;
  t.seicerchi = 0x2465;
  t.sixcircleinversesansserif = 0x278f;
  t.sixdeva = 0x096c;
  t.sixgujarati = 0x0aec;
  t.sixgurmukhi = 0x0a6c;
  t.sixhackarabic = 0x0666;
  t.sixhangzhou = 0x3026;
  t.sixideographicparen = 0x3225;
  t.seiinferiore = 0x2086;
  t.sixmonospace = 0xff16;
  t.sixoldstyle = 0xf736;
  t.sixparen = 0x2479;
  t.seiperiodo = 0x248d;
  t.sixpersian = 0x06f6;
  t.sixroman = 0x2175;
  t.sixsuperior = 0x2076;
  t.sedicicerchi = 0x246f;
  t.sixteencurrencydenominatorbengali = 0x09f9;
  t.sixteenparen = 0x2483;
  t.sediciperiodo = 0x2497;
  t.sixthai = 0x0e56;
  barra = 0x002f;
  t.slashmonospace = 0xff0f;
  t.slong = 0x017f;
  t.slongdotaccent = 0x1e9b;
  t.smileface = 0x263a;
  t.smonospace = 0xff53;
  t.sofpasuqhebrew = 0x05c3;
  t.softhyphen = 0x00ad;
  t.softsigncyrillic = 0x044c;
  t.sohiragana = 0x305d;
  t.sokatakana = 0x30bd;
  t.sokatakanahalfwidth = 0xff7f;
  t.soliduslongoverlaycmb = 0x0338;
  t.solidusshortoverlaycmb = 0x0337;
  t.sorusithai = 0x0e29;
  t.sosalathai = 0x0e28;
  t.sosothai = 0x0e0b;
  t.sosuathai = 0x0e2a;
  t.spazio = 0x0020;
  t.spacehackarabic = 0x0020;
  t.spade = 0x2660;
  t.spadesuitblack = 0x2660;
  t.spadesuitwhite = 0x2664;
  t.sparen = 0x24ae;
  t.squarebelowcmb = 0x033b;
  t.squarecc = 0x33c4;
  t.cm quadrato = 0x339d;
  t.squarediagonalcrosshatchfill = 0x25a9;
  t.squarehorizontalfill = 0x25a4;
  t.kgquadrato = 0x338f;
  t.km quadrati = 0x339e;
  t.squarekmcapital = 0x33ce;
  t.squareln = 0x33d1;
  t.logaritmoquadrato = 0x33d2;
  t.squaremg = 0x338e;
  t.millimetro quadrato = 0x33d5;
  t.mmquadrato = 0x339c;
  t.quadrato = 0x33a1;
  t.squareorthogonalcrosshatchfill = 0x25a6;
  t.squareupperlefttolowerrightfill = 0x25a7;
  t.squareupperrighttolowerleftfill = 0x25a8;
  t.squareverticalfill = 0x25a5;
  t.quadratobiancoconpiccolonero = 0x25a3;
  t.srsquare = 0x33db;
  t.ssabengali = 0x09b7;
  t.ssadeva = 0x0937;
  t.ssagujarati = 0x0ab7;
  t.ssangcieuckorean = 0x3149;
  t.ssanghieuhkorean = 0x3185;
  t.ssangieungkorean = 0x3180;
  t.ssangkiyeokkorean = 0x3132;
  t.ssangnieunkorean = 0x3165;
  t.ssangpieupkorean = 0x3143;
  t.ssangsioskorean = 0x3146;
  t.ssangtikeutkorean = 0x3138;
  t.ssuperiore = 0xf6f2;
  t.sterlina = 0x00a3;
  t.sterlingmonospace = 0xffe1;
  t.strokelongoverlaycmb = 0x0336;
  t.strokeshortoverlaycmb = 0x0335;
  t.sottoinsieme = 0x2282;
  t.subsetnotequal = 0x228a;
  t.sottosetorequal = 0x2286;
  t.succeeds = 0x227b;
  t.taleche = 0x220b;
  t.suhiragana = 0x3059;
  t.sukatakana = 0x30b9;
  t.sukatakanahalfwidth = 0xff7d;
  t.sukunarabic = 0x0652;
  t.somma = 0x2211;
  t.sole = 0x263c;
  t.superset = 0x2283;
  t.supersetnotequal = 0x228b;
  t.supersetorequal = 0x2287;
  t.svsquare = 0x33dc;
  t.syouwaerasquare = 0x337c;
  tt = 0x0074;
  t.tabengali = 0x09a4;
  t.tackdown = 0x22a4;
  t.tackleft = 0x22a3;
  t.tadeva = 0x0924;
  t.tagujarati = 0x0aa4;
  t.tagurmukhi = 0x0a24;
  t.taharabic = 0x0637;
  t.tahfinalarabic = 0xfec2;
  t.tahinitialarabic = 0xfec3;
  t.tahiragana = 0x305f;
  t.tahmedialarabic = 0xfec4;
  t.taisyouerasquare = 0x337d;
  t.takatakana = 0x30bf;
  t.takatakanahalfwidth = 0xff80;
  t.tatweelarabic = 0x0640;
  t.tau = 0x03c4;
  t.tav = 0x05ea;
  t.tavdages = 0xfb4a;
  t.tavdagesh = 0xfb4a;
  t.tavdageshhebrew = 0xfb4a;
  t.tavhebrew = 0x05ea;
  t.tbar = 0x0167;
  t.tbopomofo = 0x310a;
  t.tcaron = 0x0165;
  t.tccurl = 0x02a8;
  t.tcedilla = 0x0163;
  t.tcheharabic = 0x0686;
  t.tchehfinalarabic = 0xfb7b;
  t.tchehinitialarabic = 0xfb7c;
  t.tchehmedialarabic = 0xfb7d;
  t.tcerchio = 0x24e3;
  t.tcircumflexbelow = 0x1e71;
  t.tcommaaccent = 0x0163;
  t.tdieresi = 0x1e97;
  t.tdotaccent = 0x1e6b;
  t.tdotbelow = 0x1e6d;
  t.cirillico = 0x0442;
  t.tedescendercyrillic = 0x04ad;
  t.teharabic = 0x062a;
  t.tehfinalarabic = 0xfe96;
  t.tehhahinitialarabic = 0xfca2;
  t.tehhahisolatedarabic = 0xfc0c;
  t.tehinitialarabic = 0xfe97;
  t.tehiragana = 0x3066;
  t.tehjeeminitialarabic = 0xfca1;
  t.tehjeemisolatedarabic = 0xfc0b;
  t.tehmarbutaarabic = 0x0629;
  t.tehmarbutafinalarabic = 0xfe94;
  t.tehmedialarabic = 0xfe98;
  t.tehmeeminitialarabic = 0xfca4;
  t.tehmeemisolatedarabic = 0xfc0e;
  t.tehnoonfinalarabic = 0xfc73;
  t.tekatakana = 0x30c6;
  t.tekatakanahalfwidth = 0xff83;
  t.telephone = 0x2121;
  t.telephoneblack = 0x260e;
  t.telishagedolahebrew = 0x05a0;
  t.telishaqetanahebrew = 0x05a9;
  t.tencircle = 0x2469;
  t.tenideographicparen = 0x3229;
  t.tenparen = 0x247d;
  t.tenperiod = 0x2491;
  t.tenroman = 0x2179;
  t.tesh = 0x02a7;
  t.tet = 0x05d8;
  t.tetdagesh = 0xfb38;
  t.tetdageshhebrew = 0xfb38;
  t.tethebrew = 0x05d8;
  t.tetsecyrillic = 0x04b5;
  t.tevirhebrew = 0x059b;
  t.tevirlefthebrew = 0x059b;
  t.thabengali = 0x09a5;
  t.thadeva = 0x0925;
  t.thagujarati = 0x0aa5;
  t.thagurmukhi = 0x0a25;
  t.thalarabic = 0x0630;
  t.thalfinalarabic = 0xfeac;
  t.thanthakhatlowleftthai = 0xf898;
  t.thanthakhatlowrightthai = 0xf897;
  t.thanthakhatthai = 0x0e4c;
  t.thanthakhatupperleftthai = 0xf896;
  t.theharabic = 0x062b;
  t.thehfinalarabic = 0xfe9a;
  t.thehinitialarabic = 0xfe9b;
  t.thehmedialarabic = 0xfe9c;
  t.thereexists = 0x2203;
  t.therefore = 0x2234;
  t.theta = 0x03b8;
  t.theta1 = 0x03d1;
  t.thetasymbolgreek = 0x03d1;
  t.thieuthacirclekorean = 0x3279;
  t.thieuthaparenkorean = 0x3219;
  t.thieuthcirclekorean = 0x326b;
  t.thieuthkorean = 0x314c;
  t.thieuthparenkorean = 0x320b;
  t.thirteencircle = 0x246c;
  t.thirteenparen = 0x2480;
  t.thirteenperiod = 0x2494;
  t.thonangmonthothai = 0x0e11;
  t.thook = 0x01ad;
  t.thophuthaothai = 0x0e12;
  t.thorn = 0x00fe;
  t.thothahanthai = 0x0e17;
  t.thothanthai = 0x0e10;
  t.thothongthai = 0x0e18;
  t.thothungthai = 0x0e16;
  t.thousandcyrillic = 0x0482;
  t.thousandsseparatorarabic = 0x066c;
  t.thousandsseparatorpersian = 0x066c;
  t.three = 0x0033;
  t.threearabic = 0x0663;
  t.threebengali = 0x09e9;
  t.threecircle = 0x2462;
  t.threecircleinversesansserif = 0x278c;
  t.threedeva = 0x0969;
  t.threeeighths = 0x215c;
  t.threegujarati = 0x0ae9;
  t.threegurmukhi = 0x0a69;
  t.threehackarabic = 0x0663;
  t.threehangzhou = 0x3023;
  t.threeideographicparen = 0x3222;
  t.threeinferior = 0x2083;
  t.threemonospace = 0xff13;
  t.threenumeratorbengali = 0x09f6;
  t.threeoldstyle = 0xf733;
  t.threeparen = 0x2476;
  t.threeperiod = 0x248a;
  t.threepersian = 0x06f3;
  t.threequarters = 0x00be;
  t.threequartersemdash = 0xf6de;
  t.threeroman = 0x2172;
  t.threesuperior = 0x00b3;
  t.threethai = 0x0e53;
  t.thzsquare = 0x3394;
  t.tihiragana = 0x3061;
  t.tikatakana = 0x30c1;
  t.tikatakanahalfwidth = 0xff81;
  t.tikeutacirclekorean = 0x3270;
  t.tikeutaparenkorean = 0x3210;
  t.tikeutcirclekorean = 0x3262;
  t.tikeutkorean = 0x3137;
  t.tikeutparenkorean = 0x3202;
  t.tilde = 0x02dc;
  t.tildebelowcmb = 0x0330;
  t.tildecmb = 0x0303;
  t.tildecomb = 0x0303;
  t.tildedoublecmb = 0x0360;
  t.tildeoperator = 0x223c;
  t.tildeoverlaycmb = 0x0334;
  t.tildeverticalcmb = 0x033e;
  t.timescircle = 0x2297;
  t.tipehahebrew = 0x0596;
  t.tipehalefthebrew = 0x0596;
  t.tippigurmukhi = 0x0a70;
  t.titlocyrilliccmb = 0x0483;
  t.tiwnarmenian = 0x057f;
  t.tlinebelow = 0x1e6f;
  t.tmonospace = 0xff54;
  t.toarmenian = 0x0569;
  t.tohiragana = 0x3068;
  t.tokatakana = 0x30c8;
  t.tokatakanahalfwidth = 0xff84;
  t.tonebarextrahighmod = 0x02e5;
  t.tonebarextralowmod = 0x02e9;
  t.tonebarhighmod = 0x02e6;
  t.tonebarlowmod = 0x02e8;
  t.tonebarmidmod = 0x02e7;
  t.tonefive = 0x01bd;
  t.tonesix = 0x0185;
  t.tonetwo = 0x01a8;
  t.tonos = 0x0384;
  t.tonsquare = 0x3327;
  t.topatakthai = 0x0e0f;
  t.tortoiseshellbracketleft = 0x3014;
  t.tortoiseshellbracketleftsmall = 0xfe5d;
  t.tortoiseshellbracketleftvertical = 0xfe39;
  t.tortoiseshellbracketright = 0x3015;
  t.tortoiseshellbracketrightsmall = 0xfe5e;
  t.tortoiseshellbracketrightvertical = 0xfe3a;
  t.totaothai = 0x0e15;
  t.tpalatalhook = 0x01ab;
  t.tparen = 0x24af;
  t.trademark = 0x2122;
  t.trademarksans = 0xf8ea;
  t.trademarkserif = 0xf6db;
  t.tretroflexhook = 0x0288;
  t.triagdn = 0x25bc;
  t.triaglf = 0x25c4;
  t.triagrt = 0x25ba;
  t.triagup = 0x25b2;
  t.ts = 0x02a6;
  t.tsadi = 0x05e6;
  t.tsadidagesh = 0xfb46;
  t.tsadidageshhebrew = 0xfb46;
  t.tsadihebrew = 0x05e6;
  t.tsecyrillic = 0x0446;
  t.tsere = 0x05b5;
  t.tsere12 = 0x05b5;
  t.tsere1e = 0x05b5;
  t.tsere2b = 0x05b5;
  t.tserehebrew = 0x05b5;
  t.tserenarrowhebrew = 0x05b5;
  t.tserequarterhebrew = 0x05b5;
  t.tserewidehebrew = 0x05b5;
  t.tshecyrillic = 0x045b;
  t.tsuperior = 0xf6f3;
  t.ttabengali = 0x099f;
  t.ttadeva = 0x091f;
  t.ttagujarati = 0x0a9f;
  t.ttagurmukhi = 0x0a1f;
  t.tteharabic = 0x0679;
  t.ttehfinalarabic = 0xfb67;
  t.ttehinitialarabic = 0xfb68;
  t.ttehmedialarabic = 0xfb69;
  t.tthabengali = 0x09a0;
  t.tthadeva = 0x0920;
  t.tthagujarati = 0x0aa0;
  t.tthagurmukhi = 0x0a20;
  t.tturned = 0x0287;
  t.tuhiragana = 0x3064;
  t.tukatakana = 0x30c4;
  t.tukatakanahalfwidth = 0xff82;
  t.tusmallhiragana = 0x3063;
  t.tusmallkatakana = 0x30c3;
  t.tusmallkatakanahalfwidth = 0xff6f;
  t.twelvecircle = 0x246b;
  t.twelveparen = 0x247f;
  t.twelveperiod = 0x2493;
  t.twelveroman = 0x217b;
  t.twentycircle = 0x2473;
  t.twentyhangzhou = 0x5344;
  t.twentyparen = 0x2487;
  t.twentyperiod = 0x249b;
  t.two = 0x0032;
  t.twoarabic = 0x0662;
  t.twobengali = 0x09e8;
  t.twocircle = 0x2461;
  t.twocircleinversesansserif = 0x278b;
  t.twodeva = 0x0968;
  t.twodotenleader = 0x2025;
  t.twodotleader = 0x2025;
  t.twodotleadervertical = 0xfe30;
  t.twogujarati = 0x0ae8;
  t.twogurmukhi = 0x0a68;
  t.twohackarabic = 0x0662;
  t.twohangzhou = 0x3022;
  t.twoideographicparen = 0x3221;
  t.twoinferior = 0x2082;
  t.twomonospace = 0xff12;
  t.twonumeratorbengali = 0x09f5;
  t.twooldstyle = 0xf732;
  t.twoparen = 0x2475;
  t.twoperiod = 0x2489;
  t.twopersian = 0x06f2;
  t.tworoman = 0x2171;
  t.twostroke = 0x01bb;
  t.twosuperior = 0x00b2;
  t.twothai = 0x0e52;
  t.twothirds = 0x2154;
  t.u = 0x0075;
  t.uacute = 0x00fa;
  t.ubar = 0x0289;
  t.ubengali = 0x0989;
  t.ubopomofo = 0x3128;
  t.ubreve = 0x016d;
  t.ucaron = 0x01d4;
  t.ucircle = 0x24e4;
  t.ucircumflex = 0x00fb;
  t.ucircumflexbelow = 0x1e77;
  t.ucyrillic = 0x0443;
  t.udattadeva = 0x0951;
  t.udblacute = 0x0171;
  t.udblgrave = 0x0215;
  t.udeva = 0x0909;
  t.udieresis = 0x00fc;
  t.udieresisacute = 0x01d8;
  t.udieresisbelow = 0x1e73;
  t.udieresiscaron = 0x01da;
  t.udieresiscyrillic = 0x04f1;
  t.udieresisgrave = 0x01dc;
  t.udieresismacron = 0x01d6;
  t.udotbelow = 0x1ee5;
  t.ugrave = 0x00f9;
  t.ugujarati = 0x0a89;
  t.ugurmukhi = 0x0a09;
  t.uhiragana = 0x3046;
  t.uhookabove = 0x1ee7;
  t.uhorn = 0x01b0;
  t.uhornacute = 0x1ee9;
  t.uhorndotbelow = 0x1ef1;
  t.uhorngrave = 0x1eeb;
  t.uhornhookabove = 0x1eed;
  t.uhorntilde = 0x1eef;
  t.uhungarumlaut = 0x0171;
  t.uhungarumlautcyrillic = 0x04f3;
  t.uinvertedbreve = 0x0217;
  t.ukatakana = 0x30a6;
  t.ukatakanahalfwidth = 0xff73;
  t.ukcyrillic = 0x0479;
  t.ukorean = 0x315c;
  t.umacron = 0x016b;
  t.umacroncyrillic = 0x04ef;
  t.umacrondieresis = 0x1e7b;
  t.umatragurmukhi = 0x0a41;
  t.umonospace = 0xff55;
  t.underscore = 0x005f;
  t.underscoredbl = 0x2017;
  t.underscoremonospace = 0xff3f;
  t.underscorevertical = 0xfe33;
  t.underscorewavy = 0xfe4f;
  t.union = 0x222a;
  t.universal = 0x2200;
  t.uogonek = 0x0173;
  t.uparen = 0x24b0;
  t.upblock = 0x2580;
  t.upperdothebrew = 0x05c4;
  t.upsilon = 0x03c5;
  t.upsilondieresis = 0x03cb;
  t.upsilondieresistonos = 0x03b0;
  t.upsilonlatin = 0x028a;
  t.upsilontonos = 0x03cd;
  t.uptackbelowcmb = 0x031d;
  t.uptackmod = 0x02d4;
  t.uragurmukhi = 0x0a73;
  t.uring = 0x016f;
  t.ushortcyrillic = 0x045e;
  t.usmallhiragana = 0x3045;
  t.usmallkatakana = 0x30a5;
  t.usmallkatakanahalfwidth = 0xff69;
  t.ustraightcyrillic = 0x04af;
  t.ustraightstrokecyrillic = 0x04b1;
  t.utilde = 0x0169;
  t.utildeacute = 0x1e79;
  t.utildebelow = 0x1e75;
  t.uubengali = 0x098a;
  t.uudeva = 0x090a;
  t.uugujarati = 0x0a8a;
  t.uugurmukhi = 0x0a0a;
  t.uumatragurmukhi = 0x0a42;
  t.uuvowelsignbengali = 0x09c2;
  t.uuvowelsigndeva = 0x0942;
  t.uuvowelsigngujarati = 0x0ac2;
  t.uvowelsignbengali = 0x09c1;
  t.uvowelsigndeva = 0x0941;
  t.uvowelsigngujarati = 0x0ac1;
  t.v = 0x0076;
  t.vadeva = 0x0935;
  t.vagujarati = 0x0ab5;
  t.vagurmukhi = 0x0a35;
  t.vakatakana = 0x30f7;
  t.vav = 0x05d5;
  t.vavdagesh = 0xfb35;
  t.vavdagesh65 = 0xfb35;
  t.vavdageshhebrew = 0xfb35;
  t.vavhebrew = 0x05d5;
  t.vavholam = 0xfb4b;
  t.vavholamhebrew = 0xfb4b;
  t.vavvavhebrew = 0x05f0;
  t.vavyodhebrew = 0x05f1;
  t.vcircle = 0x24e5;
  t.vdotbelow = 0x1e7f;
  t.vecyrillic = 0x0432;
  t.veharabic = 0x06a4;
  t.vehfinalarabic = 0xfb6b;
  t.vehinitialarabic = 0xfb6c;
  t.vehmedialarabic = 0xfb6d;
  t.vekatakana = 0x30f9;
  t.venus = 0x2640;
  t.verticalbar = 0x007c;
  t.verticallineabovecmb = 0x030d;
  t.verticallinebelowcmb = 0x0329;
  t.verticallinelowmod = 0x02cc;
  t.verticallinemod = 0x02c8;
  t.vewarmenian = 0x057e;
  t.vhook = 0x028b;
  t.vikatakana = 0x30f8;
  t.viramabengali = 0x09cd;
  t.viramadeva = 0x094d;
  t.viramagujarati = 0x0acd;
  t.visargabengali = 0x0983;
  t.visargadeva = 0x0903;
  t.visargagujarati = 0x0a83;
  t.vmonospace = 0xff56;
  t.voarmenian = 0x0578;
  t.voicediterationhiragana = 0x309e;
  t.voicediterationkatakana = 0x30fe;
  t.voicedmarkkana = 0x309b;
  t.voicedmarkkanahalfwidth = 0xff9e;
  t.vokatakana = 0x30fa;
  t.vparen = 0x24b1;
  t.vtilde = 0x1e7d;
  t.vturned = 0x028c;
  t.vuhiragana = 0x3094;
  t.vukatakana = 0x30f4;
  t.w = 0x0077;
  t.wacute = 0x1e83;
  t.waekorean = 0x3159;
  t.wahiragana = 0x308f;
  t.wakatakana = 0x30ef;
  t.wakatakanahalfwidth = 0xff9c;
  t.wakorean = 0x3158;
  t.wasmallhiragana = 0x308e;
  t.wasmallkatakana = 0x30ee;
  t.wattosquare = 0x3357;
  t.wavedash = 0x301c;
  t.wavyunderscorevertical = 0xfe34;
  t.wawarabic = 0x0648;
  t.wawfinalarabic = 0xfeee;
  t.wawhamzaabovearabic = 0x0624;
  t.wawhamzaabovefinalarabic = 0xfe86;
  t.wbsquare = 0x33dd;
  t.wcircle = 0x24e6;
  t.wcircumflex = 0x0175;
  t.wdieresis = 0x1e85;
  t.wdotaccent = 0x1e87;
  t.wdotbelow = 0x1e89;
  t.wehiragana = 0x3091;
  t.weierstrass = 0x2118;
  t.wekatakana = 0x30f1;
  t.wekorean = 0x315e;
  t.weokorean = 0x315d;
  t.wgrave = 0x1e81;
  t.whitebullet = 0x25e6;
  t.whitecircle = 0x25cb;
  t.whitecircleinverse = 0x25d9;
  t.whitecornerbracketleft = 0x300e;
  t.whitecornerbracketleftvertical = 0xfe43;
  t.whitecornerbracketright = 0x300f;
  t.whitecornerbracketrightvertical = 0xfe44;
  t.whitediamond = 0x25c7;
  t.whitediamondcontainingblacksmalldiamond = 0x25c8;
  t.whitedownpointingsmalltriangle = 0x25bf;
  t.whitedownpointingtriangle = 0x25bd;
  t.whiteleftpointingsmalltriangle = 0x25c3;
  t.whiteleftpointingtriangle = 0x25c1;
  t.whitelenticularbracketleft = 0x3016;
  t.whitelenticularbracketright = 0x3017;
  t.whiterightpointingsmalltriangle = 0x25b9;
  t.whiterightpointingtriangle = 0x25b7;
  t.whitesmallsquare = 0x25ab;
  t.whitesmilingface = 0x263a;
  t.whitesquare = 0x25a1;
  t.whitestar = 0x2606;
  t.whitetelephone = 0x260f;
  t.whitetortoiseshellbracketleft = 0x3018;
  t.whitetortoiseshellbracketright = 0x3019;
  t.whiteuppointingsmalltriangle = 0x25b5;
  t.whiteuppointingtriangle = 0x25b3;
  t.wihiragana = 0x3090;
  t.wikatakana = 0x30f0;
  t.wikorean = 0x315f;
  t.wmonospace = 0xff57;
  t.wohiragana = 0x3092;
  t.wokatakana = 0x30f2;
  t.wokatakanahalfwidth = 0xff66;
  t.won = 0x20a9;
  t.wonmonospace = 0xffe6;
  t.wowaenthai = 0x0e27;
  t.wparen = 0x24b2;
  t.wring = 0x1e98;
  t.wsuperior = 0x02b7;
  t.wturned = 0x028d;
  t.wynn = 0x01bf;
  t.x = 0x0078;
  t.xabovecmb = 0x033d;
  t.xbopomofo = 0x3112;
  t.xcircle = 0x24e7;
  t.xdieresis = 0x1e8d;
  t.xdotaccent = 0x1e8b;
  t.xeharmenian = 0x056d;
  t.xi = 0x03be;
  t.xmonospace = 0xff58;
  t.xparen = 0x24b3;
  t.xsuperior = 0x02e3;
  t.y = 0x0079;
  t.yaadosquare = 0x334e;
  t.yabengali = 0x09af;
  t.yacute = 0x00fd;
  t.yadeva = 0x092f;
  t.yaekorean = 0x3152;
  t.yagujarati = 0x0aaf;
  t.yagurmukhi = 0x0a2f;
  t.yahiragana = 0x3084;
  t.yakatakana = 0x30e4;
  t.yakatakanahalfwidth = 0xff94;
  t.yakorean = 0x3151;
  t.yamakkanthai = 0x0e4e;
  t.yasmallhiragana = 0x3083;
  t.yasmallkatakana = 0x30e3;
  t.yasmallkatakanahalfwidth = 0xff6c;
  t.yatcyrillic = 0x0463;
  t.ycircle = 0x24e8;
  t.ycircumflex = 0x0177;
  t.ydieresis = 0x00ff;
  t.ydotaccent = 0x1e8f;
  t.ydotbelow = 0x1ef5;
  t.yeharabic = 0x064a;
  t.yehbarreearabic = 0x06d2;
  t.yehbarreefinalarabic = 0xfbaf;
  t.yehfinalarabic = 0xfef2;
  t.yehhamzaabovearabic = 0x0626;
  t.yehhamzaabovefinalarabic = 0xfe8a;
  t.yehhamzaaboveinitialarabic = 0xfe8b;
  t.yehhamzaabovemedialarabic = 0xfe8c;
  t.yehinitialarabic = 0xfef3;
  t.yehmedialarabic = 0xfef4;
  t.yehmeeminitialarabic = 0xfcdd;
  t.yehmeemisolatedarabic = 0xfc58;
  t.yehnoonfinalarabic = 0xfc94;
  t.yehthreedotsbelowarabic = 0x06d1;
  t.yekorean = 0x3156;
  t.yen = 0x00a5;
  t.yenmonospace = 0xffe5;
  t.yeokorean = 0x3155;
  t.yeorinhieuhkorean = 0x3186;
  t.yerahbenyomohebrew = 0x05aa;
  t.yerahbenyomolefthebrew = 0x05aa;
  t.yericyrillic = 0x044b;
  t.yerudieresiscyrillic = 0x04f9;
  t.yesieungkorean = 0x3181;
  t.yesieungpansioskorean = 0x3183;
  t.yesieungsioskorean = 0x3182;
  t.yetivhebrew = 0x059a;
  t.ygrave = 0x1ef3;
  t.yhook = 0x01b4;
  t.yhookabove = 0x1ef7;
  t.yiarmenian = 0x0575;
  t.yicyrillic = 0x0457;
  t.yikorean = 0x3162;
  t.yinyang = 0x262f;
  t.yiwnarmenian = 0x0582;
  t.ymonospace = 0xff59;
  t.yod = 0x05d9;
  t.yoddagesh = 0xfb39;
  t.yoddageshhebrew = 0xfb39;
  t.yodhebrew = 0x05d9;
  t.yodyodhebrew = 0x05f2;
  t.yodyodpatahhebrew = 0xfb1f;
  t.yohiragana = 0x3088;
  t.yoikorean = 0x3189;
  t.yokatakana = 0x30e8;
  t.yokatakanahalfwidth = 0xff96;
  t.yokorean = 0x315b;
  t.yosmallhiragana = 0x3087;
  t.yosmallkatakana = 0x30e7;
  t.yosmallkatakanahalfwidth = 0xff6e;
  t.yotgreek = 0x03f3;
  t.yoyaekorean = 0x3188;
  t.yoyakorean = 0x3187;
  t.yoyakthai = 0x0e22;
  t.yoyingthai = 0x0e0d;
  t.yparen = 0x24b4;
  t.ypogegrammeni = 0x037a;
  t.ypogegrammenigreekcmb = 0x0345;
  t.yr = 0x01a6;
  t.yring = 0x1e99;
  t.ysuperior = 0x02b8;
  t.ytilde = 0x1ef9;
  t.yturned = 0x028e;
  t.yuhiragana = 0x3086;
  t.yuikorean = 0x318c;
  t.yukatakana = 0x30e6;
  t.yukatakanahalfwidth = 0xff95;
  t.yukorean = 0x3160;
  t.yusbigcyrillic = 0x046b;
  t.yusbigiotifiedcyrillic = 0x046d;
  t.yuslittlecyrillic = 0x0467;
  t.yuslittleiotifiedcyrillic = 0x0469;
  t.yusmallhiragana = 0x3085;
  t.yusmallkatakana = 0x30e5;
  t.yusmallkatakanahalfwidth = 0xff6d;
  t.yuyekorean = 0x318b;
  t.yuyeokorean = 0x318a;
  t.yyabengali = 0x09df;
  t.yyadeva = 0x095f;
  t.z = 0x007a;
  t.zaarmenian = 0x0566;
  t.zacute = 0x017a;
  t.zadeva = 0x095b;
  t.zagurmukhi = 0x0a5b;
  t.zaharabic = 0x0638;
  t.zahfinalarabic = 0xfec6;
  t.zahinitialarabic = 0xfec7;
  t.zahiragana = 0x3056;
  t.zahmedialarabic = 0xfec8;
  t.zainarabic = 0x0632;
  t.zainfinalarabic = 0xfeb0;
  t.zakatakana = 0x30b6;
  t.zaqefgadolhebrew = 0x0595;
  t.zaqefqatanhebrew = 0x0594;
  t.zarqahebrew = 0x0598;
  t.zayin = 0x05d6;
  t.zayindagesh = 0xfb36;
  t.zayindageshhebrew = 0xfb36;
  t.zayinhebrew = 0x05d6;
  t.zbopomofo = 0x3117;
  t.zcaron = 0x017e;
  t.zcircle = 0x24e9;
  t.zcircumflex = 0x1e91;
  t.zcurl = 0x0291;
  t.zdot = 0x017c;
  t.zdotaccent = 0x017c;
  t.zdotbelow = 0x1e93;
  t.zecyrillic = 0x0437;
  t.zedescendercyrillic = 0x0499;
  t.zedieresiscyrillic = 0x04df;
  t.zehiragana = 0x305c;
  t.zekatakana = 0x30bc;
  t.zero = 0x0030;
  t.zeroarabic = 0x0660;
  t.zerobengali = 0x09e6;
  t.zerodeva = 0x0966;
  t.zerogujarati = 0x0ae6;
  t.zerogurmukhi = 0x0a66;
  t.zerohackarabic = 0x0660;
  t.zeroinferior = 0x2080;
  t.zeromonospace = 0xff10;
  t.zerooldstyle = 0xf730;
  t.zeropersian = 0x06f0;
  t.zerosuperior = 0x2070;
  t.zerothai = 0x0e50;
  t.zerowidthjoiner = 0xfeff;
  t.zerowidthnonjoiner = 0x200c;
  t.zerowidthspace = 0x200b;
  t.zeta = 0x03b6;
  t.zhbopomofo = 0x3113;
  t.zhearmenian = 0x056a;
  t.zhebrevecyrillic = 0x04c2;
  t.zhecyrillic = 0x0436;
  t.zhedescendercyrillic = 0x0497;
  t.zhedieresiscyrillic = 0x04dd;
  t.zihiragana = 0x3058;
  t.zikatakana = 0x30b8;
  t.zinorhebrew = 0x05ae;
  t.zlinebelow = 0x1e95;
  t.zmonospace = 0xff5a;
  t.zohiragana = 0x305e;
  t.zokatakana = 0x30be;
  t.zparen = 0x24b5;
  t.zretroflexhook = 0x0290;
  t.zstroke = 0x01b6;
  t.zuhiragana = 0x305a;
  t.zukatakana = 0x30ba;
  t[".notdef"] = 0x0000;
  t.angbracketleftbig = 0x2329;
  t.angbracketleftBig = 0x2329;
  t.angbracketleftbigg = 0x2329;
  t.angbracketleftBigg = 0x2329;
  t.angbracketrightBig = 0x232a;
  t.angbracketrightbig = 0x232a;
  t.angbracketrightBigg = 0x232a;
  t.angbracketrightbigg = 0x232a;
  t.arrowhookleft = 0x21aa;
  t.arrowhookright = 0x21a9;
  t.arrowlefttophalf = 0x21bc;
  t.arrowleftbothalf = 0x21bd;
  t.arrownortheast = 0x2197;
  t.arrownorthwest = 0x2196;
  t.arrowrighttophalf = 0x21c0;
  t.arrowrightbothalf = 0x21c1;
  t.arrowsoutheast = 0x2198;
  t.arrowsouthwest = 0x2199;
  t.backslashbig = 0x2216;
  t.backslashBig = 0x2216;
  t.backslashBigg = 0x2216;
  t.backslashbigg = 0x2216;
  t.bardbl = 0x2016;
  t.bracehtipdownleft = 0xfe37;
  t.bracehtipdownright = 0xfe37;
  t.bracehtipupleft = 0xfe38;
  t.bracehtipupright = 0xfe38;
  t.braceleftBig = 0x007b;
  t.braceleftbig = 0x007b;
  t.braceleftbigg = 0x007b;
  t.braceleftBigg = 0x007b;
  t.bracerightBig = 0x007d;
  t.bracerightbig = 0x007d;
  t.bracerightbigg = 0x007d;
  t.bracerightBigg = 0x007d;
  t.bracketleftbig = 0x005b;
  t.bracketleftBig = 0x005b;
  t.bracketleftbigg = 0x005b;
  t.bracketleftBigg = 0x005b;
  t.bracketrightBig = 0x005d;
  t.bracketrightbig = 0x005d;
  t.bracketrightbigg = 0x005d;
  t.bracketrightBigg = 0x005d;
  t.ceilingleftbig = 0x2308;
  t.ceilingleftBig = 0x2308;
  t.ceilingleftBigg = 0x2308;
  t.ceilingleftbigg = 0x2308;
  t.ceilingrightbig = 0x2309;
  t.ceilingrightBig = 0x2309;
  t.ceilingrightbigg = 0x2309;
  t.ceilingrightBigg = 0x2309;
  t.circledotdisplay = 0x2299;
  t.circledottext = 0x2299;
  t.circlemultiplydisplay = 0x2297;
  t.circlemultiplytext = 0x2297;
  t.circleplusdisplay = 0x2295;
  t.circleplustext = 0x2295;
  t.contintegraldisplay = 0x222e;
  t.contintegraltext = 0x222e;
  t.coproductdisplay = 0x2210;
  t.coproducttext = 0x2210;
  t.floorleftBig = 0x230a;
  t.floorleftbig = 0x230a;
  t.floorleftbigg = 0x230a;
  t.floorleftBigg = 0x230a;
  t.floorrightbig = 0x230b;
  t.floorrightBig = 0x230b;
  t.floorrightBigg = 0x230b;
  t.floorrightbigg = 0x230b;
  t.hatwide = 0x0302;
  t.hatwider = 0x0302;
  t.hatwidest = 0x0302;
  t.intercal = 0x1d40;
  t.integraldisplay = 0x222b;
  t.integraltext = 0x222b;
  t.intersectiondisplay = 0x22c2;
  t.intersectiontext = 0x22c2;
  t.logicalanddisplay = 0x2227;
  t.logicalandtext = 0x2227;
  t.logicalordisplay = 0x2228;
  t.logicalortext = 0x2228;
  t.parenleftBig = 0x0028;
  t.parenleftbig = 0x0028;
  t.parenleftBigg = 0x0028;
  t.parenleftbigg = 0x0028;
  t.parenrightBig = 0x0029;
  t.parenrightbig = 0x0029;
  t.parenrightBigg = 0x0029;
  t.parenrightbigg = 0x0029;
  t.prime = 0x2032;
  t.productdisplay = 0x220f;
  t.producttext = 0x220f;
  t.radicalbig = 0x221a;
  t.radicalBig = 0x221a;
  t.radicalBigg = 0x221a;
  t.radicalbigg = 0x221a;
  t.radicalbt = 0x221a;
  t.radicaltp = 0x221a;
  t.radicalvertex = 0x221a;
  t.slashbig = 0x002f;
  t.slashBig = 0x002f;
  t.slashBigg = 0x002f;
  t.slashbigg = 0x002f;
  t.summationdisplay = 0x2211;
  t.summationtext = 0x2211;
  t.tildewide = 0x02dc;
  t.tildewider = 0x02dc;
  t.tildewidest = 0x02dc;
  t.uniondisplay = 0x22c3;
  t.unionmultidisplay = 0x228e;
  t.unionmultitext = 0x228e;
  t.unionsqdisplay = 0x2294;
  t.unionsqtext = 0x2294;
  t.uniontext = 0x22c3;
  t.vextenddouble = 0x2225;
  t.vextendsingle = 0x2223;
});
exports.getGlyphsUnicode = getGlyphsUnicode;
const getDingbatsGlyphsUnicode = (0, _core_utils.getLookupTableFactory)(function (t) {
  t.space = 0x0020;
  t.a1 = 0x2701;
  t.a2 = 0x2702;
  t.a202 = 0x2703;
  t.a3 = 0x2704;
  t.a4 = 0x260e;
  t.a5 = 0x2706;
  t.a119 = 0x2707;
  t.a118 = 0x2708;
  t.a117 = 0x2709;
  t.a11 = 0x261b;
  t.a12 = 0x261e;
  t.a13 = 0x270c;
  t.a14 = 0x270d;
  t.a15 = 0x270e;
  t.a16 = 0x270f;
  t.a105 = 0x2710;
  t.a17 = 0x2711;
  t.a18 = 0x2712;
  t.a19 = 0x2713;
  t.a20 = 0x2714;
  t.a21 = 0x2715;
  t.a22 = 0x2716;
  t.a23 = 0x2717;
  t.a24 = 0x2718;
  t.a25 = 0x2719;
  t.a26 = 0x271a;
  t.a27 = 0x271b;
  t.a28 = 0x271c;
  t.a6 = 0x271d;
  t.a7 = 0x271e;
  t.a8 = 0x271f;
  t.a9 = 0x2720;
  t.a10 = 0x2721;
  t.a29 = 0x2722;
  t.a30 = 0x2723;
  t.a31 = 0x2724;
  t.a32 = 0x2725;
  t.a33 = 0x2726;
  t.a34 = 0x2727;
  t.a35 = 0x2605;
  t.a36 = 0x2729;
  t.a37 = 0x272a;
  t.a38 = 0x272b;
  t.a39 = 0x272c;
  t.a40 = 0x272d;
  t.a41 = 0x272e;
  t.a42 = 0x272f;
  t.a43 = 0x2730;
  t.a44 = 0x2731;
  t.a45 = 0x2732;
  t.a46 = 0x2733;
  t.a47 = 0x2734;
  t.a48 = 0x2735;
  t.a49 = 0x2736;
  t.a50 = 0x2737;
  t.a51 = 0x2738;
  t.a52 = 0x2739;
  t.a53 = 0x273a;
  t.a54 = 0x273b;
  t.a55 = 0x273c;
  t.a56 = 0x273d;
  t.a57 = 0x273e;
  t.a58 = 0x273f;
  t.a59 = 0x2740;
  t.a60 = 0x2741;
  t.a61 = 0x2742;
  t.a62 = 0x2743;
  t.a63 = 0x2744;
  t.a64 = 0x2745;
  t.a65 = 0x2746;
  t.a66 = 0x2747;
  t.a67 = 0x2748;
  t.a68 = 0x2749;
  t.a69 = 0x274a;
  t.a70 = 0x274b;
  t.a71 = 0x25cf;
  t.a72 = 0x274d;
  t.a73 = 0x25a0;
  t.a74 = 0x274f;
  t.a203 = 0x2750;
  t.a75 = 0x2751;
  t.a204 = 0x2752;
  t.a76 = 0x25b2;
  t.a77 = 0x25bc;
  t.a78 = 0x25c6;
  t.a79 = 0x2756;
  t.a81 = 0x25d7;
  t.a82 = 0x2758;
  t.a83 = 0x2759;
  t.a84 = 0x275a;
  t.a97 = 0x275b;
  t.a98 = 0x275c;
  t.a99 = 0x275d;
  t.a100 = 0x275e;
  t.a101 = 0x2761;
  t.a102 = 0x2762;
  t.a103 = 0x2763;
  t.a104 = 0x2764;
  t.a106 = 0x2765;
  t.a107 = 0x2766;
  t.a108 = 0x2767;
  t.a112 = 0x2663;
  t.a111 = 0x2666;
  t.a110 = 0x2665;
  t.a109 = 0x2660;
  t.a120 = 0x2460;
  t.a121 = 0x2461;
  t.a122 = 0x2462;
  t.a123 = 0x2463;
  t.a124 = 0x2464;
  t.a125 = 0x2465;
  t.a126 = 0x2466;
  t.a127 = 0x2467;
  t.a128 = 0x2468;
  t.a129 = 0x2469;
  t.a130 = 0x2776;
  t.a131 = 0x2777;
  t.a132 = 0x2778;
  t.a133 = 0x2779;
  t.a134 = 0x277a;
  t.a135 = 0x277b;
  t.a136 = 0x277c;
  t.a137 = 0x277d;
  t.a138 = 0x277e;
  t.a139 = 0x277f;
  t.a140 = 0x2780;
  t.a141 = 0x2781;
  t.a142 = 0x2782;
  t.a143 = 0x2783;
  t.a144 = 0x2784;
  t.a145 = 0x2785;
  t.a146 = 0x2786;
  t.a147 = 0x2787;
  t.a148 = 0x2788;
  t.a149 = 0x2789;
  t.a150 = 0x278a;
  t.a151 = 0x278b;
  t.a152 = 0x278c;
  t.a153 = 0x278d;
  t.a154 = 0x278e;
  t.a155 = 0x278f;
  t.a156 = 0x2790;
  t.a157 = 0x2791;
  t.a158 = 0x2792;
  t.a159 = 0x2793;
  t.a160 = 0x2794;
  t.a161 = 0x2192;
  t.a163 = 0x2194;
  t.a164 = 0x2195;
  t.a196 = 0x2798;
  t.a165 = 0x2799;
  t.a192 = 0x279a;
  t.a166 = 0x279b;
  t.a167 = 0x279c;
  t.a168 = 0x279d;
  t.a169 = 0x279e;
  t.a170 = 0x279f;
  t.a171 = 0x27a0;
  t.a172 = 0x27a1;
  t.a173 = 0x27a2;
  t.a162 = 0x27a3;
  t.a174 = 0x27a4;
  t.a175 = 0x27a5;
  t.a176 = 0x27a6;
  t.a177 = 0x27a7;
  t.a178 = 0x27a8;
  t.a179 = 0x27a9;
  t.a193 = 0x27aa;
  t.a180 = 0x27ab;
  t.a199 = 0x27ac;
  t.a181 = 0x27ad;
  t.a200 = 0x27ae;
  t.a182 = 0x27af;
  t.a201 = 0x27b1;
  t.a183 = 0x27b2;
  t.a184 = 0x27b3;
  t.a197 = 0x27b4;
  t.a185 = 0x27b5;
  t.a194 = 0x27b6;
  t.a198 = 0x27b7;
  t.a186 = 0x27b8;
  t.a195 = 0x27b9;
  t.a187 = 0x27ba;
  t.a188 = 0x27bb;
  t.a189 = 0x27bc;
  t.a190 = 0x27bd;
  t.a191 = 0x27be;
  t.a89 = 0x2768;
  t.a90 = 0x2769;
  t.a93 = 0x276a;
  t.a94 = 0x276b;
  t.a91 = 0x276c;
  t.a92 = 0x276d;
  t.a205 = 0x276e;
  t.a85 = 0x276f;
  t.a206 = 0x2770;
  t.a86 = 0x2771;
  t.a87 = 0x2772;
  t.a88 = 0x2773;
  t.a95 = 0x2774;
  t.a96 = 0x2775;
  t[".notdef"] = 0x0000;
});
exports.getDingbatsGlyphsUnicode = getDingbatsGlyphsUnicode;

/***/ }),
/* 40 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.clearUnicodeCaches = clearUnicodeCaches;
exports.getCharUnicodeCategory = getCharUnicodeCategory;
exports.getUnicodeForGlyph = getUnicodeForGlyph;
exports.getUnicodeRangeFor = getUnicodeRangeFor;
exports.mapSpecialUnicodeValues = mapSpecialUnicodeValues;
var _core_utils = __w_pdfjs_require__(3);
const getSpecialPUASymbols = (0, _core_utils.getLookupTableFactory)(function (t) {
  t[63721] = 0x00a9;
  t[63193] = 0x00a9;
  t[63720] = 0x00ae;
  t[63194] = 0x00ae;
  t[63722] = 0x2122;
  t[63195] = 0x2122;
  t[63729] = 0x23a7;
  t[63730] = 0x23a8;
  t[63731] = 0x23a9;
  t[63740] = 0x23ab;
  t[63741] = 0x23ac;
  t[63742] = 0x23ad;
  t[63726] = 0x23a1;
  t[63727] = 0x23a2;
  t[63728] = 0x23a3;
  t[63737] = 0x23a4;
  t[63738] = 0x23a5;
  t[63739] = 0x23a6;
  t[63723] = 0x239b;
  t[63724] = 0x239c;
  t[63725] = 0x239d;
  t[63734] = 0x239e;
  t[63735] = 0x239f;
  t[63736] = 0x23a0;
});
function mapSpecialUnicodeValues(code) {
  if (code >= 0xfff0 && code <= 0xffff) {
    return 0;
  } else if (code >= 0xf600 && code <= 0xf8ff) {
    return getSpecialPUASymbols()[code] || code;
  } else if (code === 0x00ad) {
    return 0x002d;
  }
  return code;
}
function getUnicodeForGlyph(name, glyphsUnicodeMap) {
  let unicode = glyphsUnicodeMap[name];
  if (unicode !== undefined) {
    return unicode;
  }
  if (!name) {
    return -1;
  }
  if (name[0] === "u") {
    const nameLen = name.length;
    let hexStr;
    if (nameLen === 7 && name[1] === "n" && name[2] === "i") {
      hexStr = name.substring(3);
    } else if (nameLen >= 5 && nameLen <= 7) {
      hexStr = name.substring(1);
    } else {
      return -1;
    }
    if (hexStr === hexStr.toUpperCase()) {
      unicode = parseInt(hexStr, 16);
      if (unicode >= 0) {
        return unicode;
      }
    }
  }
  return -1;
}
const UnicodeRanges = [[0x0000, 0x007f], [0x0080, 0x00ff], [0x0100, 0x017f], [0x0180, 0x024f], [0x0250, 0x02af, 0x1d00, 0x1d7f, 0x1d80, 0x1dbf], [0x02b0, 0x02ff, 0xa700, 0xa71f], [0x0300, 0x036f, 0x1dc0, 0x1dff], [0x0370, 0x03ff], [0x2c80, 0x2cff], [0x0400, 0x04ff, 0x0500, 0x052f, 0x2de0, 0x2dff, 0xa640, 0xa69f], [0x0530, 0x058f], [0x0590, 0x05ff], [0xa500, 0xa63f], [0x0600, 0x06ff, 0x0750, 0x077f], [0x07c0, 0x07ff], [0x0900, 0x097f], [0x0980, 0x09ff], [0x0a00, 0x0a7f], [0x0a80, 0x0aff], [0x0b00, 0x0b7f], [0x0b80, 0x0bff], [0x0c00, 0x0c7f], [0x0c80, 0x0cff], [0x0d00, 0x0d7f], [0x0e00, 0x0e7f], [0x0e80, 0x0eff], [0x10a0, 0x10ff, 0x2d00, 0x2d2f], [0x1b00, 0x1b7f], [0x1100, 0x11ff], [0x1e00, 0x1eff, 0x2c60, 0x2c7f, 0xa720, 0xa7ff], [0x1f00, 0x1fff], [0x2000, 0x206f, 0x2e00, 0x2e7f], [0x2070, 0x209f], [0x20a0, 0x20cf], [0x20d0, 0x20ff], [0x2100, 0x214f], [0x2150, 0x218f], [0x2190, 0x21ff, 0x27f0, 0x27ff, 0x2900, 0x297f, 0x2b00, 0x2bff], [0x2200, 0x22ff, 0x2a00, 0x2aff, 0x27c0, 0x27ef, 0x2980, 0x29ff], [0x2300, 0x23ff], [0x2400, 0x243f], [0x2440, 0x245f], [0x2460, 0x24ff], [0x2500, 0x257f], [0x2580, 0x259f], [0x25a0, 0x25ff], [0x2600, 0x26ff], [0x2700, 0x27bf], [0x3000, 0x303f], [0x3040, 0x309f], [0x30a0, 0x30ff, 0x31f0, 0x31ff], [0x3100, 0x312f, 0x31a0, 0x31bf], [0x3130, 0x318f], [0xa840, 0xa87f], [0x3200, 0x32ff], [0x3300, 0x33ff], [0xac00, 0xd7af], [0xd800, 0xdfff], [0x10900, 0x1091f], [0x4e00, 0x9fff, 0x2e80, 0x2eff, 0x2f00, 0x2fdf, 0x2ff0, 0x2fff, 0x3400, 0x4dbf, 0x20000, 0x2a6df, 0x3190, 0x319f], [0xe000, 0xf8ff], [0x31c0, 0x31ef, 0xf900, 0xfaff, 0x2f800, 0x2fa1f], [0xfb00, 0xfb4f], [0xfb50, 0xfdff], [0xfe20, 0xfe2f], [0xfe10, 0xfe1f], [0xfe50, 0xfe6f], [0xfe70, 0xfeff], [0xff00, 0xffef], [0xfff0, 0xffff], [0x0f00, 0x0fff], [0x0700, 0x074f], [0x0780, 0x07bf], [0x0d80, 0x0dff], [0x1000, 0x109f], [0x1200, 0x137f, 0x1380, 0x139f, 0x2d80, 0x2ddf], [0x13a0, 0x13ff], [0x1400, 0x167f], [0x1680, 0x169f], [0x16a0, 0x16ff], [0x1780, 0x17ff], [0x1800, 0x18af], [0x2800, 0x28ff], [0xa000, 0xa48f], [0x1700, 0x171f, 0x1720, 0x173f, 0x1740, 0x175f, 0x1760, 0x177f], [0x10300, 0x1032f], [0x10330, 0x1034f], [0x10400, 0x1044f], [0x1d000, 0x1d0ff, 0x1d100, 0x1d1ff, 0x1d200, 0x1d24f], [0x1d400, 0x1d7ff], [0xff000, 0xffffd], [0xfe00, 0xfe0f, 0xe0100, 0xe01ef], [0xe0000, 0xe007f], [0x1900, 0x194f], [0x1950, 0x197f], [0x1980, 0x19df], [0x1a00, 0x1a1f], [0x2c00, 0x2c5f], [0x2d30, 0x2d7f], [0x4dc0, 0x4dff], [0xa800, 0xa82f], [0x10000, 0x1007f, 0x10080, 0x100ff, 0x10100, 0x1013f], [0x10140, 0x1018f], [0x10380, 0x1039f], [0x103a0, 0x103df], [0x10450, 0x1047f], [0x10480, 0x104af], [0x10800, 0x1083f], [0x10a00, 0x10a5f], [0x1d300, 0x1d35f], [0x12000, 0x123ff, 0x12400, 0x1247f], [0x1d360, 0x1d37f], [0x1b80, 0x1bbf], [0x1c00, 0x1c4f], [0x1c50, 0x1c7f], [0xa880, 0xa8df], [0xa900, 0xa92f], [0xa930, 0xa95f], [0xaa00, 0xaa5f], [0x10190, 0x101cf], [0x101d0, 0x101ff], [0x102a0, 0x102df, 0x10280, 0x1029f, 0x10920, 0x1093f], [0x1f030, 0x1f09f, 0x1f000, 0x1f02f]];
function getUnicodeRangeFor(value, lastPosition = -1) {
  if (lastPosition !== -1) {
    const range = UnicodeRanges[lastPosition];
    for (let i = 0, ii = range.length; i < ii; i += 2) {
      if (value >= range[i] && value <= range[i + 1]) {
        return lastPosition;
      }
    }
  }
  for (let i = 0, ii = UnicodeRanges.length; i < ii; i++) {
    const range = UnicodeRanges[i];
    for (let j = 0, jj = range.length; j < jj; j += 2) {
      if (value >= range[j] && value <= range[j + 1]) {
        return i;
      }
    }
  }
  return -1;
}
const SpecialCharRegExp = new RegExp("^(\\s)|(\\p{Mn})|(\\p{Cf})$", "u");
const CategoryCache = new Map();
function getCharUnicodeCategory(char) {
  const cachedCategory = CategoryCache.get(char);
  if (cachedCategory) {
    return cachedCategory;
  }
  const groups = char.match(SpecialCharRegExp);
  const category = {
    isWhitespace: !!groups?.[1],
    isZeroWidthDiacritic: !!groups?.[2],
    isInvisibleFormatMark: !!groups?.[3]
  };
  CategoryCache.set(char, category);
  return category;
}
function clearUnicodeCaches() {
  CategoryCache.clear();
}

/***/ }),
/* 41 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getSerifFonts = exports.getNonStdFontMap = exports.getGlyphMapForStandardFonts = exports.getFontNameToFileMap = void 0;
exports.getStandardFontName = getStandardFontName;
exports.getSymbolsFonts = exports.getSupplementalGlyphMapForCalibri = exports.getSupplementalGlyphMapForArialBlack = exports.getStdFontMap = void 0;
exports.isKnownFontName = isKnownFontName;
var _core_utils = __w_pdfjs_require__(3);
var _fonts_utils = __w_pdfjs_require__(38);
const getStdFontMap = (0, _core_utils.getLookupTableFactory)(function (t) {
  t["Times-Roman"] = "Times-Roman";
  t.Helvetica = "Helvetica";
  t.Courier = "Courier";
  t.Symbol = "Symbol";
  t["Times-Bold"] = "Times-Bold";
  t["Helvetica-Bold"] = "Helvetica-Bold";
  t["Courier-Bold"] = "Courier-Bold";
  t.ZapfDingbats = "ZapfDingbats";
  t["Times-Italic"] = "Times-Italic";
  t["Helvetica-Oblique"] = "Helvetica-Oblique";
  t["Courier-Oblique"] = "Courier-Oblique";
  t["Times-BoldItalic"] = "Times-BoldItalic";
  t["Helvetica-BoldOblique"] = "Helvetica-BoldOblique";
  t["Courier-BoldOblique"] = "Courier-BoldOblique";
  t.ArialNarrow = "Helvetica";
  t["ArialNarrow-Bold"] = "Helvetica-Bold";
  t["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique";
  t["ArialNarrow-Italic"] = "Helvetica-Oblique";
  t.ArialBlack = "Helvetica";
  t["ArialBlack-Bold"] = "Helvetica-Bold";
  t["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique";
  t["ArialBlack-Italic"] = "Helvetica-Oblique";
  t["Arial-Black"] = "Helvetica";
  t["Arial-Black-Bold"] = "Helvetica-Bold";
  t["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique";
  t["Arial-Black-Italic"] = "Helvetica-Oblique";
  t.Arial = "Helvetica";
  t["Arial-Bold"] = "Helvetica-Bold";
  t["Arial-BoldItalic"] = "Helvetica-BoldOblique";
  t["Arial-Italic"] = "Helvetica-Oblique";
  t.ArialMT = "Helvetica";
  t["Arial-BoldItalicMT"] = "Helvetica-BoldOblique";
  t["Arial-BoldMT"] = "Helvetica-Bold";
  t["Arial-ItalicMT"] = "Helvetica-Oblique";
  t["Arial-BoldItalicMT-BoldItalic"] = "Helvetica-BoldOblique";
  t["Arial-BoldMT-Bold"] = "Helvetica-Bold";
  t["Arial-ItalicMT-Italic"] = "Helvetica-Oblique";
  t.ArialUnicodeMS = "Helvetica";
  t["ArialUnicodeMS-Bold"] = "Helvetica-Bold";
  t["ArialUnicodeMS-BoldItalic"] = "Helvetica-BoldOblique";
  t["ArialUnicodeMS-Italic"] = "Helvetica-Oblique";
  t["Courier-BoldItalic"] = "Courier-BoldOblique";
  t["Courier-Italic"] = "Courier-Oblique";
  t.CourierNew = "Courier";
  t["CourierNew-Bold"] = "Courier-Bold";
  t["CourierNew-BoldItalic"] = "Courier-BoldOblique";
  t["CourierNew-Italic"] = "Courier-Oblique";
  t["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique";
  t["CourierNewPS-BoldMT"] = "Courier-Bold";
  t["CourierNewPS-ItalicMT"] = "Courier-Oblique";
  t.CourierNewPSMT = "Courier";
  t["Helvetica-BoldItalic"] = "Helvetica-BoldOblique";
  t["Helvetica-Italic"] = "Helvetica-Oblique";
  t["Symbol-Bold"] = "Symbol";
  t["Symbol-BoldItalic"] = "Symbol";
  t["Symbol-Italic"] = "Symbol";
  t.TimesNewRoman = "Times-Roman";
  t["TimesNewRoman-Bold"] = "Times-Bold";
  t["TimesNewRoman-BoldItalic"] = "Times-BoldItalic";
  t["TimesNewRoman-Italic"] = "Times-Italic";
  t.TimesNewRomanPS = "Times-Roman";
  t["TimesNewRomanPS-Bold"] = "Times-Bold";
  t["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic";
  t["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic";
  t["TimesNewRomanPS-BoldMT"] = "Times-Bold";
  t["TimesNewRomanPS-Italic"] = "Times-Italic";
  t["TimesNewRomanPS-ItalicMT"] = "Times-Italic";
  t.TimesNewRomanPSMT = "Times-Roman";
  t["TimesNewRomanPSMT-Bold"] = "Times-Bold";
  t["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic";
  t["TimesNewRomanPSMT-Italic"] = "Times-Italic";
});
exports.getStdFontMap = getStdFontMap;
const getFontNameToFileMap = (0, _core_utils.getLookupTableFactory)(function (t) {
  t.Courier = "FoxitFixed.pfb";
  t["Courier-Bold"] = "FoxitFixedBold.pfb";
  t["Courier-BoldOblique"] = "FoxitFixedBoldItalic.pfb";
  t["Courier-Oblique"] = "FoxitFixedItalic.pfb";
  t.Helvetica = "LiberationSans-Regular.ttf";
  t["Helvetica-Bold"] = "LiberationSans-Bold.ttf";
  t["Helvetica-BoldOblique"] = "LiberationSans-BoldItalic.ttf";
  t["Helvetica-Oblique"] = "LiberationSans-Italic.ttf";
  t["Times-Roman"] = "FoxitSerif.pfb";
  t["Times-Bold"] = "FoxitSerifBold.pfb";
  t["Times-BoldItalic"] = "FoxitSerifBoldItalic.pfb";
  t["Times-Italic"] = "FoxitSerifItalic.pfb";
  t.Symbol = "FoxitSymbol.pfb";
  t.ZapfDingbats = "FoxitDingbats.pfb";
  t["LiberationSans-Regular"] = "LiberationSans-Regular.ttf";
  t["LiberationSans-Bold"] = "LiberationSans-Bold.ttf";
  t["LiberationSans-Italic"] = "LiberationSans-Italic.ttf";
  t["LiberationSans-BoldItalic"] = "LiberationSans-BoldItalic.ttf";
});
exports.getFontNameToFileMap = getFontNameToFileMap;
const getNonStdFontMap = (0, _core_utils.getLookupTableFactory)(function (t) {
  t.Calibri = "Helvetica";
  t["Calibri-Bold"] = "Helvetica-Bold";
  t["Calibri-BoldItalic"] = "Helvetica-BoldOblique";
  t["Calibri-Italic"] = "Helvetica-Oblique";
  t.CenturyGothic = "Helvetica";
  t["CenturyGothic-Bold"] = "Helvetica-Bold";
  t["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique";
  t["CenturyGothic-Italic"] = "Helvetica-Oblique";
  t.ComicSansMS = "Comic Sans MS";
  t["ComicSansMS-Bold"] = "Comic Sans MS-Bold";
  t["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic";
  t["ComicSansMS-Italic"] = "Comic Sans MS-Italic";
  t.Impact = "Helvetica";
  t["ItcSymbol-Bold"] = "Helvetica-Bold";
  t["ItcSymbol-BoldItalic"] = "Helvetica-BoldOblique";
  t["ItcSymbol-Book"] = "Helvetica";
  t["ItcSymbol-BookItalic"] = "Helvetica-Oblique";
  t["ItcSymbol-Medium"] = "Helvetica";
  t["ItcSymbol-MediumItalic"] = "Helvetica-Oblique";
  t.LucidaConsole = "Courier";
  t["LucidaConsole-Bold"] = "Courier-Bold";
  t["LucidaConsole-BoldItalic"] = "Courier-BoldOblique";
  t["LucidaConsole-Italic"] = "Courier-Oblique";
  t["LucidaSans-Demi"] = "Helvetica-Bold";
  t["MS-Gothic"] = "MS Gothic";
  t["MS-Gothic-Bold"] = "MS Gothic-Bold";
  t["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic";
  t["MS-Gothic-Italic"] = "MS Gothic-Italic";
  t["MS-Mincho"] = "MS Mincho";
  t["MS-Mincho-Bold"] = "MS Mincho-Bold";
  t["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic";
  t["MS-Mincho-Italic"] = "MS Mincho-Italic";
  t["MS-PGothic"] = "MS PGothic";
  t["MS-PGothic-Bold"] = "MS PGothic-Bold";
  t["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic";
  t["MS-PGothic-Italic"] = "MS PGothic-Italic";
  t["MS-PMincho"] = "MS PMincho";
  t["MS-PMincho-Bold"] = "MS PMincho-Bold";
  t["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic";
  t["MS-PMincho-Italic"] = "MS PMincho-Italic";
  t.NuptialScript = "Times-Italic";
  t.SegoeUISymbol = "Helvetica";
});
exports.getNonStdFontMap = getNonStdFontMap;
const getSerifFonts = (0, _core_utils.getLookupTableFactory)(function (t) {
  t["Adobe Jenson"] = true;
  t["Adobe Text"] = true;
  t.Albertus = true;
  t.Aldus = true;
  t.Alexandria = true;
  t.Algerian = true;
  t["American Typewriter"] = true;
  t.Antiqua = true;
  t.Apex = true;
  t.Arno = true;
  t.Aster = true;
  t.Aurora = true;
  t.Baskerville = true;
  t.Bell = true;
  t.Bembo = true;
  t["Bembo Schoolbook"] = true;
  t.Benguiat = true;
  t["Berkeley Old Style"] = true;
  t["Bernhard Modern"] = true;
  t["Berthold City"] = true;
  t.Bodoni = true;
  t["Bauer Bodoni"] = true;
  t["Book Antiqua"] = true;
  t.Bookman = true;
  t["Bordeaux Roman"] = true;
  t["Californian FB"] = true;
  t.Calisto = true;
  t.Calvert = true;
  t.Capitals = true;
  t.Cambria = true;
  t.Cartier = true;
  t.Caslon = true;
  t.Catull = true;
  t.Centaur = true;
  t["Century Old Style"] = true;
  t["Century Schoolbook"] = true;
  t.Chaparral = true;
  t["Charis SIL"] = true;
  t.Cheltenham = true;
  t["Cholla Slab"] = true;
  t.Clarendon = true;
  t.Clearface = true;
  t.Cochin = true;
  t.Colonna = true;
  t["Computer Modern"] = true;
  t["Concrete Roman"] = true;
  t.Constantia = true;
  t["Cooper Black"] = true;
  t.Corona = true;
  t.Ecotype = true;
  t.Egyptienne = true;
  t.Elephant = true;
  t.Excelsior = true;
  t.Fairfield = true;
  t["FF Scala"] = true;
  t.Folkard = true;
  t.Footlight = true;
  t.FreeSerif = true;
  t["Friz Quadrata"] = true;
  t.Garamond = true;
  t.Gentium = true;
  t.Georgia = true;
  t.Gloucester = true;
  t["Goudy Old Style"] = true;
  t["Goudy Schoolbook"] = true;
  t["Goudy Pro Font"] = true;
  t.Granjon = true;
  t["Guardian Egyptian"] = true;
  t.Heather = true;
  t.Hercules = true;
  t["High Tower Text"] = true;
  t.Hiroshige = true;
  t["Hoefler Text"] = true;
  t["Humana Serif"] = true;
  t.Imprint = true;
  t["Ionic No. 5"] = true;
  t.Janson = true;
  t.Joanna = true;
  t.Korinna = true;
  t.Lexicon = true;
  t.LiberationSerif = true;
  t["Liberation Serif"] = true;
  t["Linux Libertine"] = true;
  t.Literaturnaya = true;
  t.Lucida = true;
  t["Lucida Bright"] = true;
  t.Melior = true;
  t.Memphis = true;
  t.Miller = true;
  t.Minion = true;
  t.Modern = true;
  t["Mona Lisa"] = true;
  t["Mrs Eaves"] = true;
  t["MS Serif"] = true;
  t["Museo Slab"] = true;
  t["New York"] = true;
  t["Nimbus Roman"] = true;
  t["NPS Rawlinson Roadway"] = true;
  t.NuptialScript = true;
  t.Palatino = true;
  t.Perpetua = true;
  t.Plantin = true;
  t["Plantin Schoolbook"] = true;
  t.Playbill = true;
  t["Poor Richard"] = true;
  t["Rawlinson Roadway"] = true;
  t.Renault = true;
  t.Requiem = true;
  t.Rockwell = true;
  t.Roman = true;
  t["Rotis Serif"] = true;
  t.Sabon = true;
  t.Scala = true;
  t.Seagull = true;
  t.Sistina = true;
  t.Souvenir = true;
  t.STIX = true;
  t["Stone Informal"] = true;
  t["Stone Serif"] = true;
  t.Sylfaen = true;
  t.Times = true;
  t.Trajan = true;
  t["Trinité"] = true;
  t["Trump Mediaeval"] = true;
  t.Utopia = true;
  t["Vale Type"] = true;
  t["Bitstream Vera"] = true;
  t["Vera Serif"] = true;
  t.Versailles = true;
  t.Wanted = true;
  t.Weiss = true;
  t["Wide Latin"] = true;
  t.Windsor = true;
  t.XITS = true;
});
exports.getSerifFonts = getSerifFonts;
const getSymbolsFonts = (0, _core_utils.getLookupTableFactory)(function (t) {
  t.Dingbats = true;
  t.Symbol = true;
  t.ZapfDingbats = true;
  t.Wingdings = true;
  t["Wingdings-Bold"] = true;
  t["Wingdings-Regular"] = true;
});
exports.getSymbolsFonts = getSymbolsFonts;
const getGlyphMapForStandardFonts = (0, _core_utils.getLookupTableFactory)(function (t) {
  t[2] = 10;
  t[3] = 32;
  t[4] = 33;
  t[5] = 34;
  t[6] = 35;
  t[7] = 36;
  t[8] = 37;
  t[9] = 38;
  t[10] = 39;
  t[11] = 40;
  t[12] = 41;
  t[13] = 42;
  t[14] = 43;
  t[15] = 44;
  t[16] = 45;
  t[17] = 46;
  t[18] = 47;
  t[19] = 48;
  t[20] = 49;
  t[21] = 50;
  t[22] = 51;
  t[23] = 52;
  t[24] = 53;
  t[25] = 54;
  t[26] = 55;
  t[27] = 56;
  t[28] = 57;
  t[29] = 58;
  t[30] = 894;
  t[31] = 60;
  t[32] = 61;
  t[33] = 62;
  t[34] = 63;
  t[35] = 64;
  t[36] = 65;
  t[37] = 66;
  t[38] = 67;
  t[39] = 68;
  t[40] = 69;
  t[41] = 70;
  t[42] = 71;
  t[43] = 72;
  t[44] = 73;
  t[45] = 74;
  t[46] = 75;
  t[47] = 76;
  t[48] = 77;
  t[49] = 78;
  t[50] = 79;
  t[51] = 80;
  t[52] = 81;
  t[53] = 82;
  t[54] = 83;
  t[55] = 84;
  t[56] = 85;
  t[57] = 86;
  t[58] = 87;
  t[59] = 88;
  t[60] = 89;
  t[61] = 90;
  t[62] = 91;
  t[63] = 92;
  t[64] = 93;
  t[65] = 94;
  t[66] = 95;
  t[67] = 96;
  t[68] = 97;
  t[69] = 98;
  t[70] = 99;
  t[71] = 100;
  t[72] = 101;
  t[73] = 102;
  t[74] = 103;
  t[75] = 104;
  t[76] = 105;
  t[77] = 106;
  t[78] = 107;
  t[79] = 108;
  t[80] = 109;
  t[81] = 110;
  t[82] = 111;
  t[83] = 112;
  t[84] = 113;
  t[85] = 114;
  t[86] = 115;
  t[87] = 116;
  t[88] = 117;
  t[89] = 118;
  t[90] = 119;
  t[91] = 120;
  t[92] = 121;
  t[93] = 122;
  t[94] = 123;
  t[95] = 124;
  t[96] = 125;
  t[97] = 126;
  t[98] = 196;
  t[99] = 197;
  t[100] = 199;
  t[101] = 201;
  t[102] = 209;
  t[103] = 214;
  t[104] = 220;
  t[105] = 225;
  t[106] = 224;
  t[107] = 226;
  t[108] = 228;
  t[109] = 227;
  t[110] = 229;
  t[111] = 231;
  t[112] = 233;
  t[113] = 232;
  t[114] = 234;
  t[115] = 235;
  t[116] = 237;
  t[117] = 236;
  t[118] = 238;
  t[119] = 239;
  t[120] = 241;
  t[121] = 243;
  t[122] = 242;
  t[123] = 244;
  t[124] = 246;
  t[125] = 245;
  t[126] = 250;
  t[127] = 249;
  t[128] = 251;
  t[129] = 252;
  t[130] = 8224;
  t[131] = 176;
  t[132] = 162;
  t[133] = 163;
  t[134] = 167;
  t[135] = 8226;
  t[136] = 182;
  t[137] = 223;
  t[138] = 174;
  t[139] = 169;
  t[140] = 8482;
  t[141] = 180;
  t[142] = 168;
  t[143] = 8800;
  t[144] = 198;
  t[145] = 216;
  t[146] = 8734;
  t[147] = 177;
  t[148] = 8804;
  t[149] = 8805;
  t[150] = 165;
  t[151] = 181;
  t[152] = 8706;
  t[153] = 8721;
  t[154] = 8719;
  t[156] = 8747;
  t[157] = 170;
  t[158] = 186;
  t[159] = 8486;
  t[160] = 230;
  t[161] = 248;
  t[162] = 191;
  t[163] = 161;
  t[164] = 172;
  t[165] = 8730;
  t[166] = 402;
  t[167] = 8776;
  t[168] = 8710;
  t[169] = 171;
  t[170] = 187;
  t[171] = 8230;
  t[179] = 8220;
  t[180] = 8221;
  t[181] = 8216;
  t[182] = 8217;
  t[200] = 193;
  t[203] = 205;
  t[207] = 211;
  t[210] = 218;
  t[223] = 711;
  t[224] = 321;
  t[225] = 322;
  t[226] = 352;
  t[227] = 353;
  t[228] = 381;
  t[229] = 382;
  t[233] = 221;
  t[234] = 253;
  t[252] = 263;
  t[253] = 268;
  t[254] = 269;
  t[258] = 258;
  t[260] = 260;
  t[261] = 261;
  t[265] = 280;
  t[266] = 281;
  t[267] = 282;
  t[268] = 283;
  t[269] = 313;
  t[275] = 323;
  t[276] = 324;
  t[278] = 328;
  t[283] = 344;
  t[284] = 345;
  t[285] = 346;
  t[286] = 347;
  t[292] = 367;
  t[295] = 377;
  t[296] = 378;
  t[298] = 380;
  t[305] = 963;
  t[306] = 964;
  t[307] = 966;
  t[308] = 8215;
  t[309] = 8252;
  t[310] = 8319;
  t[311] = 8359;
  t[312] = 8592;
  t[313] = 8593;
  t[337] = 9552;
  t[493] = 1039;
  t[494] = 1040;
  t[672] = 1488;
  t[673] = 1489;
  t[674] = 1490;
  t[675] = 1491;
  t[676] = 1492;
  t[677] = 1493;
  t[678] = 1494;
  t[679] = 1495;
  t[680] = 1496;
  t[681] = 1497;
  t[682] = 1498;
  t[683] = 1499;
  t[684] = 1500;
  t[685] = 1501;
  t[686] = 1502;
  t[687] = 1503;
  t[688] = 1504;
  t[689] = 1505;
  t[690] = 1506;
  t[691] = 1507;
  t[692] = 1508;
  t[693] = 1509;
  t[694] = 1510;
  t[695] = 1511;
  t[696] = 1512;
  t[697] = 1513;
  t[698] = 1514;
  t[705] = 1524;
  t[706] = 8362;
  t[710] = 64288;
  t[711] = 64298;
  t[759] = 1617;
  t[761] = 1776;
  t[763] = 1778;
  t[775] = 1652;
  t[777] = 1764;
  t[778] = 1780;
  t[779] = 1781;
  t[780] = 1782;
  t[782] = 771;
  t[783] = 64726;
  t[786] = 8363;
  t[788] = 8532;
  t[790] = 768;
  t[791] = 769;
  t[792] = 768;
  t[795] = 803;
  t[797] = 64336;
  t[798] = 64337;
  t[799] = 64342;
  t[800] = 64343;
  t[801] = 64344;
  t[802] = 64345;
  t[803] = 64362;
  t[804] = 64363;
  t[805] = 64364;
  t[2424] = 7821;
  t[2425] = 7822;
  t[2426] = 7823;
  t[2427] = 7824;
  t[2428] = 7825;
  t[2429] = 7826;
  t[2430] = 7827;
  t[2433] = 7682;
  t[2678] = 8045;
  t[2679] = 8046;
  t[2830] = 1552;
  t[2838] = 686;
  t[2840] = 751;
  t[2842] = 753;
  t[2843] = 754;
  t[2844] = 755;
  t[2846] = 757;
  t[2856] = 767;
  t[2857] = 848;
  t[2858] = 849;
  t[2862] = 853;
  t[2863] = 854;
  t[2864] = 855;
  t[2865] = 861;
  t[2866] = 862;
  t[2906] = 7460;
  t[2908] = 7462;
  t[2909] = 7463;
  t[2910] = 7464;
  t[2912] = 7466;
  t[2913] = 7467;
  t[2914] = 7468;
  t[2916] = 7470;
  t[2917] = 7471;
  t[2918] = 7472;
  t[2920] = 7474;
  t[2921] = 7475;
  t[2922] = 7476;
  t[2924] = 7478;
  t[2925] = 7479;
  t[2926] = 7480;
  t[2928] = 7482;
  t[2929] = 7483;
  t[2930] = 7484;
  t[2932] = 7486;
  t[2933] = 7487;
  t[2934] = 7488;
  t[2936] = 7490;
  t[2937] = 7491;
  t[2938] = 7492;
  t[2940] = 7494;
  t[2941] = 7495;
  t[2942] = 7496;
  t[2944] = 7498;
  t[2946] = 7500;
  t[2948] = 7502;
  t[2950] = 7504;
  t[2951] = 7505;
  t[2952] = 7506;
  t[2954] = 7508;
  t[2955] = 7509;
  t[2956] = 7510;
  t[2958] = 7512;
  t[2959] = 7513;
  t[2960] = 7514;
  t[2962] = 7516;
  t[2963] = 7517;
  t[2964] = 7518;
  t[2966] = 7520;
  t[2967] = 7521;
  t[2968] = 7522;
  t[2970] = 7524;
  t[2971] = 7525;
  t[2972] = 7526;
  t[2974] = 7528;
  t[2975] = 7529;
  t[2976] = 7530;
  t[2978] = 1537;
  t[2979] = 1538;
  t[2980] = 1539;
  t[2982] = 1549;
  t[2983] = 1551;
  t[2984] = 1552;
  t[2986] = 1554;
  t[2987] = 1555;
  t[2988] = 1556;
  t[2990] = 1623;
  t[2991] = 1624;
  t[2995] = 1775;
  t[2999] = 1791;
  t[3002] = 64290;
  t[3003] = 64291;
  t[3004] = 64292;
  t[3006] = 64294;
  t[3007] = 64295;
  t[3008] = 64296;
  t[3011] = 1900;
  t[3014] = 8223;
  t[3015] = 8244;
  t[3017] = 7532;
  t[3018] = 7533;
  t[3019] = 7534;
  t[3075] = 7590;
  t[3076] = 7591;
  t[3079] = 7594;
  t[3080] = 7595;
  t[3083] = 7598;
  t[3084] = 7599;
  t[3087] = 7602;
  t[3088] = 7603;
  t[3091] = 7606;
  t[3092] = 7607;
  t[3095] = 7610;
  t[3096] = 7611;
  t[3099] = 7614;
  t[3100] = 7615;
  t[3103] = 7618;
  t[3104] = 7619;
  t[3107] = 8337;
  t[3108] = 8338;
  t[3116] = 1884;
  t[3119] = 1885;
  t[3120] = 1885;
  t[3123] = 1886;
  t[3124] = 1886;
  t[3127] = 1887;
  t[3128] = 1887;
  t[3131] = 1888;
  t[3132] = 1888;
  t[3135] = 1889;
  t[3136] = 1889;
  t[3139] = 1890;
  t[3140] = 1890;
  t[3143] = 1891;
  t[3144] = 1891;
  t[3147] = 1892;
  t[3148] = 1892;
  t[3153] = 580;
  t[3154] = 581;
  t[3157] = 584;
  t[3158] = 585;
  t[3161] = 588;
  t[3162] = 589;
  t[3165] = 891;
  t[3166] = 892;
  t[3169] = 1274;
  t[3170] = 1275;
  t[3173] = 1278;
  t[3174] = 1279;
  t[3181] = 7622;
  t[3182] = 7623;
  t[3282] = 11799;
  t[3316] = 578;
  t[3379] = 42785;
  t[3393] = 1159;
  t[3416] = 8377;
});
exports.getGlyphMapForStandardFonts = getGlyphMapForStandardFonts;
const getSupplementalGlyphMapForArialBlack = (0, _core_utils.getLookupTableFactory)(function (t) {
  t[227] = 322;
  t[264] = 261;
  t[291] = 346;
});
exports.getSupplementalGlyphMapForArialBlack = getSupplementalGlyphMapForArialBlack;
const getSupplementalGlyphMapForCalibri = (0, _core_utils.getLookupTableFactory)(function (t) {
  t[1] = 32;
  t[4] = 65;
  t[5] = 192;
  t[6] = 193;
  t[9] = 196;
  t[17] = 66;
  t[18] = 67;
  t[21] = 268;
  t[24] = 68;
  t[28] = 69;
  t[29] = 200;
  t[30] = 201;
  t[32] = 282;
  t[38] = 70;
  t[39] = 71;
  t[44] = 72;
  t[47] = 73;
  t[48] = 204;
  t[49] = 205;
  t[58] = 74;
  t[60] = 75;
  t[62] = 76;
  t[68] = 77;
  t[69] = 78;
  t[75] = 79;
  t[76] = 210;
  t[80] = 214;
  t[87] = 80;
  t[89] = 81;
  t[90] = 82;
  t[92] = 344;
  t[94] = 83;
  t[97] = 352;
  t[100] = 84;
  t[104] = 85;
  t[109] = 220;
  t[115] = 86;
  t[116] = 87;
  t[121] = 88;
  t[122] = 89;
  t[124] = 221;
  t[127] = 90;
  t[129] = 381;
  t[258] = 97;
  t[259] = 224;
  t[260] = 225;
  t[263] = 228;
  t[268] = 261;
  t[271] = 98;
  t[272] = 99;
  t[273] = 263;
  t[275] = 269;
  t[282] = 100;
  t[286] = 101;
  t[287] = 232;
  t[288] = 233;
  t[290] = 283;
  t[295] = 281;
  t[296] = 102;
  t[336] = 103;
  t[346] = 104;
  t[349] = 105;
  t[350] = 236;
  t[351] = 237;
  t[361] = 106;
  t[364] = 107;
  t[367] = 108;
  t[371] = 322;
  t[373] = 109;
  t[374] = 110;
  t[381] = 111;
  t[382] = 242;
  t[383] = 243;
  t[386] = 246;
  t[393] = 112;
  t[395] = 113;
  t[396] = 114;
  t[398] = 345;
  t[400] = 115;
  t[401] = 347;
  t[403] = 353;
  t[410] = 116;
  t[437] = 117;
  t[442] = 252;
  t[448] = 118;
  t[449] = 119;
  t[454] = 120;
  t[455] = 121;
  t[457] = 253;
  t[460] = 122;
  t[462] = 382;
  t[463] = 380;
  t[853] = 44;
  t[855] = 58;
  t[856] = 46;
  t[876] = 47;
  t[878] = 45;
  t[882] = 45;
  t[894] = 40;
  t[895] = 41;
  t[896] = 91;
  t[897] = 93;
  t[923] = 64;
  t[1004] = 48;
  t[1005] = 49;
  t[1006] = 50;
  t[1007] = 51;
  t[1008] = 52;
  t[1009] = 53;
  t[1010] = 54;
  t[1011] = 55;
  t[1012] = 56;
  t[1013] = 57;
  t[1081] = 37;
  t[1085] = 43;
  t[1086] = 45;
});
exports.getSupplementalGlyphMapForCalibri = getSupplementalGlyphMapForCalibri;
function getStandardFontName(name) {
  const fontName = (0, _fonts_utils.normalizeFontName)(name);
  const stdFontMap = getStdFontMap();
  return stdFontMap[fontName];
}
function isKnownFontName(name) {
  const fontName = (0, _fonts_utils.normalizeFontName)(name);
  return !!(getStdFontMap()[fontName] || getNonStdFontMap()[fontName] || getSerifFonts()[fontName] || getSymbolsFonts()[fontName]);
}

/***/ }),
/* 42 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ToUnicodeMap = exports.IdentityToUnicodeMap = void 0;
var _util = __w_pdfjs_require__(2);
class ToUnicodeMap {
  constructor(cmap = []) {
    this._map = cmap;
  }
  get length() {
    return this._map.length;
  }
  forEach(callback) {
    for (const charCode in this._map) {
      callback(charCode, this._map[charCode].charCodeAt(0));
    }
  }
  has(i) {
    return this._map[i] !== undefined;
  }
  get(i) {
    return this._map[i];
  }
  charCodeOf(value) {
    const map = this._map;
    if (map.length <= 0x10000) {
      return map.indexOf(value);
    }
    for (const charCode in map) {
      if (map[charCode] === value) {
        return charCode | 0;
      }
    }
    return -1;
  }
  amend(map) {
    for (const charCode in map) {
      this._map[charCode] = map[charCode];
    }
  }
}
exports.ToUnicodeMap = ToUnicodeMap;
class IdentityToUnicodeMap {
  constructor(firstChar, lastChar) {
    this.firstChar = firstChar;
    this.lastChar = lastChar;
  }
  get length() {
    return this.lastChar + 1 - this.firstChar;
  }
  forEach(callback) {
    for (let i = this.firstChar, ii = this.lastChar; i <= ii; i++) {
      callback(i, i);
    }
  }
  has(i) {
    return this.firstChar <= i && i <= this.lastChar;
  }
  get(i) {
    if (this.firstChar <= i && i <= this.lastChar) {
      return String.fromCharCode(i);
    }
    return undefined;
  }
  charCodeOf(v) {
    return Number.isInteger(v) && v >= this.firstChar && v <= this.lastChar ? v : -1;
  }
  amend(map) {
    (0, _util.unreachable)("Should not call amend()");
  }
}
exports.IdentityToUnicodeMap = IdentityToUnicodeMap;

/***/ }),
/* 43 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CFFFont = void 0;
var _cff_parser = __w_pdfjs_require__(35);
var _fonts_utils = __w_pdfjs_require__(38);
var _util = __w_pdfjs_require__(2);
class CFFFont {
  constructor(file, properties) {
    this.properties = properties;
    const parser = new _cff_parser.CFFParser(file, properties, _fonts_utils.SEAC_ANALYSIS_ENABLED);
    this.cff = parser.parse();
    this.cff.duplicateFirstGlyph();
    const compiler = new _cff_parser.CFFCompiler(this.cff);
    this.seacs = this.cff.seacs;
    try {
      this.data = compiler.compile();
    } catch {
      (0, _util.warn)("Failed to compile font " + properties.loadedName);
      this.data = file;
    }
    this._createBuiltInEncoding();
  }
  get numGlyphs() {
    return this.cff.charStrings.count;
  }
  getCharset() {
    return this.cff.charset.charset;
  }
  getGlyphMapping() {
    const cff = this.cff;
    const properties = this.properties;
    const {
      cidToGidMap,
      cMap
    } = properties;
    const charsets = cff.charset.charset;
    let charCodeToGlyphId;
    let glyphId;
    if (properties.composite) {
      let invCidToGidMap;
      if (cidToGidMap?.length > 0) {
        invCidToGidMap = Object.create(null);
        for (let i = 0, ii = cidToGidMap.length; i < ii; i++) {
          const gid = cidToGidMap[i];
          if (gid !== undefined) {
            invCidToGidMap[gid] = i;
          }
        }
      }
      charCodeToGlyphId = Object.create(null);
      let charCode;
      if (cff.isCIDFont) {
        for (glyphId = 0; glyphId < charsets.length; glyphId++) {
          const cid = charsets[glyphId];
          charCode = cMap.charCodeOf(cid);
          if (invCidToGidMap?.[charCode] !== undefined) {
            charCode = invCidToGidMap[charCode];
          }
          charCodeToGlyphId[charCode] = glyphId;
        }
      } else {
        for (glyphId = 0; glyphId < cff.charStrings.count; glyphId++) {
          charCode = cMap.charCodeOf(glyphId);
          charCodeToGlyphId[charCode] = glyphId;
        }
      }
      return charCodeToGlyphId;
    }
    let encoding = cff.encoding ? cff.encoding.encoding : null;
    if (properties.isInternalFont) {
      encoding = properties.defaultEncoding;
    }
    charCodeToGlyphId = (0, _fonts_utils.type1FontGlyphMapping)(properties, encoding, charsets);
    return charCodeToGlyphId;
  }
  hasGlyphId(id) {
    return this.cff.hasGlyphId(id);
  }
  _createBuiltInEncoding() {
    const {
      charset,
      encoding
    } = this.cff;
    if (!charset || !encoding) {
      return;
    }
    const charsets = charset.charset,
      encodings = encoding.encoding;
    const map = [];
    for (const charCode in encodings) {
      const glyphId = encodings[charCode];
      if (glyphId >= 0) {
        const glyphName = charsets[glyphId];
        if (glyphName) {
          map[charCode] = glyphName;
        }
      }
    }
    if (map.length > 0) {
      this.properties.builtInEncoding = map;
    }
  }
}
exports.CFFFont = CFFFont;

/***/ }),
/* 44 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FontRendererFactory = void 0;
var _util = __w_pdfjs_require__(2);
var _cff_parser = __w_pdfjs_require__(35);
var _glyphlist = __w_pdfjs_require__(39);
var _encodings = __w_pdfjs_require__(37);
var _stream = __w_pdfjs_require__(8);
function getUint32(data, offset) {
  return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;
}
function getUint16(data, offset) {
  return data[offset] << 8 | data[offset + 1];
}
function getInt16(data, offset) {
  return (data[offset] << 24 | data[offset + 1] << 16) >> 16;
}
function getInt8(data, offset) {
  return data[offset] << 24 >> 24;
}
function getFloat214(data, offset) {
  return getInt16(data, offset) / 16384;
}
function getSubroutineBias(subrs) {
  const numSubrs = subrs.length;
  let bias = 32768;
  if (numSubrs < 1240) {
    bias = 107;
  } else if (numSubrs < 33900) {
    bias = 1131;
  }
  return bias;
}
function parseCmap(data, start, end) {
  const offset = getUint16(data, start + 2) === 1 ? getUint32(data, start + 8) : getUint32(data, start + 16);
  const format = getUint16(data, start + offset);
  let ranges, p, i;
  if (format === 4) {
    getUint16(data, start + offset + 2);
    const segCount = getUint16(data, start + offset + 6) >> 1;
    p = start + offset + 14;
    ranges = [];
    for (i = 0; i < segCount; i++, p += 2) {
      ranges[i] = {
        end: getUint16(data, p)
      };
    }
    p += 2;
    for (i = 0; i < segCount; i++, p += 2) {
      ranges[i].start = getUint16(data, p);
    }
    for (i = 0; i < segCount; i++, p += 2) {
      ranges[i].idDelta = getUint16(data, p);
    }
    for (i = 0; i < segCount; i++, p += 2) {
      let idOffset = getUint16(data, p);
      if (idOffset === 0) {
        continue;
      }
      ranges[i].ids = [];
      for (let j = 0, jj = ranges[i].end - ranges[i].start + 1; j < jj; j++) {
        ranges[i].ids[j] = getUint16(data, p + idOffset);
        idOffset += 2;
      }
    }
    return ranges;
  } else if (format === 12) {
    const groups = getUint32(data, start + offset + 12);
    p = start + offset + 16;
    ranges = [];
    for (i = 0; i < groups; i++) {
      start = getUint32(data, p);
      ranges.push({
        start,
        end: getUint32(data, p + 4),
        idDelta: getUint32(data, p + 8) - start
      });
      p += 12;
    }
    return ranges;
  }
  throw new _util.FormatError(`unsupported cmap: ${format}`);
}
function parseCff(data, start, end, seacAnalysisEnabled) {
  const properties = {};
  const parser = new _cff_parser.CFFParser(new _stream.Stream(data, start, end - start), properties, seacAnalysisEnabled);
  const cff = parser.parse();
  return {
    glyphs: cff.charStrings.objects,
    subrs: cff.topDict.privateDict?.subrsIndex?.objects,
    gsubrs: cff.globalSubrIndex?.objects,
    isCFFCIDFont: cff.isCIDFont,
    fdSelect: cff.fdSelect,
    fdArray: cff.fdArray
  };
}
function parseGlyfTable(glyf, loca, isGlyphLocationsLong) {
  let itemSize, itemDecode;
  if (isGlyphLocationsLong) {
    itemSize = 4;
    itemDecode = getUint32;
  } else {
    itemSize = 2;
    itemDecode = (data, offset) => 2 * getUint16(data, offset);
  }
  const glyphs = [];
  let startOffset = itemDecode(loca, 0);
  for (let j = itemSize; j < loca.length; j += itemSize) {
    const endOffset = itemDecode(loca, j);
    glyphs.push(glyf.subarray(startOffset, endOffset));
    startOffset = endOffset;
  }
  return glyphs;
}
function lookupCmap(ranges, unicode) {
  const code = unicode.codePointAt(0);
  let gid = 0,
    l = 0,
    r = ranges.length - 1;
  while (l < r) {
    const c = l + r + 1 >> 1;
    if (code < ranges[c].start) {
      r = c - 1;
    } else {
      l = c;
    }
  }
  if (ranges[l].start <= code && code <= ranges[l].end) {
    gid = ranges[l].idDelta + (ranges[l].ids ? ranges[l].ids[code - ranges[l].start] : code) & 0xffff;
  }
  return {
    charCode: code,
    glyphId: gid
  };
}
function compileGlyf(code, cmds, font) {
  function moveTo(x, y) {
    cmds.push({
      cmd: "moveTo",
      args: [x, y]
    });
  }
  function lineTo(x, y) {
    cmds.push({
      cmd: "lineTo",
      args: [x, y]
    });
  }
  function quadraticCurveTo(xa, ya, x, y) {
    cmds.push({
      cmd: "quadraticCurveTo",
      args: [xa, ya, x, y]
    });
  }
  let i = 0;
  const numberOfContours = getInt16(code, i);
  let flags;
  let x = 0,
    y = 0;
  i += 10;
  if (numberOfContours < 0) {
    do {
      flags = getUint16(code, i);
      const glyphIndex = getUint16(code, i + 2);
      i += 4;
      let arg1, arg2;
      if (flags & 0x01) {
        if (flags & 0x02) {
          arg1 = getInt16(code, i);
          arg2 = getInt16(code, i + 2);
        } else {
          arg1 = getUint16(code, i);
          arg2 = getUint16(code, i + 2);
        }
        i += 4;
      } else if (flags & 0x02) {
        arg1 = getInt8(code, i++);
        arg2 = getInt8(code, i++);
      } else {
        arg1 = code[i++];
        arg2 = code[i++];
      }
      if (flags & 0x02) {
        x = arg1;
        y = arg2;
      } else {
        x = 0;
        y = 0;
      }
      let scaleX = 1,
        scaleY = 1,
        scale01 = 0,
        scale10 = 0;
      if (flags & 0x08) {
        scaleX = scaleY = getFloat214(code, i);
        i += 2;
      } else if (flags & 0x40) {
        scaleX = getFloat214(code, i);
        scaleY = getFloat214(code, i + 2);
        i += 4;
      } else if (flags & 0x80) {
        scaleX = getFloat214(code, i);
        scale01 = getFloat214(code, i + 2);
        scale10 = getFloat214(code, i + 4);
        scaleY = getFloat214(code, i + 6);
        i += 8;
      }
      const subglyph = font.glyphs[glyphIndex];
      if (subglyph) {
        cmds.push({
          cmd: "save"
        }, {
          cmd: "transform",
          args: [scaleX, scale01, scale10, scaleY, x, y]
        });
        if (!(flags & 0x02)) {}
        compileGlyf(subglyph, cmds, font);
        cmds.push({
          cmd: "restore"
        });
      }
    } while (flags & 0x20);
  } else {
    const endPtsOfContours = [];
    let j, jj;
    for (j = 0; j < numberOfContours; j++) {
      endPtsOfContours.push(getUint16(code, i));
      i += 2;
    }
    const instructionLength = getUint16(code, i);
    i += 2 + instructionLength;
    const numberOfPoints = endPtsOfContours.at(-1) + 1;
    const points = [];
    while (points.length < numberOfPoints) {
      flags = code[i++];
      let repeat = 1;
      if (flags & 0x08) {
        repeat += code[i++];
      }
      while (repeat-- > 0) {
        points.push({
          flags
        });
      }
    }
    for (j = 0; j < numberOfPoints; j++) {
      switch (points[j].flags & 0x12) {
        case 0x00:
          x += getInt16(code, i);
          i += 2;
          break;
        case 0x02:
          x -= code[i++];
          break;
        case 0x12:
          x += code[i++];
          break;
      }
      points[j].x = x;
    }
    for (j = 0; j < numberOfPoints; j++) {
      switch (points[j].flags & 0x24) {
        case 0x00:
          y += getInt16(code, i);
          i += 2;
          break;
        case 0x04:
          y -= code[i++];
          break;
        case 0x24:
          y += code[i++];
          break;
      }
      points[j].y = y;
    }
    let startPoint = 0;
    for (i = 0; i < numberOfContours; i++) {
      const endPoint = endPtsOfContours[i];
      const contour = points.slice(startPoint, endPoint + 1);
      if (contour[0].flags & 1) {
        contour.push(contour[0]);
      } else if (contour.at(-1).flags & 1) {
        contour.unshift(contour.at(-1));
      } else {
        const p = {
          flags: 1,
          x: (contour[0].x + contour.at(-1).x) / 2,
          y: (contour[0].y + contour.at(-1).y) / 2
        };
        contour.unshift(p);
        contour.push(p);
      }
      moveTo(contour[0].x, contour[0].y);
      for (j = 1, jj = contour.length; j < jj; j++) {
        if (contour[j].flags & 1) {
          lineTo(contour[j].x, contour[j].y);
        } else if (contour[j + 1].flags & 1) {
          quadraticCurveTo(contour[j].x, contour[j].y, contour[j + 1].x, contour[j + 1].y);
          j++;
        } else {
          quadraticCurveTo(contour[j].x, contour[j].y, (contour[j].x + contour[j + 1].x) / 2, (contour[j].y + contour[j + 1].y) / 2);
        }
      }
      startPoint = endPoint + 1;
    }
  }
}
function compileCharString(charStringCode, cmds, font, glyphId) {
  function moveTo(x, y) {
    cmds.push({
      cmd: "moveTo",
      args: [x, y]
    });
  }
  function lineTo(x, y) {
    cmds.push({
      cmd: "lineTo",
      args: [x, y]
    });
  }
  function bezierCurveTo(x1, y1, x2, y2, x, y) {
    cmds.push({
      cmd: "bezierCurveTo",
      args: [x1, y1, x2, y2, x, y]
    });
  }
  const stack = [];
  let x = 0,
    y = 0;
  let stems = 0;
  function parse(code) {
    let i = 0;
    while (i < code.length) {
      let stackClean = false;
      let v = code[i++];
      let xa, xb, ya, yb, y1, y2, y3, n, subrCode;
      switch (v) {
        case 1:
          stems += stack.length >> 1;
          stackClean = true;
          break;
        case 3:
          stems += stack.length >> 1;
          stackClean = true;
          break;
        case 4:
          y += stack.pop();
          moveTo(x, y);
          stackClean = true;
          break;
        case 5:
          while (stack.length > 0) {
            x += stack.shift();
            y += stack.shift();
            lineTo(x, y);
          }
          break;
        case 6:
          while (stack.length > 0) {
            x += stack.shift();
            lineTo(x, y);
            if (stack.length === 0) {
              break;
            }
            y += stack.shift();
            lineTo(x, y);
          }
          break;
        case 7:
          while (stack.length > 0) {
            y += stack.shift();
            lineTo(x, y);
            if (stack.length === 0) {
              break;
            }
            x += stack.shift();
            lineTo(x, y);
          }
          break;
        case 8:
          while (stack.length > 0) {
            xa = x + stack.shift();
            ya = y + stack.shift();
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            x = xb + stack.shift();
            y = yb + stack.shift();
            bezierCurveTo(xa, ya, xb, yb, x, y);
          }
          break;
        case 10:
          n = stack.pop();
          subrCode = null;
          if (font.isCFFCIDFont) {
            const fdIndex = font.fdSelect.getFDIndex(glyphId);
            if (fdIndex >= 0 && fdIndex < font.fdArray.length) {
              const fontDict = font.fdArray[fdIndex];
              let subrs;
              if (fontDict.privateDict?.subrsIndex) {
                subrs = fontDict.privateDict.subrsIndex.objects;
              }
              if (subrs) {
                n += getSubroutineBias(subrs);
                subrCode = subrs[n];
              }
            } else {
              (0, _util.warn)("Invalid fd index for glyph index.");
            }
          } else {
            subrCode = font.subrs[n + font.subrsBias];
          }
          if (subrCode) {
            parse(subrCode);
          }
          break;
        case 11:
          return;
        case 12:
          v = code[i++];
          switch (v) {
            case 34:
              xa = x + stack.shift();
              xb = xa + stack.shift();
              y1 = y + stack.shift();
              x = xb + stack.shift();
              bezierCurveTo(xa, y, xb, y1, x, y1);
              xa = x + stack.shift();
              xb = xa + stack.shift();
              x = xb + stack.shift();
              bezierCurveTo(xa, y1, xb, y, x, y);
              break;
            case 35:
              xa = x + stack.shift();
              ya = y + stack.shift();
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              x = xb + stack.shift();
              y = yb + stack.shift();
              bezierCurveTo(xa, ya, xb, yb, x, y);
              xa = x + stack.shift();
              ya = y + stack.shift();
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              x = xb + stack.shift();
              y = yb + stack.shift();
              bezierCurveTo(xa, ya, xb, yb, x, y);
              stack.pop();
              break;
            case 36:
              xa = x + stack.shift();
              y1 = y + stack.shift();
              xb = xa + stack.shift();
              y2 = y1 + stack.shift();
              x = xb + stack.shift();
              bezierCurveTo(xa, y1, xb, y2, x, y2);
              xa = x + stack.shift();
              xb = xa + stack.shift();
              y3 = y2 + stack.shift();
              x = xb + stack.shift();
              bezierCurveTo(xa, y2, xb, y3, x, y);
              break;
            case 37:
              const x0 = x,
                y0 = y;
              xa = x + stack.shift();
              ya = y + stack.shift();
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              x = xb + stack.shift();
              y = yb + stack.shift();
              bezierCurveTo(xa, ya, xb, yb, x, y);
              xa = x + stack.shift();
              ya = y + stack.shift();
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              x = xb;
              y = yb;
              if (Math.abs(x - x0) > Math.abs(y - y0)) {
                x += stack.shift();
              } else {
                y += stack.shift();
              }
              bezierCurveTo(xa, ya, xb, yb, x, y);
              break;
            default:
              throw new _util.FormatError(`unknown operator: 12 ${v}`);
          }
          break;
        case 14:
          if (stack.length >= 4) {
            const achar = stack.pop();
            const bchar = stack.pop();
            y = stack.pop();
            x = stack.pop();
            cmds.push({
              cmd: "save"
            }, {
              cmd: "translate",
              args: [x, y]
            });
            let cmap = lookupCmap(font.cmap, String.fromCharCode(font.glyphNameMap[_encodings.StandardEncoding[achar]]));
            compileCharString(font.glyphs[cmap.glyphId], cmds, font, cmap.glyphId);
            cmds.push({
              cmd: "restore"
            });
            cmap = lookupCmap(font.cmap, String.fromCharCode(font.glyphNameMap[_encodings.StandardEncoding[bchar]]));
            compileCharString(font.glyphs[cmap.glyphId], cmds, font, cmap.glyphId);
          }
          return;
        case 18:
          stems += stack.length >> 1;
          stackClean = true;
          break;
        case 19:
          stems += stack.length >> 1;
          i += stems + 7 >> 3;
          stackClean = true;
          break;
        case 20:
          stems += stack.length >> 1;
          i += stems + 7 >> 3;
          stackClean = true;
          break;
        case 21:
          y += stack.pop();
          x += stack.pop();
          moveTo(x, y);
          stackClean = true;
          break;
        case 22:
          x += stack.pop();
          moveTo(x, y);
          stackClean = true;
          break;
        case 23:
          stems += stack.length >> 1;
          stackClean = true;
          break;
        case 24:
          while (stack.length > 2) {
            xa = x + stack.shift();
            ya = y + stack.shift();
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            x = xb + stack.shift();
            y = yb + stack.shift();
            bezierCurveTo(xa, ya, xb, yb, x, y);
          }
          x += stack.shift();
          y += stack.shift();
          lineTo(x, y);
          break;
        case 25:
          while (stack.length > 6) {
            x += stack.shift();
            y += stack.shift();
            lineTo(x, y);
          }
          xa = x + stack.shift();
          ya = y + stack.shift();
          xb = xa + stack.shift();
          yb = ya + stack.shift();
          x = xb + stack.shift();
          y = yb + stack.shift();
          bezierCurveTo(xa, ya, xb, yb, x, y);
          break;
        case 26:
          if (stack.length % 2) {
            x += stack.shift();
          }
          while (stack.length > 0) {
            xa = x;
            ya = y + stack.shift();
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            x = xb;
            y = yb + stack.shift();
            bezierCurveTo(xa, ya, xb, yb, x, y);
          }
          break;
        case 27:
          if (stack.length % 2) {
            y += stack.shift();
          }
          while (stack.length > 0) {
            xa = x + stack.shift();
            ya = y;
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            x = xb + stack.shift();
            y = yb;
            bezierCurveTo(xa, ya, xb, yb, x, y);
          }
          break;
        case 28:
          stack.push((code[i] << 24 | code[i + 1] << 16) >> 16);
          i += 2;
          break;
        case 29:
          n = stack.pop() + font.gsubrsBias;
          subrCode = font.gsubrs[n];
          if (subrCode) {
            parse(subrCode);
          }
          break;
        case 30:
          while (stack.length > 0) {
            xa = x;
            ya = y + stack.shift();
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            x = xb + stack.shift();
            y = yb + (stack.length === 1 ? stack.shift() : 0);
            bezierCurveTo(xa, ya, xb, yb, x, y);
            if (stack.length === 0) {
              break;
            }
            xa = x + stack.shift();
            ya = y;
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            y = yb + stack.shift();
            x = xb + (stack.length === 1 ? stack.shift() : 0);
            bezierCurveTo(xa, ya, xb, yb, x, y);
          }
          break;
        case 31:
          while (stack.length > 0) {
            xa = x + stack.shift();
            ya = y;
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            y = yb + stack.shift();
            x = xb + (stack.length === 1 ? stack.shift() : 0);
            bezierCurveTo(xa, ya, xb, yb, x, y);
            if (stack.length === 0) {
              break;
            }
            xa = x;
            ya = y + stack.shift();
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            x = xb + stack.shift();
            y = yb + (stack.length === 1 ? stack.shift() : 0);
            bezierCurveTo(xa, ya, xb, yb, x, y);
          }
          break;
        default:
          if (v < 32) {
            throw new _util.FormatError(`unknown operator: ${v}`);
          }
          if (v < 247) {
            stack.push(v - 139);
          } else if (v < 251) {
            stack.push((v - 247) * 256 + code[i++] + 108);
          } else if (v < 255) {
            stack.push(-(v - 251) * 256 - code[i++] - 108);
          } else {
            stack.push((code[i] << 24 | code[i + 1] << 16 | code[i + 2] << 8 | code[i + 3]) / 65536);
            i += 4;
          }
          break;
      }
      if (stackClean) {
        stack.length = 0;
      }
    }
  }
  parse(charStringCode);
}
const NOOP = [];
class CompiledFont {
  constructor(fontMatrix) {
    if (this.constructor === CompiledFont) {
      (0, _util.unreachable)("Cannot initialize CompiledFont.");
    }
    this.fontMatrix = fontMatrix;
    this.compiledGlyphs = Object.create(null);
    this.compiledCharCodeToGlyphId = Object.create(null);
  }
  getPathJs(unicode) {
    const {
      charCode,
      glyphId
    } = lookupCmap(this.cmap, unicode);
    let fn = this.compiledGlyphs[glyphId];
    if (!fn) {
      try {
        fn = this.compileGlyph(this.glyphs[glyphId], glyphId);
        this.compiledGlyphs[glyphId] = fn;
      } catch (ex) {
        this.compiledGlyphs[glyphId] = NOOP;
        if (this.compiledCharCodeToGlyphId[charCode] === undefined) {
          this.compiledCharCodeToGlyphId[charCode] = glyphId;
        }
        throw ex;
      }
    }
    if (this.compiledCharCodeToGlyphId[charCode] === undefined) {
      this.compiledCharCodeToGlyphId[charCode] = glyphId;
    }
    return fn;
  }
  compileGlyph(code, glyphId) {
    if (!code || code.length === 0 || code[0] === 14) {
      return NOOP;
    }
    let fontMatrix = this.fontMatrix;
    if (this.isCFFCIDFont) {
      const fdIndex = this.fdSelect.getFDIndex(glyphId);
      if (fdIndex >= 0 && fdIndex < this.fdArray.length) {
        const fontDict = this.fdArray[fdIndex];
        fontMatrix = fontDict.getByName("FontMatrix") || _util.FONT_IDENTITY_MATRIX;
      } else {
        (0, _util.warn)("Invalid fd index for glyph index.");
      }
    }
    const cmds = [{
      cmd: "save"
    }, {
      cmd: "transform",
      args: fontMatrix.slice()
    }, {
      cmd: "scale",
      args: ["size", "-size"]
    }];
    this.compileGlyphImpl(code, cmds, glyphId);
    cmds.push({
      cmd: "restore"
    });
    return cmds;
  }
  compileGlyphImpl() {
    (0, _util.unreachable)("Children classes should implement this.");
  }
  hasBuiltPath(unicode) {
    const {
      charCode,
      glyphId
    } = lookupCmap(this.cmap, unicode);
    return this.compiledGlyphs[glyphId] !== undefined && this.compiledCharCodeToGlyphId[charCode] !== undefined;
  }
}
class TrueTypeCompiled extends CompiledFont {
  constructor(glyphs, cmap, fontMatrix) {
    super(fontMatrix || [0.000488, 0, 0, 0.000488, 0, 0]);
    this.glyphs = glyphs;
    this.cmap = cmap;
  }
  compileGlyphImpl(code, cmds) {
    compileGlyf(code, cmds, this);
  }
}
class Type2Compiled extends CompiledFont {
  constructor(cffInfo, cmap, fontMatrix, glyphNameMap) {
    super(fontMatrix || [0.001, 0, 0, 0.001, 0, 0]);
    this.glyphs = cffInfo.glyphs;
    this.gsubrs = cffInfo.gsubrs || [];
    this.subrs = cffInfo.subrs || [];
    this.cmap = cmap;
    this.glyphNameMap = glyphNameMap || (0, _glyphlist.getGlyphsUnicode)();
    this.gsubrsBias = getSubroutineBias(this.gsubrs);
    this.subrsBias = getSubroutineBias(this.subrs);
    this.isCFFCIDFont = cffInfo.isCFFCIDFont;
    this.fdSelect = cffInfo.fdSelect;
    this.fdArray = cffInfo.fdArray;
  }
  compileGlyphImpl(code, cmds, glyphId) {
    compileCharString(code, cmds, this, glyphId);
  }
}
class FontRendererFactory {
  static create(font, seacAnalysisEnabled) {
    const data = new Uint8Array(font.data);
    let cmap, glyf, loca, cff, indexToLocFormat, unitsPerEm;
    const numTables = getUint16(data, 4);
    for (let i = 0, p = 12; i < numTables; i++, p += 16) {
      const tag = (0, _util.bytesToString)(data.subarray(p, p + 4));
      const offset = getUint32(data, p + 8);
      const length = getUint32(data, p + 12);
      switch (tag) {
        case "cmap":
          cmap = parseCmap(data, offset, offset + length);
          break;
        case "glyf":
          glyf = data.subarray(offset, offset + length);
          break;
        case "loca":
          loca = data.subarray(offset, offset + length);
          break;
        case "head":
          unitsPerEm = getUint16(data, offset + 18);
          indexToLocFormat = getUint16(data, offset + 50);
          break;
        case "CFF ":
          cff = parseCff(data, offset, offset + length, seacAnalysisEnabled);
          break;
      }
    }
    if (glyf) {
      const fontMatrix = !unitsPerEm ? font.fontMatrix : [1 / unitsPerEm, 0, 0, 1 / unitsPerEm, 0, 0];
      return new TrueTypeCompiled(parseGlyfTable(glyf, loca, indexToLocFormat), cmap, fontMatrix);
    }
    return new Type2Compiled(cff, cmap, font.fontMatrix, font.glyphNameMap);
  }
}
exports.FontRendererFactory = FontRendererFactory;

/***/ }),
/* 45 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getMetrics = exports.getFontBasicMetrics = void 0;
var _core_utils = __w_pdfjs_require__(3);
const getMetrics = (0, _core_utils.getLookupTableFactory)(function (t) {
  t.Courier = 600;
  t["Courier-Bold"] = 600;
  t["Courier-BoldOblique"] = 600;
  t["Courier-Oblique"] = 600;
  t.Helvetica = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 278;
    t.exclam = 278;
    t.quotedbl = 355;
    t.numbersign = 556;
    t.dollar = 556;
    t.percent = 889;
    t.ampersand = 667;
    t.quoteright = 222;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 389;
    t.plus = 584;
    t.comma = 278;
    t.hyphen = 333;
    t.period = 278;
    t.slash = 278;
    t.zero = 556;
    t.one = 556;
    t.two = 556;
    t.three = 556;
    t.four = 556;
    t.five = 556;
    t.six = 556;
    t.seven = 556;
    t.eight = 556;
    t.nine = 556;
    t.colon = 278;
    t.semicolon = 278;
    t.less = 584;
    t.equal = 584;
    t.greater = 584;
    t.question = 556;
    t.at = 1015;
    t.A = 667;
    t.B = 667;
    t.C = 722;
    t.D = 722;
    t.E = 667;
    t.F = 611;
    t.G = 778;
    t.H = 722;
    t.I = 278;
    t.J = 500;
    t.K = 667;
    t.L = 556;
    t.M = 833;
    t.N = 722;
    t.O = 778;
    t.P = 667;
    t.Q = 778;
    t.R = 722;
    t.S = 667;
    t.T = 611;
    t.U = 722;
    t.V = 667;
    t.W = 944;
    t.X = 667;
    t.Y = 667;
    t.Z = 611;
    t.bracketleft = 278;
    t.backslash = 278;
    t.bracketright = 278;
    t.asciicircum = 469;
    t.underscore = 556;
    t.quoteleft = 222;
    t.a = 556;
    t.b = 556;
    t.c = 500;
    t.d = 556;
    t.e = 556;
    t.f = 278;
    t.g = 556;
    t.h = 556;
    t.i = 222;
    t.j = 222;
    t.k = 500;
    t.l = 222;
    t.m = 833;
    t.n = 556;
    t.o = 556;
    t.p = 556;
    t.q = 556;
    t.r = 333;
    t.s = 500;
    t.t = 278;
    t.u = 556;
    t.v = 500;
    t.w = 722;
    t.x = 500;
    t.y = 500;
    t.z = 500;
    t.braceleft = 334;
    t.bar = 260;
    t.braceright = 334;
    t.asciitilde = 584;
    t.exclamdown = 333;
    t.cent = 556;
    t.sterling = 556;
    t.fraction = 167;
    t.yen = 556;
    t.florin = 556;
    t.section = 556;
    t.currency = 556;
    t.quotesingle = 191;
    t.quotedblleft = 333;
    t.guillemotleft = 556;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 500;
    t.fl = 500;
    t.endash = 556;
    t.dagger = 556;
    t.daggerdbl = 556;
    t.periodcentered = 278;
    t.paragraph = 537;
    t.bullet = 350;
    t.quotesinglbase = 222;
    t.quotedblbase = 333;
    t.quotedblright = 333;
    t.guillemotright = 556;
    t.ellipsis = 1000;
    t.perthousand = 1000;
    t.questiondown = 611;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 1000;
    t.AE = 1000;
    t.ordfeminine = 370;
    t.Lslash = 556;
    t.Oslash = 778;
    t.OE = 1000;
    t.ordmasculine = 365;
    t.ae = 889;
    t.dotlessi = 278;
    t.lslash = 222;
    t.oslash = 611;
    t.oe = 944;
    t.germandbls = 611;
    t.Idieresis = 278;
    t.eacute = 556;
    t.abreve = 556;
    t.uhungarumlaut = 556;
    t.ecaron = 556;
    t.Ydieresis = 667;
    t.divide = 584;
    t.Yacute = 667;
    t.Acircumflex = 667;
    t.aacute = 556;
    t.Ucircumflex = 722;
    t.yacute = 500;
    t.scommaaccent = 500;
    t.ecircumflex = 556;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 556;
    t.Uacute = 722;
    t.uogonek = 556;
    t.Edieresis = 667;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 737;
    t.Emacron = 667;
    t.ccaron = 500;
    t.aring = 556;
    t.Ncommaaccent = 722;
    t.lacute = 222;
    t.agrave = 556;
    t.Tcommaaccent = 611;
    t.Cacute = 722;
    t.atilde = 556;
    t.Edotaccent = 667;
    t.scaron = 500;
    t.scedilla = 500;
    t.iacute = 278;
    t.lozenge = 471;
    t.Rcaron = 722;
    t.Gcommaaccent = 778;
    t.ucircumflex = 556;
    t.acircumflex = 556;
    t.Amacron = 667;
    t.rcaron = 333;
    t.ccedilla = 500;
    t.Zdotaccent = 611;
    t.Thorn = 667;
    t.Omacron = 778;
    t.Racute = 722;
    t.Sacute = 667;
    t.dcaron = 643;
    t.Umacron = 722;
    t.uring = 556;
    t.threesuperior = 333;
    t.Ograve = 778;
    t.Agrave = 667;
    t.Abreve = 667;
    t.multiply = 584;
    t.uacute = 556;
    t.Tcaron = 611;
    t.partialdiff = 476;
    t.ydieresis = 500;
    t.Nacute = 722;
    t.icircumflex = 278;
    t.Ecircumflex = 667;
    t.adieresis = 556;
    t.edieresis = 556;
    t.cacute = 500;
    t.nacute = 556;
    t.umacron = 556;
    t.Ncaron = 722;
    t.Iacute = 278;
    t.plusminus = 584;
    t.brokenbar = 260;
    t.registered = 737;
    t.Gbreve = 778;
    t.Idotaccent = 278;
    t.summation = 600;
    t.Egrave = 667;
    t.racute = 333;
    t.omacron = 556;
    t.Zacute = 611;
    t.Zcaron = 611;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 722;
    t.lcommaaccent = 222;
    t.tcaron = 317;
    t.eogonek = 556;
    t.Uogonek = 722;
    t.Aacute = 667;
    t.Adieresis = 667;
    t.egrave = 556;
    t.zacute = 500;
    t.iogonek = 222;
    t.Oacute = 778;
    t.oacute = 556;
    t.amacron = 556;
    t.sacute = 500;
    t.idieresis = 278;
    t.Ocircumflex = 778;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 556;
    t.twosuperior = 333;
    t.Odieresis = 778;
    t.mu = 556;
    t.igrave = 278;
    t.ohungarumlaut = 556;
    t.Eogonek = 667;
    t.dcroat = 556;
    t.threequarters = 834;
    t.Scedilla = 667;
    t.lcaron = 299;
    t.Kcommaaccent = 667;
    t.Lacute = 556;
    t.trademark = 1000;
    t.edotaccent = 556;
    t.Igrave = 278;
    t.Imacron = 278;
    t.Lcaron = 556;
    t.onehalf = 834;
    t.lessequal = 549;
    t.ocircumflex = 556;
    t.ntilde = 556;
    t.Uhungarumlaut = 722;
    t.Eacute = 667;
    t.emacron = 556;
    t.gbreve = 556;
    t.onequarter = 834;
    t.Scaron = 667;
    t.Scommaaccent = 667;
    t.Ohungarumlaut = 778;
    t.degree = 400;
    t.ograve = 556;
    t.Ccaron = 722;
    t.ugrave = 556;
    t.radical = 453;
    t.Dcaron = 722;
    t.rcommaaccent = 333;
    t.Ntilde = 722;
    t.otilde = 556;
    t.Rcommaaccent = 722;
    t.Lcommaaccent = 556;
    t.Atilde = 667;
    t.Aogonek = 667;
    t.Aring = 667;
    t.Otilde = 778;
    t.zdotaccent = 500;
    t.Ecaron = 667;
    t.Iogonek = 278;
    t.kcommaaccent = 500;
    t.minus = 584;
    t.Icircumflex = 278;
    t.ncaron = 556;
    t.tcommaaccent = 278;
    t.logicalnot = 584;
    t.odieresis = 556;
    t.udieresis = 556;
    t.notequal = 549;
    t.gcommaaccent = 556;
    t.eth = 556;
    t.zcaron = 500;
    t.ncommaaccent = 556;
    t.onesuperior = 333;
    t.imacron = 278;
    t.Euro = 556;
  });
  t["Helvetica-Bold"] = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 278;
    t.exclam = 333;
    t.quotedbl = 474;
    t.numbersign = 556;
    t.dollar = 556;
    t.percent = 889;
    t.ampersand = 722;
    t.quoteright = 278;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 389;
    t.plus = 584;
    t.comma = 278;
    t.hyphen = 333;
    t.period = 278;
    t.slash = 278;
    t.zero = 556;
    t.one = 556;
    t.two = 556;
    t.three = 556;
    t.four = 556;
    t.five = 556;
    t.six = 556;
    t.seven = 556;
    t.eight = 556;
    t.nine = 556;
    t.colon = 333;
    t.semicolon = 333;
    t.less = 584;
    t.equal = 584;
    t.greater = 584;
    t.question = 611;
    t.at = 975;
    t.A = 722;
    t.B = 722;
    t.C = 722;
    t.D = 722;
    t.E = 667;
    t.F = 611;
    t.G = 778;
    t.H = 722;
    t.I = 278;
    t.J = 556;
    t.K = 722;
    t.L = 611;
    t.M = 833;
    t.N = 722;
    t.O = 778;
    t.P = 667;
    t.Q = 778;
    t.R = 722;
    t.S = 667;
    t.T = 611;
    t.U = 722;
    t.V = 667;
    t.W = 944;
    t.X = 667;
    t.Y = 667;
    t.Z = 611;
    t.bracketleft = 333;
    t.backslash = 278;
    t.bracketright = 333;
    t.asciicircum = 584;
    t.underscore = 556;
    t.quoteleft = 278;
    t.a = 556;
    t.b = 611;
    t.c = 556;
    t.d = 611;
    t.e = 556;
    t.f = 333;
    t.g = 611;
    t.h = 611;
    t.i = 278;
    t.j = 278;
    t.k = 556;
    t.l = 278;
    t.m = 889;
    t.n = 611;
    t.o = 611;
    t.p = 611;
    t.q = 611;
    t.r = 389;
    t.s = 556;
    t.t = 333;
    t.u = 611;
    t.v = 556;
    t.w = 778;
    t.x = 556;
    t.y = 556;
    t.z = 500;
    t.braceleft = 389;
    t.bar = 280;
    t.braceright = 389;
    t.asciitilde = 584;
    t.exclamdown = 333;
    t.cent = 556;
    t.sterling = 556;
    t.fraction = 167;
    t.yen = 556;
    t.florin = 556;
    t.section = 556;
    t.currency = 556;
    t.quotesingle = 238;
    t.quotedblleft = 500;
    t.guillemotleft = 556;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 611;
    t.fl = 611;
    t.endash = 556;
    t.dagger = 556;
    t.daggerdbl = 556;
    t.periodcentered = 278;
    t.paragraph = 556;
    t.bullet = 350;
    t.quotesinglbase = 278;
    t.quotedblbase = 500;
    t.quotedblright = 500;
    t.guillemotright = 556;
    t.ellipsis = 1000;
    t.perthousand = 1000;
    t.questiondown = 611;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 1000;
    t.AE = 1000;
    t.ordfeminine = 370;
    t.Lslash = 611;
    t.Oslash = 778;
    t.OE = 1000;
    t.ordmasculine = 365;
    t.ae = 889;
    t.dotlessi = 278;
    t.lslash = 278;
    t.oslash = 611;
    t.oe = 944;
    t.germandbls = 611;
    t.Idieresis = 278;
    t.eacute = 556;
    t.abreve = 556;
    t.uhungarumlaut = 611;
    t.ecaron = 556;
    t.Ydieresis = 667;
    t.divide = 584;
    t.Yacute = 667;
    t.Acircumflex = 722;
    t.aacute = 556;
    t.Ucircumflex = 722;
    t.yacute = 556;
    t.scommaaccent = 556;
    t.ecircumflex = 556;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 556;
    t.Uacute = 722;
    t.uogonek = 611;
    t.Edieresis = 667;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 737;
    t.Emacron = 667;
    t.ccaron = 556;
    t.aring = 556;
    t.Ncommaaccent = 722;
    t.lacute = 278;
    t.agrave = 556;
    t.Tcommaaccent = 611;
    t.Cacute = 722;
    t.atilde = 556;
    t.Edotaccent = 667;
    t.scaron = 556;
    t.scedilla = 556;
    t.iacute = 278;
    t.lozenge = 494;
    t.Rcaron = 722;
    t.Gcommaaccent = 778;
    t.ucircumflex = 611;
    t.acircumflex = 556;
    t.Amacron = 722;
    t.rcaron = 389;
    t.ccedilla = 556;
    t.Zdotaccent = 611;
    t.Thorn = 667;
    t.Omacron = 778;
    t.Racute = 722;
    t.Sacute = 667;
    t.dcaron = 743;
    t.Umacron = 722;
    t.uring = 611;
    t.threesuperior = 333;
    t.Ograve = 778;
    t.Agrave = 722;
    t.Abreve = 722;
    t.multiply = 584;
    t.uacute = 611;
    t.Tcaron = 611;
    t.partialdiff = 494;
    t.ydieresis = 556;
    t.Nacute = 722;
    t.icircumflex = 278;
    t.Ecircumflex = 667;
    t.adieresis = 556;
    t.edieresis = 556;
    t.cacute = 556;
    t.nacute = 611;
    t.umacron = 611;
    t.Ncaron = 722;
    t.Iacute = 278;
    t.plusminus = 584;
    t.brokenbar = 280;
    t.registered = 737;
    t.Gbreve = 778;
    t.Idotaccent = 278;
    t.summation = 600;
    t.Egrave = 667;
    t.racute = 389;
    t.omacron = 611;
    t.Zacute = 611;
    t.Zcaron = 611;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 722;
    t.lcommaaccent = 278;
    t.tcaron = 389;
    t.eogonek = 556;
    t.Uogonek = 722;
    t.Aacute = 722;
    t.Adieresis = 722;
    t.egrave = 556;
    t.zacute = 500;
    t.iogonek = 278;
    t.Oacute = 778;
    t.oacute = 611;
    t.amacron = 556;
    t.sacute = 556;
    t.idieresis = 278;
    t.Ocircumflex = 778;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 611;
    t.twosuperior = 333;
    t.Odieresis = 778;
    t.mu = 611;
    t.igrave = 278;
    t.ohungarumlaut = 611;
    t.Eogonek = 667;
    t.dcroat = 611;
    t.threequarters = 834;
    t.Scedilla = 667;
    t.lcaron = 400;
    t.Kcommaaccent = 722;
    t.Lacute = 611;
    t.trademark = 1000;
    t.edotaccent = 556;
    t.Igrave = 278;
    t.Imacron = 278;
    t.Lcaron = 611;
    t.onehalf = 834;
    t.lessequal = 549;
    t.ocircumflex = 611;
    t.ntilde = 611;
    t.Uhungarumlaut = 722;
    t.Eacute = 667;
    t.emacron = 556;
    t.gbreve = 611;
    t.onequarter = 834;
    t.Scaron = 667;
    t.Scommaaccent = 667;
    t.Ohungarumlaut = 778;
    t.degree = 400;
    t.ograve = 611;
    t.Ccaron = 722;
    t.ugrave = 611;
    t.radical = 549;
    t.Dcaron = 722;
    t.rcommaaccent = 389;
    t.Ntilde = 722;
    t.otilde = 611;
    t.Rcommaaccent = 722;
    t.Lcommaaccent = 611;
    t.Atilde = 722;
    t.Aogonek = 722;
    t.Aring = 722;
    t.Otilde = 778;
    t.zdotaccent = 500;
    t.Ecaron = 667;
    t.Iogonek = 278;
    t.kcommaaccent = 556;
    t.minus = 584;
    t.Icircumflex = 278;
    t.ncaron = 611;
    t.tcommaaccent = 333;
    t.logicalnot = 584;
    t.odieresis = 611;
    t.udieresis = 611;
    t.notequal = 549;
    t.gcommaaccent = 611;
    t.eth = 611;
    t.zcaron = 500;
    t.ncommaaccent = 611;
    t.onesuperior = 333;
    t.imacron = 278;
    t.Euro = 556;
  });
  t["Helvetica-BoldOblique"] = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 278;
    t.exclam = 333;
    t.quotedbl = 474;
    t.numbersign = 556;
    t.dollar = 556;
    t.percent = 889;
    t.ampersand = 722;
    t.quoteright = 278;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 389;
    t.plus = 584;
    t.comma = 278;
    t.hyphen = 333;
    t.period = 278;
    t.slash = 278;
    t.zero = 556;
    t.one = 556;
    t.two = 556;
    t.three = 556;
    t.four = 556;
    t.five = 556;
    t.six = 556;
    t.seven = 556;
    t.eight = 556;
    t.nine = 556;
    t.colon = 333;
    t.semicolon = 333;
    t.less = 584;
    t.equal = 584;
    t.greater = 584;
    t.question = 611;
    t.at = 975;
    t.A = 722;
    t.B = 722;
    t.C = 722;
    t.D = 722;
    t.E = 667;
    t.F = 611;
    t.G = 778;
    t.H = 722;
    t.I = 278;
    t.J = 556;
    t.K = 722;
    t.L = 611;
    t.M = 833;
    t.N = 722;
    t.O = 778;
    t.P = 667;
    t.Q = 778;
    t.R = 722;
    t.S = 667;
    t.T = 611;
    t.U = 722;
    t.V = 667;
    t.W = 944;
    t.X = 667;
    t.Y = 667;
    t.Z = 611;
    t.bracketleft = 333;
    t.backslash = 278;
    t.bracketright = 333;
    t.asciicircum = 584;
    t.underscore = 556;
    t.quoteleft = 278;
    t.a = 556;
    t.b = 611;
    t.c = 556;
    t.d = 611;
    t.e = 556;
    t.f = 333;
    t.g = 611;
    t.h = 611;
    t.i = 278;
    t.j = 278;
    t.k = 556;
    t.l = 278;
    t.m = 889;
    t.n = 611;
    t.o = 611;
    t.p = 611;
    t.q = 611;
    t.r = 389;
    t.s = 556;
    t.t = 333;
    t.u = 611;
    t.v = 556;
    t.w = 778;
    t.x = 556;
    t.y = 556;
    t.z = 500;
    t.braceleft = 389;
    t.bar = 280;
    t.braceright = 389;
    t.asciitilde = 584;
    t.exclamdown = 333;
    t.cent = 556;
    t.sterling = 556;
    t.fraction = 167;
    t.yen = 556;
    t.florin = 556;
    t.section = 556;
    t.currency = 556;
    t.quotesingle = 238;
    t.quotedblleft = 500;
    t.guillemotleft = 556;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 611;
    t.fl = 611;
    t.endash = 556;
    t.dagger = 556;
    t.daggerdbl = 556;
    t.periodcentered = 278;
    t.paragraph = 556;
    t.bullet = 350;
    t.quotesinglbase = 278;
    t.quotedblbase = 500;
    t.quotedblright = 500;
    t.guillemotright = 556;
    t.ellipsis = 1000;
    t.perthousand = 1000;
    t.questiondown = 611;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 1000;
    t.AE = 1000;
    t.ordfeminine = 370;
    t.Lslash = 611;
    t.Oslash = 778;
    t.OE = 1000;
    t.ordmasculine = 365;
    t.ae = 889;
    t.dotlessi = 278;
    t.lslash = 278;
    t.oslash = 611;
    t.oe = 944;
    t.germandbls = 611;
    t.Idieresis = 278;
    t.eacute = 556;
    t.abreve = 556;
    t.uhungarumlaut = 611;
    t.ecaron = 556;
    t.Ydieresis = 667;
    t.divide = 584;
    t.Yacute = 667;
    t.Acircumflex = 722;
    t.aacute = 556;
    t.Ucircumflex = 722;
    t.yacute = 556;
    t.scommaaccent = 556;
    t.ecircumflex = 556;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 556;
    t.Uacute = 722;
    t.uogonek = 611;
    t.Edieresis = 667;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 737;
    t.Emacron = 667;
    t.ccaron = 556;
    t.aring = 556;
    t.Ncommaaccent = 722;
    t.lacute = 278;
    t.agrave = 556;
    t.Tcommaaccent = 611;
    t.Cacute = 722;
    t.atilde = 556;
    t.Edotaccent = 667;
    t.scaron = 556;
    t.scedilla = 556;
    t.iacute = 278;
    t.lozenge = 494;
    t.Rcaron = 722;
    t.Gcommaaccent = 778;
    t.ucircumflex = 611;
    t.acircumflex = 556;
    t.Amacron = 722;
    t.rcaron = 389;
    t.ccedilla = 556;
    t.Zdotaccent = 611;
    t.Thorn = 667;
    t.Omacron = 778;
    t.Racute = 722;
    t.Sacute = 667;
    t.dcaron = 743;
    t.Umacron = 722;
    t.uring = 611;
    t.threesuperior = 333;
    t.Ograve = 778;
    t.Agrave = 722;
    t.Abreve = 722;
    t.multiply = 584;
    t.uacute = 611;
    t.Tcaron = 611;
    t.partialdiff = 494;
    t.ydieresis = 556;
    t.Nacute = 722;
    t.icircumflex = 278;
    t.Ecircumflex = 667;
    t.adieresis = 556;
    t.edieresis = 556;
    t.cacute = 556;
    t.nacute = 611;
    t.umacron = 611;
    t.Ncaron = 722;
    t.Iacute = 278;
    t.plusminus = 584;
    t.brokenbar = 280;
    t.registered = 737;
    t.Gbreve = 778;
    t.Idotaccent = 278;
    t.summation = 600;
    t.Egrave = 667;
    t.racute = 389;
    t.omacron = 611;
    t.Zacute = 611;
    t.Zcaron = 611;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 722;
    t.lcommaaccent = 278;
    t.tcaron = 389;
    t.eogonek = 556;
    t.Uogonek = 722;
    t.Aacute = 722;
    t.Adieresis = 722;
    t.egrave = 556;
    t.zacute = 500;
    t.iogonek = 278;
    t.Oacute = 778;
    t.oacute = 611;
    t.amacron = 556;
    t.sacute = 556;
    t.idieresis = 278;
    t.Ocircumflex = 778;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 611;
    t.twosuperior = 333;
    t.Odieresis = 778;
    t.mu = 611;
    t.igrave = 278;
    t.ohungarumlaut = 611;
    t.Eogonek = 667;
    t.dcroat = 611;
    t.threequarters = 834;
    t.Scedilla = 667;
    t.lcaron = 400;
    t.Kcommaaccent = 722;
    t.Lacute = 611;
    t.trademark = 1000;
    t.edotaccent = 556;
    t.Igrave = 278;
    t.Imacron = 278;
    t.Lcaron = 611;
    t.onehalf = 834;
    t.lessequal = 549;
    t.ocircumflex = 611;
    t.ntilde = 611;
    t.Uhungarumlaut = 722;
    t.Eacute = 667;
    t.emacron = 556;
    t.gbreve = 611;
    t.onequarter = 834;
    t.Scaron = 667;
    t.Scommaaccent = 667;
    t.Ohungarumlaut = 778;
    t.degree = 400;
    t.ograve = 611;
    t.Ccaron = 722;
    t.ugrave = 611;
    t.radical = 549;
    t.Dcaron = 722;
    t.rcommaaccent = 389;
    t.Ntilde = 722;
    t.otilde = 611;
    t.Rcommaaccent = 722;
    t.Lcommaaccent = 611;
    t.Atilde = 722;
    t.Aogonek = 722;
    t.Aring = 722;
    t.Otilde = 778;
    t.zdotaccent = 500;
    t.Ecaron = 667;
    t.Iogonek = 278;
    t.kcommaaccent = 556;
    t.minus = 584;
    t.Icircumflex = 278;
    t.ncaron = 611;
    t.tcommaaccent = 333;
    t.logicalnot = 584;
    t.odieresis = 611;
    t.udieresis = 611;
    t.notequal = 549;
    t.gcommaaccent = 611;
    t.eth = 611;
    t.zcaron = 500;
    t.ncommaaccent = 611;
    t.onesuperior = 333;
    t.imacron = 278;
    t.Euro = 556;
  });
  t["Helvetica-Oblique"] = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 278;
    t.exclam = 278;
    t.quotedbl = 355;
    t.numbersign = 556;
    t.dollar = 556;
    t.percent = 889;
    t.ampersand = 667;
    t.quoteright = 222;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 389;
    t.plus = 584;
    t.comma = 278;
    t.hyphen = 333;
    t.period = 278;
    t.slash = 278;
    t.zero = 556;
    t.one = 556;
    t.two = 556;
    t.three = 556;
    t.four = 556;
    t.five = 556;
    t.six = 556;
    t.seven = 556;
    t.eight = 556;
    t.nine = 556;
    t.colon = 278;
    t.semicolon = 278;
    t.less = 584;
    t.equal = 584;
    t.greater = 584;
    t.question = 556;
    t.at = 1015;
    t.A = 667;
    t.B = 667;
    t.C = 722;
    t.D = 722;
    t.E = 667;
    t.F = 611;
    t.G = 778;
    t.H = 722;
    t.I = 278;
    t.J = 500;
    t.K = 667;
    t.L = 556;
    t.M = 833;
    t.N = 722;
    t.O = 778;
    t.P = 667;
    t.Q = 778;
    t.R = 722;
    t.S = 667;
    t.T = 611;
    t.U = 722;
    t.V = 667;
    t.W = 944;
    t.X = 667;
    t.Y = 667;
    t.Z = 611;
    t.bracketleft = 278;
    t.backslash = 278;
    t.bracketright = 278;
    t.asciicircum = 469;
    t.underscore = 556;
    t.quoteleft = 222;
    t.a = 556;
    t.b = 556;
    t.c = 500;
    t.d = 556;
    t.e = 556;
    t.f = 278;
    t.g = 556;
    t.h = 556;
    t.i = 222;
    t.j = 222;
    t.k = 500;
    t.l = 222;
    t.m = 833;
    t.n = 556;
    t.o = 556;
    t.p = 556;
    t.q = 556;
    t.r = 333;
    t.s = 500;
    t.t = 278;
    t.u = 556;
    t.v = 500;
    t.w = 722;
    t.x = 500;
    t.y = 500;
    t.z = 500;
    t.braceleft = 334;
    t.bar = 260;
    t.braceright = 334;
    t.asciitilde = 584;
    t.exclamdown = 333;
    t.cent = 556;
    t.sterling = 556;
    t.fraction = 167;
    t.yen = 556;
    t.florin = 556;
    t.section = 556;
    t.currency = 556;
    t.quotesingle = 191;
    t.quotedblleft = 333;
    t.guillemotleft = 556;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 500;
    t.fl = 500;
    t.endash = 556;
    t.dagger = 556;
    t.daggerdbl = 556;
    t.periodcentered = 278;
    t.paragraph = 537;
    t.bullet = 350;
    t.quotesinglbase = 222;
    t.quotedblbase = 333;
    t.quotedblright = 333;
    t.guillemotright = 556;
    t.ellipsis = 1000;
    t.perthousand = 1000;
    t.questiondown = 611;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 1000;
    t.AE = 1000;
    t.ordfeminine = 370;
    t.Lslash = 556;
    t.Oslash = 778;
    t.OE = 1000;
    t.ordmasculine = 365;
    t.ae = 889;
    t.dotlessi = 278;
    t.lslash = 222;
    t.oslash = 611;
    t.oe = 944;
    t.germandbls = 611;
    t.Idieresis = 278;
    t.eacute = 556;
    t.abreve = 556;
    t.uhungarumlaut = 556;
    t.ecaron = 556;
    t.Ydieresis = 667;
    t.divide = 584;
    t.Yacute = 667;
    t.Acircumflex = 667;
    t.aacute = 556;
    t.Ucircumflex = 722;
    t.yacute = 500;
    t.scommaaccent = 500;
    t.ecircumflex = 556;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 556;
    t.Uacute = 722;
    t.uogonek = 556;
    t.Edieresis = 667;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 737;
    t.Emacron = 667;
    t.ccaron = 500;
    t.aring = 556;
    t.Ncommaaccent = 722;
    t.lacute = 222;
    t.agrave = 556;
    t.Tcommaaccent = 611;
    t.Cacute = 722;
    t.atilde = 556;
    t.Edotaccent = 667;
    t.scaron = 500;
    t.scedilla = 500;
    t.iacute = 278;
    t.lozenge = 471;
    t.Rcaron = 722;
    t.Gcommaaccent = 778;
    t.ucircumflex = 556;
    t.acircumflex = 556;
    t.Amacron = 667;
    t.rcaron = 333;
    t.ccedilla = 500;
    t.Zdotaccent = 611;
    t.Thorn = 667;
    t.Omacron = 778;
    t.Racute = 722;
    t.Sacute = 667;
    t.dcaron = 643;
    t.Umacron = 722;
    t.uring = 556;
    t.threesuperior = 333;
    t.Ograve = 778;
    t.Agrave = 667;
    t.Abreve = 667;
    t.multiply = 584;
    t.uacute = 556;
    t.Tcaron = 611;
    t.partialdiff = 476;
    t.ydieresis = 500;
    t.Nacute = 722;
    t.icircumflex = 278;
    t.Ecircumflex = 667;
    t.adieresis = 556;
    t.edieresis = 556;
    t.cacute = 500;
    t.nacute = 556;
    t.umacron = 556;
    t.Ncaron = 722;
    t.Iacute = 278;
    t.plusminus = 584;
    t.brokenbar = 260;
    t.registered = 737;
    t.Gbreve = 778;
    t.Idotaccent = 278;
    t.summation = 600;
    t.Egrave = 667;
    t.racute = 333;
    t.omacron = 556;
    t.Zacute = 611;
    t.Zcaron = 611;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 722;
    t.lcommaaccent = 222;
    t.tcaron = 317;
    t.eogonek = 556;
    t.Uogonek = 722;
    t.Aacute = 667;
    t.Adieresis = 667;
    t.egrave = 556;
    t.zacute = 500;
    t.iogonek = 222;
    t.Oacute = 778;
    t.oacute = 556;
    t.amacron = 556;
    t.sacute = 500;
    t.idieresis = 278;
    t.Ocircumflex = 778;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 556;
    t.twosuperior = 333;
    t.Odieresis = 778;
    t.mu = 556;
    t.igrave = 278;
    t.ohungarumlaut = 556;
    t.Eogonek = 667;
    t.dcroat = 556;
    t.threequarters = 834;
    t.Scedilla = 667;
    t.lcaron = 299;
    t.Kcommaaccent = 667;
    t.Lacute = 556;
    t.trademark = 1000;
    t.edotaccent = 556;
    t.Igrave = 278;
    t.Imacron = 278;
    t.Lcaron = 556;
    t.onehalf = 834;
    t.lessequal = 549;
    t.ocircumflex = 556;
    t.ntilde = 556;
    t.Uhungarumlaut = 722;
    t.Eacute = 667;
    t.emacron = 556;
    t.gbreve = 556;
    t.onequarter = 834;
    t.Scaron = 667;
    t.Scommaaccent = 667;
    t.Ohungarumlaut = 778;
    t.degree = 400;
    t.ograve = 556;
    t.Ccaron = 722;
    t.ugrave = 556;
    t.radical = 453;
    t.Dcaron = 722;
    t.rcommaaccent = 333;
    t.Ntilde = 722;
    t.otilde = 556;
    t.Rcommaaccent = 722;
    t.Lcommaaccent = 556;
    t.Atilde = 667;
    t.Aogonek = 667;
    t.Aring = 667;
    t.Otilde = 778;
    t.zdotaccent = 500;
    t.Ecaron = 667;
    t.Iogonek = 278;
    t.kcommaaccent = 500;
    t.minus = 584;
    t.Icircumflex = 278;
    t.ncaron = 556;
    t.tcommaaccent = 278;
    t.logicalnot = 584;
    t.odieresis = 556;
    t.udieresis = 556;
    t.notequal = 549;
    t.gcommaaccent = 556;
    t.eth = 556;
    t.zcaron = 500;
    t.ncommaaccent = 556;
    t.onesuperior = 333;
    t.imacron = 278;
    t.Euro = 556;
  });
  t.Symbol = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 250;
    t.exclam = 333;
    t.universal = 713;
    t.numbersign = 500;
    t.existential = 549;
    t.percent = 833;
    t.ampersand = 778;
    t.suchthat = 439;
    t.parenleft = 333;
    t.parenright = 333;
    t.asteriskmath = 500;
    t.plus = 549;
    t.comma = 250;
    t.minus = 549;
    t.period = 250;
    t.slash = 278;
    t.zero = 500;
    t.one = 500;
    t.two = 500;
    t.three = 500;
    t.four = 500;
    t.five = 500;
    t.six = 500;
    t.seven = 500;
    t.eight = 500;
    t.nine = 500;
    t.colon = 278;
    t.semicolon = 278;
    t.less = 549;
    t.equal = 549;
    t.greater = 549;
    t.question = 444;
    t.congruent = 549;
    t.Alpha = 722;
    t.Beta = 667;
    t.Chi = 722;
    t.Delta = 612;
    t.Epsilon = 611;
    t.Phi = 763;
    t.Gamma = 603;
    t.Eta = 722;
    t.Iota = 333;
    t.theta1 = 631;
    t.Kappa = 722;
    t.Lambda = 686;
    t.Mu = 889;
    t.Nu = 722;
    t.Omicron = 722;
    t.Pi = 768;
    t.Theta = 741;
    t.Rho = 556;
    t.Sigma = 592;
    t.Tau = 611;
    t.Upsilon = 690;
    t.sigma1 = 439;
    t.Omega = 768;
    t.Xi = 645;
    t.Psi = 795;
    t.Zeta = 611;
    t.bracketleft = 333;
    t.therefore = 863;
    t.bracketright = 333;
    t.perpendicular = 658;
    t.underscore = 500;
    t.radicalex = 500;
    t.alpha = 631;
    t.beta = 549;
    t.chi = 549;
    t.delta = 494;
    t.epsilon = 439;
    t.phi = 521;
    t.gamma = 411;
    t.eta = 603;
    t.iota = 329;
    t.phi1 = 603;
    t.kappa = 549;
    t.lambda = 549;
    t.mu = 576;
    t.nu = 521;
    t.omicron = 549;
    t.pi = 549;
    t.theta = 521;
    t.rho = 549;
    t.sigma = 603;
    t.tau = 439;
    t.upsilon = 576;
    t.omega1 = 713;
    t.omega = 686;
    t.xi = 493;
    t.psi = 686;
    t.zeta = 494;
    t.braceleft = 480;
    t.bar = 200;
    t.braceright = 480;
    t.similar = 549;
    t.Euro = 750;
    t.Upsilon1 = 620;
    t.minute = 247;
    t.lessequal = 549;
    t.fraction = 167;
    t.infinity = 713;
    t.florin = 500;
    t.club = 753;
    t.diamond = 753;
    t.heart = 753;
    t.spade = 753;
    t.arrowboth = 1042;
    t.arrowleft = 987;
    t.arrowup = 603;
    t.arrowright = 987;
    t.arrowdown = 603;
    t.degree = 400;
    t.plusminus = 549;
    t.second = 411;
    t.greaterequal = 549;
    t.multiply = 549;
    t.proportional = 713;
    t.partialdiff = 494;
    t.bullet = 460;
    t.divide = 549;
    t.notequal = 549;
    t.equivalence = 549;
    t.approxequal = 549;
    t.ellipsis = 1000;
    t.arrowvertex = 603;
    t.arrowhorizex = 1000;
    t.carriagereturn = 658;
    t.aleph = 823;
    t.Ifraktur = 686;
    t.Rfraktur = 795;
    t.weierstrass = 987;
    t.circlemultiply = 768;
    t.circleplus = 768;
    t.emptyset = 823;
    t.intersection = 768;
    t.union = 768;
    t.propersuperset = 713;
    t.reflexsuperset = 713;
    t.notsubset = 713;
    t.propersubset = 713;
    t.reflexsubset = 713;
    t.element = 713;
    t.notelement = 713;
    t.angle = 768;
    t.gradient = 713;
    t.registerserif = 790;
    t.copyrightserif = 790;
    t.trademarkserif = 890;
    t.product = 823;
    t.radical = 549;
    t.dotmath = 250;
    t.logicalnot = 713;
    t.logicaland = 603;
    t.logicalor = 603;
    t.arrowdblboth = 1042;
    t.arrowdblleft = 987;
    t.arrowdblup = 603;
    t.arrowdblright = 987;
    t.arrowdbldown = 603;
    t.lozenge = 494;
    t.angleleft = 329;
    t.registersans = 790;
    t.copyrightsans = 790;
    t.trademarksans = 786;
    t.summation = 713;
    t.parenlefttp = 384;
    t.parenleftex = 384;
    t.parenleftbt = 384;
    t.bracketlefttp = 384;
    t.bracketleftex = 384;
    t.bracketleftbt = 384;
    t.bracelefttp = 494;
    t.braceleftmid = 494;
    t.braceleftbt = 494;
    t.braceex = 494;
    t.angleright = 329;
    t.integral = 274;
    t.integraltp = 686;
    t.integralex = 686;
    t.integralbt = 686;
    t.parenrighttp = 384;
    t.parenrightex = 384;
    t.parenrightbt = 384;
    t.bracketrighttp = 384;
    t.bracketrightex = 384;
    t.bracketrightbt = 384;
    t.bracerighttp = 494;
    t.bracerightmid = 494;
    t.bracerightbt = 494;
    t.apple = 790;
  });
  t["Times-Roman"] = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 250;
    t.exclam = 333;
    t.quotedbl = 408;
    t.numbersign = 500;
    t.dollar = 500;
    t.percent = 833;
    t.ampersand = 778;
    t.quoteright = 333;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 500;
    t.plus = 564;
    t.comma = 250;
    t.hyphen = 333;
    t.period = 250;
    t.slash = 278;
    t.zero = 500;
    t.one = 500;
    t.two = 500;
    t.three = 500;
    t.four = 500;
    t.five = 500;
    t.six = 500;
    t.seven = 500;
    t.eight = 500;
    t.nine = 500;
    t.colon = 278;
    t.semicolon = 278;
    t.less = 564;
    t.equal = 564;
    t.greater = 564;
    t.question = 444;
    t.at = 921;
    t.A = 722;
    t.B = 667;
    t.C = 667;
    t.D = 722;
    t.E = 611;
    t.F = 556;
    t.G = 722;
    t.H = 722;
    t.I = 333;
    t.J = 389;
    t.K = 722;
    t.L = 611;
    t.M = 889;
    t.N = 722;
    t.O = 722;
    t.P = 556;
    t.Q = 722;
    t.R = 667;
    t.S = 556;
    t.T = 611;
    t.U = 722;
    t.V = 722;
    t.W = 944;
    t.X = 722;
    t.Y = 722;
    t.Z = 611;
    t.bracketleft = 333;
    t.backslash = 278;
    t.bracketright = 333;
    t.asciicircum = 469;
    t.underscore = 500;
    t.quoteleft = 333;
    t.a = 444;
    t.b = 500;
    t.c = 444;
    t.d = 500;
    t.e = 444;
    t.f = 333;
    t.g = 500;
    t.h = 500;
    t.i = 278;
    t.j = 278;
    t.k = 500;
    t.l = 278;
    t.m = 778;
    t.n = 500;
    t.o = 500;
    t.p = 500;
    t.q = 500;
    t.r = 333;
    t.s = 389;
    t.t = 278;
    t.u = 500;
    t.v = 500;
    t.w = 722;
    t.x = 500;
    t.y = 500;
    t.z = 444;
    t.braceleft = 480;
    t.bar = 200;
    t.braceright = 480;
    t.asciitilde = 541;
    t.exclamdown = 333;
    t.cent = 500;
    t.sterling = 500;
    t.fraction = 167;
    t.yen = 500;
    t.florin = 500;
    t.section = 500;
    t.currency = 500;
    t.quotesingle = 180;
    t.quotedblleft = 444;
    t.guillemotleft = 500;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 556;
    t.fl = 556;
    t.endash = 500;
    t.dagger = 500;
    t.daggerdbl = 500;
    t.periodcentered = 250;
    t.paragraph = 453;
    t.bullet = 350;
    t.quotesinglbase = 333;
    t.quotedblbase = 444;
    t.quotedblright = 444;
    t.guillemotright = 500;
    t.ellipsis = 1000;
    t.perthousand = 1000;
    t.questiondown = 444;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 1000;
    t.AE = 889;
    t.ordfeminine = 276;
    t.Lslash = 611;
    t.Oslash = 722;
    t.OE = 889;
    t.ordmasculine = 310;
    t.ae = 667;
    t.dotlessi = 278;
    t.lslash = 278;
    t.oslash = 500;
    t.oe = 722;
    t.germandbls = 500;
    t.Idieresis = 333;
    t.eacute = 444;
    t.abreve = 444;
    t.uhungarumlaut = 500;
    t.ecaron = 444;
    t.Ydieresis = 722;
    t.divide = 564;
    t.Yacute = 722;
    t.Acircumflex = 722;
    t.aacute = 444;
    t.Ucircumflex = 722;
    t.yacute = 500;
    t.scommaaccent = 389;
    t.ecircumflex = 444;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 444;
    t.Uacute = 722;
    t.uogonek = 500;
    t.Edieresis = 611;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 760;
    t.Emacron = 611;
    t.ccaron = 444;
    t.aring = 444;
    t.Ncommaaccent = 722;
    t.lacute = 278;
    t.agrave = 444;
    t.Tcommaaccent = 611;
    t.Cacute = 667;
    t.atilde = 444;
    t.Edotaccent = 611;
    t.scaron = 389;
    t.scedilla = 389;
    t.iacute = 278;
    t.lozenge = 471;
    t.Rcaron = 667;
    t.Gcommaaccent = 722;
    t.ucircumflex = 500;
    t.acircumflex = 444;
    t.Amacron = 722;
    t.rcaron = 333;
    t.ccedilla = 444;
    t.Zdotaccent = 611;
    t.Thorn = 556;
    t.Omacron = 722;
    t.Racute = 667;
    t.Sacute = 556;
    t.dcaron = 588;
    t.Umacron = 722;
    t.uring = 500;
    t.threesuperior = 300;
    t.Ograve = 722;
    t.Agrave = 722;
    t.Abreve = 722;
    t.multiply = 564;
    t.uacute = 500;
    t.Tcaron = 611;
    t.partialdiff = 476;
    t.ydieresis = 500;
    t.Nacute = 722;
    t.icircumflex = 278;
    t.Ecircumflex = 611;
    t.adieresis = 444;
    t.edieresis = 444;
    t.cacute = 444;
    t.nacute = 500;
    t.umacron = 500;
    t.Ncaron = 722;
    t.Iacute = 333;
    t.plusminus = 564;
    t.brokenbar = 200;
    t.registered = 760;
    t.Gbreve = 722;
    t.Idotaccent = 333;
    t.summation = 600;
    t.Egrave = 611;
    t.racute = 333;
    t.omacron = 500;
    t.Zacute = 611;
    t.Zcaron = 611;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 667;
    t.lcommaaccent = 278;
    t.tcaron = 326;
    t.eogonek = 444;
    t.Uogonek = 722;
    t.Aacute = 722;
    t.Adieresis = 722;
    t.egrave = 444;
    t.zacute = 444;
    t.iogonek = 278;
    t.Oacute = 722;
    t.oacute = 500;
    t.amacron = 444;
    t.sacute = 389;
    t.idieresis = 278;
    t.Ocircumflex = 722;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 500;
    t.twosuperior = 300;
    t.Odieresis = 722;
    t.mu = 500;
    t.igrave = 278;
    t.ohungarumlaut = 500;
    t.Eogonek = 611;
    t.dcroat = 500;
    t.threequarters = 750;
    t.Scedilla = 556;
    t.lcaron = 344;
    t.Kcommaaccent = 722;
    t.Lacute = 611;
    t.trademark = 980;
    t.edotaccent = 444;
    t.Igrave = 333;
    t.Imacron = 333;
    t.Lcaron = 611;
    t.onehalf = 750;
    t.lessequal = 549;
    t.ocircumflex = 500;
    t.ntilde = 500;
    t.Uhungarumlaut = 722;
    t.Eacute = 611;
    t.emacron = 444;
    t.gbreve = 500;
    t.onequarter = 750;
    t.Scaron = 556;
    t.Scommaaccent = 556;
    t.Ohungarumlaut = 722;
    t.degree = 400;
    t.ograve = 500;
    t.Ccaron = 667;
    t.ugrave = 500;
    t.radical = 453;
    t.Dcaron = 722;
    t.rcommaaccent = 333;
    t.Ntilde = 722;
    t.otilde = 500;
    t.Rcommaaccent = 667;
    t.Lcommaaccent = 611;
    t.Atilde = 722;
    t.Aogonek = 722;
    t.Aring = 722;
    t.Otilde = 722;
    t.zdotaccent = 444;
    t.Ecaron = 611;
    t.Iogonek = 333;
    t.kcommaaccent = 500;
    t.minus = 564;
    t.Icircumflex = 333;
    t.ncaron = 500;
    t.tcommaaccent = 278;
    t.logicalnot = 564;
    t.odieresis = 500;
    t.udieresis = 500;
    t.notequal = 549;
    t.gcommaaccent = 500;
    t.eth = 500;
    t.zcaron = 444;
    t.ncommaaccent = 500;
    t.onesuperior = 300;
    t.imacron = 278;
    t.Euro = 500;
  });
  t["Times-Bold"] = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 250;
    t.exclam = 333;
    t.quotedbl = 555;
    t.numbersign = 500;
    t.dollar = 500;
    t.percent = 1000;
    t.ampersand = 833;
    t.quoteright = 333;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 500;
    t.plus = 570;
    t.comma = 250;
    t.hyphen = 333;
    t.period = 250;
    t.slash = 278;
    t.zero = 500;
    t.one = 500;
    t.two = 500;
    t.three = 500;
    t.four = 500;
    t.five = 500;
    t.six = 500;
    t.seven = 500;
    t.eight = 500;
    t.nine = 500;
    t.colon = 333;
    t.semicolon = 333;
    t.less = 570;
    t.equal = 570;
    t.greater = 570;
    t.question = 500;
    t.at = 930;
    t.A = 722;
    t.B = 667;
    t.C = 722;
    t.D = 722;
    t.E = 667;
    t.F = 611;
    t.G = 778;
    t.H = 778;
    t.I = 389;
    t.J = 500;
    t.K = 778;
    t.L = 667;
    t.M = 944;
    t.N = 722;
    t.O = 778;
    t.P = 611;
    t.Q = 778;
    t.R = 722;
    t.S = 556;
    t.T = 667;
    t.U = 722;
    t.V = 722;
    t.W = 1000;
    t.X = 722;
    t.Y = 722;
    t.Z = 667;
    t.bracketleft = 333;
    t.backslash = 278;
    t.bracketright = 333;
    t.asciicircum = 581;
    t.underscore = 500;
    t.quoteleft = 333;
    t.a = 500;
    t.b = 556;
    t.c = 444;
    t.d = 556;
    t.e = 444;
    t.f = 333;
    t.g = 500;
    t.h = 556;
    t.i = 278;
    t.j = 333;
    t.k = 556;
    t.l = 278;
    t.m = 833;
    t.n = 556;
    t.o = 500;
    t.p = 556;
    t.q = 556;
    t.r = 444;
    t.s = 389;
    t.t = 333;
    t.u = 556;
    t.v = 500;
    t.w = 722;
    t.x = 500;
    t.y = 500;
    t.z = 444;
    t.braceleft = 394;
    t.bar = 220;
    t.braceright = 394;
    t.asciitilde = 520;
    t.exclamdown = 333;
    t.cent = 500;
    t.sterling = 500;
    t.fraction = 167;
    t.yen = 500;
    t.florin = 500;
    t.section = 500;
    t.currency = 500;
    t.quotesingle = 278;
    t.quotedblleft = 500;
    t.guillemotleft = 500;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 556;
    t.fl = 556;
    t.endash = 500;
    t.dagger = 500;
    t.daggerdbl = 500;
    t.periodcentered = 250;
    t.paragraph = 540;
    t.bullet = 350;
    t.quotesinglbase = 333;
    t.quotedblbase = 500;
    t.quotedblright = 500;
    t.guillemotright = 500;
    t.ellipsis = 1000;
    t.perthousand = 1000;
    t.questiondown = 500;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 1000;
    t.AE = 1000;
    t.ordfeminine = 300;
    t.Lslash = 667;
    t.Oslash = 778;
    t.OE = 1000;
    t.ordmasculine = 330;
    t.ae = 722;
    t.dotlessi = 278;
    t.lslash = 278;
    t.oslash = 500;
    t.oe = 722;
    t.germandbls = 556;
    t.Idieresis = 389;
    t.eacute = 444;
    t.abreve = 500;
    t.uhungarumlaut = 556;
    t.ecaron = 444;
    t.Ydieresis = 722;
    t.divide = 570;
    t.Yacute = 722;
    t.Acircumflex = 722;
    t.aacute = 500;
    t.Ucircumflex = 722;
    t.yacute = 500;
    t.scommaaccent = 389;
    t.ecircumflex = 444;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 500;
    t.Uacute = 722;
    t.uogonek = 556;
    t.Edieresis = 667;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 747;
    t.Emacron = 667;
    t.ccaron = 444;
    t.aring = 500;
    t.Ncommaaccent = 722;
    t.lacute = 278;
    t.agrave = 500;
    t.Tcommaaccent = 667;
    t.Cacute = 722;
    t.atilde = 500;
    t.Edotaccent = 667;
    t.scaron = 389;
    t.scedilla = 389;
    t.iacute = 278;
    t.lozenge = 494;
    t.Rcaron = 722;
    t.Gcommaaccent = 778;
    t.ucircumflex = 556;
    t.acircumflex = 500;
    t.Amacron = 722;
    t.rcaron = 444;
    t.ccedilla = 444;
    t.Zdotaccent = 667;
    t.Thorn = 611;
    t.Omacron = 778;
    t.Racute = 722;
    t.Sacute = 556;
    t.dcaron = 672;
    t.Umacron = 722;
    t.uring = 556;
    t.threesuperior = 300;
    t.Ograve = 778;
    t.Agrave = 722;
    t.Abreve = 722;
    t.multiply = 570;
    t.uacute = 556;
    t.Tcaron = 667;
    t.partialdiff = 494;
    t.ydieresis = 500;
    t.Nacute = 722;
    t.icircumflex = 278;
    t.Ecircumflex = 667;
    t.adieresis = 500;
    t.edieresis = 444;
    t.cacute = 444;
    t.nacute = 556;
    t.umacron = 556;
    t.Ncaron = 722;
    t.Iacute = 389;
    t.plusminus = 570;
    t.brokenbar = 220;
    t.registered = 747;
    t.Gbreve = 778;
    t.Idotaccent = 389;
    t.summation = 600;
    t.Egrave = 667;
    t.racute = 444;
    t.omacron = 500;
    t.Zacute = 667;
    t.Zcaron = 667;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 722;
    t.lcommaaccent = 278;
    t.tcaron = 416;
    t.eogonek = 444;
    t.Uogonek = 722;
    t.Aacute = 722;
    t.Adieresis = 722;
    t.egrave = 444;
    t.zacute = 444;
    t.iogonek = 278;
    t.Oacute = 778;
    t.oacute = 500;
    t.amacron = 500;
    t.sacute = 389;
    t.idieresis = 278;
    t.Ocircumflex = 778;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 556;
    t.twosuperior = 300;
    t.Odieresis = 778;
    t.mu = 556;
    t.igrave = 278;
    t.ohungarumlaut = 500;
    t.Eogonek = 667;
    t.dcroat = 556;
    t.threequarters = 750;
    t.Scedilla = 556;
    t.lcaron = 394;
    t.Kcommaaccent = 778;
    t.Lacute = 667;
    t.trademark = 1000;
    t.edotaccent = 444;
    t.Igrave = 389;
    t.Imacron = 389;
    t.Lcaron = 667;
    t.onehalf = 750;
    t.lessequal = 549;
    t.ocircumflex = 500;
    t.ntilde = 556;
    t.Uhungarumlaut = 722;
    t.Eacute = 667;
    t.emacron = 444;
    t.gbreve = 500;
    t.onequarter = 750;
    t.Scaron = 556;
    t.Scommaaccent = 556;
    t.Ohungarumlaut = 778;
    t.degree = 400;
    t.ograve = 500;
    t.Ccaron = 722;
    t.ugrave = 556;
    t.radical = 549;
    t.Dcaron = 722;
    t.rcommaaccent = 444;
    t.Ntilde = 722;
    t.otilde = 500;
    t.Rcommaaccent = 722;
    t.Lcommaaccent = 667;
    t.Atilde = 722;
    t.Aogonek = 722;
    t.Aring = 722;
    t.Otilde = 778;
    t.zdotaccent = 444;
    t.Ecaron = 667;
    t.Iogonek = 389;
    t.kcommaaccent = 556;
    t.minus = 570;
    t.Icircumflex = 389;
    t.ncaron = 556;
    t.tcommaaccent = 333;
    t.logicalnot = 570;
    t.odieresis = 500;
    t.udieresis = 556;
    t.notequal = 549;
    t.gcommaaccent = 500;
    t.eth = 500;
    t.zcaron = 444;
    t.ncommaaccent = 556;
    t.onesuperior = 300;
    t.imacron = 278;
    t.Euro = 500;
  });
  t["Times-BoldItalic"] = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 250;
    t.exclam = 389;
    t.quotedbl = 555;
    t.numbersign = 500;
    t.dollar = 500;
    t.percent = 833;
    t.ampersand = 778;
    t.quoteright = 333;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 500;
    t.plus = 570;
    t.comma = 250;
    t.hyphen = 333;
    t.period = 250;
    t.slash = 278;
    t.zero = 500;
    t.one = 500;
    t.two = 500;
    t.three = 500;
    t.four = 500;
    t.five = 500;
    t.six = 500;
    t.seven = 500;
    t.eight = 500;
    t.nine = 500;
    t.colon = 333;
    t.semicolon = 333;
    t.less = 570;
    t.equal = 570;
    t.greater = 570;
    t.question = 500;
    t.at = 832;
    t.A = 667;
    t.B = 667;
    t.C = 667;
    t.D = 722;
    t.E = 667;
    t.F = 667;
    t.G = 722;
    t.H = 778;
    t.I = 389;
    t.J = 500;
    t.K = 667;
    t.L = 611;
    t.M = 889;
    t.N = 722;
    t.O = 722;
    t.P = 611;
    t.Q = 722;
    t.R = 667;
    t.S = 556;
    t.T = 611;
    t.U = 722;
    t.V = 667;
    t.W = 889;
    t.X = 667;
    t.Y = 611;
    t.Z = 611;
    t.bracketleft = 333;
    t.backslash = 278;
    t.bracketright = 333;
    t.asciicircum = 570;
    t.underscore = 500;
    t.quoteleft = 333;
    t.a = 500;
    t.b = 500;
    t.c = 444;
    t.d = 500;
    t.e = 444;
    t.f = 333;
    t.g = 500;
    t.h = 556;
    t.i = 278;
    t.j = 278;
    t.k = 500;
    t.l = 278;
    t.m = 778;
    t.n = 556;
    t.o = 500;
    t.p = 500;
    t.q = 500;
    t.r = 389;
    t.s = 389;
    t.t = 278;
    t.u = 556;
    t.v = 444;
    t.w = 667;
    t.x = 500;
    t.y = 444;
    t.z = 389;
    t.braceleft = 348;
    t.bar = 220;
    t.braceright = 348;
    t.asciitilde = 570;
    t.exclamdown = 389;
    t.cent = 500;
    t.sterling = 500;
    t.fraction = 167;
    t.yen = 500;
    t.florin = 500;
    t.section = 500;
    t.currency = 500;
    t.quotesingle = 278;
    t.quotedblleft = 500;
    t.guillemotleft = 500;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 556;
    t.fl = 556;
    t.endash = 500;
    t.dagger = 500;
    t.daggerdbl = 500;
    t.periodcentered = 250;
    t.paragraph = 500;
    t.bullet = 350;
    t.quotesinglbase = 333;
    t.quotedblbase = 500;
    t.quotedblright = 500;
    t.guillemotright = 500;
    t.ellipsis = 1000;
    t.perthousand = 1000;
    t.questiondown = 500;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 1000;
    t.AE = 944;
    t.ordfeminine = 266;
    t.Lslash = 611;
    t.Oslash = 722;
    t.OE = 944;
    t.ordmasculine = 300;
    t.ae = 722;
    t.dotlessi = 278;
    t.lslash = 278;
    t.oslash = 500;
    t.oe = 722;
    t.germandbls = 500;
    t.Idieresis = 389;
    t.eacute = 444;
    t.abreve = 500;
    t.uhungarumlaut = 556;
    t.ecaron = 444;
    t.Ydieresis = 611;
    t.divide = 570;
    t.Yacute = 611;
    t.Acircumflex = 667;
    t.aacute = 500;
    t.Ucircumflex = 722;
    t.yacute = 444;
    t.scommaaccent = 389;
    t.ecircumflex = 444;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 500;
    t.Uacute = 722;
    t.uogonek = 556;
    t.Edieresis = 667;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 747;
    t.Emacron = 667;
    t.ccaron = 444;
    t.aring = 500;
    t.Ncommaaccent = 722;
    t.lacute = 278;
    t.agrave = 500;
    t.Tcommaaccent = 611;
    t.Cacute = 667;
    t.atilde = 500;
    t.Edotaccent = 667;
    t.scaron = 389;
    t.scedilla = 389;
    t.iacute = 278;
    t.lozenge = 494;
    t.Rcaron = 667;
    t.Gcommaaccent = 722;
    t.ucircumflex = 556;
    t.acircumflex = 500;
    t.Amacron = 667;
    t.rcaron = 389;
    t.ccedilla = 444;
    t.Zdotaccent = 611;
    t.Thorn = 611;
    t.Omacron = 722;
    t.Racute = 667;
    t.Sacute = 556;
    t.dcaron = 608;
    t.Umacron = 722;
    t.uring = 556;
    t.threesuperior = 300;
    t.Ograve = 722;
    t.Agrave = 667;
    t.Abreve = 667;
    t.multiply = 570;
    t.uacute = 556;
    t.Tcaron = 611;
    t.partialdiff = 494;
    t.ydieresis = 444;
    t.Nacute = 722;
    t.icircumflex = 278;
    t.Ecircumflex = 667;
    t.adieresis = 500;
    t.edieresis = 444;
    t.cacute = 444;
    t.nacute = 556;
    t.umacron = 556;
    t.Ncaron = 722;
    t.Iacute = 389;
    t.plusminus = 570;
    t.brokenbar = 220;
    t.registered = 747;
    t.Gbreve = 722;
    t.Idotaccent = 389;
    t.summation = 600;
    t.Egrave = 667;
    t.racute = 389;
    t.omacron = 500;
    t.Zacute = 611;
    t.Zcaron = 611;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 667;
    t.lcommaaccent = 278;
    t.tcaron = 366;
    t.eogonek = 444;
    t.Uogonek = 722;
    t.Aacute = 667;
    t.Adieresis = 667;
    t.egrave = 444;
    t.zacute = 389;
    t.iogonek = 278;
    t.Oacute = 722;
    t.oacute = 500;
    t.amacron = 500;
    t.sacute = 389;
    t.idieresis = 278;
    t.Ocircumflex = 722;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 500;
    t.twosuperior = 300;
    t.Odieresis = 722;
    t.mu = 576;
    t.igrave = 278;
    t.ohungarumlaut = 500;
    t.Eogonek = 667;
    t.dcroat = 500;
    t.threequarters = 750;
    t.Scedilla = 556;
    t.lcaron = 382;
    t.Kcommaaccent = 667;
    t.Lacute = 611;
    t.trademark = 1000;
    t.edotaccent = 444;
    t.Igrave = 389;
    t.Imacron = 389;
    t.Lcaron = 611;
    t.onehalf = 750;
    t.lessequal = 549;
    t.ocircumflex = 500;
    t.ntilde = 556;
    t.Uhungarumlaut = 722;
    t.Eacute = 667;
    t.emacron = 444;
    t.gbreve = 500;
    t.onequarter = 750;
    t.Scaron = 556;
    t.Scommaaccent = 556;
    t.Ohungarumlaut = 722;
    t.degree = 400;
    t.ograve = 500;
    t.Ccaron = 667;
    t.ugrave = 556;
    t.radical = 549;
    t.Dcaron = 722;
    t.rcommaaccent = 389;
    t.Ntilde = 722;
    t.otilde = 500;
    t.Rcommaaccent = 667;
    t.Lcommaaccent = 611;
    t.Atilde = 667;
    t.Aogonek = 667;
    t.Aring = 667;
    t.Otilde = 722;
    t.zdotaccent = 389;
    t.Ecaron = 667;
    t.Iogonek = 389;
    t.kcommaaccent = 500;
    t.minus = 606;
    t.Icircumflex = 389;
    t.ncaron = 556;
    t.tcommaaccent = 278;
    t.logicalnot = 606;
    t.odieresis = 500;
    t.udieresis = 556;
    t.notequal = 549;
    t.gcommaaccent = 500;
    t.eth = 500;
    t.zcaron = 389;
    t.ncommaaccent = 556;
    t.onesuperior = 300;
    t.imacron = 278;
    t.Euro = 500;
  });
  t["Times-Italic"] = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 250;
    t.exclam = 333;
    t.quotedbl = 420;
    t.numbersign = 500;
    t.dollar = 500;
    t.percent = 833;
    t.ampersand = 778;
    t.quoteright = 333;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 500;
    t.plus = 675;
    t.comma = 250;
    t.hyphen = 333;
    t.period = 250;
    t.slash = 278;
    t.zero = 500;
    t.one = 500;
    t.two = 500;
    t.three = 500;
    t.four = 500;
    t.five = 500;
    t.six = 500;
    t.seven = 500;
    t.eight = 500;
    t.nine = 500;
    t.colon = 333;
    t.semicolon = 333;
    t.less = 675;
    t.equal = 675;
    t.greater = 675;
    t.question = 500;
    t.at = 920;
    t.A = 611;
    t.B = 611;
    t.C = 667;
    t.D = 722;
    t.E = 611;
    t.F = 611;
    t.G = 722;
    t.H = 722;
    t.I = 333;
    t.J = 444;
    t.K = 667;
    t.L = 556;
    t.M = 833;
    t.N = 667;
    t.O = 722;
    t.P = 611;
    t.Q = 722;
    t.R = 611;
    t.S = 500;
    t.T = 556;
    t.U = 722;
    t.V = 611;
    t.W = 833;
    t.X = 611;
    t.Y = 556;
    t.Z = 556;
    t.bracketleft = 389;
    t.backslash = 278;
    t.bracketright = 389;
    t.asciicircum = 422;
    t.underscore = 500;
    t.quoteleft = 333;
    t.a = 500;
    t.b = 500;
    t.c = 444;
    t.d = 500;
    t.e = 444;
    t.f = 278;
    t.g = 500;
    t.h = 500;
    t.i = 278;
    t.j = 278;
    t.k = 444;
    t.l = 278;
    t.m = 722;
    t.n = 500;
    t.o = 500;
    t.p = 500;
    t.q = 500;
    t.r = 389;
    t.s = 389;
    t.t = 278;
    t.u = 500;
    t.v = 444;
    t.w = 667;
    t.x = 444;
    t.y = 444;
    t.z = 389;
    t.braceleft = 400;
    t.bar = 275;
    t.braceright = 400;
    t.asciitilde = 541;
    t.exclamdown = 389;
    t.cent = 500;
    t.sterling = 500;
    t.fraction = 167;
    t.yen = 500;
    t.florin = 500;
    t.section = 500;
    t.currency = 500;
    t.quotesingle = 214;
    t.quotedblleft = 556;
    t.guillemotleft = 500;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 500;
    t.fl = 500;
    t.endash = 500;
    t.dagger = 500;
    t.daggerdbl = 500;
    t.periodcentered = 250;
    t.paragraph = 523;
    t.bullet = 350;
    t.quotesinglbase = 333;
    t.quotedblbase = 556;
    t.quotedblright = 556;
    t.guillemotright = 500;
    t.ellipsis = 889;
    t.perthousand = 1000;
    t.questiondown = 500;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 889;
    t.AE = 889;
    t.ordfeminine = 276;
    t.Lslash = 556;
    t.Oslash = 722;
    t.OE = 944;
    t.ordmasculine = 310;
    t.ae = 667;
    t.dotlessi = 278;
    t.lslash = 278;
    t.oslash = 500;
    t.oe = 667;
    t.germandbls = 500;
    t.Idieresis = 333;
    t.eacute = 444;
    t.abreve = 500;
    t.uhungarumlaut = 500;
    t.ecaron = 444;
    t.Ydieresis = 556;
    t.divide = 675;
    t.Yacute = 556;
    t.Acircumflex = 611;
    t.aacute = 500;
    t.Ucircumflex = 722;
    t.yacute = 444;
    t.scommaaccent = 389;
    t.ecircumflex = 444;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 500;
    t.Uacute = 722;
    t.uogonek = 500;
    t.Edieresis = 611;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 760;
    t.Emacron = 611;
    t.ccaron = 444;
    t.aring = 500;
    t.Ncommaaccent = 667;
    t.lacute = 278;
    t.agrave = 500;
    t.Tcommaaccent = 556;
    t.Cacute = 667;
    t.atilde = 500;
    t.Edotaccent = 611;
    t.scaron = 389;
    t.scedilla = 389;
    t.iacute = 278;
    t.lozenge = 471;
    t.Rcaron = 611;
    t.Gcommaaccent = 722;
    t.ucircumflex = 500;
    t.acircumflex = 500;
    t.Amacron = 611;
    t.rcaron = 389;
    t.ccedilla = 444;
    t.Zdotaccent = 556;
    t.Thorn = 611;
    t.Omacron = 722;
    t.Racute = 611;
    t.Sacute = 500;
    t.dcaron = 544;
    t.Umacron = 722;
    t.uring = 500;
    t.threesuperior = 300;
    t.Ograve = 722;
    t.Agrave = 611;
    t.Abreve = 611;
    t.multiply = 675;
    t.uacute = 500;
    t.Tcaron = 556;
    t.partialdiff = 476;
    t.ydieresis = 444;
    t.Nacute = 667;
    t.icircumflex = 278;
    t.Ecircumflex = 611;
    t.adieresis = 500;
    t.edieresis = 444;
    t.cacute = 444;
    t.nacute = 500;
    t.umacron = 500;
    t.Ncaron = 667;
    t.Iacute = 333;
    t.plusminus = 675;
    t.brokenbar = 275;
    t.registered = 760;
    t.Gbreve = 722;
    t.Idotaccent = 333;
    t.summation = 600;
    t.Egrave = 611;
    t.racute = 389;
    t.omacron = 500;
    t.Zacute = 556;
    t.Zcaron = 556;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 667;
    t.lcommaaccent = 278;
    t.tcaron = 300;
    t.eogonek = 444;
    t.Uogonek = 722;
    t.Aacute = 611;
    t.Adieresis = 611;
    t.egrave = 444;
    t.zacute = 389;
    t.iogonek = 278;
    t.Oacute = 722;
    t.oacute = 500;
    t.amacron = 500;
    t.sacute = 389;
    t.idieresis = 278;
    t.Ocircumflex = 722;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 500;
    t.twosuperior = 300;
    t.Odieresis = 722;
    t.mu = 500;
    t.igrave = 278;
    t.ohungarumlaut = 500;
    t.Eogonek = 611;
    t.dcroat = 500;
    t.threequarters = 750;
    t.Scedilla = 500;
    t.lcaron = 300;
    t.Kcommaaccent = 667;
    t.Lacute = 556;
    t.trademark = 980;
    t.edotaccent = 444;
    t.Igrave = 333;
    t.Imacron = 333;
    t.Lcaron = 611;
    t.onehalf = 750;
    t.lessequal = 549;
    t.ocircumflex = 500;
    t.ntilde = 500;
    t.Uhungarumlaut = 722;
    t.Eacute = 611;
    t.emacron = 444;
    t.gbreve = 500;
    t.onequarter = 750;
    t.Scaron = 500;
    t.Scommaaccent = 500;
    t.Ohungarumlaut = 722;
    t.degree = 400;
    t.ograve = 500;
    t.Ccaron = 667;
    t.ugrave = 500;
    t.radical = 453;
    t.Dcaron = 722;
    t.rcommaaccent = 389;
    t.Ntilde = 667;
    t.otilde = 500;
    t.Rcommaaccent = 611;
    t.Lcommaaccent = 556;
    t.Atilde = 611;
    t.Aogonek = 611;
    t.Aring = 611;
    t.Otilde = 722;
    t.zdotaccent = 389;
    t.Ecaron = 611;
    t.Iogonek = 333;
    t.kcommaaccent = 444;
    t.minus = 675;
    t.Icircumflex = 333;
    t.ncaron = 500;
    t.tcommaaccent = 278;
    t.logicalnot = 675;
    t.odieresis = 500;
    t.udieresis = 500;
    t.notequal = 549;
    t.gcommaaccent = 500;
    t.eth = 500;
    t.zcaron = 389;
    t.ncommaaccent = 500;
    t.onesuperior = 300;
    t.imacron = 278;
    t.Euro = 500;
  });
  t.ZapfDingbats = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 278;
    t.a1 = 974;
    t.a2 = 961;
    t.a202 = 974;
    t.a3 = 980;
    t.a4 = 719;
    t.a5 = 789;
    t.a119 = 790;
    t.a118 = 791;
    t.a117 = 690;
    t.a11 = 960;
    t.a12 = 939;
    t.a13 = 549;
    t.a14 = 855;
    t.a15 = 911;
    t.a16 = 933;
    t.a105 = 911;
    t.a17 = 945;
    t.a18 = 974;
    t.a19 = 755;
    t.a20 = 846;
    t.a21 = 762;
    t.a22 = 761;
    t.a23 = 571;
    t.a24 = 677;
    t.a25 = 763;
    t.a26 = 760;
    t.a27 = 759;
    t.a28 = 754;
    t.a6 = 494;
    t.a7 = 552;
    t.a8 = 537;
    t.a9 = 577;
    t.a10 = 692;
    t.a29 = 786;
    t.a30 = 788;
    t.a31 = 788;
    t.a32 = 790;
    t.a33 = 793;
    t.a34 = 794;
    t.a35 = 816;
    t.a36 = 823;
    t.a37 = 789;
    t.a38 = 841;
    t.a39 = 823;
    t.a40 = 833;
    t.a41 = 816;
    t.a42 = 831;
    t.a43 = 923;
    t.a44 = 744;
    t.a45 = 723;
    t.a46 = 749;
    t.a47 = 790;
    t.a48 = 792;
    t.a49 = 695;
    t.a50 = 776;
    t.a51 = 768;
    t.a52 = 792;
    t.a53 = 759;
    t.a54 = 707;
    t.a55 = 708;
    t.a56 = 682;
    t.a57 = 701;
    t.a58 = 826;
    t.a59 = 815;
    t.a60 = 789;
    t.a61 = 789;
    t.a62 = 707;
    t.a63 = 687;
    t.a64 = 696;
    t.a65 = 689;
    t.a66 = 786;
    t.a67 = 787;
    t.a68 = 713;
    t.a69 = 791;
    t.a70 = 785;
    t.a71 = 791;
    t.a72 = 873;
    t.a73 = 761;
    t.a74 = 762;
    t.a203 = 762;
    t.a75 = 759;
    t.a204 = 759;
    t.a76 = 892;
    t.a77 = 892;
    t.a78 = 788;
    t.a79 = 784;
    t.a81 = 438;
    t.a82 = 138;
    t.a83 = 277;
    t.a84 = 415;
    t.a97 = 392;
    t.a98 = 392;
    t.a99 = 668;
    t.a100 = 668;
    t.a89 = 390;
    t.a90 = 390;
    t.a93 = 317;
    t.a94 = 317;
    t.a91 = 276;
    t.a92 = 276;
    t.a205 = 509;
    t.a85 = 509;
    t.a206 = 410;
    t.a86 = 410;
    t.a87 = 234;
    t.a88 = 234;
    t.a95 = 334;
    t.a96 = 334;
    t.a101 = 732;
    t.a102 = 544;
    t.a103 = 544;
    t.a104 = 910;
    t.a106 = 667;
    t.a107 = 760;
    t.a108 = 760;
    t.a112 = 776;
    t.a111 = 595;
    t.a110 = 694;
    t.a109 = 626;
    t.a120 = 788;
    t.a121 = 788;
    t.a122 = 788;
    t.a123 = 788;
    t.a124 = 788;
    t.a125 = 788;
    t.a126 = 788;
    t.a127 = 788;
    t.a128 = 788;
    t.a129 = 788;
    t.a130 = 788;
    t.a131 = 788;
    t.a132 = 788;
    t.a133 = 788;
    t.a134 = 788;
    t.a135 = 788;
    t.a136 = 788;
    t.a137 = 788;
    t.a138 = 788;
    t.a139 = 788;
    t.a140 = 788;
    t.a141 = 788;
    t.a142 = 788;
    t.a143 = 788;
    t.a144 = 788;
    t.a145 = 788;
    t.a146 = 788;
    t.a147 = 788;
    t.a148 = 788;
    t.a149 = 788;
    t.a150 = 788;
    t.a151 = 788;
    t.a152 = 788;
    t.a153 = 788;
    t.a154 = 788;
    t.a155 = 788;
    t.a156 = 788;
    t.a157 = 788;
    t.a158 = 788;
    t.a159 = 788;
    t.a160 = 894;
    t.a161 = 838;
    t.a163 = 1016;
    t.a164 = 458;
    t.a196 = 748;
    t.a165 = 924;
    t.a192 = 748;
    t.a166 = 918;
    t.a167 = 927;
    t.a168 = 928;
    t.a169 = 928;
    t.a170 = 834;
    t.a171 = 873;
    t.a172 = 828;
    t.a173 = 924;
    t.a162 = 924;
    t.a174 = 917;
    t.a175 = 930;
    t.a176 = 931;
    t.a177 = 463;
    t.a178 = 883;
    t.a179 = 836;
    t.a193 = 836;
    t.a180 = 867;
    t.a199 = 867;
    t.a181 = 696;
    t.a200 = 696;
    t.a182 = 874;
    t.a201 = 874;
    t.a183 = 760;
    t.a184 = 946;
    t.a197 = 771;
    t.a185 = 865;
    t.a194 = 771;
    t.a198 = 888;
    t.a186 = 967;
    t.a195 = 888;
    t.a187 = 831;
    t.a188 = 873;
    t.a189 = 927;
    t.a190 = 970;
    t.a191 = 918;
  });
});
exports.getMetrics = getMetrics;
const getFontBasicMetrics = (0, _core_utils.getLookupTableFactory)(function (t) {
  t.Courier = {
    ascent: 629,
    descent: -157,
    capHeight: 562,
    xHeight: -426
  };
  t["Courier-Bold"] = {
    ascent: 629,
    descent: -157,
    capHeight: 562,
    xHeight: 439
  };
  t["Courier-Oblique"] = {
    ascent: 629,
    descent: -157,
    capHeight: 562,
    xHeight: 426
  };
  t["Courier-BoldOblique"] = {
    ascent: 629,
    descent: -157,
    capHeight: 562,
    xHeight: 426
  };
  t.Helvetica = {
    ascent: 718,
    descent: -207,
    capHeight: 718,
    xHeight: 523
  };
  t["Helvetica-Bold"] = {
    ascent: 718,
    descent: -207,
    capHeight: 718,
    xHeight: 532
  };
  t["Helvetica-Oblique"] = {
    ascent: 718,
    descent: -207,
    capHeight: 718,
    xHeight: 523
  };
  t["Helvetica-BoldOblique"] = {
    ascent: 718,
    descent: -207,
    capHeight: 718,
    xHeight: 532
  };
  t["Times-Roman"] = {
    ascent: 683,
    descent: -217,
    capHeight: 662,
    xHeight: 450
  };
  t["Times-Bold"] = {
    ascent: 683,
    descent: -217,
    capHeight: 676,
    xHeight: 461
  };
  t["Times-Italic"] = {
    ascent: 683,
    descent: -217,
    capHeight: 653,
    xHeight: 441
  };
  t["Times-BoldItalic"] = {
    ascent: 683,
    descent: -217,
    capHeight: 669,
    xHeight: 462
  };
  t.Symbol = {
    ascent: Math.NaN,
    descent: Math.NaN,
    capHeight: Math.NaN,
    xHeight: Math.NaN
  };
  t.ZapfDingbats = {
    ascent: Math.NaN,
    descent: Math.NaN,
    capHeight: Math.NaN,
    xHeight: Math.NaN
  };
});
exports.getFontBasicMetrics = getFontBasicMetrics;

/***/ }),
/* 46 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.GlyfTable = void 0;
const ON_CURVE_POINT = 1 << 0;
const X_SHORT_VECTOR = 1 << 1;
const Y_SHORT_VECTOR = 1 << 2;
const REPEAT_FLAG = 1 << 3;
const X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR = 1 << 4;
const Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR = 1 << 5;
const OVERLAP_SIMPLE = 1 << 6;
const ARG_1_AND_2_ARE_WORDS = 1 << 0;
const ARGS_ARE_XY_VALUES = 1 << 1;
const WE_HAVE_A_SCALE = 1 << 3;
const MORE_COMPONENTS = 1 << 5;
const WE_HAVE_AN_X_AND_Y_SCALE = 1 << 6;
const WE_HAVE_A_TWO_BY_TWO = 1 << 7;
const WE_HAVE_INSTRUCTIONS = 1 << 8;
class GlyfTable {
  constructor({
    glyfTable,
    isGlyphLocationsLong,
    locaTable,
    numGlyphs
  }) {
    this.glyphs = [];
    const loca = new DataView(locaTable.buffer, locaTable.byteOffset, locaTable.byteLength);
    const glyf = new DataView(glyfTable.buffer, glyfTable.byteOffset, glyfTable.byteLength);
    const offsetSize = isGlyphLocationsLong ? 4 : 2;
    let prev = isGlyphLocationsLong ? loca.getUint32(0) : 2 * loca.getUint16(0);
    let pos = 0;
    for (let i = 0; i < numGlyphs; i++) {
      pos += offsetSize;
      const next = isGlyphLocationsLong ? loca.getUint32(pos) : 2 * loca.getUint16(pos);
      if (next === prev) {
        this.glyphs.push(new Glyph({}));
        continue;
      }
      const glyph = Glyph.parse(prev, glyf);
      this.glyphs.push(glyph);
      prev = next;
    }
  }
  getSize() {
    return this.glyphs.reduce((a, g) => {
      const size = g.getSize();
      return a + (size + 3 & ~3);
    }, 0);
  }
  write() {
    const totalSize = this.getSize();
    const glyfTable = new DataView(new ArrayBuffer(totalSize));
    const isLocationLong = totalSize > 0x1fffe;
    const offsetSize = isLocationLong ? 4 : 2;
    const locaTable = new DataView(new ArrayBuffer((this.glyphs.length + 1) * offsetSize));
    if (isLocationLong) {
      locaTable.setUint32(0, 0);
    } else {
      locaTable.setUint16(0, 0);
    }
    let pos = 0;
    let locaIndex = 0;
    for (const glyph of this.glyphs) {
      pos += glyph.write(pos, glyfTable);
      pos = pos + 3 & ~3;
      locaIndex += offsetSize;
      if (isLocationLong) {
        locaTable.setUint32(locaIndex, pos);
      } else {
        locaTable.setUint16(locaIndex, pos >> 1);
      }
    }
    return {
      isLocationLong,
      loca: new Uint8Array(locaTable.buffer),
      glyf: new Uint8Array(glyfTable.buffer)
    };
  }
  scale(factors) {
    for (let i = 0, ii = this.glyphs.length; i < ii; i++) {
      this.glyphs[i].scale(factors[i]);
    }
  }
}
exports.GlyfTable = GlyfTable;
class Glyph {
  constructor({
    header = null,
    simple = null,
    composites = null
  }) {
    this.header = header;
    this.simple = simple;
    this.composites = composites;
  }
  static parse(pos, glyf) {
    const [read, header] = GlyphHeader.parse(pos, glyf);
    pos += read;
    if (header.numberOfContours < 0) {
      const composites = [];
      while (true) {
        const [n, composite] = CompositeGlyph.parse(pos, glyf);
        pos += n;
        composites.push(composite);
        if (!(composite.flags & MORE_COMPONENTS)) {
          break;
        }
      }
      return new Glyph({
        header,
        composites
      });
    }
    const simple = SimpleGlyph.parse(pos, glyf, header.numberOfContours);
    return new Glyph({
      header,
      simple
    });
  }
  getSize() {
    if (!this.header) {
      return 0;
    }
    const size = this.simple ? this.simple.getSize() : this.composites.reduce((a, c) => a + c.getSize(), 0);
    return this.header.getSize() + size;
  }
  write(pos, buf) {
    if (!this.header) {
      return 0;
    }
    const spos = pos;
    pos += this.header.write(pos, buf);
    if (this.simple) {
      pos += this.simple.write(pos, buf);
    } else {
      for (const composite of this.composites) {
        pos += composite.write(pos, buf);
      }
    }
    return pos - spos;
  }
  scale(factor) {
    if (!this.header) {
      return;
    }
    const xMiddle = (this.header.xMin + this.header.xMax) / 2;
    this.header.scale(xMiddle, factor);
    if (this.simple) {
      this.simple.scale(xMiddle, factor);
    } else {
      for (const composite of this.composites) {
        composite.scale(xMiddle, factor);
      }
    }
  }
}
class GlyphHeader {
  constructor({
    numberOfContours,
    xMin,
    yMin,
    xMax,
    yMax
  }) {
    this.numberOfContours = numberOfContours;
    this.xMin = xMin;
    this.yMin = yMin;
    this.xMax = xMax;
    this.yMax = yMax;
  }
  static parse(pos, glyf) {
    return [10, new GlyphHeader({
      numberOfContours: glyf.getInt16(pos),
      xMin: glyf.getInt16(pos + 2),
      yMin: glyf.getInt16(pos + 4),
      xMax: glyf.getInt16(pos + 6),
      yMax: glyf.getInt16(pos + 8)
    })];
  }
  getSize() {
    return 10;
  }
  write(pos, buf) {
    buf.setInt16(pos, this.numberOfContours);
    buf.setInt16(pos + 2, this.xMin);
    buf.setInt16(pos + 4, this.yMin);
    buf.setInt16(pos + 6, this.xMax);
    buf.setInt16(pos + 8, this.yMax);
    return 10;
  }
  scale(x, factor) {
    this.xMin = Math.round(x + (this.xMin - x) * factor);
    this.xMax = Math.round(x + (this.xMax - x) * factor);
  }
}
class Contour {
  constructor({
    flags,
    xCoordinates,
    yCoordinates
  }) {
    this.xCoordinates = xCoordinates;
    this.yCoordinates = yCoordinates;
    this.flags = flags;
  }
}
class SimpleGlyph {
  constructor({
    contours,
    instructions
  }) {
    this.contours = contours;
    this.instructions = instructions;
  }
  static parse(pos, glyf, numberOfContours) {
    const endPtsOfContours = [];
    for (let i = 0; i < numberOfContours; i++) {
      const endPt = glyf.getUint16(pos);
      pos += 2;
      endPtsOfContours.push(endPt);
    }
    const numberOfPt = endPtsOfContours[numberOfContours - 1] + 1;
    const instructionLength = glyf.getUint16(pos);
    pos += 2;
    const instructions = new Uint8Array(glyf).slice(pos, pos + instructionLength);
    pos += instructionLength;
    const flags = [];
    for (let i = 0; i < numberOfPt; pos++, i++) {
      let flag = glyf.getUint8(pos);
      flags.push(flag);
      if (flag & REPEAT_FLAG) {
        const count = glyf.getUint8(++pos);
        flag ^= REPEAT_FLAG;
        for (let m = 0; m < count; m++) {
          flags.push(flag);
        }
        i += count;
      }
    }
    const allXCoordinates = [];
    let xCoordinates = [];
    let yCoordinates = [];
    let pointFlags = [];
    const contours = [];
    let endPtsOfContoursIndex = 0;
    let lastCoordinate = 0;
    for (let i = 0; i < numberOfPt; i++) {
      const flag = flags[i];
      if (flag & X_SHORT_VECTOR) {
        const x = glyf.getUint8(pos++);
        lastCoordinate += flag & X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR ? x : -x;
        xCoordinates.push(lastCoordinate);
      } else if (flag & X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR) {
        xCoordinates.push(lastCoordinate);
      } else {
        lastCoordinate += glyf.getInt16(pos);
        pos += 2;
        xCoordinates.push(lastCoordinate);
      }
      if (endPtsOfContours[endPtsOfContoursIndex] === i) {
        endPtsOfContoursIndex++;
        allXCoordinates.push(xCoordinates);
        xCoordinates = [];
      }
    }
    lastCoordinate = 0;
    endPtsOfContoursIndex = 0;
    for (let i = 0; i < numberOfPt; i++) {
      const flag = flags[i];
      if (flag & Y_SHORT_VECTOR) {
        const y = glyf.getUint8(pos++);
        lastCoordinate += flag & Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR ? y : -y;
        yCoordinates.push(lastCoordinate);
      } else if (flag & Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR) {
        yCoordinates.push(lastCoordinate);
      } else {
        lastCoordinate += glyf.getInt16(pos);
        pos += 2;
        yCoordinates.push(lastCoordinate);
      }
      pointFlags.push(flag & ON_CURVE_POINT | flag & OVERLAP_SIMPLE);
      if (endPtsOfContours[endPtsOfContoursIndex] === i) {
        xCoordinates = allXCoordinates[endPtsOfContoursIndex];
        endPtsOfContoursIndex++;
        contours.push(new Contour({
          flags: pointFlags,
          xCoordinates,
          yCoordinates
        }));
        yCoordinates = [];
        pointFlags = [];
      }
    }
    return new SimpleGlyph({
      contours,
      instructions
    });
  }
  getSize() {
    let size = this.contours.length * 2 + 2 + this.instructions.length;
    let lastX = 0;
    let lastY = 0;
    for (const contour of this.contours) {
      size += contour.flags.length;
      for (let i = 0, ii = contour.xCoordinates.length; i < ii; i++) {
        const x = contour.xCoordinates[i];
        const y = contour.yCoordinates[i];
        let abs = Math.abs(x - lastX);
        if (abs > 255) {
          size += 2;
        } else if (abs > 0) {
          size += 1;
        }
        lastX = x;
        abs = Math.abs(y - lastY);
        if (abs > 255) {
          size += 2;
        } else if (abs > 0) {
          size += 1;
        }
        lastY = y;
      }
    }
    return size;
  }
  write(pos, buf) {
    const spos = pos;
    const xCoordinates = [];
    const yCoordinates = [];
    const flags = [];
    let lastX = 0;
    let lastY = 0;
    for (const contour of this.contours) {
      for (let i = 0, ii = contour.xCoordinates.length; i < ii; i++) {
        let flag = contour.flags[i];
        const x = contour.xCoordinates[i];
        let delta = x - lastX;
        if (delta === 0) {
          flag |= X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR;
          xCoordinates.push(0);
        } else {
          const abs = Math.abs(delta);
          if (abs <= 255) {
            flag |= delta >= 0 ? X_SHORT_VECTOR | X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR : X_SHORT_VECTOR;
            xCoordinates.push(abs);
          } else {
            xCoordinates.push(delta);
          }
        }
        lastX = x;
        const y = contour.yCoordinates[i];
        delta = y - lastY;
        if (delta === 0) {
          flag |= Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR;
          yCoordinates.push(0);
        } else {
          const abs = Math.abs(delta);
          if (abs <= 255) {
            flag |= delta >= 0 ? Y_SHORT_VECTOR | Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR : Y_SHORT_VECTOR;
            yCoordinates.push(abs);
          } else {
            yCoordinates.push(delta);
          }
        }
        lastY = y;
        flags.push(flag);
      }
      buf.setUint16(pos, xCoordinates.length - 1);
      pos += 2;
    }
    buf.setUint16(pos, this.instructions.length);
    pos += 2;
    if (this.instructions.length) {
      new Uint8Array(buf.buffer, 0, buf.buffer.byteLength).set(this.instructions, pos);
      pos += this.instructions.length;
    }
    for (const flag of flags) {
      buf.setUint8(pos++, flag);
    }
    for (let i = 0, ii = xCoordinates.length; i < ii; i++) {
      const x = xCoordinates[i];
      const flag = flags[i];
      if (flag & X_SHORT_VECTOR) {
        buf.setUint8(pos++, x);
      } else if (!(flag & X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR)) {
        buf.setInt16(pos, x);
        pos += 2;
      }
    }
    for (let i = 0, ii = yCoordinates.length; i < ii; i++) {
      const y = yCoordinates[i];
      const flag = flags[i];
      if (flag & Y_SHORT_VECTOR) {
        buf.setUint8(pos++, y);
      } else if (!(flag & Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR)) {
        buf.setInt16(pos, y);
        pos += 2;
      }
    }
    return pos - spos;
  }
  scale(x, factor) {
    for (const contour of this.contours) {
      if (contour.xCoordinates.length === 0) {
        continue;
      }
      for (let i = 0, ii = contour.xCoordinates.length; i < ii; i++) {
        contour.xCoordinates[i] = Math.round(x + (contour.xCoordinates[i] - x) * factor);
      }
    }
  }
}
class CompositeGlyph {
  constructor({
    flags,
    glyphIndex,
    argument1,
    argument2,
    transf,
    instructions
  }) {
    this.flags = flags;
    this.glyphIndex = glyphIndex;
    this.argument1 = argument1;
    this.argument2 = argument2;
    this.transf = transf;
    this.instructions = instructions;
  }
  static parse(pos, glyf) {
    const spos = pos;
    const transf = [];
    let flags = glyf.getUint16(pos);
    const glyphIndex = glyf.getUint16(pos + 2);
    pos += 4;
    let argument1, argument2;
    if (flags & ARG_1_AND_2_ARE_WORDS) {
      if (flags & ARGS_ARE_XY_VALUES) {
        argument1 = glyf.getInt16(pos);
        argument2 = glyf.getInt16(pos + 2);
      } else {
        argument1 = glyf.getUint16(pos);
        argument2 = glyf.getUint16(pos + 2);
      }
      pos += 4;
      flags ^= ARG_1_AND_2_ARE_WORDS;
    } else {
      if (flags & ARGS_ARE_XY_VALUES) {
        argument1 = glyf.getInt8(pos);
        argument2 = glyf.getInt8(pos + 1);
      } else {
        argument1 = glyf.getUint8(pos);
        argument2 = glyf.getUint8(pos + 1);
      }
      pos += 2;
    }
    if (flags & WE_HAVE_A_SCALE) {
      transf.push(glyf.getUint16(pos));
      pos += 2;
    } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {
      transf.push(glyf.getUint16(pos), glyf.getUint16(pos + 2));
      pos += 4;
    } else if (flags & WE_HAVE_A_TWO_BY_TWO) {
      transf.push(glyf.getUint16(pos), glyf.getUint16(pos + 2), glyf.getUint16(pos + 4), glyf.getUint16(pos + 6));
      pos += 8;
    }
    let instructions = null;
    if (flags & WE_HAVE_INSTRUCTIONS) {
      const instructionLength = glyf.getUint16(pos);
      pos += 2;
      instructions = new Uint8Array(glyf).slice(pos, pos + instructionLength);
      pos += instructionLength;
    }
    return [pos - spos, new CompositeGlyph({
      flags,
      glyphIndex,
      argument1,
      argument2,
      transf,
      instructions
    })];
  }
  getSize() {
    let size = 2 + 2 + this.transf.length * 2;
    if (this.flags & WE_HAVE_INSTRUCTIONS) {
      size += 2 + this.instructions.length;
    }
    size += 2;
    if (this.flags & 2) {
      if (!(this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127)) {
        size += 2;
      }
    } else if (!(this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255)) {
      size += 2;
    }
    return size;
  }
  write(pos, buf) {
    const spos = pos;
    if (this.flags & ARGS_ARE_XY_VALUES) {
      if (!(this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127)) {
        this.flags |= ARG_1_AND_2_ARE_WORDS;
      }
    } else if (!(this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255)) {
      this.flags |= ARG_1_AND_2_ARE_WORDS;
    }
    buf.setUint16(pos, this.flags);
    buf.setUint16(pos + 2, this.glyphIndex);
    pos += 4;
    if (this.flags & ARG_1_AND_2_ARE_WORDS) {
      if (this.flags & ARGS_ARE_XY_VALUES) {
        buf.setInt16(pos, this.argument1);
        buf.setInt16(pos + 2, this.argument2);
      } else {
        buf.setUint16(pos, this.argument1);
        buf.setUint16(pos + 2, this.argument2);
      }
      pos += 4;
    } else {
      buf.setUint8(pos, this.argument1);
      buf.setUint8(pos + 1, this.argument2);
      pos += 2;
    }
    if (this.flags & WE_HAVE_INSTRUCTIONS) {
      buf.setUint16(pos, this.instructions.length);
      pos += 2;
      if (this.instructions.length) {
        new Uint8Array(buf.buffer, 0, buf.buffer.byteLength).set(this.instructions, pos);
        pos += this.instructions.length;
      }
    }
    return pos - spos;
  }
  scale(x, factor) {}
}

/***/ }),
/* 47 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.OpenTypeFileBuilder = void 0;
var _core_utils = __w_pdfjs_require__(3);
var _util = __w_pdfjs_require__(2);
function writeInt16(dest, offset, num) {
  dest[offset] = num >> 8 & 0xff;
  dest[offset + 1] = num & 0xff;
}
function writeInt32(dest, offset, num) {
  dest[offset] = num >> 24 & 0xff;
  dest[offset + 1] = num >> 16 & 0xff;
  dest[offset + 2] = num >> 8 & 0xff;
  dest[offset + 3] = num & 0xff;
}
function writeData(dest, offset, data) {
  if (data instanceof Uint8Array) {
    dest.set(data, offset);
  } else if (typeof data === "string") {
    for (let i = 0, ii = data.length; i < ii; i++) {
      dest[offset++] = data.charCodeAt(i) & 0xff;
    }
  } else {
    for (const num of data) {
      dest[offset++] = num & 0xff;
    }
  }
}
const OTF_HEADER_SIZE = 12;
const OTF_TABLE_ENTRY_SIZE = 16;
class OpenTypeFileBuilder {
  constructor(sfnt) {
    this.sfnt = sfnt;
    this.tables = Object.create(null);
  }
  static getSearchParams(entriesCount, entrySize) {
    let maxPower2 = 1,
      log2 = 0;
    while ((maxPower2 ^ entriesCount) > maxPower2) {
      maxPower2 <<= 1;
      log2++;
    }
    const searchRange = maxPower2 * entrySize;
    return {
      range: searchRange,
      entry: log2,
      rangeShift: entrySize * entriesCount - searchRange
    };
  }
  toArray() {
    let sfnt = this.sfnt;
    const tables = this.tables;
    const tablesNames = Object.keys(tables);
    tablesNames.sort();
    const numTables = tablesNames.length;
    let i, j, jj, table, tableName;
    let offset = OTF_HEADER_SIZE + numTables * OTF_TABLE_ENTRY_SIZE;
    const tableOffsets = [offset];
    for (i = 0; i < numTables; i++) {
      table = tables[tablesNames[i]];
      const paddedLength = (table.length + 3 & ~3) >>> 0;
      offset += paddedLength;
      tableOffsets.push(offset);
    }
    const file = new Uint8Array(offset);
    for (i = 0; i < numTables; i++) {
      table = tables[tablesNames[i]];
      writeData(file, tableOffsets[i], table);
    }
    if (sfnt === "true") {
      sfnt = (0, _util.string32)(0x00010000);
    }
    file[0] = sfnt.charCodeAt(0) & 0xff;
    file[1] = sfnt.charCodeAt(1) & 0xff;
    file[2] = sfnt.charCodeAt(2) & 0xff;
    file[3] = sfnt.charCodeAt(3) & 0xff;
    writeInt16(file, 4, numTables);
    const searchParams = OpenTypeFileBuilder.getSearchParams(numTables, 16);
    writeInt16(file, 6, searchParams.range);
    writeInt16(file, 8, searchParams.entry);
    writeInt16(file, 10, searchParams.rangeShift);
    offset = OTF_HEADER_SIZE;
    for (i = 0; i < numTables; i++) {
      tableName = tablesNames[i];
      file[offset] = tableName.charCodeAt(0) & 0xff;
      file[offset + 1] = tableName.charCodeAt(1) & 0xff;
      file[offset + 2] = tableName.charCodeAt(2) & 0xff;
      file[offset + 3] = tableName.charCodeAt(3) & 0xff;
      let checksum = 0;
      for (j = tableOffsets[i], jj = tableOffsets[i + 1]; j < jj; j += 4) {
        const quad = (0, _core_utils.readUint32)(file, j);
        checksum = checksum + quad >>> 0;
      }
      writeInt32(file, offset + 4, checksum);
      writeInt32(file, offset + 8, tableOffsets[i]);
      writeInt32(file, offset + 12, tables[tableName].length);
      offset += OTF_TABLE_ENTRY_SIZE;
    }
    return file;
  }
  addTable(tag, data) {
    if (tag in this.tables) {
      throw new Error("Table " + tag + " already exists");
    }
    this.tables[tag] = data;
  }
}
exports.OpenTypeFileBuilder = OpenTypeFileBuilder;

/***/ }),
/* 48 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Type1Font = void 0;
var _cff_parser = __w_pdfjs_require__(35);
var _util = __w_pdfjs_require__(2);
var _fonts_utils = __w_pdfjs_require__(38);
var _core_utils = __w_pdfjs_require__(3);
var _stream = __w_pdfjs_require__(8);
var _type1_parser = __w_pdfjs_require__(49);
function findBlock(streamBytes, signature, startIndex) {
  const streamBytesLength = streamBytes.length;
  const signatureLength = signature.length;
  const scanLength = streamBytesLength - signatureLength;
  let i = startIndex,
    found = false;
  while (i < scanLength) {
    let j = 0;
    while (j < signatureLength && streamBytes[i + j] === signature[j]) {
      j++;
    }
    if (j >= signatureLength) {
      i += j;
      while (i < streamBytesLength && (0, _core_utils.isWhiteSpace)(streamBytes[i])) {
        i++;
      }
      found = true;
      break;
    }
    i++;
  }
  return {
    found,
    length: i
  };
}
function getHeaderBlock(stream, suggestedLength) {
  const EEXEC_SIGNATURE = [0x65, 0x65, 0x78, 0x65, 0x63];
  const streamStartPos = stream.pos;
  let headerBytes, headerBytesLength, block;
  try {
    headerBytes = stream.getBytes(suggestedLength);
    headerBytesLength = headerBytes.length;
  } catch {}
  if (headerBytesLength === suggestedLength) {
    block = findBlock(headerBytes, EEXEC_SIGNATURE, suggestedLength - 2 * EEXEC_SIGNATURE.length);
    if (block.found && block.length === suggestedLength) {
      return {
        stream: new _stream.Stream(headerBytes),
        length: suggestedLength
      };
    }
  }
  (0, _util.warn)('Invalid "Length1" property in Type1 font -- trying to recover.');
  stream.pos = streamStartPos;
  const SCAN_BLOCK_LENGTH = 2048;
  let actualLength;
  while (true) {
    const scanBytes = stream.peekBytes(SCAN_BLOCK_LENGTH);
    block = findBlock(scanBytes, EEXEC_SIGNATURE, 0);
    if (block.length === 0) {
      break;
    }
    stream.pos += block.length;
    if (block.found) {
      actualLength = stream.pos - streamStartPos;
      break;
    }
  }
  stream.pos = streamStartPos;
  if (actualLength) {
    return {
      stream: new _stream.Stream(stream.getBytes(actualLength)),
      length: actualLength
    };
  }
  (0, _util.warn)('Unable to recover "Length1" property in Type1 font -- using as is.');
  return {
    stream: new _stream.Stream(stream.getBytes(suggestedLength)),
    length: suggestedLength
  };
}
function getEexecBlock(stream, suggestedLength) {
  const eexecBytes = stream.getBytes();
  if (eexecBytes.length === 0) {
    throw new _util.FormatError("getEexecBlock - no font program found.");
  }
  return {
    stream: new _stream.Stream(eexecBytes),
    length: eexecBytes.length
  };
}
class Type1Font {
  constructor(name, file, properties) {
    const PFB_HEADER_SIZE = 6;
    let headerBlockLength = properties.length1;
    let eexecBlockLength = properties.length2;
    let pfbHeader = file.peekBytes(PFB_HEADER_SIZE);
    const pfbHeaderPresent = pfbHeader[0] === 0x80 && pfbHeader[1] === 0x01;
    if (pfbHeaderPresent) {
      file.skip(PFB_HEADER_SIZE);
      headerBlockLength = pfbHeader[5] << 24 | pfbHeader[4] << 16 | pfbHeader[3] << 8 | pfbHeader[2];
    }
    const headerBlock = getHeaderBlock(file, headerBlockLength);
    const headerBlockParser = new _type1_parser.Type1Parser(headerBlock.stream, false, _fonts_utils.SEAC_ANALYSIS_ENABLED);
    headerBlockParser.extractFontHeader(properties);
    if (pfbHeaderPresent) {
      pfbHeader = file.getBytes(PFB_HEADER_SIZE);
      eexecBlockLength = pfbHeader[5] << 24 | pfbHeader[4] << 16 | pfbHeader[3] << 8 | pfbHeader[2];
    }
    const eexecBlock = getEexecBlock(file, eexecBlockLength);
    const eexecBlockParser = new _type1_parser.Type1Parser(eexecBlock.stream, true, _fonts_utils.SEAC_ANALYSIS_ENABLED);
    const data = eexecBlockParser.extractFontProgram(properties);
    for (const key in data.properties) {
      properties[key] = data.properties[key];
    }
    const charstrings = data.charstrings;
    const type2Charstrings = this.getType2Charstrings(charstrings);
    const subrs = this.getType2Subrs(data.subrs);
    this.charstrings = charstrings;
    this.data = this.wrap(name, type2Charstrings, this.charstrings, subrs, properties);
    this.seacs = this.getSeacs(data.charstrings);
  }
  get numGlyphs() {
    return this.charstrings.length + 1;
  }
  getCharset() {
    const charset = [".notdef"];
    for (const {
      glyphName
    } of this.charstrings) {
      charset.push(glyphName);
    }
    return charset;
  }
  getGlyphMapping(properties) {
    const charstrings = this.charstrings;
    if (properties.composite) {
      const charCodeToGlyphId = Object.create(null);
      for (let glyphId = 0, charstringsLen = charstrings.length; glyphId < charstringsLen; glyphId++) {
        const charCode = properties.cMap.charCodeOf(glyphId);
        charCodeToGlyphId[charCode] = glyphId + 1;
      }
      return charCodeToGlyphId;
    }
    const glyphNames = [".notdef"];
    let builtInEncoding, glyphId;
    for (glyphId = 0; glyphId < charstrings.length; glyphId++) {
      glyphNames.push(charstrings[glyphId].glyphName);
    }
    const encoding = properties.builtInEncoding;
    if (encoding) {
      builtInEncoding = Object.create(null);
      for (const charCode in encoding) {
        glyphId = glyphNames.indexOf(encoding[charCode]);
        if (glyphId >= 0) {
          builtInEncoding[charCode] = glyphId;
        }
      }
    }
    return (0, _fonts_utils.type1FontGlyphMapping)(properties, builtInEncoding, glyphNames);
  }
  hasGlyphId(id) {
    if (id < 0 || id >= this.numGlyphs) {
      return false;
    }
    if (id === 0) {
      return true;
    }
    const glyph = this.charstrings[id - 1];
    return glyph.charstring.length > 0;
  }
  getSeacs(charstrings) {
    const seacMap = [];
    for (let i = 0, ii = charstrings.length; i < ii; i++) {
      const charstring = charstrings[i];
      if (charstring.seac) {
        seacMap[i + 1] = charstring.seac;
      }
    }
    return seacMap;
  }
  getType2Charstrings(type1Charstrings) {
    const type2Charstrings = [];
    for (const type1Charstring of type1Charstrings) {
      type2Charstrings.push(type1Charstring.charstring);
    }
    return type2Charstrings;
  }
  getType2Subrs(type1Subrs) {
    let bias = 0;
    const count = type1Subrs.length;
    if (count < 1133) {
      bias = 107;
    } else if (count < 33769) {
      bias = 1131;
    } else {
      bias = 32768;
    }
    const type2Subrs = [];
    let i;
    for (i = 0; i < bias; i++) {
      type2Subrs.push([0x0b]);
    }
    for (i = 0; i < count; i++) {
      type2Subrs.push(type1Subrs[i]);
    }
    return type2Subrs;
  }
  wrap(name, glyphs, charstrings, subrs, properties) {
    const cff = new _cff_parser.CFF();
    cff.header = new _cff_parser.CFFHeader(1, 0, 4, 4);
    cff.names = [name];
    const topDict = new _cff_parser.CFFTopDict();
    topDict.setByName("version", 391);
    topDict.setByName("Notice", 392);
    topDict.setByName("FullName", 393);
    topDict.setByName("FamilyName", 394);
    topDict.setByName("Weight", 395);
    topDict.setByName("Encoding", null);
    topDict.setByName("FontMatrix", properties.fontMatrix);
    topDict.setByName("FontBBox", properties.bbox);
    topDict.setByName("charset", null);
    topDict.setByName("CharStrings", null);
    topDict.setByName("Private", null);
    cff.topDict = topDict;
    const strings = new _cff_parser.CFFStrings();
    strings.add("Version 0.11");
    strings.add("See original notice");
    strings.add(name);
    strings.add(name);
    strings.add("Medium");
    cff.strings = strings;
    cff.globalSubrIndex = new _cff_parser.CFFIndex();
    const count = glyphs.length;
    const charsetArray = [".notdef"];
    let i, ii;
    for (i = 0; i < count; i++) {
      const glyphName = charstrings[i].glyphName;
      const index = _cff_parser.CFFStandardStrings.indexOf(glyphName);
      if (index === -1) {
        strings.add(glyphName);
      }
      charsetArray.push(glyphName);
    }
    cff.charset = new _cff_parser.CFFCharset(false, 0, charsetArray);
    const charStringsIndex = new _cff_parser.CFFIndex();
    charStringsIndex.add([0x8b, 0x0e]);
    for (i = 0; i < count; i++) {
      charStringsIndex.add(glyphs[i]);
    }
    cff.charStrings = charStringsIndex;
    const privateDict = new _cff_parser.CFFPrivateDict();
    privateDict.setByName("Subrs", null);
    const fields = ["BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StemSnapH", "StemSnapV", "BlueShift", "BlueFuzz", "BlueScale", "LanguageGroup", "ExpansionFactor", "ForceBold", "StdHW", "StdVW"];
    for (i = 0, ii = fields.length; i < ii; i++) {
      const field = fields[i];
      if (!(field in properties.privateData)) {
        continue;
      }
      const value = properties.privateData[field];
      if (Array.isArray(value)) {
        for (let j = value.length - 1; j > 0; j--) {
          value[j] -= value[j - 1];
        }
      }
      privateDict.setByName(field, value);
    }
    cff.topDict.privateDict = privateDict;
    const subrIndex = new _cff_parser.CFFIndex();
    for (i = 0, ii = subrs.length; i < ii; i++) {
      subrIndex.add(subrs[i]);
    }
    privateDict.subrsIndex = subrIndex;
    const compiler = new _cff_parser.CFFCompiler(cff);
    return compiler.compile();
  }
}
exports.Type1Font = Type1Font;

/***/ }),
/* 49 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Type1Parser = void 0;
var _encodings = __w_pdfjs_require__(37);
var _core_utils = __w_pdfjs_require__(3);
var _stream = __w_pdfjs_require__(8);
var _util = __w_pdfjs_require__(2);
const HINTING_ENABLED = false;
const COMMAND_MAP = {
  hstem: [1],
  vstem: [3],
  vmoveto: [4],
  rlineto: [5],
  hlineto: [6],
  vlineto: [7],
  rrcurveto: [8],
  callsubr: [10],
  flex: [12, 35],
  drop: [12, 18],
  endchar: [14],
  rmoveto: [21],
  hmoveto: [22],
  vhcurveto: [30],
  hvcurveto: [31]
};
class Type1CharString {
  constructor() {
    this.width = 0;
    this.lsb = 0;
    this.flexing = false;
    this.output = [];
    this.stack = [];
  }
  convert(encoded, subrs, seacAnalysisEnabled) {
    const count = encoded.length;
    let error = false;
    let wx, sbx, subrNumber;
    for (let i = 0; i < count; i++) {
      let value = encoded[i];
      if (value < 32) {
        if (value === 12) {
          value = (value << 8) + encoded[++i];
        }
        switch (value) {
          case 1:
            if (!HINTING_ENABLED) {
              this.stack = [];
              break;
            }
            error = this.executeCommand(2, COMMAND_MAP.hstem);
            break;
          case 3:
            if (!HINTING_ENABLED) {
              this.stack = [];
              break;
            }
            error = this.executeCommand(2, COMMAND_MAP.vstem);
            break;
          case 4:
            if (this.flexing) {
              if (this.stack.length < 1) {
                error = true;
                break;
              }
              const dy = this.stack.pop();
              this.stack.push(0, dy);
              break;
            }
            error = this.executeCommand(1, COMMAND_MAP.vmoveto);
            break;
          case 5:
            error = this.executeCommand(2, COMMAND_MAP.rlineto);
            break;
          case 6:
            error = this.executeCommand(1, COMMAND_MAP.hlineto);
            break;
          case 7:
            error = this.executeCommand(1, COMMAND_MAP.vlineto);
            break;
          case 8:
            error = this.executeCommand(6, COMMAND_MAP.rrcurveto);
            break;
          case 9:
            this.stack = [];
            break;
          case 10:
            if (this.stack.length < 1) {
              error = true;
              break;
            }
            subrNumber = this.stack.pop();
            if (!subrs[subrNumber]) {
              error = true;
              break;
            }
            error = this.convert(subrs[subrNumber], subrs, seacAnalysisEnabled);
            break;
          case 11:
            return error;
          case 13:
            if (this.stack.length < 2) {
              error = true;
              break;
            }
            wx = this.stack.pop();
            sbx = this.stack.pop();
            this.lsb = sbx;
            this.width = wx;
            this.stack.push(wx, sbx);
            error = this.executeCommand(2, COMMAND_MAP.hmoveto);
            break;
          case 14:
            this.output.push(COMMAND_MAP.endchar[0]);
            break;
          case 21:
            if (this.flexing) {
              break;
            }
            error = this.executeCommand(2, COMMAND_MAP.rmoveto);
            break;
          case 22:
            if (this.flexing) {
              this.stack.push(0);
              break;
            }
            error = this.executeCommand(1, COMMAND_MAP.hmoveto);
            break;
          case 30:
            error = this.executeCommand(4, COMMAND_MAP.vhcurveto);
            break;
          case 31:
            error = this.executeCommand(4, COMMAND_MAP.hvcurveto);
            break;
          case (12 << 8) + 0:
            this.stack = [];
            break;
          case (12 << 8) + 1:
            if (!HINTING_ENABLED) {
              this.stack = [];
              break;
            }
            error = this.executeCommand(2, COMMAND_MAP.vstem);
            break;
          case (12 << 8) + 2:
            if (!HINTING_ENABLED) {
              this.stack = [];
              break;
            }
            error = this.executeCommand(2, COMMAND_MAP.hstem);
            break;
          case (12 << 8) + 6:
            if (seacAnalysisEnabled) {
              const asb = this.stack.at(-5);
              this.seac = this.stack.splice(-4, 4);
              this.seac[0] += this.lsb - asb;
              error = this.executeCommand(0, COMMAND_MAP.endchar);
            } else {
              error = this.executeCommand(4, COMMAND_MAP.endchar);
            }
            break;
          case (12 << 8) + 7:
            if (this.stack.length < 4) {
              error = true;
              break;
            }
            this.stack.pop();
            wx = this.stack.pop();
            const sby = this.stack.pop();
            sbx = this.stack.pop();
            this.lsb = sbx;
            this.width = wx;
            this.stack.push(wx, sbx, sby);
            error = this.executeCommand(3, COMMAND_MAP.rmoveto);
            break;
          case (12 << 8) + 12:
            if (this.stack.length < 2) {
              error = true;
              break;
            }
            const num2 = this.stack.pop();
            const num1 = this.stack.pop();
            this.stack.push(num1 / num2);
            break;
          case (12 << 8) + 16:
            if (this.stack.length < 2) {
              error = true;
              break;
            }
            subrNumber = this.stack.pop();
            const numArgs = this.stack.pop();
            if (subrNumber === 0 && numArgs === 3) {
              const flexArgs = this.stack.splice(-17, 17);
              this.stack.push(flexArgs[2] + flexArgs[0], flexArgs[3] + flexArgs[1], flexArgs[4], flexArgs[5], flexArgs[6], flexArgs[7], flexArgs[8], flexArgs[9], flexArgs[10], flexArgs[11], flexArgs[12], flexArgs[13], flexArgs[14]);
              error = this.executeCommand(13, COMMAND_MAP.flex, true);
              this.flexing = false;
              this.stack.push(flexArgs[15], flexArgs[16]);
            } else if (subrNumber === 1 && numArgs === 0) {
              this.flexing = true;
            }
            break;
          case (12 << 8) + 17:
            break;
          case (12 << 8) + 33:
            this.stack = [];
            break;
          default:
            (0, _util.warn)('Unknown type 1 charstring command of "' + value + '"');
            break;
        }
        if (error) {
          break;
        }
        continue;
      } else if (value <= 246) {
        value -= 139;
      } else if (value <= 250) {
        value = (value - 247) * 256 + encoded[++i] + 108;
      } else if (value <= 254) {
        value = -((value - 251) * 256) - encoded[++i] - 108;
      } else {
        value = (encoded[++i] & 0xff) << 24 | (encoded[++i] & 0xff) << 16 | (encoded[++i] & 0xff) << 8 | (encoded[++i] & 0xff) << 0;
      }
      this.stack.push(value);
    }
    return error;
  }
  executeCommand(howManyArgs, command, keepStack) {
    const stackLength = this.stack.length;
    if (howManyArgs > stackLength) {
      return true;
    }
    const start = stackLength - howManyArgs;
    for (let i = start; i < stackLength; i++) {
      let value = this.stack[i];
      if (Number.isInteger(value)) {
        this.output.push(28, value >> 8 & 0xff, value & 0xff);
      } else {
        value = 65536 * value | 0;
        this.output.push(255, value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
      }
    }
    this.output.push(...command);
    if (keepStack) {
      this.stack.splice(start, howManyArgs);
    } else {
      this.stack.length = 0;
    }
    return false;
  }
}
const EEXEC_ENCRYPT_KEY = 55665;
const CHAR_STRS_ENCRYPT_KEY = 4330;
function isHexDigit(code) {
  return code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102;
}
function decrypt(data, key, discardNumber) {
  if (discardNumber >= data.length) {
    return new Uint8Array(0);
  }
  const c1 = 52845,
    c2 = 22719;
  let r = key | 0,
    i,
    j;
  for (i = 0; i < discardNumber; i++) {
    r = (data[i] + r) * c1 + c2 & (1 << 16) - 1;
  }
  const count = data.length - discardNumber;
  const decrypted = new Uint8Array(count);
  for (i = discardNumber, j = 0; j < count; i++, j++) {
    const value = data[i];
    decrypted[j] = value ^ r >> 8;
    r = (value + r) * c1 + c2 & (1 << 16) - 1;
  }
  return decrypted;
}
function decryptAscii(data, key, discardNumber) {
  const c1 = 52845,
    c2 = 22719;
  let r = key | 0;
  const count = data.length,
    maybeLength = count >>> 1;
  const decrypted = new Uint8Array(maybeLength);
  let i, j;
  for (i = 0, j = 0; i < count; i++) {
    const digit1 = data[i];
    if (!isHexDigit(digit1)) {
      continue;
    }
    i++;
    let digit2;
    while (i < count && !isHexDigit(digit2 = data[i])) {
      i++;
    }
    if (i < count) {
      const value = parseInt(String.fromCharCode(digit1, digit2), 16);
      decrypted[j++] = value ^ r >> 8;
      r = (value + r) * c1 + c2 & (1 << 16) - 1;
    }
  }
  return decrypted.slice(discardNumber, j);
}
function isSpecial(c) {
  return c === 0x2f || c === 0x5b || c === 0x5d || c === 0x7b || c === 0x7d || c === 0x28 || c === 0x29;
}
class Type1Parser {
  constructor(stream, encrypted, seacAnalysisEnabled) {
    if (encrypted) {
      const data = stream.getBytes();
      const isBinary = !((isHexDigit(data[0]) || (0, _core_utils.isWhiteSpace)(data[0])) && isHexDigit(data[1]) && isHexDigit(data[2]) && isHexDigit(data[3]) && isHexDigit(data[4]) && isHexDigit(data[5]) && isHexDigit(data[6]) && isHexDigit(data[7]));
      stream = new _stream.Stream(isBinary ? decrypt(data, EEXEC_ENCRYPT_KEY, 4) : decryptAscii(data, EEXEC_ENCRYPT_KEY, 4));
    }
    this.seacAnalysisEnabled = !!seacAnalysisEnabled;
    this.stream = stream;
    this.nextChar();
  }
  readNumberArray() {
    this.getToken();
    const array = [];
    while (true) {
      const token = this.getToken();
      if (token === null || token === "]" || token === "}") {
        break;
      }
      array.push(parseFloat(token || 0));
    }
    return array;
  }
  readNumber() {
    const token = this.getToken();
    return parseFloat(token || 0);
  }
  readInt() {
    const token = this.getToken();
    return parseInt(token || 0, 10) | 0;
  }
  readBoolean() {
    const token = this.getToken();
    return token === "true" ? 1 : 0;
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  prevChar() {
    this.stream.skip(-2);
    return this.currentChar = this.stream.getByte();
  }
  getToken() {
    let comment = false;
    let ch = this.currentChar;
    while (true) {
      if (ch === -1) {
        return null;
      }
      if (comment) {
        if (ch === 0x0a || ch === 0x0d) {
          comment = false;
        }
      } else if (ch === 0x25) {
        comment = true;
      } else if (!(0, _core_utils.isWhiteSpace)(ch)) {
        break;
      }
      ch = this.nextChar();
    }
    if (isSpecial(ch)) {
      this.nextChar();
      return String.fromCharCode(ch);
    }
    let token = "";
    do {
      token += String.fromCharCode(ch);
      ch = this.nextChar();
    } while (ch >= 0 && !(0, _core_utils.isWhiteSpace)(ch) && !isSpecial(ch));
    return token;
  }
  readCharStrings(bytes, lenIV) {
    if (lenIV === -1) {
      return bytes;
    }
    return decrypt(bytes, CHAR_STRS_ENCRYPT_KEY, lenIV);
  }
  extractFontProgram(properties) {
    const stream = this.stream;
    const subrs = [],
      charstrings = [];
    const privateData = Object.create(null);
    privateData.lenIV = 4;
    const program = {
      subrs: [],
      charstrings: [],
      properties: {
        privateData
      }
    };
    let token, length, data, lenIV;
    while ((token = this.getToken()) !== null) {
      if (token !== "/") {
        continue;
      }
      token = this.getToken();
      switch (token) {
        case "CharStrings":
          this.getToken();
          this.getToken();
          this.getToken();
          this.getToken();
          while (true) {
            token = this.getToken();
            if (token === null || token === "end") {
              break;
            }
            if (token !== "/") {
              continue;
            }
            const glyph = this.getToken();
            length = this.readInt();
            this.getToken();
            data = length > 0 ? stream.getBytes(length) : new Uint8Array(0);
            lenIV = program.properties.privateData.lenIV;
            const encoded = this.readCharStrings(data, lenIV);
            this.nextChar();
            token = this.getToken();
            if (token === "noaccess") {
              this.getToken();
            } else if (token === "/") {
              this.prevChar();
            }
            charstrings.push({
              glyph,
              encoded
            });
          }
          break;
        case "Subrs":
          this.readInt();
          this.getToken();
          while (this.getToken() === "dup") {
            const index = this.readInt();
            length = this.readInt();
            this.getToken();
            data = length > 0 ? stream.getBytes(length) : new Uint8Array(0);
            lenIV = program.properties.privateData.lenIV;
            const encoded = this.readCharStrings(data, lenIV);
            this.nextChar();
            token = this.getToken();
            if (token === "noaccess") {
              this.getToken();
            }
            subrs[index] = encoded;
          }
          break;
        case "BlueValues":
        case "OtherBlues":
        case "FamilyBlues":
        case "FamilyOtherBlues":
          const blueArray = this.readNumberArray();
          if (blueArray.length > 0 && blueArray.length % 2 === 0 && HINTING_ENABLED) {
            program.properties.privateData[token] = blueArray;
          }
          break;
        case "StemSnapH":
        case "StemSnapV":
          program.properties.privateData[token] = this.readNumberArray();
          break;
        case "StdHW":
        case "StdVW":
          program.properties.privateData[token] = this.readNumberArray()[0];
          break;
        case "BlueShift":
        case "lenIV":
        case "BlueFuzz":
        case "BlueScale":
        case "LanguageGroup":
          program.properties.privateData[token] = this.readNumber();
          break;
        case "ExpansionFactor":
          program.properties.privateData[token] = this.readNumber() || 0.06;
          break;
        case "ForceBold":
          program.properties.privateData[token] = this.readBoolean();
          break;
      }
    }
    for (const {
      encoded,
      glyph
    } of charstrings) {
      const charString = new Type1CharString();
      const error = charString.convert(encoded, subrs, this.seacAnalysisEnabled);
      let output = charString.output;
      if (error) {
        output = [14];
      }
      const charStringObject = {
        glyphName: glyph,
        charstring: output,
        width: charString.width,
        lsb: charString.lsb,
        seac: charString.seac
      };
      if (glyph === ".notdef") {
        program.charstrings.unshift(charStringObject);
      } else {
        program.charstrings.push(charStringObject);
      }
      if (properties.builtInEncoding) {
        const index = properties.builtInEncoding.indexOf(glyph);
        if (index > -1 && properties.widths[index] === undefined && index >= properties.firstChar && index <= properties.lastChar) {
          properties.widths[index] = charString.width;
        }
      }
    }
    return program;
  }
  extractFontHeader(properties) {
    let token;
    while ((token = this.getToken()) !== null) {
      if (token !== "/") {
        continue;
      }
      token = this.getToken();
      switch (token) {
        case "FontMatrix":
          const matrix = this.readNumberArray();
          properties.fontMatrix = matrix;
          break;
        case "Encoding":
          const encodingArg = this.getToken();
          let encoding;
          if (!/^\d+$/.test(encodingArg)) {
            encoding = (0, _encodings.getEncoding)(encodingArg);
          } else {
            encoding = [];
            const size = parseInt(encodingArg, 10) | 0;
            this.getToken();
            for (let j = 0; j < size; j++) {
              token = this.getToken();
              while (token !== "dup" && token !== "def") {
                token = this.getToken();
                if (token === null) {
                  return;
                }
              }
              if (token === "def") {
                break;
              }
              const index = this.readInt();
              this.getToken();
              const glyph = this.getToken();
              encoding[index] = glyph;
              this.getToken();
            }
          }
          properties.builtInEncoding = encoding;
          break;
        case "FontBBox":
          const fontBBox = this.readNumberArray();
          properties.ascent = Math.max(fontBBox[3], fontBBox[1]);
          properties.descent = Math.min(fontBBox[1], fontBBox[3]);
          properties.ascentScaled = true;
          break;
      }
    }
  }
}
exports.Type1Parser = Type1Parser;

/***/ }),
/* 50 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Pattern = void 0;
exports.clearPatternCaches = clearPatternCaches;
exports.getTilingPatternIR = getTilingPatternIR;
var _util = __w_pdfjs_require__(2);
var _base_stream = __w_pdfjs_require__(5);
var _colorspace = __w_pdfjs_require__(12);
var _core_utils = __w_pdfjs_require__(3);
const ShadingType = {
  FUNCTION_BASED: 1,
  AXIAL: 2,
  RADIAL: 3,
  FREE_FORM_MESH: 4,
  LATTICE_FORM_MESH: 5,
  COONS_PATCH_MESH: 6,
  TENSOR_PATCH_MESH: 7
};
class Pattern {
  constructor() {
    (0, _util.unreachable)("Cannot initialize Pattern.");
  }
  static parseShading(shading, xref, res, pdfFunctionFactory, localColorSpaceCache) {
    const dict = shading instanceof _base_stream.BaseStream ? shading.dict : shading;
    const type = dict.get("ShadingType");
    try {
      switch (type) {
        case ShadingType.AXIAL:
        case ShadingType.RADIAL:
          return new RadialAxialShading(dict, xref, res, pdfFunctionFactory, localColorSpaceCache);
        case ShadingType.FREE_FORM_MESH:
        case ShadingType.LATTICE_FORM_MESH:
        case ShadingType.COONS_PATCH_MESH:
        case ShadingType.TENSOR_PATCH_MESH:
          return new MeshShading(shading, xref, res, pdfFunctionFactory, localColorSpaceCache);
        default:
          throw new _util.FormatError("Unsupported ShadingType: " + type);
      }
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }
      (0, _util.warn)(ex);
      return new DummyShading();
    }
  }
}
exports.Pattern = Pattern;
class BaseShading {
  static SMALL_NUMBER = 1e-6;
  constructor() {
    if (this.constructor === BaseShading) {
      (0, _util.unreachable)("Cannot initialize BaseShading.");
    }
  }
  getIR() {
    (0, _util.unreachable)("Abstract method `getIR` called.");
  }
}
class RadialAxialShading extends BaseShading {
  constructor(dict, xref, resources, pdfFunctionFactory, localColorSpaceCache) {
    super();
    this.coordsArr = dict.getArray("Coords");
    this.shadingType = dict.get("ShadingType");
    const cs = _colorspace.ColorSpace.parse({
      cs: dict.getRaw("CS") || dict.getRaw("ColorSpace"),
      xref,
      resources,
      pdfFunctionFactory,
      localColorSpaceCache
    });
    const bbox = dict.getArray("BBox");
    this.bbox = Array.isArray(bbox) && bbox.length === 4 ? _util.Util.normalizeRect(bbox) : null;
    let t0 = 0.0,
      t1 = 1.0;
    if (dict.has("Domain")) {
      const domainArr = dict.getArray("Domain");
      t0 = domainArr[0];
      t1 = domainArr[1];
    }
    let extendStart = false,
      extendEnd = false;
    if (dict.has("Extend")) {
      const extendArr = dict.getArray("Extend");
      extendStart = extendArr[0];
      extendEnd = extendArr[1];
    }
    if (this.shadingType === ShadingType.RADIAL && (!extendStart || !extendEnd)) {
      const [x1, y1, r1, x2, y2, r2] = this.coordsArr;
      const distance = Math.hypot(x1 - x2, y1 - y2);
      if (r1 <= r2 + distance && r2 <= r1 + distance) {
        (0, _util.warn)("Unsupported radial gradient.");
      }
    }
    this.extendStart = extendStart;
    this.extendEnd = extendEnd;
    const fnObj = dict.getRaw("Function");
    const fn = pdfFunctionFactory.createFromArray(fnObj);
    const NUMBER_OF_SAMPLES = 840;
    const step = (t1 - t0) / NUMBER_OF_SAMPLES;
    const colorStops = this.colorStops = [];
    if (t0 >= t1 || step <= 0) {
      (0, _util.info)("Bad shading domain.");
      return;
    }
    const color = new Float32Array(cs.numComps),
      ratio = new Float32Array(1);
    let rgbColor;
    let iBase = 0;
    ratio[0] = t0;
    fn(ratio, 0, color, 0);
    let rgbBase = cs.getRgb(color, 0);
    const cssColorBase = _util.Util.makeHexColor(rgbBase[0], rgbBase[1], rgbBase[2]);
    colorStops.push([0, cssColorBase]);
    let iPrev = 1;
    ratio[0] = t0 + step;
    fn(ratio, 0, color, 0);
    let rgbPrev = cs.getRgb(color, 0);
    let maxSlopeR = rgbPrev[0] - rgbBase[0] + 1;
    let maxSlopeG = rgbPrev[1] - rgbBase[1] + 1;
    let maxSlopeB = rgbPrev[2] - rgbBase[2] + 1;
    let minSlopeR = rgbPrev[0] - rgbBase[0] - 1;
    let minSlopeG = rgbPrev[1] - rgbBase[1] - 1;
    let minSlopeB = rgbPrev[2] - rgbBase[2] - 1;
    for (let i = 2; i < NUMBER_OF_SAMPLES; i++) {
      ratio[0] = t0 + i * step;
      fn(ratio, 0, color, 0);
      rgbColor = cs.getRgb(color, 0);
      const run = i - iBase;
      maxSlopeR = Math.min(maxSlopeR, (rgbColor[0] - rgbBase[0] + 1) / run);
      maxSlopeG = Math.min(maxSlopeG, (rgbColor[1] - rgbBase[1] + 1) / run);
      maxSlopeB = Math.min(maxSlopeB, (rgbColor[2] - rgbBase[2] + 1) / run);
      minSlopeR = Math.max(minSlopeR, (rgbColor[0] - rgbBase[0] - 1) / run);
      minSlopeG = Math.max(minSlopeG, (rgbColor[1] - rgbBase[1] - 1) / run);
      minSlopeB = Math.max(minSlopeB, (rgbColor[2] - rgbBase[2] - 1) / run);
      const slopesExist = minSlopeR <= maxSlopeR && minSlopeG <= maxSlopeG && minSlopeB <= maxSlopeB;
      if (!slopesExist) {
        const cssColor = _util.Util.makeHexColor(rgbPrev[0], rgbPrev[1], rgbPrev[2]);
        colorStops.push([iPrev / NUMBER_OF_SAMPLES, cssColor]);
        maxSlopeR = rgbColor[0] - rgbPrev[0] + 1;
        maxSlopeG = rgbColor[1] - rgbPrev[1] + 1;
        maxSlopeB = rgbColor[2] - rgbPrev[2] + 1;
        minSlopeR = rgbColor[0] - rgbPrev[0] - 1;
        minSlopeG = rgbColor[1] - rgbPrev[1] - 1;
        minSlopeB = rgbColor[2] - rgbPrev[2] - 1;
        iBase = iPrev;
        rgbBase = rgbPrev;
      }
      iPrev = i;
      rgbPrev = rgbColor;
    }
    const cssColor = _util.Util.makeHexColor(rgbPrev[0], rgbPrev[1], rgbPrev[2]);
    colorStops.push([1, cssColor]);
    let background = "transparent";
    if (dict.has("Background")) {
      rgbColor = cs.getRgb(dict.get("Background"), 0);
      background = _util.Util.makeHexColor(rgbColor[0], rgbColor[1], rgbColor[2]);
    }
    if (!extendStart) {
      colorStops.unshift([0, background]);
      colorStops[1][0] += BaseShading.SMALL_NUMBER;
    }
    if (!extendEnd) {
      colorStops.at(-1)[0] -= BaseShading.SMALL_NUMBER;
      colorStops.push([1, background]);
    }
    this.colorStops = colorStops;
  }
  getIR() {
    const coordsArr = this.coordsArr;
    const shadingType = this.shadingType;
    let type, p0, p1, r0, r1;
    if (shadingType === ShadingType.AXIAL) {
      p0 = [coordsArr[0], coordsArr[1]];
      p1 = [coordsArr[2], coordsArr[3]];
      r0 = null;
      r1 = null;
      type = "axial";
    } else if (shadingType === ShadingType.RADIAL) {
      p0 = [coordsArr[0], coordsArr[1]];
      p1 = [coordsArr[3], coordsArr[4]];
      r0 = coordsArr[2];
      r1 = coordsArr[5];
      type = "radial";
    } else {
      (0, _util.unreachable)(`getPattern type unknown: ${shadingType}`);
    }
    return ["RadialAxial", type, this.bbox, this.colorStops, p0, p1, r0, r1];
  }
}
class MeshStreamReader {
  constructor(stream, context) {
    this.stream = stream;
    this.context = context;
    this.buffer = 0;
    this.bufferLength = 0;
    const numComps = context.numComps;
    this.tmpCompsBuf = new Float32Array(numComps);
    const csNumComps = context.colorSpace.numComps;
    this.tmpCsCompsBuf = context.colorFn ? new Float32Array(csNumComps) : this.tmpCompsBuf;
  }
  get hasData() {
    if (this.stream.end) {
      return this.stream.pos < this.stream.end;
    }
    if (this.bufferLength > 0) {
      return true;
    }
    const nextByte = this.stream.getByte();
    if (nextByte < 0) {
      return false;
    }
    this.buffer = nextByte;
    this.bufferLength = 8;
    return true;
  }
  readBits(n) {
    let buffer = this.buffer;
    let bufferLength = this.bufferLength;
    if (n === 32) {
      if (bufferLength === 0) {
        return (this.stream.getByte() << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte()) >>> 0;
      }
      buffer = buffer << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte();
      const nextByte = this.stream.getByte();
      this.buffer = nextByte & (1 << bufferLength) - 1;
      return (buffer << 8 - bufferLength | (nextByte & 0xff) >> bufferLength) >>> 0;
    }
    if (n === 8 && bufferLength === 0) {
      return this.stream.getByte();
    }
    while (bufferLength < n) {
      buffer = buffer << 8 | this.stream.getByte();
      bufferLength += 8;
    }
    bufferLength -= n;
    this.bufferLength = bufferLength;
    this.buffer = buffer & (1 << bufferLength) - 1;
    return buffer >> bufferLength;
  }
  align() {
    this.buffer = 0;
    this.bufferLength = 0;
  }
  readFlag() {
    return this.readBits(this.context.bitsPerFlag);
  }
  readCoordinate() {
    const bitsPerCoordinate = this.context.bitsPerCoordinate;
    const xi = this.readBits(bitsPerCoordinate);
    const yi = this.readBits(bitsPerCoordinate);
    const decode = this.context.decode;
    const scale = bitsPerCoordinate < 32 ? 1 / ((1 << bitsPerCoordinate) - 1) : 2.3283064365386963e-10;
    return [xi * scale * (decode[1] - decode[0]) + decode[0], yi * scale * (decode[3] - decode[2]) + decode[2]];
  }
  readComponents() {
    const numComps = this.context.numComps;
    const bitsPerComponent = this.context.bitsPerComponent;
    const scale = bitsPerComponent < 32 ? 1 / ((1 << bitsPerComponent) - 1) : 2.3283064365386963e-10;
    const decode = this.context.decode;
    const components = this.tmpCompsBuf;
    for (let i = 0, j = 4; i < numComps; i++, j += 2) {
      const ci = this.readBits(bitsPerComponent);
      components[i] = ci * scale * (decode[j + 1] - decode[j]) + decode[j];
    }
    const color = this.tmpCsCompsBuf;
    if (this.context.colorFn) {
      this.context.colorFn(components, 0, color, 0);
    }
    return this.context.colorSpace.getRgb(color, 0);
  }
}
let bCache = Object.create(null);
function buildB(count) {
  const lut = [];
  for (let i = 0; i <= count; i++) {
    const t = i / count,
      t_ = 1 - t;
    lut.push(new Float32Array([t_ ** 3, 3 * t * t_ ** 2, 3 * t ** 2 * t_, t ** 3]));
  }
  return lut;
}
function getB(count) {
  return bCache[count] ||= buildB(count);
}
function clearPatternCaches() {
  bCache = Object.create(null);
}
class MeshShading extends BaseShading {
  static MIN_SPLIT_PATCH_CHUNKS_AMOUNT = 3;
  static MAX_SPLIT_PATCH_CHUNKS_AMOUNT = 20;
  static TRIANGLE_DENSITY = 20;
  constructor(stream, xref, resources, pdfFunctionFactory, localColorSpaceCache) {
    super();
    if (!(stream instanceof _base_stream.BaseStream)) {
      throw new _util.FormatError("Mesh data is not a stream");
    }
    const dict = stream.dict;
    this.shadingType = dict.get("ShadingType");
    const bbox = dict.getArray("BBox");
    this.bbox = Array.isArray(bbox) && bbox.length === 4 ? _util.Util.normalizeRect(bbox) : null;
    const cs = _colorspace.ColorSpace.parse({
      cs: dict.getRaw("CS") || dict.getRaw("ColorSpace"),
      xref,
      resources,
      pdfFunctionFactory,
      localColorSpaceCache
    });
    this.background = dict.has("Background") ? cs.getRgb(dict.get("Background"), 0) : null;
    const fnObj = dict.getRaw("Function");
    const fn = fnObj ? pdfFunctionFactory.createFromArray(fnObj) : null;
    this.coords = [];
    this.colors = [];
    this.figures = [];
    const decodeContext = {
      bitsPerCoordinate: dict.get("BitsPerCoordinate"),
      bitsPerComponent: dict.get("BitsPerComponent"),
      bitsPerFlag: dict.get("BitsPerFlag"),
      decode: dict.getArray("Decode"),
      colorFn: fn,
      colorSpace: cs,
      numComps: fn ? 1 : cs.numComps
    };
    const reader = new MeshStreamReader(stream, decodeContext);
    let patchMesh = false;
    switch (this.shadingType) {
      case ShadingType.FREE_FORM_MESH:
        this._decodeType4Shading(reader);
        break;
      case ShadingType.LATTICE_FORM_MESH:
        const verticesPerRow = dict.get("VerticesPerRow") | 0;
        if (verticesPerRow < 2) {
          throw new _util.FormatError("Invalid VerticesPerRow");
        }
        this._decodeType5Shading(reader, verticesPerRow);
        break;
      case ShadingType.COONS_PATCH_MESH:
        this._decodeType6Shading(reader);
        patchMesh = true;
        break;
      case ShadingType.TENSOR_PATCH_MESH:
        this._decodeType7Shading(reader);
        patchMesh = true;
        break;
      default:
        (0, _util.unreachable)("Unsupported mesh type.");
        break;
    }
    if (patchMesh) {
      this._updateBounds();
      for (let i = 0, ii = this.figures.length; i < ii; i++) {
        this._buildFigureFromPatch(i);
      }
    }
    this._updateBounds();
    this._packData();
  }
  _decodeType4Shading(reader) {
    const coords = this.coords;
    const colors = this.colors;
    const operators = [];
    const ps = [];
    let verticesLeft = 0;
    while (reader.hasData) {
      const f = reader.readFlag();
      const coord = reader.readCoordinate();
      const color = reader.readComponents();
      if (verticesLeft === 0) {
        if (!(0 <= f && f <= 2)) {
          throw new _util.FormatError("Unknown type4 flag");
        }
        switch (f) {
          case 0:
            verticesLeft = 3;
            break;
          case 1:
            ps.push(ps.at(-2), ps.at(-1));
            verticesLeft = 1;
            break;
          case 2:
            ps.push(ps.at(-3), ps.at(-1));
            verticesLeft = 1;
            break;
        }
        operators.push(f);
      }
      ps.push(coords.length);
      coords.push(coord);
      colors.push(color);
      verticesLeft--;
      reader.align();
    }
    this.figures.push({
      type: "triangles",
      coords: new Int32Array(ps),
      colors: new Int32Array(ps)
    });
  }
  _decodeType5Shading(reader, verticesPerRow) {
    const coords = this.coords;
    const colors = this.colors;
    const ps = [];
    while (reader.hasData) {
      const coord = reader.readCoordinate();
      const color = reader.readComponents();
      ps.push(coords.length);
      coords.push(coord);
      colors.push(color);
    }
    this.figures.push({
      type: "lattice",
      coords: new Int32Array(ps),
      colors: new Int32Array(ps),
      verticesPerRow
    });
  }
  _decodeType6Shading(reader) {
    const coords = this.coords;
    const colors = this.colors;
    const ps = new Int32Array(16);
    const cs = new Int32Array(4);
    while (reader.hasData) {
      const f = reader.readFlag();
      if (!(0 <= f && f <= 3)) {
        throw new _util.FormatError("Unknown type6 flag");
      }
      const pi = coords.length;
      for (let i = 0, ii = f !== 0 ? 8 : 12; i < ii; i++) {
        coords.push(reader.readCoordinate());
      }
      const ci = colors.length;
      for (let i = 0, ii = f !== 0 ? 2 : 4; i < ii; i++) {
        colors.push(reader.readComponents());
      }
      let tmp1, tmp2, tmp3, tmp4;
      switch (f) {
        case 0:
          ps[12] = pi + 3;
          ps[13] = pi + 4;
          ps[14] = pi + 5;
          ps[15] = pi + 6;
          ps[8] = pi + 2;
          ps[11] = pi + 7;
          ps[4] = pi + 1;
          ps[7] = pi + 8;
          ps[0] = pi;
          ps[1] = pi + 11;
          ps[2] = pi + 10;
          ps[3] = pi + 9;
          cs[2] = ci + 1;
          cs[3] = ci + 2;
          cs[0] = ci;
          cs[1] = ci + 3;
          break;
        case 1:
          tmp1 = ps[12];
          tmp2 = ps[13];
          tmp3 = ps[14];
          tmp4 = ps[15];
          ps[12] = tmp4;
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = tmp3;
          ps[11] = pi + 3;
          ps[4] = tmp2;
          ps[7] = pi + 4;
          ps[0] = tmp1;
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          tmp1 = cs[2];
          tmp2 = cs[3];
          cs[2] = tmp2;
          cs[3] = ci;
          cs[0] = tmp1;
          cs[1] = ci + 1;
          break;
        case 2:
          tmp1 = ps[15];
          tmp2 = ps[11];
          ps[12] = ps[3];
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = ps[7];
          ps[11] = pi + 3;
          ps[4] = tmp2;
          ps[7] = pi + 4;
          ps[0] = tmp1;
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          tmp1 = cs[3];
          cs[2] = cs[1];
          cs[3] = ci;
          cs[0] = tmp1;
          cs[1] = ci + 1;
          break;
        case 3:
          ps[12] = ps[0];
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = ps[1];
          ps[11] = pi + 3;
          ps[4] = ps[2];
          ps[7] = pi + 4;
          ps[0] = ps[3];
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          cs[2] = cs[0];
          cs[3] = ci;
          cs[0] = cs[1];
          cs[1] = ci + 1;
          break;
      }
      ps[5] = coords.length;
      coords.push([(-4 * coords[ps[0]][0] - coords[ps[15]][0] + 6 * (coords[ps[4]][0] + coords[ps[1]][0]) - 2 * (coords[ps[12]][0] + coords[ps[3]][0]) + 3 * (coords[ps[13]][0] + coords[ps[7]][0])) / 9, (-4 * coords[ps[0]][1] - coords[ps[15]][1] + 6 * (coords[ps[4]][1] + coords[ps[1]][1]) - 2 * (coords[ps[12]][1] + coords[ps[3]][1]) + 3 * (coords[ps[13]][1] + coords[ps[7]][1])) / 9]);
      ps[6] = coords.length;
      coords.push([(-4 * coords[ps[3]][0] - coords[ps[12]][0] + 6 * (coords[ps[2]][0] + coords[ps[7]][0]) - 2 * (coords[ps[0]][0] + coords[ps[15]][0]) + 3 * (coords[ps[4]][0] + coords[ps[14]][0])) / 9, (-4 * coords[ps[3]][1] - coords[ps[12]][1] + 6 * (coords[ps[2]][1] + coords[ps[7]][1]) - 2 * (coords[ps[0]][1] + coords[ps[15]][1]) + 3 * (coords[ps[4]][1] + coords[ps[14]][1])) / 9]);
      ps[9] = coords.length;
      coords.push([(-4 * coords[ps[12]][0] - coords[ps[3]][0] + 6 * (coords[ps[8]][0] + coords[ps[13]][0]) - 2 * (coords[ps[0]][0] + coords[ps[15]][0]) + 3 * (coords[ps[11]][0] + coords[ps[1]][0])) / 9, (-4 * coords[ps[12]][1] - coords[ps[3]][1] + 6 * (coords[ps[8]][1] + coords[ps[13]][1]) - 2 * (coords[ps[0]][1] + coords[ps[15]][1]) + 3 * (coords[ps[11]][1] + coords[ps[1]][1])) / 9]);
      ps[10] = coords.length;
      coords.push([(-4 * coords[ps[15]][0] - coords[ps[0]][0] + 6 * (coords[ps[11]][0] + coords[ps[14]][0]) - 2 * (coords[ps[12]][0] + coords[ps[3]][0]) + 3 * (coords[ps[2]][0] + coords[ps[8]][0])) / 9, (-4 * coords[ps[15]][1] - coords[ps[0]][1] + 6 * (coords[ps[11]][1] + coords[ps[14]][1]) - 2 * (coords[ps[12]][1] + coords[ps[3]][1]) + 3 * (coords[ps[2]][1] + coords[ps[8]][1])) / 9]);
      this.figures.push({
        type: "patch",
        coords: new Int32Array(ps),
        colors: new Int32Array(cs)
      });
    }
  }
  _decodeType7Shading(reader) {
    const coords = this.coords;
    const colors = this.colors;
    const ps = new Int32Array(16);
    const cs = new Int32Array(4);
    while (reader.hasData) {
      const f = reader.readFlag();
      if (!(0 <= f && f <= 3)) {
        throw new _util.FormatError("Unknown type7 flag");
      }
      const pi = coords.length;
      for (let i = 0, ii = f !== 0 ? 12 : 16; i < ii; i++) {
        coords.push(reader.readCoordinate());
      }
      const ci = colors.length;
      for (let i = 0, ii = f !== 0 ? 2 : 4; i < ii; i++) {
        colors.push(reader.readComponents());
      }
      let tmp1, tmp2, tmp3, tmp4;
      switch (f) {
        case 0:
          ps[12] = pi + 3;
          ps[13] = pi + 4;
          ps[14] = pi + 5;
          ps[15] = pi + 6;
          ps[8] = pi + 2;
          ps[9] = pi + 13;
          ps[10] = pi + 14;
          ps[11] = pi + 7;
          ps[4] = pi + 1;
          ps[5] = pi + 12;
          ps[6] = pi + 15;
          ps[7] = pi + 8;
          ps[0] = pi;
          ps[1] = pi + 11;
          ps[2] = pi + 10;
          ps[3] = pi + 9;
          cs[2] = ci + 1;
          cs[3] = ci + 2;
          cs[0] = ci;
          cs[1] = ci + 3;
          break;
        case 1:
          tmp1 = ps[12];
          tmp2 = ps[13];
          tmp3 = ps[14];
          tmp4 = ps[15];
          ps[12] = tmp4;
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = tmp3;
          ps[9] = pi + 9;
          ps[10] = pi + 10;
          ps[11] = pi + 3;
          ps[4] = tmp2;
          ps[5] = pi + 8;
          ps[6] = pi + 11;
          ps[7] = pi + 4;
          ps[0] = tmp1;
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          tmp1 = cs[2];
          tmp2 = cs[3];
          cs[2] = tmp2;
          cs[3] = ci;
          cs[0] = tmp1;
          cs[1] = ci + 1;
          break;
        case 2:
          tmp1 = ps[15];
          tmp2 = ps[11];
          ps[12] = ps[3];
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = ps[7];
          ps[9] = pi + 9;
          ps[10] = pi + 10;
          ps[11] = pi + 3;
          ps[4] = tmp2;
          ps[5] = pi + 8;
          ps[6] = pi + 11;
          ps[7] = pi + 4;
          ps[0] = tmp1;
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          tmp1 = cs[3];
          cs[2] = cs[1];
          cs[3] = ci;
          cs[0] = tmp1;
          cs[1] = ci + 1;
          break;
        case 3:
          ps[12] = ps[0];
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = ps[1];
          ps[9] = pi + 9;
          ps[10] = pi + 10;
          ps[11] = pi + 3;
          ps[4] = ps[2];
          ps[5] = pi + 8;
          ps[6] = pi + 11;
          ps[7] = pi + 4;
          ps[0] = ps[3];
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          cs[2] = cs[0];
          cs[3] = ci;
          cs[0] = cs[1];
          cs[1] = ci + 1;
          break;
      }
      this.figures.push({
        type: "patch",
        coords: new Int32Array(ps),
        colors: new Int32Array(cs)
      });
    }
  }
  _buildFigureFromPatch(index) {
    const figure = this.figures[index];
    (0, _util.assert)(figure.type === "patch", "Unexpected patch mesh figure");
    const coords = this.coords,
      colors = this.colors;
    const pi = figure.coords;
    const ci = figure.colors;
    const figureMinX = Math.min(coords[pi[0]][0], coords[pi[3]][0], coords[pi[12]][0], coords[pi[15]][0]);
    const figureMinY = Math.min(coords[pi[0]][1], coords[pi[3]][1], coords[pi[12]][1], coords[pi[15]][1]);
    const figureMaxX = Math.max(coords[pi[0]][0], coords[pi[3]][0], coords[pi[12]][0], coords[pi[15]][0]);
    const figureMaxY = Math.max(coords[pi[0]][1], coords[pi[3]][1], coords[pi[12]][1], coords[pi[15]][1]);
    let splitXBy = Math.ceil((figureMaxX - figureMinX) * MeshShading.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));
    splitXBy = Math.max(MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, splitXBy));
    let splitYBy = Math.ceil((figureMaxY - figureMinY) * MeshShading.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));
    splitYBy = Math.max(MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, splitYBy));
    const verticesPerRow = splitXBy + 1;
    const figureCoords = new Int32Array((splitYBy + 1) * verticesPerRow);
    const figureColors = new Int32Array((splitYBy + 1) * verticesPerRow);
    let k = 0;
    const cl = new Uint8Array(3),
      cr = new Uint8Array(3);
    const c0 = colors[ci[0]],
      c1 = colors[ci[1]],
      c2 = colors[ci[2]],
      c3 = colors[ci[3]];
    const bRow = getB(splitYBy),
      bCol = getB(splitXBy);
    for (let row = 0; row <= splitYBy; row++) {
      cl[0] = (c0[0] * (splitYBy - row) + c2[0] * row) / splitYBy | 0;
      cl[1] = (c0[1] * (splitYBy - row) + c2[1] * row) / splitYBy | 0;
      cl[2] = (c0[2] * (splitYBy - row) + c2[2] * row) / splitYBy | 0;
      cr[0] = (c1[0] * (splitYBy - row) + c3[0] * row) / splitYBy | 0;
      cr[1] = (c1[1] * (splitYBy - row) + c3[1] * row) / splitYBy | 0;
      cr[2] = (c1[2] * (splitYBy - row) + c3[2] * row) / splitYBy | 0;
      for (let col = 0; col <= splitXBy; col++, k++) {
        if ((row === 0 || row === splitYBy) && (col === 0 || col === splitXBy)) {
          continue;
        }
        let x = 0,
          y = 0;
        let q = 0;
        for (let i = 0; i <= 3; i++) {
          for (let j = 0; j <= 3; j++, q++) {
            const m = bRow[row][i] * bCol[col][j];
            x += coords[pi[q]][0] * m;
            y += coords[pi[q]][1] * m;
          }
        }
        figureCoords[k] = coords.length;
        coords.push([x, y]);
        figureColors[k] = colors.length;
        const newColor = new Uint8Array(3);
        newColor[0] = (cl[0] * (splitXBy - col) + cr[0] * col) / splitXBy | 0;
        newColor[1] = (cl[1] * (splitXBy - col) + cr[1] * col) / splitXBy | 0;
        newColor[2] = (cl[2] * (splitXBy - col) + cr[2] * col) / splitXBy | 0;
        colors.push(newColor);
      }
    }
    figureCoords[0] = pi[0];
    figureColors[0] = ci[0];
    figureCoords[splitXBy] = pi[3];
    figureColors[splitXBy] = ci[1];
    figureCoords[verticesPerRow * splitYBy] = pi[12];
    figureColors[verticesPerRow * splitYBy] = ci[2];
    figureCoords[verticesPerRow * splitYBy + splitXBy] = pi[15];
    figureColors[verticesPerRow * splitYBy + splitXBy] = ci[3];
    this.figures[index] = {
      type: "lattice",
      coords: figureCoords,
      colors: figureColors,
      verticesPerRow
    };
  }
  _updateBounds() {
    let minX = this.coords[0][0],
      minY = this.coords[0][1],
      maxX = minX,
      maxY = minY;
    for (let i = 1, ii = this.coords.length; i < ii; i++) {
      const x = this.coords[i][0],
        y = this.coords[i][1];
      minX = minX > x ? x : minX;
      minY = minY > y ? y : minY;
      maxX = maxX < x ? x : maxX;
      maxY = maxY < y ? y : maxY;
    }
    this.bounds = [minX, minY, maxX, maxY];
  }
  _packData() {
    let i, ii, j, jj;
    const coords = this.coords;
    const coordsPacked = new Float32Array(coords.length * 2);
    for (i = 0, j = 0, ii = coords.length; i < ii; i++) {
      const xy = coords[i];
      coordsPacked[j++] = xy[0];
      coordsPacked[j++] = xy[1];
    }
    this.coords = coordsPacked;
    const colors = this.colors;
    const colorsPacked = new Uint8Array(colors.length * 3);
    for (i = 0, j = 0, ii = colors.length; i < ii; i++) {
      const c = colors[i];
      colorsPacked[j++] = c[0];
      colorsPacked[j++] = c[1];
      colorsPacked[j++] = c[2];
    }
    this.colors = colorsPacked;
    const figures = this.figures;
    for (i = 0, ii = figures.length; i < ii; i++) {
      const figure = figures[i],
        ps = figure.coords,
        cs = figure.colors;
      for (j = 0, jj = ps.length; j < jj; j++) {
        ps[j] *= 2;
        cs[j] *= 3;
      }
    }
  }
  getIR() {
    return ["Mesh", this.shadingType, this.coords, this.colors, this.figures, this.bounds, this.bbox, this.background];
  }
}
class DummyShading extends BaseShading {
  getIR() {
    return ["Dummy"];
  }
}
function getTilingPatternIR(operatorList, dict, color) {
  const matrix = dict.getArray("Matrix");
  const bbox = _util.Util.normalizeRect(dict.getArray("BBox"));
  const xstep = dict.get("XStep");
  const ystep = dict.get("YStep");
  const paintType = dict.get("PaintType");
  const tilingType = dict.get("TilingType");
  if (bbox[2] - bbox[0] === 0 || bbox[3] - bbox[1] === 0) {
    throw new _util.FormatError(`Invalid getTilingPatternIR /BBox array: [${bbox}].`);
  }
  return ["TilingPattern", color, operatorList, matrix, bbox, xstep, ystep, paintType, tilingType];
}

/***/ }),
/* 51 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getXfaFontDict = getXfaFontDict;
exports.getXfaFontName = getXfaFontName;
var _calibri_factors = __w_pdfjs_require__(52);
var _primitives = __w_pdfjs_require__(4);
var _helvetica_factors = __w_pdfjs_require__(53);
var _liberationsans_widths = __w_pdfjs_require__(54);
var _myriadpro_factors = __w_pdfjs_require__(55);
var _segoeui_factors = __w_pdfjs_require__(56);
var _core_utils = __w_pdfjs_require__(3);
var _fonts_utils = __w_pdfjs_require__(38);
const getXFAFontMap = (0, _core_utils.getLookupTableFactory)(function (t) {
  t["MyriadPro-Regular"] = t["PdfJS-Fallback-Regular"] = {
    name: "LiberationSans-Regular",
    factors: _myriadpro_factors.MyriadProRegularFactors,
    baseWidths: _liberationsans_widths.LiberationSansRegularWidths,
    baseMapping: _liberationsans_widths.LiberationSansRegularMapping,
    metrics: _myriadpro_factors.MyriadProRegularMetrics
  };
  t["MyriadPro-Bold"] = t["PdfJS-Fallback-Bold"] = {
    name: "LiberationSans-Bold",
    factors: _myriadpro_factors.MyriadProBoldFactors,
    baseWidths: _liberationsans_widths.LiberationSansBoldWidths,
    baseMapping: _liberationsans_widths.LiberationSansBoldMapping,
    metrics: _myriadpro_factors.MyriadProBoldMetrics
  };
  t["MyriadPro-It"] = t["MyriadPro-Italic"] = t["PdfJS-Fallback-Italic"] = {
    name: "LiberationSans-Italic",
    factors: _myriadpro_factors.MyriadProItalicFactors,
    baseWidths: _liberationsans_widths.LiberationSansItalicWidths,
    baseMapping: _liberationsans_widths.LiberationSansItalicMapping,
    metrics: _myriadpro_factors.MyriadProItalicMetrics
  };
  t["MyriadPro-BoldIt"] = t["MyriadPro-BoldItalic"] = t["PdfJS-Fallback-BoldItalic"] = {
    name: "LiberationSans-BoldItalic",
    factors: _myriadpro_factors.MyriadProBoldItalicFactors,
    baseWidths: _liberationsans_widths.LiberationSansBoldItalicWidths,
    baseMapping: _liberationsans_widths.LiberationSansBoldItalicMapping,
    metrics: _myriadpro_factors.MyriadProBoldItalicMetrics
  };
  t.ArialMT = t.Arial = t["Arial-Regular"] = {
    name: "LiberationSans-Regular",
    baseWidths: _liberationsans_widths.LiberationSansRegularWidths,
    baseMapping: _liberationsans_widths.LiberationSansRegularMapping
  };
  t["Arial-BoldMT"] = t["Arial-Bold"] = {
    name: "LiberationSans-Bold",
    baseWidths: _liberationsans_widths.LiberationSansBoldWidths,
    baseMapping: _liberationsans_widths.LiberationSansBoldMapping
  };
  t["Arial-ItalicMT"] = t["Arial-Italic"] = {
    name: "LiberationSans-Italic",
    baseWidths: _liberationsans_widths.LiberationSansItalicWidths,
    baseMapping: _liberationsans_widths.LiberationSansItalicMapping
  };
  t["Arial-BoldItalicMT"] = t["Arial-BoldItalic"] = {
    name: "LiberationSans-BoldItalic",
    baseWidths: _liberationsans_widths.LiberationSansBoldItalicWidths,
    baseMapping: _liberationsans_widths.LiberationSansBoldItalicMapping
  };
  t["Calibri-Regular"] = {
    name: "LiberationSans-Regular",
    factors: _calibri_factors.CalibriRegularFactors,
    baseWidths: _liberationsans_widths.LiberationSansRegularWidths,
    baseMapping: _liberationsans_widths.LiberationSansRegularMapping,
    metrics: _calibri_factors.CalibriRegularMetrics
  };
  t["Calibri-Bold"] = {
    name: "LiberationSans-Bold",
    factors: _calibri_factors.CalibriBoldFactors,
    baseWidths: _liberationsans_widths.LiberationSansBoldWidths,
    baseMapping: _liberationsans_widths.LiberationSansBoldMapping,
    metrics: _calibri_factors.CalibriBoldMetrics
  };
  t["Calibri-Italic"] = {
    name: "LiberationSans-Italic",
    factors: _calibri_factors.CalibriItalicFactors,
    baseWidths: _liberationsans_widths.LiberationSansItalicWidths,
    baseMapping: _liberationsans_widths.LiberationSansItalicMapping,
    metrics: _calibri_factors.CalibriItalicMetrics
  };
  t["Calibri-BoldItalic"] = {
    name: "LiberationSans-BoldItalic",
    factors: _calibri_factors.CalibriBoldItalicFactors,
    baseWidths: _liberationsans_widths.LiberationSansBoldItalicWidths,
    baseMapping: _liberationsans_widths.LiberationSansBoldItalicMapping,
    metrics: _calibri_factors.CalibriBoldItalicMetrics
  };
  t["Segoeui-Regular"] = {
    name: "LiberationSans-Regular",
    factors: _segoeui_factors.SegoeuiRegularFactors,
    baseWidths: _liberationsans_widths.LiberationSansRegularWidths,
    baseMapping: _liberationsans_widths.LiberationSansRegularMapping,
    metrics: _segoeui_factors.SegoeuiRegularMetrics
  };
  t["Segoeui-Bold"] = {
    name: "LiberationSans-Bold",
    factors: _segoeui_factors.SegoeuiBoldFactors,
    baseWidths: _liberationsans_widths.LiberationSansBoldWidths,
    baseMapping: _liberationsans_widths.LiberationSansBoldMapping,
    metrics: _segoeui_factors.SegoeuiBoldMetrics
  };
  t["Segoeui-Italic"] = {
    name: "LiberationSans-Italic",
    factors: _segoeui_factors.SegoeuiItalicFactors,
    baseWidths: _liberationsans_widths.LiberationSansItalicWidths,
    baseMapping: _liberationsans_widths.LiberationSansItalicMapping,
    metrics: _segoeui_factors.SegoeuiItalicMetrics
  };
  t["Segoeui-BoldItalic"] = {
    name: "LiberationSans-BoldItalic",
    factors: _segoeui_factors.SegoeuiBoldItalicFactors,
    baseWidths: _liberationsans_widths.LiberationSansBoldItalicWidths,
    baseMapping: _liberationsans_widths.LiberationSansBoldItalicMapping,
    metrics: _segoeui_factors.SegoeuiBoldItalicMetrics
  };
  t["Helvetica-Regular"] = t.Helvetica = {
    name: "LiberationSans-Regular",
    factors: _helvetica_factors.HelveticaRegularFactors,
    baseWidths: _liberationsans_widths.LiberationSansRegularWidths,
    baseMapping: _liberationsans_widths.LiberationSansRegularMapping,
    metrics: _helvetica_factors.HelveticaRegularMetrics
  };
  t["Helvetica-Bold"] = {
    name: "LiberationSans-Bold",
    factors: _helvetica_factors.HelveticaBoldFactors,
    baseWidths: _liberationsans_widths.LiberationSansBoldWidths,
    baseMapping: _liberationsans_widths.LiberationSansBoldMapping,
    metrics: _helvetica_factors.HelveticaBoldMetrics
  };
  t["Helvetica-Italic"] = {
    name: "LiberationSans-Italic",
    factors: _helvetica_factors.HelveticaItalicFactors,
    baseWidths: _liberationsans_widths.LiberationSansItalicWidths,
    baseMapping: _liberationsans_widths.LiberationSansItalicMapping,
    metrics: _helvetica_factors.HelveticaItalicMetrics
  };
  t["Helvetica-BoldItalic"] = {
    name: "LiberationSans-BoldItalic",
    factors: _helvetica_factors.HelveticaBoldItalicFactors,
    baseWidths: _liberationsans_widths.LiberationSansBoldItalicWidths,
    baseMapping: _liberationsans_widths.LiberationSansBoldItalicMapping,
    metrics: _helvetica_factors.HelveticaBoldItalicMetrics
  };
});
function getXfaFontName(name) {
  const fontName = (0, _fonts_utils.normalizeFontName)(name);
  const fontMap = getXFAFontMap();
  return fontMap[fontName];
}
function getXfaFontWidths(name) {
  const info = getXfaFontName(name);
  if (!info) {
    return null;
  }
  const {
    baseWidths,
    baseMapping,
    factors
  } = info;
  const rescaledBaseWidths = !factors ? baseWidths : baseWidths.map((w, i) => w * factors[i]);
  let currentCode = -2;
  let currentArray;
  const newWidths = [];
  for (const [unicode, glyphIndex] of baseMapping.map((charUnicode, index) => [charUnicode, index]).sort(([unicode1], [unicode2]) => unicode1 - unicode2)) {
    if (unicode === -1) {
      continue;
    }
    if (unicode === currentCode + 1) {
      currentArray.push(rescaledBaseWidths[glyphIndex]);
      currentCode += 1;
    } else {
      currentCode = unicode;
      currentArray = [rescaledBaseWidths[glyphIndex]];
      newWidths.push(unicode, currentArray);
    }
  }
  return newWidths;
}
function getXfaFontDict(name) {
  const widths = getXfaFontWidths(name);
  const dict = new _primitives.Dict(null);
  dict.set("BaseFont", _primitives.Name.get(name));
  dict.set("Type", _primitives.Name.get("Font"));
  dict.set("Subtype", _primitives.Name.get("CIDFontType2"));
  dict.set("Encoding", _primitives.Name.get("Identity-H"));
  dict.set("CIDToGIDMap", _primitives.Name.get("Identity"));
  dict.set("W", widths);
  dict.set("FirstChar", widths[0]);
  dict.set("LastChar", widths.at(-2) + widths.at(-1).length - 1);
  const descriptor = new _primitives.Dict(null);
  dict.set("FontDescriptor", descriptor);
  const systemInfo = new _primitives.Dict(null);
  systemInfo.set("Ordering", "Identity");
  systemInfo.set("Registry", "Adobe");
  systemInfo.set("Supplement", 0);
  dict.set("CIDSystemInfo", systemInfo);
  return dict;
}

/***/ }),
/* 52 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CalibriRegularMetrics = exports.CalibriRegularFactors = exports.CalibriItalicMetrics = exports.CalibriItalicFactors = exports.CalibriBoldMetrics = exports.CalibriBoldItalicMetrics = exports.CalibriBoldItalicFactors = exports.CalibriBoldFactors = void 0;
const CalibriBoldFactors = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.54657, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.73293, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.9121, 0.86943, 0.79795, 0.88198, 0.77958, 0.70864, 0.81055, 0.90399, 0.88653, 0.96017, 0.82577, 0.77892, 0.78257, 0.97507, 1.54657, 0.97507, 0.85284, 0.89552, 0.90176, 0.88762, 0.8785, 0.75241, 0.8785, 0.90518, 0.95015, 0.77618, 0.8785, 0.88401, 0.91916, 0.86304, 0.88401, 0.91488, 0.8785, 0.8801, 0.8785, 0.8785, 0.91343, 0.7173, 1.04106, 0.8785, 0.85075, 0.95794, 0.82616, 0.85162, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.12401, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.73293, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.9121, 0.86943, 0.86943, 0.86943, 0.86943, 0.86943, 0.85284, 0.87508, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.8715, 0.75241, 0.90518, 0.90518, 0.90518, 0.90518, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.8785, 0.8801, 0.8801, 0.8801, 0.8801, 0.8801, 0.90747, 0.89049, 0.8785, 0.8785, 0.8785, 0.8785, 0.85162, 0.8785, 0.85162, 0.83908, 0.88762, 0.83908, 0.88762, 0.83908, 0.88762, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.87289, 0.83016, 0.88506, 0.93125, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.81921, 0.77618, 0.81921, 0.77618, 0.81921, 0.77618, 1, 1, 0.87356, 0.8785, 0.91075, 0.89608, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76229, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.79468, 0.91926, 0.88175, 0.70823, 0.94903, 0.9121, 0.8785, 1, 1, 0.9121, 0.8785, 0.87802, 0.88656, 0.8785, 0.86943, 0.8801, 0.86943, 0.8801, 0.86943, 0.8801, 0.87402, 0.89291, 0.77958, 0.91343, 1, 1, 0.77958, 0.91343, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.96017, 0.95794, 0.77892, 0.85162, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.88762, 0.77539, 0.8715, 0.87508, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70674, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.06303, 0.83908, 0.80352, 0.57184, 0.6965, 0.56289, 0.82001, 0.56029, 0.81235, 1.02988, 0.83908, 0.7762, 0.68156, 0.80367, 0.73133, 0.78257, 0.87356, 0.86943, 0.95958, 0.75727, 0.89019, 1.04924, 0.9121, 0.7648, 0.86943, 0.87356, 0.79795, 0.78275, 0.81055, 0.77892, 0.9762, 0.82577, 0.99819, 0.84896, 0.95958, 0.77892, 0.96108, 1.01407, 0.89049, 1.02988, 0.94211, 0.96108, 0.8936, 0.84021, 0.87842, 0.96399, 0.79109, 0.89049, 1.00813, 1.02988, 0.86077, 0.87445, 0.92099, 0.84723, 0.86513, 0.8801, 0.75638, 0.85714, 0.78216, 0.79586, 0.87965, 0.94211, 0.97747, 0.78287, 0.97926, 0.84971, 1.02988, 0.94211, 0.8801, 0.94211, 0.84971, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90264, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90518, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90548, 1, 1, 1, 1, 1, 1, 0.96017, 0.95794, 0.96017, 0.95794, 0.96017, 0.95794, 0.77892, 0.85162, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.92794, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71143, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.93835, 0.83406, 0.91133, 0.84107, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90527, 1.81055, 0.90527, 1.81055, 1.31006, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.CalibriBoldFactors = CalibriBoldFactors;
const CalibriBoldMetrics = {
  lineHeight: 1.2207,
  lineGap: 0.2207
};
exports.CalibriBoldMetrics = CalibriBoldMetrics;
const CalibriBoldItalicFactors = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.56239, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.71805, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.90872, 0.85938, 0.79795, 0.87068, 0.77958, 0.69766, 0.81055, 0.90399, 0.88653, 0.96068, 0.82577, 0.77892, 0.78257, 0.97507, 1.529, 0.97507, 0.85284, 0.89552, 0.90176, 0.94908, 0.86411, 0.74012, 0.86411, 0.88323, 0.95015, 0.86411, 0.86331, 0.88401, 0.91916, 0.86304, 0.88401, 0.9039, 0.86331, 0.86331, 0.86411, 0.86411, 0.90464, 0.70852, 1.04106, 0.86331, 0.84372, 0.95794, 0.82616, 0.84548, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.19129, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.71805, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.90872, 0.85938, 0.85938, 0.85938, 0.85938, 0.85938, 0.85284, 0.87068, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.85887, 0.74012, 0.88323, 0.88323, 0.88323, 0.88323, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.90747, 0.89049, 0.86331, 0.86331, 0.86331, 0.86331, 0.84548, 0.86411, 0.84548, 0.83908, 0.94908, 0.83908, 0.94908, 0.83908, 0.94908, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.87289, 0.79538, 0.88506, 0.92726, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.81921, 0.86411, 0.81921, 0.86411, 0.81921, 0.86411, 1, 1, 0.87356, 0.86331, 0.91075, 0.8777, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76467, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.77312, 0.91926, 0.88175, 0.70823, 0.94903, 0.90872, 0.86331, 1, 1, 0.90872, 0.86331, 0.86906, 0.88116, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.87402, 0.86549, 0.77958, 0.90464, 1, 1, 0.77958, 0.90464, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.96068, 0.95794, 0.77892, 0.84548, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.94908, 0.77539, 0.85887, 0.87068, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70088, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.48387, 0.83908, 0.80352, 0.57118, 0.6965, 0.56347, 0.79179, 0.55853, 0.80346, 1.02988, 0.83908, 0.7762, 0.67174, 0.86036, 0.73133, 0.78257, 0.87356, 0.86441, 0.95958, 0.75727, 0.89019, 1.04924, 0.90872, 0.74889, 0.85938, 0.87891, 0.79795, 0.7957, 0.81055, 0.77892, 0.97447, 0.82577, 0.97466, 0.87179, 0.95958, 0.77892, 0.94252, 0.95612, 0.8753, 1.02988, 0.92733, 0.94252, 0.87411, 0.84021, 0.8728, 0.95612, 0.74081, 0.8753, 1.02189, 1.02988, 0.84814, 0.87445, 0.91822, 0.84723, 0.85668, 0.86331, 0.81344, 0.87581, 0.76422, 0.82046, 0.96057, 0.92733, 0.99375, 0.78022, 0.95452, 0.86015, 1.02988, 0.92733, 0.86331, 0.92733, 0.86015, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90631, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88323, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85174, 1, 1, 1, 1, 1, 1, 0.96068, 0.95794, 0.96068, 0.95794, 0.96068, 0.95794, 0.77892, 0.84548, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.89807, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71094, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.92972, 0.83406, 0.91133, 0.83326, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90616, 1.81055, 0.90527, 1.81055, 1.3107, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.CalibriBoldItalicFactors = CalibriBoldItalicFactors;
const CalibriBoldItalicMetrics = {
  lineHeight: 1.2207,
  lineGap: 0.2207
};
exports.CalibriBoldItalicMetrics = CalibriBoldItalicMetrics;
const CalibriItalicFactors = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39543, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.72346, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89249, 0.84118, 0.77452, 0.85374, 0.75186, 0.67789, 0.79776, 0.88844, 0.85066, 0.94309, 0.77818, 0.7306, 0.76659, 1.10369, 1.38313, 1.10369, 1.06139, 0.89552, 0.8739, 0.9245, 0.9245, 0.83203, 0.9245, 0.85865, 1.09842, 0.9245, 0.9245, 1.03297, 1.07692, 0.90918, 1.03297, 0.94959, 0.9245, 0.92274, 0.9245, 0.9245, 1.02933, 0.77832, 1.20562, 0.9245, 0.8916, 0.98986, 0.86621, 0.89453, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.16359, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.72346, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89249, 0.84118, 0.84118, 0.84118, 0.84118, 0.84118, 0.85284, 0.84557, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.84843, 0.83203, 0.85865, 0.85865, 0.85865, 0.85865, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.9245, 0.92274, 0.92274, 0.92274, 0.92274, 0.92274, 0.90747, 0.86651, 0.9245, 0.9245, 0.9245, 0.9245, 0.89453, 0.9245, 0.89453, 0.8675, 0.9245, 0.8675, 0.9245, 0.8675, 0.9245, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.85193, 0.8875, 0.86477, 0.99034, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.81105, 0.9245, 0.81105, 0.9245, 0.81105, 0.9245, 1, 1, 0.86275, 0.9245, 0.90872, 0.93591, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77896, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.9375, 0.98156, 0.93407, 0.77261, 1.11429, 0.89249, 0.9245, 1, 1, 0.89249, 0.9245, 0.92534, 0.86698, 0.9245, 0.84118, 0.92274, 0.84118, 0.92274, 0.84118, 0.92274, 0.8667, 0.86291, 0.75186, 1.02933, 1, 1, 0.75186, 1.02933, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 1, 1, 0.79776, 0.97655, 0.79776, 1.23023, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.94309, 0.98986, 0.7306, 0.89453, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.9245, 0.76318, 0.84843, 0.84557, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67009, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.8675, 0.90861, 0.6192, 0.7363, 0.64824, 0.82411, 0.56321, 0.85696, 1.23516, 0.8675, 0.81552, 0.7286, 0.84134, 0.73206, 0.76659, 0.86275, 0.84369, 0.90685, 0.77892, 0.85871, 1.02638, 0.89249, 0.75828, 0.84118, 0.85984, 0.77452, 0.76466, 0.79776, 0.7306, 0.90782, 0.77818, 0.903, 0.87291, 0.90685, 0.7306, 0.99058, 1.03667, 0.94635, 1.23516, 0.9849, 0.99058, 0.92393, 0.8916, 0.942, 1.03667, 0.75026, 0.94635, 1.0297, 1.23516, 0.90918, 0.94048, 0.98217, 0.89746, 0.84153, 0.92274, 0.82507, 0.88832, 0.84438, 0.88178, 1.03525, 0.9849, 1.00225, 0.78086, 0.97248, 0.89404, 1.23516, 0.9849, 0.92274, 0.9849, 0.89404, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89693, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85865, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90933, 1, 1, 1, 1, 1, 1, 0.94309, 0.98986, 0.94309, 0.98986, 0.94309, 0.98986, 0.7306, 0.89453, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.68994, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.97858, 0.82616, 0.91133, 0.83437, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90572, 1.81055, 0.90749, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85284, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.CalibriItalicFactors = CalibriItalicFactors;
const CalibriItalicMetrics = {
  lineHeight: 1.2207,
  lineGap: 0.2207
};
exports.CalibriItalicMetrics = CalibriItalicMetrics;
const CalibriRegularFactors = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39016, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.73834, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89385, 0.85122, 0.77452, 0.86503, 0.75186, 0.68887, 0.79776, 0.88844, 0.85066, 0.94258, 0.77818, 0.7306, 0.76659, 1.10369, 1.39016, 1.10369, 1.06139, 0.89552, 0.8739, 0.86128, 0.94469, 0.8457, 0.94469, 0.89464, 1.09842, 0.84636, 0.94469, 1.03297, 1.07692, 0.90918, 1.03297, 0.95897, 0.94469, 0.9482, 0.94469, 0.94469, 1.04692, 0.78223, 1.20562, 0.94469, 0.90332, 0.98986, 0.86621, 0.90527, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.08707, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.73834, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89385, 0.85122, 0.85122, 0.85122, 0.85122, 0.85122, 0.85284, 0.85311, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.8693, 0.8457, 0.89464, 0.89464, 0.89464, 0.89464, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.94469, 0.9482, 0.9482, 0.9482, 0.9482, 0.9482, 0.90747, 0.86651, 0.94469, 0.94469, 0.94469, 0.94469, 0.90527, 0.94469, 0.90527, 0.8675, 0.86128, 0.8675, 0.86128, 0.8675, 0.86128, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.85193, 0.92454, 0.86477, 0.9921, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.81105, 0.84636, 0.81105, 0.84636, 0.81105, 0.84636, 1, 1, 0.86275, 0.94469, 0.90872, 0.95786, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77741, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.90452, 0.98156, 1.11842, 0.77261, 1.11429, 0.89385, 0.94469, 1, 1, 0.89385, 0.94469, 0.95877, 0.86901, 0.94469, 0.85122, 0.9482, 0.85122, 0.9482, 0.85122, 0.9482, 0.8667, 0.90016, 0.75186, 1.04692, 1, 1, 0.75186, 1.04692, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 1, 1, 0.79776, 0.92188, 0.79776, 1.23023, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.94258, 0.98986, 0.7306, 0.90527, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.86128, 0.76318, 0.8693, 0.85311, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67742, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.86686, 0.90861, 0.62267, 0.74359, 0.65649, 0.85498, 0.56963, 0.88254, 1.23516, 0.8675, 0.81552, 0.75443, 0.84503, 0.73206, 0.76659, 0.86275, 0.85122, 0.90685, 0.77892, 0.85746, 1.02638, 0.89385, 0.75657, 0.85122, 0.86275, 0.77452, 0.74171, 0.79776, 0.7306, 0.95165, 0.77818, 0.89772, 0.88831, 0.90685, 0.7306, 0.98142, 1.02191, 0.96576, 1.23516, 0.99018, 0.98142, 0.9236, 0.89258, 0.94035, 1.02191, 0.78848, 0.96576, 0.9561, 1.23516, 0.90918, 0.92578, 0.95424, 0.89746, 0.83969, 0.9482, 0.80113, 0.89442, 0.85208, 0.86155, 0.98022, 0.99018, 1.00452, 0.81209, 0.99247, 0.89181, 1.23516, 0.99018, 0.9482, 0.99018, 0.89181, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88844, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89464, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96766, 1, 1, 1, 1, 1, 1, 0.94258, 0.98986, 0.94258, 0.98986, 0.94258, 0.98986, 0.7306, 0.90527, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.69043, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.99331, 0.82616, 0.91133, 0.84286, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90527, 1.81055, 0.90527, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1.07185, 0.99413, 0.96334, 1.08065, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.CalibriRegularFactors = CalibriRegularFactors;
const CalibriRegularMetrics = {
  lineHeight: 1.2207,
  lineGap: 0.2207
};
exports.CalibriRegularMetrics = CalibriRegularMetrics;

/***/ }),
/* 53 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.HelveticaRegularMetrics = exports.HelveticaRegularFactors = exports.HelveticaItalicMetrics = exports.HelveticaItalicFactors = exports.HelveticaBoldMetrics = exports.HelveticaBoldItalicMetrics = exports.HelveticaBoldItalicFactors = exports.HelveticaBoldFactors = void 0;
const HelveticaBoldFactors = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.03374, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00042, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.03828, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00034, 0.99977, 1, 0.99997, 1.00026, 1.00078, 1.00036, 0.99973, 1.00013, 1.0006, 0.99977, 0.99977, 0.99988, 0.85148, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 1.00069, 1.00022, 0.99977, 1.00001, 0.99984, 1.00026, 1.00001, 1.00024, 1.00001, 0.9999, 1, 1.0006, 1.00001, 1.00041, 0.99962, 1.00026, 1.0006, 0.99995, 1.00041, 0.99942, 0.99973, 0.99927, 1.00082, 0.99902, 1.00026, 1.00087, 1.0006, 1.00069, 0.99973, 0.99867, 0.99973, 0.9993, 1.00026, 1.00049, 1.00056, 1, 0.99988, 0.99935, 0.99995, 0.99954, 1.00055, 0.99945, 1.00032, 1.0006, 0.99995, 1.00026, 0.99995, 1.00032, 1.00001, 1.00008, 0.99971, 1.00019, 0.9994, 1.00001, 1.0006, 1.00044, 0.99973, 1.00023, 1.00047, 1, 0.99942, 0.99561, 0.99989, 1.00035, 0.99977, 1.00035, 0.99977, 1.00019, 0.99944, 1.00001, 1.00021, 0.99926, 1.00035, 1.00035, 0.99942, 1.00048, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.99989, 1.00057, 1.00001, 0.99936, 1.00052, 1.00012, 0.99996, 1.00043, 1, 1.00035, 0.9994, 0.99976, 1.00035, 0.99973, 1.00052, 1.00041, 1.00119, 1.00037, 0.99973, 1.00002, 0.99986, 1.00041, 1.00041, 0.99902, 0.9996, 1.00034, 0.99999, 1.00026, 0.99999, 1.00026, 0.99973, 1.00052, 0.99973, 1, 0.99973, 1.00041, 1.00075, 0.9994, 1.0003, 0.99999, 1, 1.00041, 0.99955, 1, 0.99915, 0.99973, 0.99973, 1.00026, 1.00119, 0.99955, 0.99973, 1.0006, 0.99911, 1.0006, 1.00026, 0.99972, 1.00026, 0.99902, 1.00041, 0.99973, 0.99999, 1, 1, 1.00038, 1.0005, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 1.00047, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.HelveticaBoldFactors = HelveticaBoldFactors;
const HelveticaBoldMetrics = {
  lineHeight: 1.2,
  lineGap: 0.2
};
exports.HelveticaBoldMetrics = HelveticaBoldMetrics;
const HelveticaBoldItalicFactors = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.0044, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99971, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.01011, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99977, 1, 1, 1.00026, 0.99969, 0.99972, 0.99981, 0.9998, 1.0006, 0.99977, 0.99977, 1.00022, 0.91155, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 0.99966, 1.00022, 1.00032, 1.00001, 0.99944, 1.00026, 1.00001, 0.99968, 1.00001, 1.00047, 1, 1.0006, 1.00001, 0.99981, 1.00101, 1.00026, 1.0006, 0.99948, 0.99981, 1.00064, 0.99973, 0.99942, 1.00101, 1.00061, 1.00026, 1.00069, 1.0006, 1.00014, 0.99973, 1.01322, 0.99973, 1.00065, 1.00026, 1.00012, 0.99923, 1, 1.00064, 1.00076, 0.99948, 1.00055, 1.00063, 1.00007, 0.99943, 1.0006, 0.99948, 1.00026, 0.99948, 0.99943, 1.00001, 1.00001, 1.00029, 1.00038, 1.00035, 1.00001, 1.0006, 1.0006, 0.99973, 0.99978, 1.00001, 1.00057, 0.99989, 0.99967, 0.99964, 0.99967, 0.99977, 0.99999, 0.99977, 1.00038, 0.99977, 1.00001, 0.99973, 1.00066, 0.99967, 0.99967, 1.00041, 0.99998, 0.99999, 0.99977, 1.00022, 0.99967, 1.00001, 0.99977, 1.00026, 0.99964, 1.00031, 1.00001, 0.99999, 0.99999, 1, 1.00023, 1, 1, 0.99999, 1.00035, 1.00001, 0.99999, 0.99973, 0.99977, 0.99999, 1.00058, 0.99973, 0.99973, 0.99955, 0.9995, 1.00026, 1.00026, 1.00032, 0.99989, 1.00034, 0.99999, 1.00026, 1.00026, 1.00026, 0.99973, 0.45998, 0.99973, 1.00026, 0.99973, 1.00001, 0.99999, 0.99982, 0.99994, 0.99996, 1, 1.00042, 1.00044, 1.00029, 1.00023, 0.99973, 0.99973, 1.00026, 0.99949, 1.00002, 0.99973, 1.0006, 1.0006, 1.0006, 0.99975, 1.00026, 1.00026, 1.00032, 0.98685, 0.99973, 1.00026, 1, 1, 0.99966, 1.00044, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1, 0.99973, 0.99971, 0.99978, 1, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00098, 1, 1, 1, 1.00049, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.HelveticaBoldItalicFactors = HelveticaBoldItalicFactors;
const HelveticaBoldItalicMetrics = {
  lineHeight: 1.35,
  lineGap: 0.2
};
exports.HelveticaBoldItalicMetrics = HelveticaBoldItalicMetrics;
const HelveticaItalicFactors = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.0288, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 0.99946, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.06311, 0.99973, 1.00024, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00041, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.89547, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00001, 1, 1.00054, 0.99977, 1.00084, 1.00007, 0.99973, 1.00013, 0.99924, 1.00001, 1.00001, 0.99945, 0.91221, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00001, 0.99999, 0.99977, 0.99933, 1.00022, 1.00054, 1.00001, 1.00065, 1.00026, 1.00001, 1.0001, 1.00001, 1.00052, 1, 1.0006, 1.00001, 0.99945, 0.99897, 0.99968, 0.99924, 1.00036, 0.99945, 0.99949, 1, 1.0006, 0.99897, 0.99918, 0.99968, 0.99911, 0.99924, 1, 0.99962, 1.01487, 1, 1.0005, 0.99973, 1.00012, 1.00043, 1, 0.99995, 0.99994, 1.00036, 0.99947, 1.00019, 1.00063, 1.00025, 0.99924, 1.00036, 0.99973, 1.00036, 1.00025, 1.00001, 1.00001, 1.00027, 1.0001, 1.00068, 1.00001, 1.0006, 1.0006, 1, 1.00008, 0.99957, 0.99972, 0.9994, 0.99954, 0.99975, 1.00051, 1.00001, 1.00019, 1.00001, 1.0001, 0.99986, 1.00001, 1.00001, 1.00038, 0.99954, 0.99954, 0.9994, 1.00066, 0.99999, 0.99977, 1.00022, 1.00054, 1.00001, 0.99977, 1.00026, 0.99975, 1.0001, 1.00001, 0.99993, 0.9995, 0.99955, 1.00016, 0.99978, 0.99974, 1.00019, 1.00022, 0.99955, 1.00053, 0.99973, 1.00089, 1.00005, 0.99967, 1.00048, 0.99973, 1.00002, 1.00034, 0.99973, 0.99973, 0.99964, 1.00006, 1.00066, 0.99947, 0.99973, 0.98894, 0.99973, 1, 0.44898, 1, 0.99946, 1, 1.00039, 1.00082, 0.99991, 0.99991, 0.99985, 1.00022, 1.00023, 1.00061, 1.00006, 0.99966, 0.99973, 0.99973, 0.99973, 1.00019, 1.0008, 1, 0.99924, 0.99924, 0.99924, 0.99983, 1.00044, 0.99973, 0.99964, 0.98332, 1, 0.99973, 1, 1, 0.99962, 0.99895, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 1.00423, 0.99925, 0.99999, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00049, 1, 1.00245, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 1.00003, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.HelveticaItalicFactors = HelveticaItalicFactors;
const HelveticaItalicMetrics = {
  lineHeight: 1.35,
  lineGap: 0.2
};
exports.HelveticaItalicMetrics = HelveticaItalicMetrics;
const HelveticaRegularFactors = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.04596, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 1.00019, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.02572, 0.99973, 1.00005, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99999, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.84533, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99928, 1, 0.99977, 1.00013, 1.00055, 0.99947, 0.99945, 0.99941, 0.99924, 1.00001, 1.00001, 1.0004, 0.91621, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00005, 0.99999, 0.99977, 1.00015, 1.00022, 0.99977, 1.00001, 0.99973, 1.00026, 1.00001, 1.00019, 1.00001, 0.99946, 1, 1.0006, 1.00001, 0.99978, 1.00045, 0.99973, 0.99924, 1.00023, 0.99978, 0.99966, 1, 1.00065, 1.00045, 1.00019, 0.99973, 0.99973, 0.99924, 1, 1, 0.96499, 1, 1.00055, 0.99973, 1.00008, 1.00027, 1, 0.9997, 0.99995, 1.00023, 0.99933, 1.00019, 1.00015, 1.00031, 0.99924, 1.00023, 0.99973, 1.00023, 1.00031, 1.00001, 0.99928, 1.00029, 1.00092, 1.00035, 1.00001, 1.0006, 1.0006, 1, 0.99988, 0.99975, 1, 1.00082, 0.99561, 0.9996, 1.00035, 1.00001, 0.99962, 1.00001, 1.00092, 0.99964, 1.00001, 0.99963, 0.99999, 1.00035, 1.00035, 1.00082, 0.99962, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.9996, 0.99967, 1.00001, 1.00034, 1.00074, 1.00054, 1.00053, 1.00063, 0.99971, 0.99962, 1.00035, 0.99975, 0.99977, 0.99973, 1.00043, 0.99953, 1.0007, 0.99915, 0.99973, 1.00008, 0.99892, 1.00073, 1.00073, 1.00114, 0.99915, 1.00073, 0.99955, 0.99973, 1.00092, 0.99973, 1, 0.99998, 1, 1.0003, 1, 1.00043, 1.00001, 0.99969, 1.0003, 1, 1.00035, 1.00001, 0.9995, 1, 1.00092, 0.99973, 0.99973, 0.99973, 1.0007, 0.9995, 1, 0.99924, 1.0006, 0.99924, 0.99972, 1.00062, 0.99973, 1.00114, 1.00073, 1, 0.99955, 1, 1, 1.00047, 0.99968, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 0.99925, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.HelveticaRegularFactors = HelveticaRegularFactors;
const HelveticaRegularMetrics = {
  lineHeight: 1.2,
  lineGap: 0.2
};
exports.HelveticaRegularMetrics = HelveticaRegularMetrics;

/***/ }),
/* 54 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.LiberationSansRegularWidths = exports.LiberationSansRegularMapping = exports.LiberationSansItalicWidths = exports.LiberationSansItalicMapping = exports.LiberationSansBoldWidths = exports.LiberationSansBoldMapping = exports.LiberationSansBoldItalicWidths = exports.LiberationSansBoldItalicMapping = void 0;
const LiberationSansBoldWidths = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1000, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 719, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 785, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 385, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1000, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1000, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 465, 722, 333, 853, 906, 474, 825, 927, 838, 278, 722, 722, 601, 719, 667, 611, 722, 778, 278, 722, 667, 833, 722, 644, 778, 722, 667, 600, 611, 667, 821, 667, 809, 802, 278, 667, 615, 451, 611, 278, 582, 615, 610, 556, 606, 475, 460, 611, 541, 278, 558, 556, 612, 556, 445, 611, 766, 619, 520, 684, 446, 582, 715, 576, 753, 845, 278, 582, 611, 582, 845, 667, 669, 885, 567, 711, 667, 278, 276, 556, 1094, 1062, 875, 610, 722, 622, 719, 722, 719, 722, 567, 712, 667, 904, 626, 719, 719, 610, 702, 833, 722, 778, 719, 667, 722, 611, 622, 854, 667, 730, 703, 1005, 1019, 870, 979, 719, 711, 1031, 719, 556, 618, 615, 417, 635, 556, 709, 497, 615, 615, 500, 635, 740, 604, 611, 604, 611, 556, 490, 556, 875, 556, 615, 581, 833, 844, 729, 854, 615, 552, 854, 583, 556, 556, 611, 417, 552, 556, 278, 281, 278, 969, 906, 611, 500, 615, 556, 604, 778, 611, 487, 447, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1000, 1000, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1000, 1000, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1094, 556, 885, 489, 1115, 1000, 768, 600, 834, 834, 834, 834, 1000, 500, 1000, 500, 1000, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1000, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
exports.LiberationSansBoldWidths = LiberationSansBoldWidths;
const LiberationSansBoldMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
exports.LiberationSansBoldMapping = LiberationSansBoldMapping;
const LiberationSansBoldItalicWidths = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1000, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 740, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 782, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 396, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1000, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1000, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 722, 333, 854, 906, 473, 844, 930, 847, 278, 722, 722, 610, 671, 667, 611, 722, 778, 278, 722, 667, 833, 722, 657, 778, 718, 667, 590, 611, 667, 822, 667, 829, 781, 278, 667, 620, 479, 611, 278, 591, 620, 621, 556, 610, 479, 492, 611, 558, 278, 566, 556, 603, 556, 450, 611, 712, 605, 532, 664, 409, 591, 704, 578, 773, 834, 278, 591, 611, 591, 834, 667, 667, 886, 614, 719, 667, 278, 278, 556, 1094, 1042, 854, 622, 719, 677, 719, 722, 708, 722, 614, 722, 667, 927, 643, 719, 719, 615, 687, 833, 722, 778, 719, 667, 722, 611, 677, 781, 667, 729, 708, 979, 989, 854, 1000, 708, 719, 1042, 729, 556, 619, 604, 534, 618, 556, 736, 510, 611, 611, 507, 622, 740, 604, 611, 611, 611, 556, 889, 556, 885, 556, 646, 583, 889, 935, 707, 854, 594, 552, 865, 589, 556, 556, 611, 469, 563, 556, 278, 278, 278, 969, 906, 611, 507, 619, 556, 611, 778, 611, 575, 467, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1000, 1000, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1000, 1000, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1104, 556, 885, 516, 1146, 1000, 768, 600, 834, 834, 834, 834, 999, 500, 1000, 500, 1000, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1000, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
exports.LiberationSansBoldItalicWidths = LiberationSansBoldItalicWidths;
const LiberationSansBoldItalicMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
exports.LiberationSansBoldItalicMapping = LiberationSansBoldItalicMapping;
const LiberationSansItalicWidths = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1000, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 625, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 733, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 281, 556, 400, 556, 222, 722, 556, 722, 556, 722, 556, 615, 723, 556, 778, 556, 778, 556, 778, 556, 1000, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 354, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1000, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 789, 846, 389, 794, 865, 775, 222, 667, 667, 570, 671, 667, 611, 722, 778, 278, 667, 667, 833, 722, 648, 778, 725, 667, 600, 611, 667, 837, 667, 831, 761, 278, 667, 570, 439, 555, 222, 550, 570, 571, 500, 556, 439, 463, 555, 542, 222, 500, 492, 548, 500, 447, 556, 670, 573, 486, 603, 374, 550, 652, 546, 728, 779, 222, 550, 556, 550, 779, 667, 667, 843, 544, 708, 667, 278, 278, 500, 1066, 982, 844, 589, 715, 639, 724, 667, 651, 667, 544, 704, 667, 917, 614, 715, 715, 589, 686, 833, 722, 778, 725, 667, 722, 611, 639, 795, 667, 727, 673, 920, 923, 805, 886, 651, 694, 1022, 682, 556, 562, 522, 493, 553, 556, 688, 465, 556, 556, 472, 564, 686, 550, 556, 556, 556, 500, 833, 500, 835, 500, 572, 518, 830, 851, 621, 736, 526, 492, 752, 534, 556, 556, 556, 378, 496, 500, 222, 222, 222, 910, 828, 556, 472, 565, 500, 556, 778, 556, 492, 339, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1000, 1000, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1000, 1000, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1083, 1000, 768, 600, 834, 834, 834, 834, 1000, 500, 998, 500, 1000, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 584, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1000, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
exports.LiberationSansItalicWidths = LiberationSansItalicWidths;
const LiberationSansItalicMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
exports.LiberationSansItalicMapping = LiberationSansItalicMapping;
const LiberationSansRegularWidths = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1000, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 615, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 735, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 292, 556, 334, 556, 222, 722, 556, 722, 556, 722, 556, 604, 723, 556, 778, 556, 778, 556, 778, 556, 1000, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 375, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1000, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 784, 838, 384, 774, 855, 752, 222, 667, 667, 551, 668, 667, 611, 722, 778, 278, 667, 668, 833, 722, 650, 778, 722, 667, 618, 611, 667, 798, 667, 835, 748, 278, 667, 578, 446, 556, 222, 547, 578, 575, 500, 557, 446, 441, 556, 556, 222, 500, 500, 576, 500, 448, 556, 690, 569, 482, 617, 395, 547, 648, 525, 713, 781, 222, 547, 556, 547, 781, 667, 667, 865, 542, 719, 667, 278, 278, 500, 1057, 1010, 854, 583, 722, 635, 719, 667, 656, 667, 542, 677, 667, 923, 604, 719, 719, 583, 656, 833, 722, 778, 719, 667, 722, 611, 635, 760, 667, 740, 667, 917, 938, 792, 885, 656, 719, 1010, 722, 556, 573, 531, 365, 583, 556, 669, 458, 559, 559, 438, 583, 688, 552, 556, 542, 556, 500, 458, 500, 823, 500, 573, 521, 802, 823, 625, 719, 521, 510, 750, 542, 556, 556, 556, 365, 510, 500, 222, 278, 222, 906, 812, 556, 438, 559, 500, 552, 778, 556, 489, 411, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1000, 1000, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1000, 1000, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1073, 1000, 768, 600, 834, 834, 834, 834, 1000, 500, 1000, 500, 1000, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1000, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
exports.LiberationSansRegularWidths = LiberationSansRegularWidths;
const LiberationSansRegularMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
exports.LiberationSansRegularMapping = LiberationSansRegularMapping;

/***/ }),
/* 55 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MyriadProRegularMetrics = exports.MyriadProRegularFactors = exports.MyriadProItalicMetrics = exports.MyriadProItalicFactors = exports.MyriadProBoldMetrics = exports.MyriadProBoldItalicMetrics = exports.MyriadProBoldItalicFactors = exports.MyriadProBoldFactors = void 0;
const MyriadProBoldFactors = [1.36898, 1, 1, 0.72706, 0.80479, 0.83734, 0.98894, 0.99793, 0.9897, 0.93884, 0.86209, 0.94292, 0.94292, 1.16661, 1.02058, 0.93582, 0.96694, 0.93582, 1.19137, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.72851, 0.78966, 0.90838, 0.83637, 0.82391, 0.96376, 0.80061, 0.86275, 0.8768, 0.95407, 1.0258, 0.73901, 0.85022, 0.83655, 1.0156, 0.95546, 0.92179, 0.87107, 0.92179, 0.82114, 0.8096, 0.89713, 0.94438, 0.95353, 0.94083, 0.91905, 0.90406, 0.9446, 0.94292, 1.18777, 0.94292, 1.02058, 0.89903, 0.90088, 0.94938, 0.97898, 0.81093, 0.97571, 0.94938, 1.024, 0.9577, 0.95933, 0.98621, 1.0474, 0.97455, 0.98981, 0.9672, 0.95933, 0.9446, 0.97898, 0.97407, 0.97646, 0.78036, 1.10208, 0.95442, 0.95298, 0.97579, 0.9332, 0.94039, 0.938, 0.80687, 1.01149, 0.80687, 1.02058, 0.80479, 0.99793, 0.99793, 0.99793, 0.99793, 1.01149, 1.00872, 0.90088, 0.91882, 1.0213, 0.8361, 1.02058, 0.62295, 0.54324, 0.89022, 1.08595, 1, 1, 0.90088, 1, 0.97455, 0.93582, 0.90088, 1, 1.05686, 0.8361, 0.99642, 0.99642, 0.99642, 0.72851, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.868, 0.82391, 0.80061, 0.80061, 0.80061, 0.80061, 1.0258, 1.0258, 1.0258, 1.0258, 0.97484, 0.95546, 0.92179, 0.92179, 0.92179, 0.92179, 0.92179, 1.02058, 0.92179, 0.94438, 0.94438, 0.94438, 0.94438, 0.90406, 0.86958, 0.98225, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.9031, 0.81093, 0.94938, 0.94938, 0.94938, 0.94938, 0.98621, 0.98621, 0.98621, 0.98621, 0.93969, 0.95933, 0.9446, 0.9446, 0.9446, 0.9446, 0.9446, 1.08595, 0.9446, 0.95442, 0.95442, 0.95442, 0.95442, 0.94039, 0.97898, 0.94039, 0.90838, 0.94938, 0.90838, 0.94938, 0.90838, 0.94938, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.96376, 0.84313, 0.97484, 0.97571, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.8768, 0.9577, 0.8768, 0.9577, 0.8768, 0.9577, 1, 1, 0.95407, 0.95933, 0.97069, 0.95933, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 0.887, 1.01591, 0.73901, 1.0474, 1, 1, 0.97455, 0.83655, 0.98981, 1, 1, 0.83655, 0.73977, 0.83655, 0.73903, 0.84638, 1.033, 0.95546, 0.95933, 1, 1, 0.95546, 0.95933, 0.8271, 0.95417, 0.95933, 0.92179, 0.9446, 0.92179, 0.9446, 0.92179, 0.9446, 0.936, 0.91964, 0.82114, 0.97646, 1, 1, 0.82114, 0.97646, 0.8096, 0.78036, 0.8096, 0.78036, 1, 1, 0.8096, 0.78036, 1, 1, 0.89713, 0.77452, 0.89713, 1.10208, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94083, 0.97579, 0.90406, 0.94039, 0.90406, 0.9446, 0.938, 0.9446, 0.938, 0.9446, 0.938, 1, 0.99793, 0.90838, 0.94938, 0.868, 0.9031, 0.92179, 0.9446, 1, 1, 0.89713, 1.10208, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90989, 0.9358, 0.91945, 0.83181, 0.75261, 0.87992, 0.82976, 0.96034, 0.83689, 0.97268, 1.0078, 0.90838, 0.83637, 0.8019, 0.90157, 0.80061, 0.9446, 0.95407, 0.92436, 1.0258, 0.85022, 0.97153, 1.0156, 0.95546, 0.89192, 0.92179, 0.92361, 0.87107, 0.96318, 0.89713, 0.93704, 0.95638, 0.91905, 0.91709, 0.92796, 1.0258, 0.93704, 0.94836, 1.0373, 0.95933, 1.0078, 0.95871, 0.94836, 0.96174, 0.92601, 0.9498, 0.98607, 0.95776, 0.95933, 1.05453, 1.0078, 0.98275, 0.9314, 0.95617, 0.91701, 1.05993, 0.9446, 0.78367, 0.9553, 1, 0.86832, 1.0128, 0.95871, 0.99394, 0.87548, 0.96361, 0.86774, 1.0078, 0.95871, 0.9446, 0.95871, 0.86774, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.94083, 0.97579, 0.94083, 0.97579, 0.94083, 0.97579, 0.90406, 0.94039, 0.96694, 1, 0.89903, 1, 1, 1, 0.93582, 0.93582, 0.93582, 1, 0.908, 0.908, 0.918, 0.94219, 0.94219, 0.96544, 1, 1.285, 1, 1, 0.81079, 0.81079, 1, 1, 0.74854, 1, 1, 1, 1, 0.99793, 1, 1, 1, 0.65, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.17173, 1, 0.80535, 0.76169, 1.02058, 1.0732, 1.05486, 1, 1, 1.30692, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.16161, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.MyriadProBoldFactors = MyriadProBoldFactors;
const MyriadProBoldMetrics = {
  lineHeight: 1.2,
  lineGap: 0.2
};
exports.MyriadProBoldMetrics = MyriadProBoldMetrics;
const MyriadProBoldItalicFactors = [1.36898, 1, 1, 0.66227, 0.80779, 0.81625, 0.97276, 0.97276, 0.97733, 0.92222, 0.83266, 0.94292, 0.94292, 1.16148, 1.02058, 0.93582, 0.96694, 0.93582, 1.17337, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.71541, 0.76813, 0.85576, 0.80591, 0.80729, 0.94299, 0.77512, 0.83655, 0.86523, 0.92222, 0.98621, 0.71743, 0.81698, 0.79726, 0.98558, 0.92222, 0.90637, 0.83809, 0.90637, 0.80729, 0.76463, 0.86275, 0.90699, 0.91605, 0.9154, 0.85308, 0.85458, 0.90531, 0.94292, 1.21296, 0.94292, 1.02058, 0.89903, 1.18616, 0.99613, 0.91677, 0.78216, 0.91677, 0.90083, 0.98796, 0.9135, 0.92168, 0.95381, 0.98981, 0.95298, 0.95381, 0.93459, 0.92168, 0.91513, 0.92004, 0.91677, 0.95077, 0.748, 1.04502, 0.91677, 0.92061, 0.94236, 0.89544, 0.89364, 0.9, 0.80687, 0.8578, 0.80687, 1.02058, 0.80779, 0.97276, 0.97276, 0.97276, 0.97276, 0.8578, 0.99973, 1.18616, 0.91339, 1.08074, 0.82891, 1.02058, 0.55509, 0.71526, 0.89022, 1.08595, 1, 1, 1.18616, 1, 0.96736, 0.93582, 1.18616, 1, 1.04864, 0.82711, 0.99043, 0.99043, 0.99043, 0.71541, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.845, 0.80729, 0.77512, 0.77512, 0.77512, 0.77512, 0.98621, 0.98621, 0.98621, 0.98621, 0.95961, 0.92222, 0.90637, 0.90637, 0.90637, 0.90637, 0.90637, 1.02058, 0.90251, 0.90699, 0.90699, 0.90699, 0.90699, 0.85458, 0.83659, 0.94951, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.85811, 0.78216, 0.90083, 0.90083, 0.90083, 0.90083, 0.95381, 0.95381, 0.95381, 0.95381, 0.9135, 0.92168, 0.91513, 0.91513, 0.91513, 0.91513, 0.91513, 1.08595, 0.91677, 0.91677, 0.91677, 0.91677, 0.91677, 0.89364, 0.92332, 0.89364, 0.85576, 0.99613, 0.85576, 0.99613, 0.85576, 0.99613, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.94299, 0.76783, 0.95961, 0.91677, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.86523, 0.9135, 0.86523, 0.9135, 0.86523, 0.9135, 1, 1, 0.92222, 0.92168, 0.92222, 0.92168, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.86036, 0.97096, 0.71743, 0.98981, 1, 1, 0.95298, 0.79726, 0.95381, 1, 1, 0.79726, 0.6894, 0.79726, 0.74321, 0.81691, 1.0006, 0.92222, 0.92168, 1, 1, 0.92222, 0.92168, 0.79464, 0.92098, 0.92168, 0.90637, 0.91513, 0.90637, 0.91513, 0.90637, 0.91513, 0.909, 0.87514, 0.80729, 0.95077, 1, 1, 0.80729, 0.95077, 0.76463, 0.748, 0.76463, 0.748, 1, 1, 0.76463, 0.748, 1, 1, 0.86275, 0.72651, 0.86275, 1.04502, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.9154, 0.94236, 0.85458, 0.89364, 0.85458, 0.90531, 0.9, 0.90531, 0.9, 0.90531, 0.9, 1, 0.97276, 0.85576, 0.99613, 0.845, 0.85811, 0.90251, 0.91677, 1, 1, 0.86275, 1.04502, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.00899, 1.30628, 0.85576, 0.80178, 0.66862, 0.7927, 0.69323, 0.88127, 0.72459, 0.89711, 0.95381, 0.85576, 0.80591, 0.7805, 0.94729, 0.77512, 0.90531, 0.92222, 0.90637, 0.98621, 0.81698, 0.92655, 0.98558, 0.92222, 0.85359, 0.90637, 0.90976, 0.83809, 0.94523, 0.86275, 0.83509, 0.93157, 0.85308, 0.83392, 0.92346, 0.98621, 0.83509, 0.92886, 0.91324, 0.92168, 0.95381, 0.90646, 0.92886, 0.90557, 0.86847, 0.90276, 0.91324, 0.86842, 0.92168, 0.99531, 0.95381, 0.9224, 0.85408, 0.92699, 0.86847, 1.0051, 0.91513, 0.80487, 0.93481, 1, 0.88159, 1.05214, 0.90646, 0.97355, 0.81539, 0.89398, 0.85923, 0.95381, 0.90646, 0.91513, 0.90646, 0.85923, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9154, 0.94236, 0.9154, 0.94236, 0.9154, 0.94236, 0.85458, 0.89364, 0.96694, 1, 0.89903, 1, 1, 1, 0.91782, 0.91782, 0.91782, 1, 0.896, 0.896, 0.896, 0.9332, 0.9332, 0.95973, 1, 1.26, 1, 1, 0.80479, 0.80178, 1, 1, 0.85633, 1, 1, 1, 1, 0.97276, 1, 1, 1, 0.698, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.14542, 1, 0.79199, 0.78694, 1.02058, 1.03493, 1.05486, 1, 1, 1.23026, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.20006, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.MyriadProBoldItalicFactors = MyriadProBoldItalicFactors;
const MyriadProBoldItalicMetrics = {
  lineHeight: 1.2,
  lineGap: 0.2
};
exports.MyriadProBoldItalicMetrics = MyriadProBoldItalicMetrics;
const MyriadProItalicFactors = [1.36898, 1, 1, 0.65507, 0.84943, 0.85639, 0.88465, 0.88465, 0.86936, 0.88307, 0.86948, 0.85283, 0.85283, 1.06383, 1.02058, 0.75945, 0.9219, 0.75945, 1.17337, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.75945, 0.75945, 1.02058, 1.02058, 1.02058, 0.69046, 0.70926, 0.85158, 0.77812, 0.76852, 0.89591, 0.70466, 0.76125, 0.80094, 0.86822, 0.83864, 0.728, 0.77212, 0.79475, 0.93637, 0.87514, 0.8588, 0.76013, 0.8588, 0.72421, 0.69866, 0.77598, 0.85991, 0.80811, 0.87832, 0.78112, 0.77512, 0.8562, 1.0222, 1.18417, 1.0222, 1.27014, 0.89903, 1.15012, 0.93859, 0.94399, 0.846, 0.94399, 0.81453, 1.0186, 0.94219, 0.96017, 1.03075, 1.02175, 0.912, 1.03075, 0.96998, 0.96017, 0.93859, 0.94399, 0.94399, 0.95493, 0.746, 1.12658, 0.94578, 0.91, 0.979, 0.882, 0.882, 0.83, 0.85034, 0.83537, 0.85034, 1.02058, 0.70869, 0.88465, 0.88465, 0.88465, 0.88465, 0.83537, 0.90083, 1.15012, 0.9161, 0.94565, 0.73541, 1.02058, 0.53609, 0.69353, 0.79519, 1.08595, 1, 1, 1.15012, 1, 0.91974, 0.75945, 1.15012, 1, 0.9446, 0.73361, 0.9005, 0.9005, 0.9005, 0.62864, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.773, 0.76852, 0.70466, 0.70466, 0.70466, 0.70466, 0.83864, 0.83864, 0.83864, 0.83864, 0.90561, 0.87514, 0.8588, 0.8588, 0.8588, 0.8588, 0.8588, 1.02058, 0.85751, 0.85991, 0.85991, 0.85991, 0.85991, 0.77512, 0.76013, 0.88075, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.8075, 0.846, 0.81453, 0.81453, 0.81453, 0.81453, 0.82424, 0.82424, 0.82424, 0.82424, 0.9278, 0.96017, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 1.08595, 0.8562, 0.94578, 0.94578, 0.94578, 0.94578, 0.882, 0.94578, 0.882, 0.85158, 0.93859, 0.85158, 0.93859, 0.85158, 0.93859, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.89591, 0.8544, 0.90561, 0.94399, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.80094, 0.94219, 0.80094, 0.94219, 0.80094, 0.94219, 1, 1, 0.86822, 0.96017, 0.86822, 0.96017, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 1.03075, 0.83864, 0.82424, 0.81402, 1.02738, 0.728, 1.02175, 1, 1, 0.912, 0.79475, 1.03075, 1, 1, 0.79475, 0.83911, 0.79475, 0.66266, 0.80553, 1.06676, 0.87514, 0.96017, 1, 1, 0.87514, 0.96017, 0.86865, 0.87396, 0.96017, 0.8588, 0.93859, 0.8588, 0.93859, 0.8588, 0.93859, 0.867, 0.84759, 0.72421, 0.95493, 1, 1, 0.72421, 0.95493, 0.69866, 0.746, 0.69866, 0.746, 1, 1, 0.69866, 0.746, 1, 1, 0.77598, 0.88417, 0.77598, 1.12658, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.87832, 0.979, 0.77512, 0.882, 0.77512, 0.8562, 0.83, 0.8562, 0.83, 0.8562, 0.83, 1, 0.88465, 0.85158, 0.93859, 0.773, 0.8075, 0.85751, 0.8562, 1, 1, 0.77598, 1.12658, 1.15012, 1.15012, 1.15012, 1.15012, 1.15012, 1.15313, 1.15012, 1.15012, 1.15012, 1.08106, 1.03901, 0.85158, 0.77025, 0.62264, 0.7646, 0.65351, 0.86026, 0.69461, 0.89947, 1.03075, 0.85158, 0.77812, 0.76449, 0.88836, 0.70466, 0.8562, 0.86822, 0.8588, 0.83864, 0.77212, 0.85308, 0.93637, 0.87514, 0.82352, 0.8588, 0.85701, 0.76013, 0.89058, 0.77598, 0.8156, 0.82565, 0.78112, 0.77899, 0.89386, 0.83864, 0.8156, 0.9486, 0.92388, 0.96186, 1.03075, 0.91123, 0.9486, 0.93298, 0.878, 0.93942, 0.92388, 0.84596, 0.96186, 0.95119, 1.03075, 0.922, 0.88787, 0.95829, 0.88, 0.93559, 0.93859, 0.78815, 0.93758, 1, 0.89217, 1.03737, 0.91123, 0.93969, 0.77487, 0.85769, 0.86799, 1.03075, 0.91123, 0.93859, 0.91123, 0.86799, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87832, 0.979, 0.87832, 0.979, 0.87832, 0.979, 0.77512, 0.882, 0.9219, 1, 0.89903, 1, 1, 1, 0.87321, 0.87321, 0.87321, 1, 1.027, 1.027, 1.027, 0.86847, 0.86847, 0.79121, 1, 1.124, 1, 1, 0.73572, 0.73572, 1, 1, 0.85034, 1, 1, 1, 1, 0.88465, 1, 1, 1, 0.669, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04828, 1, 0.74948, 0.75187, 1.02058, 0.98391, 1.02119, 1, 1, 1.06233, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05233, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.MyriadProItalicFactors = MyriadProItalicFactors;
const MyriadProItalicMetrics = {
  lineHeight: 1.2,
  lineGap: 0.2
};
exports.MyriadProItalicMetrics = MyriadProItalicMetrics;
const MyriadProRegularFactors = [1.36898, 1, 1, 0.76305, 0.82784, 0.94935, 0.89364, 0.92241, 0.89073, 0.90706, 0.98472, 0.85283, 0.85283, 1.0664, 1.02058, 0.74505, 0.9219, 0.74505, 1.23456, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.74505, 0.74505, 1.02058, 1.02058, 1.02058, 0.73002, 0.72601, 0.91755, 0.8126, 0.80314, 0.92222, 0.73764, 0.79726, 0.83051, 0.90284, 0.86023, 0.74, 0.8126, 0.84869, 0.96518, 0.91115, 0.8858, 0.79761, 0.8858, 0.74498, 0.73914, 0.81363, 0.89591, 0.83659, 0.89633, 0.85608, 0.8111, 0.90531, 1.0222, 1.22736, 1.0222, 1.27014, 0.89903, 0.90088, 0.86667, 1.0231, 0.896, 1.01411, 0.90083, 1.05099, 1.00512, 0.99793, 1.05326, 1.09377, 0.938, 1.06226, 1.00119, 0.99793, 0.98714, 1.0231, 1.01231, 0.98196, 0.792, 1.19137, 0.99074, 0.962, 1.01915, 0.926, 0.942, 0.856, 0.85034, 0.92006, 0.85034, 1.02058, 0.69067, 0.92241, 0.92241, 0.92241, 0.92241, 0.92006, 0.9332, 0.90088, 0.91882, 0.93484, 0.75339, 1.02058, 0.56866, 0.54324, 0.79519, 1.08595, 1, 1, 0.90088, 1, 0.95325, 0.74505, 0.90088, 1, 0.97198, 0.75339, 0.91009, 0.91009, 0.91009, 0.66466, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.788, 0.80314, 0.73764, 0.73764, 0.73764, 0.73764, 0.86023, 0.86023, 0.86023, 0.86023, 0.92915, 0.91115, 0.8858, 0.8858, 0.8858, 0.8858, 0.8858, 1.02058, 0.8858, 0.89591, 0.89591, 0.89591, 0.89591, 0.8111, 0.79611, 0.89713, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86936, 0.896, 0.90083, 0.90083, 0.90083, 0.90083, 0.84224, 0.84224, 0.84224, 0.84224, 0.97276, 0.99793, 0.98714, 0.98714, 0.98714, 0.98714, 0.98714, 1.08595, 0.89876, 0.99074, 0.99074, 0.99074, 0.99074, 0.942, 1.0231, 0.942, 0.91755, 0.86667, 0.91755, 0.86667, 0.91755, 0.86667, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.92222, 0.93372, 0.92915, 1.01411, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.83051, 1.00512, 0.83051, 1.00512, 0.83051, 1.00512, 1, 1, 0.90284, 0.99793, 0.90976, 0.99793, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 1.05326, 0.86023, 0.84224, 0.82873, 1.07469, 0.74, 1.09377, 1, 1, 0.938, 0.84869, 1.06226, 1, 1, 0.84869, 0.83704, 0.84869, 0.81441, 0.85588, 1.08927, 0.91115, 0.99793, 1, 1, 0.91115, 0.99793, 0.91887, 0.90991, 0.99793, 0.8858, 0.98714, 0.8858, 0.98714, 0.8858, 0.98714, 0.894, 0.91434, 0.74498, 0.98196, 1, 1, 0.74498, 0.98196, 0.73914, 0.792, 0.73914, 0.792, 1, 1, 0.73914, 0.792, 1, 1, 0.81363, 0.904, 0.81363, 1.19137, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89633, 1.01915, 0.8111, 0.942, 0.8111, 0.90531, 0.856, 0.90531, 0.856, 0.90531, 0.856, 1, 0.92241, 0.91755, 0.86667, 0.788, 0.86936, 0.8858, 0.89876, 1, 1, 0.81363, 1.19137, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90388, 1.03901, 0.92138, 0.78105, 0.7154, 0.86169, 0.80513, 0.94007, 0.82528, 0.98612, 1.06226, 0.91755, 0.8126, 0.81884, 0.92819, 0.73764, 0.90531, 0.90284, 0.8858, 0.86023, 0.8126, 0.91172, 0.96518, 0.91115, 0.83089, 0.8858, 0.87791, 0.79761, 0.89297, 0.81363, 0.88157, 0.89992, 0.85608, 0.81992, 0.94307, 0.86023, 0.88157, 0.95308, 0.98699, 0.99793, 1.06226, 0.95817, 0.95308, 0.97358, 0.928, 0.98088, 0.98699, 0.92761, 0.99793, 0.96017, 1.06226, 0.986, 0.944, 0.95978, 0.938, 0.96705, 0.98714, 0.80442, 0.98972, 1, 0.89762, 1.04552, 0.95817, 0.99007, 0.87064, 0.91879, 0.88888, 1.06226, 0.95817, 0.98714, 0.95817, 0.88888, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89633, 1.01915, 0.89633, 1.01915, 0.89633, 1.01915, 0.8111, 0.942, 0.9219, 1, 0.89903, 1, 1, 1, 0.93173, 0.93173, 0.93173, 1, 1.06304, 1.06304, 1.06904, 0.89903, 0.89903, 0.80549, 1, 1.156, 1, 1, 0.76575, 0.76575, 1, 1, 0.72458, 1, 1, 1, 1, 0.92241, 1, 1, 1, 0.619, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.07257, 1, 0.74705, 0.71119, 1.02058, 1.024, 1.02119, 1, 1, 1.1536, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05638, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.MyriadProRegularFactors = MyriadProRegularFactors;
const MyriadProRegularMetrics = {
  lineHeight: 1.2,
  lineGap: 0.2
};
exports.MyriadProRegularMetrics = MyriadProRegularMetrics;

/***/ }),
/* 56 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SegoeuiRegularMetrics = exports.SegoeuiRegularFactors = exports.SegoeuiItalicMetrics = exports.SegoeuiItalicFactors = exports.SegoeuiBoldMetrics = exports.SegoeuiBoldItalicMetrics = exports.SegoeuiBoldItalicFactors = exports.SegoeuiBoldFactors = void 0;
const SegoeuiBoldFactors = [1.76738, 1, 1, 0.99297, 0.9824, 1.04016, 1.06497, 1.03424, 0.97529, 1.17647, 1.23203, 1.1085, 1.1085, 1.16939, 1.2107, 0.9754, 1.21408, 0.9754, 1.59578, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 0.81378, 0.81378, 1.2107, 1.2107, 1.2107, 0.71703, 0.97847, 0.97363, 0.88776, 0.8641, 1.02096, 0.79795, 0.85132, 0.914, 1.06085, 1.1406, 0.8007, 0.89858, 0.83693, 1.14889, 1.09398, 0.97489, 0.92094, 0.97489, 0.90399, 0.84041, 0.95923, 1.00135, 1, 1.06467, 0.98243, 0.90996, 0.99361, 1.1085, 1.56942, 1.1085, 1.2107, 0.74627, 0.94282, 0.96752, 1.01519, 0.86304, 1.01359, 0.97278, 1.15103, 1.01359, 0.98561, 1.02285, 1.02285, 1.00527, 1.02285, 1.0302, 0.99041, 1.0008, 1.01519, 1.01359, 1.02258, 0.79104, 1.16862, 0.99041, 0.97454, 1.02511, 0.99298, 0.96752, 0.95801, 0.94856, 1.16579, 0.94856, 1.2107, 0.9824, 1.03424, 1.03424, 1, 1.03424, 1.16579, 0.8727, 1.3871, 1.18622, 1.10818, 1.04478, 1.2107, 1.18622, 0.75155, 0.94994, 1.28826, 1.21408, 1.21408, 0.91056, 1, 0.91572, 0.9754, 0.64663, 1.18328, 1.24866, 1.04478, 1.14169, 1.15749, 1.17389, 0.71703, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.93506, 0.8641, 0.79795, 0.79795, 0.79795, 0.79795, 1.1406, 1.1406, 1.1406, 1.1406, 1.02096, 1.09398, 0.97426, 0.97426, 0.97426, 0.97426, 0.97426, 1.2107, 0.97489, 1.00135, 1.00135, 1.00135, 1.00135, 0.90996, 0.92094, 1.02798, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.93136, 0.86304, 0.97278, 0.97278, 0.97278, 0.97278, 1.02285, 1.02285, 1.02285, 1.02285, 0.97122, 0.99041, 1, 1, 1, 1, 1, 1.28826, 1.0008, 0.99041, 0.99041, 0.99041, 0.99041, 0.96752, 1.01519, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 1.02096, 1.03057, 1.02096, 1.03517, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.914, 1.01359, 0.914, 1.01359, 0.914, 1.01359, 1, 1, 1.06085, 0.98561, 1.06085, 1.00879, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 0.97138, 1.08692, 0.8007, 1.02285, 1, 1, 1.00527, 0.83693, 1.02285, 1, 1, 0.83693, 0.9455, 0.83693, 0.90418, 0.83693, 1.13005, 1.09398, 0.99041, 1, 1, 1.09398, 0.99041, 0.96692, 1.09251, 0.99041, 0.97489, 1.0008, 0.97489, 1.0008, 0.97489, 1.0008, 0.93994, 0.97931, 0.90399, 1.02258, 1, 1, 0.90399, 1.02258, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 1, 1, 0.95923, 1.07034, 0.95923, 1.16862, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.06467, 1.02511, 0.90996, 0.96752, 0.90996, 0.99361, 0.95801, 0.99361, 0.95801, 0.99361, 0.95801, 1.07733, 1.03424, 0.97363, 0.96752, 0.93506, 0.93136, 0.97489, 1.0008, 1, 1, 0.95923, 1.16862, 1.15103, 1.15103, 1.01173, 1.03959, 0.75953, 0.81378, 0.79912, 1.15103, 1.21994, 0.95161, 0.87815, 1.01149, 0.81525, 0.7676, 0.98167, 1.01134, 1.02546, 0.84097, 1.03089, 1.18102, 0.97363, 0.88776, 0.85134, 0.97826, 0.79795, 0.99361, 1.06085, 0.97489, 1.1406, 0.89858, 1.0388, 1.14889, 1.09398, 0.86039, 0.97489, 1.0595, 0.92094, 0.94793, 0.95923, 0.90996, 0.99346, 0.98243, 1.02112, 0.95493, 1.1406, 0.90996, 1.03574, 1.02597, 1.0008, 1.18102, 1.06628, 1.03574, 1.0192, 1.01932, 1.00886, 0.97531, 1.0106, 1.0008, 1.13189, 1.18102, 1.02277, 0.98683, 1.0016, 0.99561, 1.07237, 1.0008, 0.90434, 0.99921, 0.93803, 0.8965, 1.23085, 1.06628, 1.04983, 0.96268, 1.0499, 0.98439, 1.18102, 1.06628, 1.0008, 1.06628, 0.98439, 0.79795, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09466, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.97278, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.02065, 1, 1, 1, 1, 1, 1, 1.06467, 1.02511, 1.06467, 1.02511, 1.06467, 1.02511, 0.90996, 0.96752, 1, 1.21408, 0.89903, 1, 1, 0.75155, 1.04394, 1.04394, 1.04394, 1.04394, 0.98633, 0.98633, 0.98633, 0.73047, 0.73047, 1.20642, 0.91211, 1.25635, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.12454, 0.93503, 1.03424, 1.19687, 1.03424, 1, 1, 1, 0.771, 1, 1, 1.15749, 1.15749, 1.15749, 1.10948, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.16897, 1, 0.96085, 0.90137, 1.2107, 1.18416, 1.13973, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21172, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18874, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.09193, 1.09193, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.SegoeuiBoldFactors = SegoeuiBoldFactors;
const SegoeuiBoldMetrics = {
  lineHeight: 1.33008,
  lineGap: 0
};
exports.SegoeuiBoldMetrics = SegoeuiBoldMetrics;
const SegoeuiBoldItalicFactors = [1.76738, 1, 1, 0.98946, 1.03959, 1.04016, 1.02809, 1.036, 0.97639, 1.10953, 1.23203, 1.11144, 1.11144, 1.16939, 1.21237, 0.9754, 1.21261, 0.9754, 1.59754, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 0.81378, 0.81378, 1.21237, 1.21237, 1.21237, 0.73541, 0.97847, 0.97363, 0.89723, 0.87897, 1.0426, 0.79429, 0.85292, 0.91149, 1.05815, 1.1406, 0.79631, 0.90128, 0.83853, 1.04396, 1.10615, 0.97552, 0.94436, 0.97552, 0.88641, 0.80527, 0.96083, 1.00135, 1, 1.06777, 0.9817, 0.91142, 0.99361, 1.11144, 1.57293, 1.11144, 1.21237, 0.74627, 1.31818, 1.06585, 0.97042, 0.83055, 0.97042, 0.93503, 1.1261, 0.97042, 0.97922, 1.14236, 0.94552, 1.01054, 1.14236, 1.02471, 0.97922, 0.94165, 0.97042, 0.97042, 1.0276, 0.78929, 1.1261, 0.97922, 0.95874, 1.02197, 0.98507, 0.96752, 0.97168, 0.95107, 1.16579, 0.95107, 1.21237, 1.03959, 1.036, 1.036, 1, 1.036, 1.16579, 0.87357, 1.31818, 1.18754, 1.26781, 1.05356, 1.21237, 1.18622, 0.79487, 0.94994, 1.29004, 1.24047, 1.24047, 1.31818, 1, 0.91484, 0.9754, 1.31818, 1.1349, 1.24866, 1.05356, 1.13934, 1.15574, 1.17389, 0.73541, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.94385, 0.87897, 0.79429, 0.79429, 0.79429, 0.79429, 1.1406, 1.1406, 1.1406, 1.1406, 1.0426, 1.10615, 0.97552, 0.97552, 0.97552, 0.97552, 0.97552, 1.21237, 0.97552, 1.00135, 1.00135, 1.00135, 1.00135, 0.91142, 0.94436, 0.98721, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 0.96705, 0.83055, 0.93503, 0.93503, 0.93503, 0.93503, 1.14236, 1.14236, 1.14236, 1.14236, 0.93125, 0.97922, 0.94165, 0.94165, 0.94165, 0.94165, 0.94165, 1.29004, 0.94165, 0.97922, 0.97922, 0.97922, 0.97922, 0.96752, 0.97042, 0.96752, 0.97363, 1.06585, 0.97363, 1.06585, 0.97363, 1.06585, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 1.0426, 1.0033, 1.0426, 0.97042, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.91149, 0.97042, 0.91149, 0.97042, 0.91149, 0.97042, 1, 1, 1.05815, 0.97922, 1.05815, 0.97922, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 0.97441, 1.04302, 0.79631, 1.01582, 1, 1, 1.01054, 0.83853, 1.14236, 1, 1, 0.83853, 1.09125, 0.83853, 0.90418, 0.83853, 1.19508, 1.10615, 0.97922, 1, 1, 1.10615, 0.97922, 1.01034, 1.10466, 0.97922, 0.97552, 0.94165, 0.97552, 0.94165, 0.97552, 0.94165, 0.91602, 0.91981, 0.88641, 1.0276, 1, 1, 0.88641, 1.0276, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 1, 1, 0.96083, 1.05403, 0.95923, 1.16862, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.06777, 1.02197, 0.91142, 0.96752, 0.91142, 0.99361, 0.97168, 0.99361, 0.97168, 0.99361, 0.97168, 1.23199, 1.036, 0.97363, 1.06585, 0.94385, 0.96705, 0.97552, 0.94165, 1, 1, 0.96083, 1.1261, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 0.95161, 1.27126, 1.00811, 0.83284, 0.77702, 0.99137, 0.95253, 1.0347, 0.86142, 1.07205, 1.14236, 0.97363, 0.89723, 0.86869, 1.09818, 0.79429, 0.99361, 1.05815, 0.97552, 1.1406, 0.90128, 1.06662, 1.04396, 1.10615, 0.84918, 0.97552, 1.04694, 0.94436, 0.98015, 0.96083, 0.91142, 1.00356, 0.9817, 1.01945, 0.98999, 1.1406, 0.91142, 1.04961, 0.9898, 1.00639, 1.14236, 1.07514, 1.04961, 0.99607, 1.02897, 1.008, 0.9898, 0.95134, 1.00639, 1.11121, 1.14236, 1.00518, 0.97981, 1.02186, 1, 1.08578, 0.94165, 0.99314, 0.98387, 0.93028, 0.93377, 1.35125, 1.07514, 1.10687, 0.93491, 1.04232, 1.00351, 1.14236, 1.07514, 0.94165, 1.07514, 1.00351, 0.79429, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09097, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.93503, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96609, 1, 1, 1, 1, 1, 1, 1.06777, 1.02197, 1.06777, 1.02197, 1.06777, 1.02197, 0.91142, 0.96752, 1, 1.21261, 0.89903, 1, 1, 0.75155, 1.04745, 1.04745, 1.04745, 1.04394, 0.98633, 0.98633, 0.98633, 0.72959, 0.72959, 1.20502, 0.91406, 1.26514, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.09125, 0.93327, 1.03336, 1.16541, 1.036, 1, 1, 1, 0.771, 1, 1, 1.15574, 1.15574, 1.15574, 1.15574, 0.86364, 0.94434, 0.86279, 0.94434, 0.86224, 1, 1, 1.16798, 1, 0.96085, 0.90068, 1.21237, 1.18416, 1.13904, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21339, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18775, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.13269, 1.13269, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.SegoeuiBoldItalicFactors = SegoeuiBoldItalicFactors;
const SegoeuiBoldItalicMetrics = {
  lineHeight: 1.33008,
  lineGap: 0
};
exports.SegoeuiBoldItalicMetrics = SegoeuiBoldItalicMetrics;
const SegoeuiItalicFactors = [1.76738, 1, 1, 0.98946, 1.14763, 1.05365, 1.06234, 0.96927, 0.92586, 1.15373, 1.18414, 0.91349, 0.91349, 1.07403, 1.17308, 0.78383, 1.20088, 0.78383, 1.42531, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78383, 0.78383, 1.17308, 1.17308, 1.17308, 0.77349, 0.94565, 0.94729, 0.85944, 0.88506, 0.9858, 0.74817, 0.80016, 0.88449, 0.98039, 0.95782, 0.69238, 0.89898, 0.83231, 0.98183, 1.03989, 0.96924, 0.86237, 0.96924, 0.80595, 0.74524, 0.86091, 0.95402, 0.94143, 0.98448, 0.8858, 0.83089, 0.93285, 1.0949, 1.39016, 1.0949, 1.45994, 0.74627, 1.04839, 0.97454, 0.97454, 0.87207, 0.97454, 0.87533, 1.06151, 0.97454, 1.00176, 1.16484, 1.08132, 0.98047, 1.16484, 1.02989, 1.01054, 0.96225, 0.97454, 0.97454, 1.06598, 0.79004, 1.16344, 1.00351, 0.94629, 0.9973, 0.91016, 0.96777, 0.9043, 0.91082, 0.92481, 0.91082, 1.17308, 0.95748, 0.96927, 0.96927, 1, 0.96927, 0.92481, 0.80597, 1.04839, 1.23393, 1.1781, 0.9245, 1.17308, 1.20808, 0.63218, 0.94261, 1.24822, 1.09971, 1.09971, 1.04839, 1, 0.85273, 0.78032, 1.04839, 1.09971, 1.22326, 0.9245, 1.09836, 1.13525, 1.15222, 0.70424, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.85498, 0.88506, 0.74817, 0.74817, 0.74817, 0.74817, 0.95782, 0.95782, 0.95782, 0.95782, 0.9858, 1.03989, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.17308, 0.96924, 0.95402, 0.95402, 0.95402, 0.95402, 0.83089, 0.86237, 0.88409, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.92916, 0.87207, 0.87533, 0.87533, 0.87533, 0.87533, 0.93146, 0.93146, 0.93146, 0.93146, 0.93854, 1.01054, 0.96225, 0.96225, 0.96225, 0.96225, 0.96225, 1.24822, 0.8761, 1.00351, 1.00351, 1.00351, 1.00351, 0.96777, 0.97454, 0.96777, 0.94729, 0.97454, 0.94729, 0.97454, 0.94729, 0.97454, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.9858, 0.95391, 0.9858, 0.97454, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.88449, 0.97454, 0.88449, 0.97454, 0.88449, 0.97454, 1, 1, 0.98039, 1.00176, 0.98039, 1.00176, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 1.16484, 0.95782, 0.93146, 0.84421, 1.12761, 0.69238, 1.08132, 1, 1, 0.98047, 0.83231, 1.16484, 1, 1, 0.84723, 1.04861, 0.84723, 0.78755, 0.83231, 1.23736, 1.03989, 1.01054, 1, 1, 1.03989, 1.01054, 0.9857, 1.03849, 1.01054, 0.96924, 0.96225, 0.96924, 0.96225, 0.96924, 0.96225, 0.92383, 0.90171, 0.80595, 1.06598, 1, 1, 0.80595, 1.06598, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 1, 1, 0.86091, 1.02759, 0.85771, 1.16344, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.98448, 0.9973, 0.83089, 0.96777, 0.83089, 0.93285, 0.9043, 0.93285, 0.9043, 0.93285, 0.9043, 1.31868, 0.96927, 0.94729, 0.97454, 0.85498, 0.92916, 0.96924, 0.8761, 1, 1, 0.86091, 1.16344, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 0.81965, 0.81965, 0.94729, 0.78032, 0.71022, 0.90883, 0.84171, 0.99877, 0.77596, 1.05734, 1.2, 0.94729, 0.85944, 0.82791, 0.9607, 0.74817, 0.93285, 0.98039, 0.96924, 0.95782, 0.89898, 0.98316, 0.98183, 1.03989, 0.78614, 0.96924, 0.97642, 0.86237, 0.86075, 0.86091, 0.83089, 0.90082, 0.8858, 0.97296, 1.01284, 0.95782, 0.83089, 1.0976, 1.04, 1.03342, 1.2, 1.0675, 1.0976, 0.98205, 1.03809, 1.05097, 1.04, 0.95364, 1.03342, 1.05401, 1.2, 1.02148, 1.0119, 1.04724, 1.0127, 1.02732, 0.96225, 0.8965, 0.97783, 0.93574, 0.94818, 1.30679, 1.0675, 1.11826, 0.99821, 1.0557, 1.0326, 1.2, 1.0675, 0.96225, 1.0675, 1.0326, 0.74817, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03754, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87533, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.98705, 1, 1, 1, 1, 1, 1, 0.98448, 0.9973, 0.98448, 0.9973, 0.98448, 0.9973, 0.83089, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 0.94945, 0.94945, 0.94945, 0.94945, 1.12317, 1.12317, 1.12317, 0.67603, 0.67603, 1.15621, 0.73584, 1.21191, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87709, 0.96927, 1.01473, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.09836, 1.09836, 1.09836, 1.01522, 0.86321, 0.94434, 0.8649, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86438, 1.17308, 1.18416, 1.14589, 0.69825, 0.97622, 1.96791, 1.24822, 1.24822, 1.17308, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.17984, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10742, 1.10742, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.SegoeuiItalicFactors = SegoeuiItalicFactors;
const SegoeuiItalicMetrics = {
  lineHeight: 1.33008,
  lineGap: 0
};
exports.SegoeuiItalicMetrics = SegoeuiItalicMetrics;
const SegoeuiRegularFactors = [1.76738, 1, 1, 0.98594, 1.02285, 1.10454, 1.06234, 0.96927, 0.92037, 1.19985, 1.2046, 0.90616, 0.90616, 1.07152, 1.1714, 0.78032, 1.20088, 0.78032, 1.40246, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78032, 0.78032, 1.1714, 1.1714, 1.1714, 0.80597, 0.94084, 0.96706, 0.85944, 0.85734, 0.97093, 0.75842, 0.79936, 0.88198, 0.9831, 0.95782, 0.71387, 0.86969, 0.84636, 1.07796, 1.03584, 0.96924, 0.83968, 0.96924, 0.82826, 0.79649, 0.85771, 0.95132, 0.93119, 0.98965, 0.88433, 0.8287, 0.93365, 1.08612, 1.3638, 1.08612, 1.45786, 0.74627, 0.80499, 0.91484, 1.05707, 0.92383, 1.05882, 0.9403, 1.12654, 1.05882, 1.01756, 1.09011, 1.09011, 0.99414, 1.09011, 1.034, 1.01756, 1.05356, 1.05707, 1.05882, 1.04399, 0.84863, 1.21968, 1.01756, 0.95801, 1.00068, 0.91797, 0.96777, 0.9043, 0.90351, 0.92105, 0.90351, 1.1714, 0.85337, 0.96927, 0.96927, 0.99912, 0.96927, 0.92105, 0.80597, 1.2434, 1.20808, 1.05937, 0.90957, 1.1714, 1.20808, 0.75155, 0.94261, 1.24644, 1.09971, 1.09971, 0.84751, 1, 0.85273, 0.78032, 0.61584, 1.05425, 1.17914, 0.90957, 1.08665, 1.11593, 1.14169, 0.73381, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.86035, 0.85734, 0.75842, 0.75842, 0.75842, 0.75842, 0.95782, 0.95782, 0.95782, 0.95782, 0.97093, 1.03584, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.1714, 0.96924, 0.95132, 0.95132, 0.95132, 0.95132, 0.8287, 0.83968, 0.89049, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.93575, 0.92383, 0.9403, 0.9403, 0.9403, 0.9403, 0.8717, 0.8717, 0.8717, 0.8717, 1.00527, 1.01756, 1.05356, 1.05356, 1.05356, 1.05356, 1.05356, 1.24644, 0.95923, 1.01756, 1.01756, 1.01756, 1.01756, 0.96777, 1.05707, 0.96777, 0.96706, 0.91484, 0.96706, 0.91484, 0.96706, 0.91484, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.97093, 1.0969, 0.97093, 1.05882, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.88198, 1.05882, 0.88198, 1.05882, 0.88198, 1.05882, 1, 1, 0.9831, 1.01756, 0.9831, 1.01756, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 1.09011, 0.95782, 0.8717, 0.84784, 1.11551, 0.71387, 1.09011, 1, 1, 0.99414, 0.84636, 1.09011, 1, 1, 0.84636, 1.0536, 0.84636, 0.94298, 0.84636, 1.23297, 1.03584, 1.01756, 1, 1, 1.03584, 1.01756, 1.00323, 1.03444, 1.01756, 0.96924, 1.05356, 0.96924, 1.05356, 0.96924, 1.05356, 0.93066, 0.98293, 0.82826, 1.04399, 1, 1, 0.82826, 1.04399, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 1, 1, 0.85771, 1.17318, 0.85771, 1.21968, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.98965, 1.00068, 0.8287, 0.96777, 0.8287, 0.93365, 0.9043, 0.93365, 0.9043, 0.93365, 0.9043, 1.08571, 0.96927, 0.96706, 0.91484, 0.86035, 0.93575, 0.96924, 0.95923, 1, 1, 0.85771, 1.21968, 1.11437, 1.11437, 0.93109, 0.91202, 0.60411, 0.84164, 0.55572, 1.01173, 0.97361, 0.81818, 0.81818, 0.96635, 0.78032, 0.72727, 0.92366, 0.98601, 1.03405, 0.77968, 1.09799, 1.2, 0.96706, 0.85944, 0.85638, 0.96491, 0.75842, 0.93365, 0.9831, 0.96924, 0.95782, 0.86969, 0.94152, 1.07796, 1.03584, 0.78437, 0.96924, 0.98715, 0.83968, 0.83491, 0.85771, 0.8287, 0.94492, 0.88433, 0.9287, 1.0098, 0.95782, 0.8287, 1.0625, 0.98248, 1.03424, 1.2, 1.01071, 1.0625, 0.95246, 1.03809, 1.04912, 0.98248, 1.00221, 1.03424, 1.05443, 1.2, 1.04785, 0.99609, 1.00169, 1.05176, 0.99346, 1.05356, 0.9087, 1.03004, 0.95542, 0.93117, 1.23362, 1.01071, 1.07831, 1.02512, 1.05205, 1.03502, 1.2, 1.01071, 1.05356, 1.01071, 1.03502, 0.75842, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03719, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9403, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04021, 1, 1, 1, 1, 1, 1, 0.98965, 1.00068, 0.98965, 1.00068, 0.98965, 1.00068, 0.8287, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 1.03077, 1.03077, 1.03077, 1.03077, 1.13196, 1.13196, 1.13196, 0.67428, 0.67428, 1.16039, 0.73291, 1.20996, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87796, 0.96927, 1.01518, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.10539, 1.10539, 1.11358, 1.06967, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86507, 1.1714, 1.18416, 1.14589, 0.69825, 0.97622, 1.9697, 1.24822, 1.24822, 1.17238, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18083, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10938, 1.10938, 1, 1, 1, 1.05425, 1.09971, 1.09971, 1.09971, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.SegoeuiRegularFactors = SegoeuiRegularFactors;
const SegoeuiRegularMetrics = {
  lineHeight: 1.33008,
  lineGap: 0
};
exports.SegoeuiRegularMetrics = SegoeuiRegularMetrics;

/***/ }),
/* 57 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PostScriptEvaluator = exports.PostScriptCompiler = exports.PDFFunctionFactory = void 0;
exports.isPDFFunction = isPDFFunction;
var _primitives = __w_pdfjs_require__(4);
var _util = __w_pdfjs_require__(2);
var _ps_parser = __w_pdfjs_require__(58);
var _base_stream = __w_pdfjs_require__(5);
var _image_utils = __w_pdfjs_require__(59);
class PDFFunctionFactory {
  constructor({
    xref,
    isEvalSupported = true
  }) {
    this.xref = xref;
    this.isEvalSupported = isEvalSupported !== false;
  }
  create(fn) {
    const cachedFunction = this.getCached(fn);
    if (cachedFunction) {
      return cachedFunction;
    }
    const parsedFunction = PDFFunction.parse({
      xref: this.xref,
      isEvalSupported: this.isEvalSupported,
      fn: fn instanceof _primitives.Ref ? this.xref.fetch(fn) : fn
    });
    this._cache(fn, parsedFunction);
    return parsedFunction;
  }
  createFromArray(fnObj) {
    const cachedFunction = this.getCached(fnObj);
    if (cachedFunction) {
      return cachedFunction;
    }
    const parsedFunction = PDFFunction.parseArray({
      xref: this.xref,
      isEvalSupported: this.isEvalSupported,
      fnObj: fnObj instanceof _primitives.Ref ? this.xref.fetch(fnObj) : fnObj
    });
    this._cache(fnObj, parsedFunction);
    return parsedFunction;
  }
  getCached(cacheKey) {
    let fnRef;
    if (cacheKey instanceof _primitives.Ref) {
      fnRef = cacheKey;
    } else if (cacheKey instanceof _primitives.Dict) {
      fnRef = cacheKey.objId;
    } else if (cacheKey instanceof _base_stream.BaseStream) {
      fnRef = cacheKey.dict?.objId;
    }
    if (fnRef) {
      const localFunction = this._localFunctionCache.getByRef(fnRef);
      if (localFunction) {
        return localFunction;
      }
    }
    return null;
  }
  _cache(cacheKey, parsedFunction) {
    if (!parsedFunction) {
      throw new Error('PDFFunctionFactory._cache - expected "parsedFunction" argument.');
    }
    let fnRef;
    if (cacheKey instanceof _primitives.Ref) {
      fnRef = cacheKey;
    } else if (cacheKey instanceof _primitives.Dict) {
      fnRef = cacheKey.objId;
    } else if (cacheKey instanceof _base_stream.BaseStream) {
      fnRef = cacheKey.dict?.objId;
    }
    if (fnRef) {
      this._localFunctionCache.set(null, fnRef, parsedFunction);
    }
  }
  get _localFunctionCache() {
    return (0, _util.shadow)(this, "_localFunctionCache", new _image_utils.LocalFunctionCache());
  }
}
exports.PDFFunctionFactory = PDFFunctionFactory;
function toNumberArray(arr) {
  if (!Array.isArray(arr)) {
    return null;
  }
  const length = arr.length;
  for (let i = 0; i < length; i++) {
    if (typeof arr[i] !== "number") {
      const result = new Array(length);
      for (let j = 0; j < length; j++) {
        result[j] = +arr[j];
      }
      return result;
    }
  }
  return arr;
}
class PDFFunction {
  static getSampleArray(size, outputSize, bps, stream) {
    let i, ii;
    let length = 1;
    for (i = 0, ii = size.length; i < ii; i++) {
      length *= size[i];
    }
    length *= outputSize;
    const array = new Array(length);
    let codeSize = 0;
    let codeBuf = 0;
    const sampleMul = 1.0 / (2.0 ** bps - 1);
    const strBytes = stream.getBytes((length * bps + 7) / 8);
    let strIdx = 0;
    for (i = 0; i < length; i++) {
      while (codeSize < bps) {
        codeBuf <<= 8;
        codeBuf |= strBytes[strIdx++];
        codeSize += 8;
      }
      codeSize -= bps;
      array[i] = (codeBuf >> codeSize) * sampleMul;
      codeBuf &= (1 << codeSize) - 1;
    }
    return array;
  }
  static parse({
    xref,
    isEvalSupported,
    fn
  }) {
    const dict = fn.dict || fn;
    const typeNum = dict.get("FunctionType");
    switch (typeNum) {
      case 0:
        return this.constructSampled({
          xref,
          isEvalSupported,
          fn,
          dict
        });
      case 1:
        break;
      case 2:
        return this.constructInterpolated({
          xref,
          isEvalSupported,
          dict
        });
      case 3:
        return this.constructStiched({
          xref,
          isEvalSupported,
          dict
        });
      case 4:
        return this.constructPostScript({
          xref,
          isEvalSupported,
          fn,
          dict
        });
    }
    throw new _util.FormatError("Unknown type of function");
  }
  static parseArray({
    xref,
    isEvalSupported,
    fnObj
  }) {
    if (!Array.isArray(fnObj)) {
      return this.parse({
        xref,
        isEvalSupported,
        fn: fnObj
      });
    }
    const fnArray = [];
    for (const fn of fnObj) {
      fnArray.push(this.parse({
        xref,
        isEvalSupported,
        fn: xref.fetchIfRef(fn)
      }));
    }
    return function (src, srcOffset, dest, destOffset) {
      for (let i = 0, ii = fnArray.length; i < ii; i++) {
        fnArray[i](src, srcOffset, dest, destOffset + i);
      }
    };
  }
  static constructSampled({
    xref,
    isEvalSupported,
    fn,
    dict
  }) {
    function toMultiArray(arr) {
      const inputLength = arr.length;
      const out = [];
      let index = 0;
      for (let i = 0; i < inputLength; i += 2) {
        out[index++] = [arr[i], arr[i + 1]];
      }
      return out;
    }
    function interpolate(x, xmin, xmax, ymin, ymax) {
      return ymin + (x - xmin) * ((ymax - ymin) / (xmax - xmin));
    }
    let domain = toNumberArray(dict.getArray("Domain"));
    let range = toNumberArray(dict.getArray("Range"));
    if (!domain || !range) {
      throw new _util.FormatError("No domain or range");
    }
    const inputSize = domain.length / 2;
    const outputSize = range.length / 2;
    domain = toMultiArray(domain);
    range = toMultiArray(range);
    const size = toNumberArray(dict.getArray("Size"));
    const bps = dict.get("BitsPerSample");
    const order = dict.get("Order") || 1;
    if (order !== 1) {
      (0, _util.info)("No support for cubic spline interpolation: " + order);
    }
    let encode = toNumberArray(dict.getArray("Encode"));
    if (!encode) {
      encode = [];
      for (let i = 0; i < inputSize; ++i) {
        encode.push([0, size[i] - 1]);
      }
    } else {
      encode = toMultiArray(encode);
    }
    let decode = toNumberArray(dict.getArray("Decode"));
    decode = !decode ? range : toMultiArray(decode);
    const samples = this.getSampleArray(size, outputSize, bps, fn);
    return function constructSampledFn(src, srcOffset, dest, destOffset) {
      const cubeVertices = 1 << inputSize;
      const cubeN = new Float64Array(cubeVertices);
      const cubeVertex = new Uint32Array(cubeVertices);
      let i, j;
      for (j = 0; j < cubeVertices; j++) {
        cubeN[j] = 1;
      }
      let k = outputSize,
        pos = 1;
      for (i = 0; i < inputSize; ++i) {
        const domain_2i = domain[i][0];
        const domain_2i_1 = domain[i][1];
        const xi = Math.min(Math.max(src[srcOffset + i], domain_2i), domain_2i_1);
        let e = interpolate(xi, domain_2i, domain_2i_1, encode[i][0], encode[i][1]);
        const size_i = size[i];
        e = Math.min(Math.max(e, 0), size_i - 1);
        const e0 = e < size_i - 1 ? Math.floor(e) : e - 1;
        const n0 = e0 + 1 - e;
        const n1 = e - e0;
        const offset0 = e0 * k;
        const offset1 = offset0 + k;
        for (j = 0; j < cubeVertices; j++) {
          if (j & pos) {
            cubeN[j] *= n1;
            cubeVertex[j] += offset1;
          } else {
            cubeN[j] *= n0;
            cubeVertex[j] += offset0;
          }
        }
        k *= size_i;
        pos <<= 1;
      }
      for (j = 0; j < outputSize; ++j) {
        let rj = 0;
        for (i = 0; i < cubeVertices; i++) {
          rj += samples[cubeVertex[i] + j] * cubeN[i];
        }
        rj = interpolate(rj, 0, 1, decode[j][0], decode[j][1]);
        dest[destOffset + j] = Math.min(Math.max(rj, range[j][0]), range[j][1]);
      }
    };
  }
  static constructInterpolated({
    xref,
    isEvalSupported,
    dict
  }) {
    const c0 = toNumberArray(dict.getArray("C0")) || [0];
    const c1 = toNumberArray(dict.getArray("C1")) || [1];
    const n = dict.get("N");
    const diff = [];
    for (let i = 0, ii = c0.length; i < ii; ++i) {
      diff.push(c1[i] - c0[i]);
    }
    const length = diff.length;
    return function constructInterpolatedFn(src, srcOffset, dest, destOffset) {
      const x = n === 1 ? src[srcOffset] : src[srcOffset] ** n;
      for (let j = 0; j < length; ++j) {
        dest[destOffset + j] = c0[j] + x * diff[j];
      }
    };
  }
  static constructStiched({
    xref,
    isEvalSupported,
    dict
  }) {
    const domain = toNumberArray(dict.getArray("Domain"));
    if (!domain) {
      throw new _util.FormatError("No domain");
    }
    const inputSize = domain.length / 2;
    if (inputSize !== 1) {
      throw new _util.FormatError("Bad domain for stiched function");
    }
    const fns = [];
    for (const fn of dict.get("Functions")) {
      fns.push(this.parse({
        xref,
        isEvalSupported,
        fn: xref.fetchIfRef(fn)
      }));
    }
    const bounds = toNumberArray(dict.getArray("Bounds"));
    const encode = toNumberArray(dict.getArray("Encode"));
    const tmpBuf = new Float32Array(1);
    return function constructStichedFn(src, srcOffset, dest, destOffset) {
      const clip = function constructStichedFromIRClip(v, min, max) {
        if (v > max) {
          v = max;
        } else if (v < min) {
          v = min;
        }
        return v;
      };
      const v = clip(src[srcOffset], domain[0], domain[1]);
      const length = bounds.length;
      let i;
      for (i = 0; i < length; ++i) {
        if (v < bounds[i]) {
          break;
        }
      }
      let dmin = domain[0];
      if (i > 0) {
        dmin = bounds[i - 1];
      }
      let dmax = domain[1];
      if (i < bounds.length) {
        dmax = bounds[i];
      }
      const rmin = encode[2 * i];
      const rmax = encode[2 * i + 1];
      tmpBuf[0] = dmin === dmax ? rmin : rmin + (v - dmin) * (rmax - rmin) / (dmax - dmin);
      fns[i](tmpBuf, 0, dest, destOffset);
    };
  }
  static constructPostScript({
    xref,
    isEvalSupported,
    fn,
    dict
  }) {
    const domain = toNumberArray(dict.getArray("Domain"));
    const range = toNumberArray(dict.getArray("Range"));
    if (!domain) {
      throw new _util.FormatError("No domain.");
    }
    if (!range) {
      throw new _util.FormatError("No range.");
    }
    const lexer = new _ps_parser.PostScriptLexer(fn);
    const parser = new _ps_parser.PostScriptParser(lexer);
    const code = parser.parse();
    if (isEvalSupported && _util.FeatureTest.isEvalSupported) {
      const compiled = new PostScriptCompiler().compile(code, domain, range);
      if (compiled) {
        return new Function("src", "srcOffset", "dest", "destOffset", compiled);
      }
    }
    (0, _util.info)("Unable to compile PS function");
    const numOutputs = range.length >> 1;
    const numInputs = domain.length >> 1;
    const evaluator = new PostScriptEvaluator(code);
    const cache = Object.create(null);
    const MAX_CACHE_SIZE = 2048 * 4;
    let cache_available = MAX_CACHE_SIZE;
    const tmpBuf = new Float32Array(numInputs);
    return function constructPostScriptFn(src, srcOffset, dest, destOffset) {
      let i, value;
      let key = "";
      const input = tmpBuf;
      for (i = 0; i < numInputs; i++) {
        value = src[srcOffset + i];
        input[i] = value;
        key += value + "_";
      }
      const cachedValue = cache[key];
      if (cachedValue !== undefined) {
        dest.set(cachedValue, destOffset);
        return;
      }
      const output = new Float32Array(numOutputs);
      const stack = evaluator.execute(input);
      const stackIndex = stack.length - numOutputs;
      for (i = 0; i < numOutputs; i++) {
        value = stack[stackIndex + i];
        let bound = range[i * 2];
        if (value < bound) {
          value = bound;
        } else {
          bound = range[i * 2 + 1];
          if (value > bound) {
            value = bound;
          }
        }
        output[i] = value;
      }
      if (cache_available > 0) {
        cache_available--;
        cache[key] = output;
      }
      dest.set(output, destOffset);
    };
  }
}
function isPDFFunction(v) {
  let fnDict;
  if (v instanceof _primitives.Dict) {
    fnDict = v;
  } else if (v instanceof _base_stream.BaseStream) {
    fnDict = v.dict;
  } else {
    return false;
  }
  return fnDict.has("FunctionType");
}
class PostScriptStack {
  static MAX_STACK_SIZE = 100;
  constructor(initialStack) {
    this.stack = initialStack ? Array.from(initialStack) : [];
  }
  push(value) {
    if (this.stack.length >= PostScriptStack.MAX_STACK_SIZE) {
      throw new Error("PostScript function stack overflow.");
    }
    this.stack.push(value);
  }
  pop() {
    if (this.stack.length <= 0) {
      throw new Error("PostScript function stack underflow.");
    }
    return this.stack.pop();
  }
  copy(n) {
    if (this.stack.length + n >= PostScriptStack.MAX_STACK_SIZE) {
      throw new Error("PostScript function stack overflow.");
    }
    const stack = this.stack;
    for (let i = stack.length - n, j = n - 1; j >= 0; j--, i++) {
      stack.push(stack[i]);
    }
  }
  index(n) {
    this.push(this.stack[this.stack.length - n - 1]);
  }
  roll(n, p) {
    const stack = this.stack;
    const l = stack.length - n;
    const r = stack.length - 1;
    const c = l + (p - Math.floor(p / n) * n);
    for (let i = l, j = r; i < j; i++, j--) {
      const t = stack[i];
      stack[i] = stack[j];
      stack[j] = t;
    }
    for (let i = l, j = c - 1; i < j; i++, j--) {
      const t = stack[i];
      stack[i] = stack[j];
      stack[j] = t;
    }
    for (let i = c, j = r; i < j; i++, j--) {
      const t = stack[i];
      stack[i] = stack[j];
      stack[j] = t;
    }
  }
}
class PostScriptEvaluator {
  constructor(operators) {
    this.operators = operators;
  }
  execute(initialStack) {
    const stack = new PostScriptStack(initialStack);
    let counter = 0;
    const operators = this.operators;
    const length = operators.length;
    let operator, a, b;
    while (counter < length) {
      operator = operators[counter++];
      if (typeof operator === "number") {
        stack.push(operator);
        continue;
      }
      switch (operator) {
        case "jz":
          b = stack.pop();
          a = stack.pop();
          if (!a) {
            counter = b;
          }
          break;
        case "j":
          a = stack.pop();
          counter = a;
          break;
        case "abs":
          a = stack.pop();
          stack.push(Math.abs(a));
          break;
        case "add":
          b = stack.pop();
          a = stack.pop();
          stack.push(a + b);
          break;
        case "and":
          b = stack.pop();
          a = stack.pop();
          if (typeof a === "boolean" && typeof b === "boolean") {
            stack.push(a && b);
          } else {
            stack.push(a & b);
          }
          break;
        case "atan":
          b = stack.pop();
          a = stack.pop();
          a = Math.atan2(a, b) / Math.PI * 180;
          if (a < 0) {
            a += 360;
          }
          stack.push(a);
          break;
        case "bitshift":
          b = stack.pop();
          a = stack.pop();
          if (a > 0) {
            stack.push(a << b);
          } else {
            stack.push(a >> b);
          }
          break;
        case "ceiling":
          a = stack.pop();
          stack.push(Math.ceil(a));
          break;
        case "copy":
          a = stack.pop();
          stack.copy(a);
          break;
        case "cos":
          a = stack.pop();
          stack.push(Math.cos(a % 360 / 180 * Math.PI));
          break;
        case "cvi":
          a = stack.pop() | 0;
          stack.push(a);
          break;
        case "cvr":
          break;
        case "div":
          b = stack.pop();
          a = stack.pop();
          stack.push(a / b);
          break;
        case "dup":
          stack.copy(1);
          break;
        case "eq":
          b = stack.pop();
          a = stack.pop();
          stack.push(a === b);
          break;
        case "exch":
          stack.roll(2, 1);
          break;
        case "exp":
          b = stack.pop();
          a = stack.pop();
          stack.push(a ** b);
          break;
        case "false":
          stack.push(false);
          break;
        case "floor":
          a = stack.pop();
          stack.push(Math.floor(a));
          break;
        case "ge":
          b = stack.pop();
          a = stack.pop();
          stack.push(a >= b);
          break;
        case "gt":
          b = stack.pop();
          a = stack.pop();
          stack.push(a > b);
          break;
        case "idiv":
          b = stack.pop();
          a = stack.pop();
          stack.push(a / b | 0);
          break;
        case "index":
          a = stack.pop();
          stack.index(a);
          break;
        case "le":
          b = stack.pop();
          a = stack.pop();
          stack.push(a <= b);
          break;
        case "ln":
          a = stack.pop();
          stack.push(Math.log(a));
          break;
        case "log":
          a = stack.pop();
          stack.push(Math.log10(a));
          break;
        case "lt":
          b = stack.pop();
          a = stack.pop();
          stack.push(a < b);
          break;
        case "mod":
          b = stack.pop();
          a = stack.pop();
          stack.push(a % b);
          break;
        case "mul":
          b = stack.pop();
          a = stack.pop();
          stack.push(a * b);
          break;
        case "ne":
          b = stack.pop();
          a = stack.pop();
          stack.push(a !== b);
          break;
        case "neg":
          a = stack.pop();
          stack.push(-a);
          break;
        case "not":
          a = stack.pop();
          if (typeof a === "boolean") {
            stack.push(!a);
          } else {
            stack.push(~a);
          }
          break;
        case "or":
          b = stack.pop();
          a = stack.pop();
          if (typeof a === "boolean" && typeof b === "boolean") {
            stack.push(a || b);
          } else {
            stack.push(a | b);
          }
          break;
        case "pop":
          stack.pop();
          break;
        case "roll":
          b = stack.pop();
          a = stack.pop();
          stack.roll(a, b);
          break;
        case "round":
          a = stack.pop();
          stack.push(Math.round(a));
          break;
        case "sin":
          a = stack.pop();
          stack.push(Math.sin(a % 360 / 180 * Math.PI));
          break;
        case "sqrt":
          a = stack.pop();
          stack.push(Math.sqrt(a));
          break;
        case "sub":
          b = stack.pop();
          a = stack.pop();
          stack.push(a - b);
          break;
        case "true":
          stack.push(true);
          break;
        case "truncate":
          a = stack.pop();
          a = a < 0 ? Math.ceil(a) : Math.floor(a);
          stack.push(a);
          break;
        case "xor":
          b = stack.pop();
          a = stack.pop();
          if (typeof a === "boolean" && typeof b === "boolean") {
            stack.push(a !== b);
          } else {
            stack.push(a ^ b);
          }
          break;
        default:
          throw new _util.FormatError(`Unknown operator ${operator}`);
      }
    }
    return stack.stack;
  }
}
exports.PostScriptEvaluator = PostScriptEvaluator;
class AstNode {
  constructor(type) {
    this.type = type;
  }
  visit(visitor) {
    (0, _util.unreachable)("abstract method");
  }
}
class AstArgument extends AstNode {
  constructor(index, min, max) {
    super("args");
    this.index = index;
    this.min = min;
    this.max = max;
  }
  visit(visitor) {
    visitor.visitArgument(this);
  }
}
class AstLiteral extends AstNode {
  constructor(number) {
    super("literal");
    this.number = number;
    this.min = number;
    this.max = number;
  }
  visit(visitor) {
    visitor.visitLiteral(this);
  }
}
class AstBinaryOperation extends AstNode {
  constructor(op, arg1, arg2, min, max) {
    super("binary");
    this.op = op;
    this.arg1 = arg1;
    this.arg2 = arg2;
    this.min = min;
    this.max = max;
  }
  visit(visitor) {
    visitor.visitBinaryOperation(this);
  }
}
class AstMin extends AstNode {
  constructor(arg, max) {
    super("max");
    this.arg = arg;
    this.min = arg.min;
    this.max = max;
  }
  visit(visitor) {
    visitor.visitMin(this);
  }
}
class AstVariable extends AstNode {
  constructor(index, min, max) {
    super("var");
    this.index = index;
    this.min = min;
    this.max = max;
  }
  visit(visitor) {
    visitor.visitVariable(this);
  }
}
class AstVariableDefinition extends AstNode {
  constructor(variable, arg) {
    super("definition");
    this.variable = variable;
    this.arg = arg;
  }
  visit(visitor) {
    visitor.visitVariableDefinition(this);
  }
}
class ExpressionBuilderVisitor {
  constructor() {
    this.parts = [];
  }
  visitArgument(arg) {
    this.parts.push("Math.max(", arg.min, ", Math.min(", arg.max, ", src[srcOffset + ", arg.index, "]))");
  }
  visitVariable(variable) {
    this.parts.push("v", variable.index);
  }
  visitLiteral(literal) {
    this.parts.push(literal.number);
  }
  visitBinaryOperation(operation) {
    this.parts.push("(");
    operation.arg1.visit(this);
    this.parts.push(" ", operation.op, " ");
    operation.arg2.visit(this);
    this.parts.push(")");
  }
  visitVariableDefinition(definition) {
    this.parts.push("var ");
    definition.variable.visit(this);
    this.parts.push(" = ");
    definition.arg.visit(this);
    this.parts.push(";");
  }
  visitMin(max) {
    this.parts.push("Math.min(");
    max.arg.visit(this);
    this.parts.push(", ", max.max, ")");
  }
  toString() {
    return this.parts.join("");
  }
}
function buildAddOperation(num1, num2) {
  if (num2.type === "literal" && num2.number === 0) {
    return num1;
  }
  if (num1.type === "literal" && num1.number === 0) {
    return num2;
  }
  if (num2.type === "literal" && num1.type === "literal") {
    return new AstLiteral(num1.number + num2.number);
  }
  return new AstBinaryOperation("+", num1, num2, num1.min + num2.min, num1.max + num2.max);
}
function buildMulOperation(num1, num2) {
  if (num2.type === "literal") {
    if (num2.number === 0) {
      return new AstLiteral(0);
    } else if (num2.number === 1) {
      return num1;
    } else if (num1.type === "literal") {
      return new AstLiteral(num1.number * num2.number);
    }
  }
  if (num1.type === "literal") {
    if (num1.number === 0) {
      return new AstLiteral(0);
    } else if (num1.number === 1) {
      return num2;
    }
  }
  const min = Math.min(num1.min * num2.min, num1.min * num2.max, num1.max * num2.min, num1.max * num2.max);
  const max = Math.max(num1.min * num2.min, num1.min * num2.max, num1.max * num2.min, num1.max * num2.max);
  return new AstBinaryOperation("*", num1, num2, min, max);
}
function buildSubOperation(num1, num2) {
  if (num2.type === "literal") {
    if (num2.number === 0) {
      return num1;
    } else if (num1.type === "literal") {
      return new AstLiteral(num1.number - num2.number);
    }
  }
  if (num2.type === "binary" && num2.op === "-" && num1.type === "literal" && num1.number === 1 && num2.arg1.type === "literal" && num2.arg1.number === 1) {
    return num2.arg2;
  }
  return new AstBinaryOperation("-", num1, num2, num1.min - num2.max, num1.max - num2.min);
}
function buildMinOperation(num1, max) {
  if (num1.min >= max) {
    return new AstLiteral(max);
  } else if (num1.max <= max) {
    return num1;
  }
  return new AstMin(num1, max);
}
class PostScriptCompiler {
  compile(code, domain, range) {
    const stack = [];
    const instructions = [];
    const inputSize = domain.length >> 1,
      outputSize = range.length >> 1;
    let lastRegister = 0;
    let n, j;
    let num1, num2, ast1, ast2, tmpVar, item;
    for (let i = 0; i < inputSize; i++) {
      stack.push(new AstArgument(i, domain[i * 2], domain[i * 2 + 1]));
    }
    for (let i = 0, ii = code.length; i < ii; i++) {
      item = code[i];
      if (typeof item === "number") {
        stack.push(new AstLiteral(item));
        continue;
      }
      switch (item) {
        case "add":
          if (stack.length < 2) {
            return null;
          }
          num2 = stack.pop();
          num1 = stack.pop();
          stack.push(buildAddOperation(num1, num2));
          break;
        case "cvr":
          if (stack.length < 1) {
            return null;
          }
          break;
        case "mul":
          if (stack.length < 2) {
            return null;
          }
          num2 = stack.pop();
          num1 = stack.pop();
          stack.push(buildMulOperation(num1, num2));
          break;
        case "sub":
          if (stack.length < 2) {
            return null;
          }
          num2 = stack.pop();
          num1 = stack.pop();
          stack.push(buildSubOperation(num1, num2));
          break;
        case "exch":
          if (stack.length < 2) {
            return null;
          }
          ast1 = stack.pop();
          ast2 = stack.pop();
          stack.push(ast1, ast2);
          break;
        case "pop":
          if (stack.length < 1) {
            return null;
          }
          stack.pop();
          break;
        case "index":
          if (stack.length < 1) {
            return null;
          }
          num1 = stack.pop();
          if (num1.type !== "literal") {
            return null;
          }
          n = num1.number;
          if (n < 0 || !Number.isInteger(n) || stack.length < n) {
            return null;
          }
          ast1 = stack[stack.length - n - 1];
          if (ast1.type === "literal" || ast1.type === "var") {
            stack.push(ast1);
            break;
          }
          tmpVar = new AstVariable(lastRegister++, ast1.min, ast1.max);
          stack[stack.length - n - 1] = tmpVar;
          stack.push(tmpVar);
          instructions.push(new AstVariableDefinition(tmpVar, ast1));
          break;
        case "dup":
          if (stack.length < 1) {
            return null;
          }
          if (typeof code[i + 1] === "number" && code[i + 2] === "gt" && code[i + 3] === i + 7 && code[i + 4] === "jz" && code[i + 5] === "pop" && code[i + 6] === code[i + 1]) {
            num1 = stack.pop();
            stack.push(buildMinOperation(num1, code[i + 1]));
            i += 6;
            break;
          }
          ast1 = stack.at(-1);
          if (ast1.type === "literal" || ast1.type === "var") {
            stack.push(ast1);
            break;
          }
          tmpVar = new AstVariable(lastRegister++, ast1.min, ast1.max);
          stack[stack.length - 1] = tmpVar;
          stack.push(tmpVar);
          instructions.push(new AstVariableDefinition(tmpVar, ast1));
          break;
        case "roll":
          if (stack.length < 2) {
            return null;
          }
          num2 = stack.pop();
          num1 = stack.pop();
          if (num2.type !== "literal" || num1.type !== "literal") {
            return null;
          }
          j = num2.number;
          n = num1.number;
          if (n <= 0 || !Number.isInteger(n) || !Number.isInteger(j) || stack.length < n) {
            return null;
          }
          j = (j % n + n) % n;
          if (j === 0) {
            break;
          }
          stack.push(...stack.splice(stack.length - n, n - j));
          break;
        default:
          return null;
      }
    }
    if (stack.length !== outputSize) {
      return null;
    }
    const result = [];
    for (const instruction of instructions) {
      const statementBuilder = new ExpressionBuilderVisitor();
      instruction.visit(statementBuilder);
      result.push(statementBuilder.toString());
    }
    for (let i = 0, ii = stack.length; i < ii; i++) {
      const expr = stack[i],
        statementBuilder = new ExpressionBuilderVisitor();
      expr.visit(statementBuilder);
      const min = range[i * 2],
        max = range[i * 2 + 1];
      const out = [statementBuilder.toString()];
      if (min > expr.min) {
        out.unshift("Math.max(", min, ", ");
        out.push(")");
      }
      if (max < expr.max) {
        out.unshift("Math.min(", max, ", ");
        out.push(")");
      }
      out.unshift("dest[destOffset + ", i, "] = ");
      out.push(";");
      result.push(out.join(""));
    }
    return result.join("\n");
  }
}
exports.PostScriptCompiler = PostScriptCompiler;

/***/ }),
/* 58 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PostScriptParser = exports.PostScriptLexer = void 0;
var _util = __w_pdfjs_require__(2);
var _primitives = __w_pdfjs_require__(4);
var _core_utils = __w_pdfjs_require__(3);
class PostScriptParser {
  constructor(lexer) {
    this.lexer = lexer;
    this.operators = [];
    this.token = null;
    this.prev = null;
  }
  nextToken() {
    this.prev = this.token;
    this.token = this.lexer.getToken();
  }
  accept(type) {
    if (this.token.type === type) {
      this.nextToken();
      return true;
    }
    return false;
  }
  expect(type) {
    if (this.accept(type)) {
      return true;
    }
    throw new _util.FormatError(`Unexpected symbol: found ${this.token.type} expected ${type}.`);
  }
  parse() {
    this.nextToken();
    this.expect(PostScriptTokenTypes.LBRACE);
    this.parseBlock();
    this.expect(PostScriptTokenTypes.RBRACE);
    return this.operators;
  }
  parseBlock() {
    while (true) {
      if (this.accept(PostScriptTokenTypes.NUMBER)) {
        this.operators.push(this.prev.value);
      } else if (this.accept(PostScriptTokenTypes.OPERATOR)) {
        this.operators.push(this.prev.value);
      } else if (this.accept(PostScriptTokenTypes.LBRACE)) {
        this.parseCondition();
      } else {
        return;
      }
    }
  }
  parseCondition() {
    const conditionLocation = this.operators.length;
    this.operators.push(null, null);
    this.parseBlock();
    this.expect(PostScriptTokenTypes.RBRACE);
    if (this.accept(PostScriptTokenTypes.IF)) {
      this.operators[conditionLocation] = this.operators.length;
      this.operators[conditionLocation + 1] = "jz";
    } else if (this.accept(PostScriptTokenTypes.LBRACE)) {
      const jumpLocation = this.operators.length;
      this.operators.push(null, null);
      const endOfTrue = this.operators.length;
      this.parseBlock();
      this.expect(PostScriptTokenTypes.RBRACE);
      this.expect(PostScriptTokenTypes.IFELSE);
      this.operators[jumpLocation] = this.operators.length;
      this.operators[jumpLocation + 1] = "j";
      this.operators[conditionLocation] = endOfTrue;
      this.operators[conditionLocation + 1] = "jz";
    } else {
      throw new _util.FormatError("PS Function: error parsing conditional.");
    }
  }
}
exports.PostScriptParser = PostScriptParser;
const PostScriptTokenTypes = {
  LBRACE: 0,
  RBRACE: 1,
  NUMBER: 2,
  OPERATOR: 3,
  IF: 4,
  IFELSE: 5
};
class PostScriptToken {
  static get opCache() {
    return (0, _util.shadow)(this, "opCache", Object.create(null));
  }
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  static getOperator(op) {
    return PostScriptToken.opCache[op] ||= new PostScriptToken(PostScriptTokenTypes.OPERATOR, op);
  }
  static get LBRACE() {
    return (0, _util.shadow)(this, "LBRACE", new PostScriptToken(PostScriptTokenTypes.LBRACE, "{"));
  }
  static get RBRACE() {
    return (0, _util.shadow)(this, "RBRACE", new PostScriptToken(PostScriptTokenTypes.RBRACE, "}"));
  }
  static get IF() {
    return (0, _util.shadow)(this, "IF", new PostScriptToken(PostScriptTokenTypes.IF, "IF"));
  }
  static get IFELSE() {
    return (0, _util.shadow)(this, "IFELSE", new PostScriptToken(PostScriptTokenTypes.IFELSE, "IFELSE"));
  }
}
class PostScriptLexer {
  constructor(stream) {
    this.stream = stream;
    this.nextChar();
    this.strBuf = [];
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  getToken() {
    let comment = false;
    let ch = this.currentChar;
    while (true) {
      if (ch < 0) {
        return _primitives.EOF;
      }
      if (comment) {
        if (ch === 0x0a || ch === 0x0d) {
          comment = false;
        }
      } else if (ch === 0x25) {
        comment = true;
      } else if (!(0, _core_utils.isWhiteSpace)(ch)) {
        break;
      }
      ch = this.nextChar();
    }
    switch (ch | 0) {
      case 0x30:
      case 0x31:
      case 0x32:
      case 0x33:
      case 0x34:
      case 0x35:
      case 0x36:
      case 0x37:
      case 0x38:
      case 0x39:
      case 0x2b:
      case 0x2d:
      case 0x2e:
        return new PostScriptToken(PostScriptTokenTypes.NUMBER, this.getNumber());
      case 0x7b:
        this.nextChar();
        return PostScriptToken.LBRACE;
      case 0x7d:
        this.nextChar();
        return PostScriptToken.RBRACE;
    }
    const strBuf = this.strBuf;
    strBuf.length = 0;
    strBuf[0] = String.fromCharCode(ch);
    while ((ch = this.nextChar()) >= 0 && (ch >= 0x41 && ch <= 0x5a || ch >= 0x61 && ch <= 0x7a)) {
      strBuf.push(String.fromCharCode(ch));
    }
    const str = strBuf.join("");
    switch (str.toLowerCase()) {
      case "if":
        return PostScriptToken.IF;
      case "ifelse":
        return PostScriptToken.IFELSE;
      default:
        return PostScriptToken.getOperator(str);
    }
  }
  getNumber() {
    let ch = this.currentChar;
    const strBuf = this.strBuf;
    strBuf.length = 0;
    strBuf[0] = String.fromCharCode(ch);
    while ((ch = this.nextChar()) >= 0) {
      if (ch >= 0x30 && ch <= 0x39 || ch === 0x2d || ch === 0x2e) {
        strBuf.push(String.fromCharCode(ch));
      } else {
        break;
      }
    }
    const value = parseFloat(strBuf.join(""));
    if (isNaN(value)) {
      throw new _util.FormatError(`Invalid floating point number: ${value}`);
    }
    return value;
  }
}
exports.PostScriptLexer = PostScriptLexer;

/***/ }),
/* 59 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RegionalImageCache = exports.LocalTilingPatternCache = exports.LocalImageCache = exports.LocalGStateCache = exports.LocalFunctionCache = exports.LocalColorSpaceCache = exports.GlobalImageCache = void 0;
var _util = __w_pdfjs_require__(2);
var _primitives = __w_pdfjs_require__(4);
class BaseLocalCache {
  constructor(options) {
    if (this.constructor === BaseLocalCache) {
      (0, _util.unreachable)("Cannot initialize BaseLocalCache.");
    }
    this._onlyRefs = options?.onlyRefs === true;
    if (!this._onlyRefs) {
      this._nameRefMap = new Map();
      this._imageMap = new Map();
    }
    this._imageCache = new _primitives.RefSetCache();
  }
  getByName(name) {
    if (this._onlyRefs) {
      (0, _util.unreachable)("Should not call `getByName` method.");
    }
    const ref = this._nameRefMap.get(name);
    if (ref) {
      return this.getByRef(ref);
    }
    return this._imageMap.get(name) || null;
  }
  getByRef(ref) {
    return this._imageCache.get(ref) || null;
  }
  set(name, ref, data) {
    (0, _util.unreachable)("Abstract method `set` called.");
  }
}
class LocalImageCache extends BaseLocalCache {
  set(name, ref = null, data) {
    if (typeof name !== "string") {
      throw new Error('LocalImageCache.set - expected "name" argument.');
    }
    if (ref) {
      if (this._imageCache.has(ref)) {
        return;
      }
      this._nameRefMap.set(name, ref);
      this._imageCache.put(ref, data);
      return;
    }
    if (this._imageMap.has(name)) {
      return;
    }
    this._imageMap.set(name, data);
  }
}
exports.LocalImageCache = LocalImageCache;
class LocalColorSpaceCache extends BaseLocalCache {
  set(name = null, ref = null, data) {
    if (typeof name !== "string" && !ref) {
      throw new Error('LocalColorSpaceCache.set - expected "name" and/or "ref" argument.');
    }
    if (ref) {
      if (this._imageCache.has(ref)) {
        return;
      }
      if (name !== null) {
        this._nameRefMap.set(name, ref);
      }
      this._imageCache.put(ref, data);
      return;
    }
    if (this._imageMap.has(name)) {
      return;
    }
    this._imageMap.set(name, data);
  }
}
exports.LocalColorSpaceCache = LocalColorSpaceCache;
class LocalFunctionCache extends BaseLocalCache {
  constructor(options) {
    super({
      onlyRefs: true
    });
  }
  set(name = null, ref, data) {
    if (!ref) {
      throw new Error('LocalFunctionCache.set - expected "ref" argument.');
    }
    if (this._imageCache.has(ref)) {
      return;
    }
    this._imageCache.put(ref, data);
  }
}
exports.LocalFunctionCache = LocalFunctionCache;
class LocalGStateCache extends BaseLocalCache {
  set(name, ref = null, data) {
    if (typeof name !== "string") {
      throw new Error('LocalGStateCache.set - expected "name" argument.');
    }
    if (ref) {
      if (this._imageCache.has(ref)) {
        return;
      }
      this._nameRefMap.set(name, ref);
      this._imageCache.put(ref, data);
      return;
    }
    if (this._imageMap.has(name)) {
      return;
    }
    this._imageMap.set(name, data);
  }
}
exports.LocalGStateCache = LocalGStateCache;
class LocalTilingPatternCache extends BaseLocalCache {
  constructor(options) {
    super({
      onlyRefs: true
    });
  }
  set(name = null, ref, data) {
    if (!ref) {
      throw new Error('LocalTilingPatternCache.set - expected "ref" argument.');
    }
    if (this._imageCache.has(ref)) {
      return;
    }
    this._imageCache.put(ref, data);
  }
}
exports.LocalTilingPatternCache = LocalTilingPatternCache;
class RegionalImageCache extends BaseLocalCache {
  constructor(options) {
    super({
      onlyRefs: true
    });
  }
  set(name = null, ref, data) {
    if (!ref) {
      throw new Error('RegionalImageCache.set - expected "ref" argument.');
    }
    if (this._imageCache.has(ref)) {
      return;
    }
    this._imageCache.put(ref, data);
  }
}
exports.RegionalImageCache = RegionalImageCache;
class GlobalImageCache {
  static NUM_PAGES_THRESHOLD = 2;
  static MIN_IMAGES_TO_CACHE = 10;
  static MAX_BYTE_SIZE = 5 * _util.MAX_IMAGE_SIZE_TO_CACHE;
  constructor() {
    this._refCache = new _primitives.RefSetCache();
    this._imageCache = new _primitives.RefSetCache();
  }
  get _byteSize() {
    let byteSize = 0;
    for (const imageData of this._imageCache) {
      byteSize += imageData.byteSize;
    }
    return byteSize;
  }
  get _cacheLimitReached() {
    if (this._imageCache.size < GlobalImageCache.MIN_IMAGES_TO_CACHE) {
      return false;
    }
    if (this._byteSize < GlobalImageCache.MAX_BYTE_SIZE) {
      return false;
    }
    return true;
  }
  shouldCache(ref, pageIndex) {
    let pageIndexSet = this._refCache.get(ref);
    if (!pageIndexSet) {
      pageIndexSet = new Set();
      this._refCache.put(ref, pageIndexSet);
    }
    pageIndexSet.add(pageIndex);
    if (pageIndexSet.size < GlobalImageCache.NUM_PAGES_THRESHOLD) {
      return false;
    }
    if (!this._imageCache.has(ref) && this._cacheLimitReached) {
      return false;
    }
    return true;
  }
  addByteSize(ref, byteSize) {
    const imageData = this._imageCache.get(ref);
    if (!imageData) {
      return;
    }
    if (imageData.byteSize) {
      return;
    }
    imageData.byteSize = byteSize;
  }
  getData(ref, pageIndex) {
    const pageIndexSet = this._refCache.get(ref);
    if (!pageIndexSet) {
      return null;
    }
    if (pageIndexSet.size < GlobalImageCache.NUM_PAGES_THRESHOLD) {
      return null;
    }
    const imageData = this._imageCache.get(ref);
    if (!imageData) {
      return null;
    }
    pageIndexSet.add(pageIndex);
    return imageData;
  }
  setData(ref, data) {
    if (!this._refCache.has(ref)) {
      throw new Error('GlobalImageCache.setData - expected "shouldCache" to have been called.');
    }
    if (this._imageCache.has(ref)) {
      return;
    }
    if (this._cacheLimitReached) {
      (0, _util.warn)("GlobalImageCache.setData - cache limit reached.");
      return;
    }
    this._imageCache.put(ref, data);
  }
  clear(onlyData = false) {
    if (!onlyData) {
      this._refCache.clear();
    }
    this._imageCache.clear();
  }
}
exports.GlobalImageCache = GlobalImageCache;

/***/ }),
/* 60 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.bidi = bidi;
var _util = __w_pdfjs_require__(2);
const baseTypes = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "ON", "ON", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "ON", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "ON", "ET", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "L", "ON", "ON", "BN", "ON", "ON", "ET", "ET", "EN", "EN", "ON", "L", "ON", "ON", "ON", "EN", "L", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L"];
const arabicTypes = ["AN", "AN", "AN", "AN", "AN", "AN", "ON", "ON", "AL", "ET", "ET", "AL", "CS", "AL", "ON", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "ON", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL"];
function isOdd(i) {
  return (i & 1) !== 0;
}
function isEven(i) {
  return (i & 1) === 0;
}
function findUnequal(arr, start, value) {
  let j, jj;
  for (j = start, jj = arr.length; j < jj; ++j) {
    if (arr[j] !== value) {
      return j;
    }
  }
  return j;
}
function setValues(arr, start, end, value) {
  for (let j = start; j < end; ++j) {
    arr[j] = value;
  }
}
function reverseValues(arr, start, end) {
  for (let i = start, j = end - 1; i < j; ++i, --j) {
    const temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }
}
function createBidiText(str, isLTR, vertical = false) {
  let dir = "ltr";
  if (vertical) {
    dir = "ttb";
  } else if (!isLTR) {
    dir = "rtl";
  }
  return {
    str,
    dir
  };
}
const chars = [];
const types = [];
function bidi(str, startLevel = -1, vertical = false) {
  let isLTR = true;
  const strLength = str.length;
  if (strLength === 0 || vertical) {
    return createBidiText(str, isLTR, vertical);
  }
  chars.length = strLength;
  types.length = strLength;
  let numBidi = 0;
  let i, ii;
  for (i = 0; i < strLength; ++i) {
    chars[i] = str.charAt(i);
    const charCode = str.charCodeAt(i);
    let charType = "L";
    if (charCode <= 0x00ff) {
      charType = baseTypes[charCode];
    } else if (0x0590 <= charCode && charCode <= 0x05f4) {
      charType = "R";
    } else if (0x0600 <= charCode && charCode <= 0x06ff) {
      charType = arabicTypes[charCode & 0xff];
      if (!charType) {
        (0, _util.warn)("Bidi: invalid Unicode character " + charCode.toString(16));
      }
    } else if (0x0700 <= charCode && charCode <= 0x08ac || 0xfb50 <= charCode && charCode <= 0xfdff || 0xfe70 <= charCode && charCode <= 0xfeff) {
      charType = "AL";
    }
    if (charType === "R" || charType === "AL" || charType === "AN") {
      numBidi++;
    }
    types[i] = charType;
  }
  if (numBidi === 0) {
    isLTR = true;
    return createBidiText(str, isLTR);
  }
  if (startLevel === -1) {
    if (numBidi / strLength < 0.3 && strLength > 4) {
      isLTR = true;
      startLevel = 0;
    } else {
      isLTR = false;
      startLevel = 1;
    }
  }
  const levels = [];
  for (i = 0; i < strLength; ++i) {
    levels[i] = startLevel;
  }
  const e = isOdd(startLevel) ? "R" : "L";
  const sor = e;
  const eor = sor;
  let lastType = sor;
  for (i = 0; i < strLength; ++i) {
    if (types[i] === "NSM") {
      types[i] = lastType;
    } else {
      lastType = types[i];
    }
  }
  lastType = sor;
  let t;
  for (i = 0; i < strLength; ++i) {
    t = types[i];
    if (t === "EN") {
      types[i] = lastType === "AL" ? "AN" : "EN";
    } else if (t === "R" || t === "L" || t === "AL") {
      lastType = t;
    }
  }
  for (i = 0; i < strLength; ++i) {
    t = types[i];
    if (t === "AL") {
      types[i] = "R";
    }
  }
  for (i = 1; i < strLength - 1; ++i) {
    if (types[i] === "ES" && types[i - 1] === "EN" && types[i + 1] === "EN") {
      types[i] = "EN";
    }
    if (types[i] === "CS" && (types[i - 1] === "EN" || types[i - 1] === "AN") && types[i + 1] === types[i - 1]) {
      types[i] = types[i - 1];
    }
  }
  for (i = 0; i < strLength; ++i) {
    if (types[i] === "EN") {
      for (let j = i - 1; j >= 0; --j) {
        if (types[j] !== "ET") {
          break;
        }
        types[j] = "EN";
      }
      for (let j = i + 1; j < strLength; ++j) {
        if (types[j] !== "ET") {
          break;
        }
        types[j] = "EN";
      }
    }
  }
  for (i = 0; i < strLength; ++i) {
    t = types[i];
    if (t === "WS" || t === "ES" || t === "ET" || t === "CS") {
      types[i] = "ON";
    }
  }
  lastType = sor;
  for (i = 0; i < strLength; ++i) {
    t = types[i];
    if (t === "EN") {
      types[i] = lastType === "L" ? "L" : "EN";
    } else if (t === "R" || t === "L") {
      lastType = t;
    }
  }
  for (i = 0; i < strLength; ++i) {
    if (types[i] === "ON") {
      const end = findUnequal(types, i + 1, "ON");
      let before = sor;
      if (i > 0) {
        before = types[i - 1];
      }
      let after = eor;
      if (end + 1 < strLength) {
        after = types[end + 1];
      }
      if (before !== "L") {
        before = "R";
      }
      if (after !== "L") {
        after = "R";
      }
      if (before === after) {
        setValues(types, i, end, before);
      }
      i = end - 1;
    }
  }
  for (i = 0; i < strLength; ++i) {
    if (types[i] === "ON") {
      types[i] = e;
    }
  }
  for (i = 0; i < strLength; ++i) {
    t = types[i];
    if (isEven(levels[i])) {
      if (t === "R") {
        levels[i] += 1;
      } else if (t === "AN" || t === "EN") {
        levels[i] += 2;
      }
    } else if (t === "L" || t === "AN" || t === "EN") {
      levels[i] += 1;
    }
  }
  let highestLevel = -1;
  let lowestOddLevel = 99;
  let level;
  for (i = 0, ii = levels.length; i < ii; ++i) {
    level = levels[i];
    if (highestLevel < level) {
      highestLevel = level;
    }
    if (lowestOddLevel > level && isOdd(level)) {
      lowestOddLevel = level;
    }
  }
  for (level = highestLevel; level >= lowestOddLevel; --level) {
    let start = -1;
    for (i = 0, ii = levels.length; i < ii; ++i) {
      if (levels[i] < level) {
        if (start >= 0) {
          reverseValues(chars, start, i);
          start = -1;
        }
      } else if (start < 0) {
        start = i;
      }
    }
    if (start >= 0) {
      reverseValues(chars, start, levels.length);
    }
  }
  for (i = 0, ii = chars.length; i < ii; ++i) {
    const ch = chars[i];
    if (ch === "<" || ch === ">") {
      chars[i] = "";
    }
  }
  return createBidiText(chars.join(""), isLTR);
}

/***/ }),
/* 61 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getFontSubstitution = getFontSubstitution;
var _fonts_utils = __w_pdfjs_require__(38);
var _core_utils = __w_pdfjs_require__(3);
const NORMAL = {
  style: "normal",
  weight: "normal"
};
const BOLD = {
  style: "normal",
  weight: "bold"
};
const ITALIC = {
  style: "italic",
  weight: "normal"
};
const BOLDITALIC = {
  style: "italic",
  weight: "bold"
};
const substitutionMap = new Map([["Times-Roman", {
  local: ["Times New Roman", "Times-Roman", "Times", "Liberation Serif", "Nimbus Roman", "Nimbus Roman L", "Tinos", "Thorndale", "TeX Gyre Termes", "FreeSerif", "DejaVu Serif", "Bitstream Vera Serif", "Ubuntu"],
  style: NORMAL,
  ultimate: "serif"
}], ["Times-Bold", {
  alias: "Times-Roman",
  style: BOLD,
  ultimate: "serif"
}], ["Times-Italic", {
  alias: "Times-Roman",
  style: ITALIC,
  ultimate: "serif"
}], ["Times-BoldItalic", {
  alias: "Times-Roman",
  style: BOLDITALIC,
  ultimate: "serif"
}], ["Helvetica", {
  local: ["Helvetica", "Helvetica Neue", "Arial", "Arial Nova", "Liberation Sans", "Arimo", "Nimbus Sans", "Nimbus Sans L", "A030", "TeX Gyre Heros", "FreeSans", "DejaVu Sans", "Albany", "Bitstream Vera Sans", "Arial Unicode MS", "Microsoft Sans Serif", "Apple Symbols", "Cantarell"],
  path: "LiberationSans-Regular.ttf",
  style: NORMAL,
  ultimate: "sans-serif"
}], ["Helvetica-Bold", {
  alias: "Helvetica",
  path: "LiberationSans-Bold.ttf",
  style: BOLD,
  ultimate: "sans-serif"
}], ["Helvetica-Oblique", {
  alias: "Helvetica",
  path: "LiberationSans-Italic.ttf",
  style: ITALIC,
  ultimate: "sans-serif"
}], ["Helvetica-BoldOblique", {
  alias: "Helvetica",
  path: "LiberationSans-BoldItalic.ttf",
  style: BOLDITALIC,
  ultimate: "sans-serif"
}], ["Courier", {
  local: ["Courier", "Courier New", "Liberation Mono", "Nimbus Mono", "Nimbus Mono L", "Cousine", "Cumberland", "TeX Gyre Cursor", "FreeMono"],
  style: NORMAL,
  ultimate: "monospace"
}], ["Courier-Bold", {
  alias: "Courier",
  style: BOLD,
  ultimate: "monospace"
}], ["Courier-Oblique", {
  alias: "Courier",
  style: ITALIC,
  ultimate: "monospace"
}], ["Courier-BoldOblique", {
  alias: "Courier",
  style: BOLDITALIC,
  ultimate: "monospace"
}], ["ArialBlack", {
  local: ["Arial Black"],
  style: {
    style: "normal",
    weight: "900"
  },
  fallback: "Helvetica-Bold"
}], ["ArialBlack-Bold", {
  alias: "ArialBlack"
}], ["ArialBlack-Italic", {
  alias: "ArialBlack",
  style: {
    style: "italic",
    weight: "900"
  },
  fallback: "Helvetica-BoldOblique"
}], ["ArialBlack-BoldItalic", {
  alias: "ArialBlack-Italic"
}], ["ArialNarrow", {
  local: ["Arial Narrow", "Liberation Sans Narrow", "Helvetica Condensed", "Nimbus Sans Narrow", "TeX Gyre Heros Cn"],
  style: NORMAL,
  fallback: "Helvetica"
}], ["ArialNarrow-Bold", {
  alias: "ArialNarrow",
  style: BOLD,
  fallback: "Helvetica-Bold"
}], ["ArialNarrow-Italic", {
  alias: "ArialNarrow",
  style: ITALIC,
  fallback: "Helvetica-Oblique"
}], ["ArialNarrow-BoldItalic", {
  alias: "ArialNarrow",
  style: BOLDITALIC,
  fallback: "Helvetica-BoldOblique"
}], ["Calibri", {
  local: ["Calibri", "Carlito"],
  style: NORMAL,
  fallback: "Helvetica"
}], ["Calibri-Bold", {
  alias: "Calibri",
  style: BOLD,
  fallback: "Helvetica-Bold"
}], ["Calibri-Italic", {
  alias: "Calibri",
  style: ITALIC,
  fallback: "Helvetica-Oblique"
}], ["Calibri-BoldItalic", {
  alias: "Calibri",
  style: BOLDITALIC,
  fallback: "Helvetica-BoldOblique"
}], ["Wingdings", {
  local: ["Wingdings", "URW Dingbats"],
  style: NORMAL
}], ["Wingdings-Regular", {
  alias: "Wingdings"
}], ["Wingdings-Bold", {
  alias: "Wingdings"
}]]);
const fontAliases = new Map([["Arial-Black", "ArialBlack"]]);
function getStyleToAppend(style) {
  switch (style) {
    case BOLD:
      return "Bold";
    case ITALIC:
      return "Italic";
    case BOLDITALIC:
      return "Bold Italic";
    default:
      if (style?.weight === "bold") {
        return "Bold";
      }
      if (style?.style === "italic") {
        return "Italic";
      }
  }
  return "";
}
function generateFont({
  alias,
  local,
  path,
  fallback,
  style,
  ultimate
}, src, localFontPath, useFallback = true, usePath = true, append = "") {
  const result = {
    style: null,
    ultimate: null
  };
  if (local) {
    const extra = append ? ` ${append}` : "";
    for (const name of local) {
      src.push(`local(${name}${extra})`);
    }
  }
  if (alias) {
    const substitution = substitutionMap.get(alias);
    const aliasAppend = append || getStyleToAppend(style);
    Object.assign(result, generateFont(substitution, src, localFontPath, useFallback && !fallback, usePath && !path, aliasAppend));
  }
  if (style) {
    result.style = style;
  }
  if (ultimate) {
    result.ultimate = ultimate;
  }
  if (useFallback && fallback) {
    const fallbackInfo = substitutionMap.get(fallback);
    const {
      ultimate: fallbackUltimate
    } = generateFont(fallbackInfo, src, localFontPath, useFallback, usePath && !path, append);
    result.ultimate ||= fallbackUltimate;
  }
  if (usePath && path && localFontPath) {
    src.push(`url(${localFontPath}${path})`);
  }
  return result;
}
function getFontSubstitution(systemFontCache, idFactory, localFontPath, baseFontName, standardFontName) {
  baseFontName = (0, _fonts_utils.normalizeFontName)(baseFontName);
  const key = baseFontName;
  let substitutionInfo = systemFontCache.get(key);
  if (substitutionInfo) {
    return substitutionInfo;
  }
  let substitution = substitutionMap.get(baseFontName);
  if (!substitution) {
    for (const [alias, subst] of fontAliases) {
      if (baseFontName.startsWith(alias)) {
        baseFontName = `${subst}${baseFontName.substring(alias.length)}`;
        substitution = substitutionMap.get(baseFontName);
        break;
      }
    }
  }
  let mustAddBaseFont = false;
  if (!substitution) {
    substitution = substitutionMap.get(standardFontName);
    mustAddBaseFont = true;
  }
  const loadedName = `${idFactory.getDocId()}_s${idFactory.createFontId()}`;
  if (!substitution) {
    if (!(0, _core_utils.validateFontName)(baseFontName)) {
      systemFontCache.set(key, null);
      return null;
    }
    const bold = /bold/gi.test(baseFontName);
    const italic = /oblique|italic/gi.test(baseFontName);
    const style = bold && italic && BOLDITALIC || bold && BOLD || italic && ITALIC || NORMAL;
    substitutionInfo = {
      css: loadedName,
      guessFallback: true,
      loadedName,
      baseFontName,
      src: `local(${baseFontName})`,
      style
    };
    systemFontCache.set(key, substitutionInfo);
    return substitutionInfo;
  }
  const src = [];
  if (mustAddBaseFont && (0, _core_utils.validateFontName)(baseFontName)) {
    src.push(`local(${baseFontName})`);
  }
  const {
    style,
    ultimate
  } = generateFont(substitution, src, localFontPath);
  const guessFallback = ultimate === null;
  const fallback = guessFallback ? "" : `,${ultimate}`;
  substitutionInfo = {
    css: `${loadedName}${fallback}`,
    guessFallback,
    loadedName,
    baseFontName,
    src: src.join(","),
    style
  };
  systemFontCache.set(key, substitutionInfo);
  return substitutionInfo;
}

/***/ }),
/* 62 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ImageResizer = void 0;
var _util = __w_pdfjs_require__(2);
const MIN_IMAGE_DIM = 2048;
const MAX_IMAGE_DIM = 65537;
const MAX_ERROR = 128;
class ImageResizer {
  constructor(imgData, isMask) {
    this._imgData = imgData;
    this._isMask = isMask;
  }
  static needsToBeResized(width, height) {
    if (width <= this._goodSquareLength && height <= this._goodSquareLength) {
      return false;
    }
    const {
      MAX_DIM
    } = this;
    if (width > MAX_DIM || height > MAX_DIM) {
      return true;
    }
    const area = width * height;
    if (this._hasMaxArea) {
      return area > this.MAX_AREA;
    }
    if (area < this._goodSquareLength ** 2) {
      return false;
    }
    if (this._areGoodDims(width, height)) {
      this._goodSquareLength = Math.max(this._goodSquareLength, Math.floor(Math.sqrt(width * height)));
      return false;
    }
    this._goodSquareLength = this._guessMax(this._goodSquareLength, MAX_DIM, MAX_ERROR, 0);
    const maxArea = this.MAX_AREA = this._goodSquareLength ** 2;
    return area > maxArea;
  }
  static get MAX_DIM() {
    return (0, _util.shadow)(this, "MAX_DIM", this._guessMax(MIN_IMAGE_DIM, MAX_IMAGE_DIM, 0, 1));
  }
  static get MAX_AREA() {
    this._hasMaxArea = true;
    return (0, _util.shadow)(this, "MAX_AREA", this._guessMax(ImageResizer._goodSquareLength, this.MAX_DIM, MAX_ERROR, 0) ** 2);
  }
  static set MAX_AREA(area) {
    if (area >= 0) {
      this._hasMaxArea = true;
      (0, _util.shadow)(this, "MAX_AREA", area);
    }
  }
  static setMaxArea(area) {
    if (!this._hasMaxArea) {
      this.MAX_AREA = area >> 2;
    }
  }
  static _areGoodDims(width, height) {
    try {
      const canvas = new OffscreenCanvas(width, height);
      const ctx = canvas.getContext("2d");
      ctx.fillRect(0, 0, 1, 1);
      const opacity = ctx.getImageData(0, 0, 1, 1).data[3];
      canvas.width = canvas.height = 1;
      return opacity !== 0;
    } catch {
      return false;
    }
  }
  static _guessMax(start, end, tolerance, defaultHeight) {
    while (start + tolerance + 1 < end) {
      const middle = Math.floor((start + end) / 2);
      const height = defaultHeight || middle;
      if (this._areGoodDims(middle, height)) {
        start = middle;
      } else {
        end = middle;
      }
    }
    return start;
  }
  static async createImage(imgData, isMask = false) {
    return new ImageResizer(imgData, isMask)._createImage();
  }
  async _createImage() {
    const data = this._encodeBMP();
    const blob = new Blob([data.buffer], {
      type: "image/bmp"
    });
    const bitmapPromise = createImageBitmap(blob);
    const {
      MAX_AREA,
      MAX_DIM
    } = ImageResizer;
    const {
      _imgData: imgData
    } = this;
    const {
      width,
      height
    } = imgData;
    const minFactor = Math.max(width / MAX_DIM, height / MAX_DIM, Math.sqrt(width * height / MAX_AREA));
    const firstFactor = Math.max(minFactor, 2);
    const factor = Math.round(10 * (minFactor + 1.25)) / 10 / firstFactor;
    const N = Math.floor(Math.log2(factor));
    const steps = new Array(N + 2).fill(2);
    steps[0] = firstFactor;
    steps.splice(-1, 1, factor / (1 << N));
    let newWidth = width;
    let newHeight = height;
    let bitmap = await bitmapPromise;
    for (const step of steps) {
      const prevWidth = newWidth;
      const prevHeight = newHeight;
      newWidth = Math.floor(newWidth / step) - 1;
      newHeight = Math.floor(newHeight / step) - 1;
      const canvas = new OffscreenCanvas(newWidth, newHeight);
      const ctx = canvas.getContext("2d");
      ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);
      bitmap = canvas.transferToImageBitmap();
    }
    imgData.data = null;
    imgData.bitmap = bitmap;
    imgData.width = newWidth;
    imgData.height = newHeight;
    return imgData;
  }
  _encodeBMP() {
    const {
      width,
      height,
      kind
    } = this._imgData;
    let data = this._imgData.data;
    let bitPerPixel;
    let colorTable = new Uint8Array(0);
    let maskTable = colorTable;
    let compression = 0;
    switch (kind) {
      case _util.ImageKind.GRAYSCALE_1BPP:
        {
          bitPerPixel = 1;
          colorTable = new Uint8Array(this._isMask ? [255, 255, 255, 255, 0, 0, 0, 0] : [0, 0, 0, 0, 255, 255, 255, 255]);
          const rowLen = width + 7 >> 3;
          const rowSize = rowLen + 3 & -4;
          if (rowLen !== rowSize) {
            const newData = new Uint8Array(rowSize * height);
            let k = 0;
            for (let i = 0, ii = height * rowLen; i < ii; i += rowLen, k += rowSize) {
              newData.set(data.subarray(i, i + rowLen), k);
            }
            data = newData;
          }
          break;
        }
      case _util.ImageKind.RGB_24BPP:
        {
          bitPerPixel = 24;
          if (width & 3) {
            const rowLen = 3 * width;
            const rowSize = rowLen + 3 & -4;
            const extraLen = rowSize - rowLen;
            const newData = new Uint8Array(rowSize * height);
            let k = 0;
            for (let i = 0, ii = height * rowLen; i < ii; i += rowLen) {
              const row = data.subarray(i, i + rowLen);
              for (let j = 0; j < rowLen; j += 3) {
                newData[k++] = row[j + 2];
                newData[k++] = row[j + 1];
                newData[k++] = row[j];
              }
              k += extraLen;
            }
            data = newData;
          } else {
            for (let i = 0, ii = data.length; i < ii; i += 3) {
              const tmp = data[i];
              data[i] = data[i + 2];
              data[i + 2] = tmp;
            }
          }
          break;
        }
      case _util.ImageKind.RGBA_32BPP:
        bitPerPixel = 32;
        compression = 3;
        maskTable = new Uint8Array(4 + 4 + 4 + 4 + 52);
        const view = new DataView(maskTable.buffer);
        if (_util.FeatureTest.isLittleEndian) {
          view.setUint32(0, 0x000000ff, true);
          view.setUint32(4, 0x0000ff00, true);
          view.setUint32(8, 0x00ff0000, true);
          view.setUint32(12, 0xff000000, true);
        } else {
          view.setUint32(0, 0xff000000, true);
          view.setUint32(4, 0x00ff0000, true);
          view.setUint32(8, 0x0000ff00, true);
          view.setUint32(12, 0x000000ff, true);
        }
        break;
      default:
        throw new Error("invalid format");
    }
    let i = 0;
    const headerLength = 40 + maskTable.length;
    const fileLength = 14 + headerLength + colorTable.length + data.length;
    const bmpData = new Uint8Array(fileLength);
    const view = new DataView(bmpData.buffer);
    view.setUint16(i, 0x4d42, true);
    i += 2;
    view.setUint32(i, fileLength, true);
    i += 4;
    view.setUint32(i, 0, true);
    i += 4;
    view.setUint32(i, 14 + headerLength + colorTable.length, true);
    i += 4;
    view.setUint32(i, headerLength, true);
    i += 4;
    view.setInt32(i, width, true);
    i += 4;
    view.setInt32(i, -height, true);
    i += 4;
    view.setUint16(i, 1, true);
    i += 2;
    view.setUint16(i, bitPerPixel, true);
    i += 2;
    view.setUint32(i, compression, true);
    i += 4;
    view.setUint32(i, 0, true);
    i += 4;
    view.setInt32(i, 0, true);
    i += 4;
    view.setInt32(i, 0, true);
    i += 4;
    view.setUint32(i, colorTable.length / 4, true);
    i += 4;
    view.setUint32(i, 0, true);
    i += 4;
    bmpData.set(maskTable, i);
    i += maskTable.length;
    bmpData.set(colorTable, i);
    i += colorTable.length;
    bmpData.set(data, i);
    return bmpData;
  }
}
exports.ImageResizer = ImageResizer;
ImageResizer._goodSquareLength = MIN_IMAGE_DIM;

/***/ }),
/* 63 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MurmurHash3_64 = void 0;
var _util = __w_pdfjs_require__(2);
const SEED = 0xc3d2e1f0;
const MASK_HIGH = 0xffff0000;
const MASK_LOW = 0xffff;
class MurmurHash3_64 {
  constructor(seed) {
    this.h1 = seed ? seed & 0xffffffff : SEED;
    this.h2 = seed ? seed & 0xffffffff : SEED;
  }
  update(input) {
    let data, length;
    if (typeof input === "string") {
      data = new Uint8Array(input.length * 2);
      length = 0;
      for (let i = 0, ii = input.length; i < ii; i++) {
        const code = input.charCodeAt(i);
        if (code <= 0xff) {
          data[length++] = code;
        } else {
          data[length++] = code >>> 8;
          data[length++] = code & 0xff;
        }
      }
    } else if ((0, _util.isArrayBuffer)(input)) {
      data = input.slice();
      length = data.byteLength;
    } else {
      throw new Error("Wrong data format in MurmurHash3_64_update. " + "Input must be a string or array.");
    }
    const blockCounts = length >> 2;
    const tailLength = length - blockCounts * 4;
    const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
    let k1 = 0,
      k2 = 0;
    let h1 = this.h1,
      h2 = this.h2;
    const C1 = 0xcc9e2d51,
      C2 = 0x1b873593;
    const C1_LOW = C1 & MASK_LOW,
      C2_LOW = C2 & MASK_LOW;
    for (let i = 0; i < blockCounts; i++) {
      if (i & 1) {
        k1 = dataUint32[i];
        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
        h1 ^= k1;
        h1 = h1 << 13 | h1 >>> 19;
        h1 = h1 * 5 + 0xe6546b64;
      } else {
        k2 = dataUint32[i];
        k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
        k2 = k2 << 15 | k2 >>> 17;
        k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
        h2 ^= k2;
        h2 = h2 << 13 | h2 >>> 19;
        h2 = h2 * 5 + 0xe6546b64;
      }
    }
    k1 = 0;
    switch (tailLength) {
      case 3:
        k1 ^= data[blockCounts * 4 + 2] << 16;
      case 2:
        k1 ^= data[blockCounts * 4 + 1] << 8;
      case 1:
        k1 ^= data[blockCounts * 4];
        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
        if (blockCounts & 1) {
          h1 ^= k1;
        } else {
          h2 ^= k1;
        }
    }
    this.h1 = h1;
    this.h2 = h2;
  }
  hexdigest() {
    let h1 = this.h1,
      h2 = this.h2;
    h1 ^= h2 >>> 1;
    h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;
    h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;
    h1 ^= h2 >>> 1;
    h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;
    h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;
    h1 ^= h2 >>> 1;
    return (h1 >>> 0).toString(16).padStart(8, "0") + (h2 >>> 0).toString(16).padStart(8, "0");
  }
}
exports.MurmurHash3_64 = MurmurHash3_64;

/***/ }),
/* 64 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.OperatorList = void 0;
var _util = __w_pdfjs_require__(2);
function addState(parentState, pattern, checkFn, iterateFn, processFn) {
  let state = parentState;
  for (let i = 0, ii = pattern.length - 1; i < ii; i++) {
    const item = pattern[i];
    state = state[item] ||= [];
  }
  state[pattern.at(-1)] = {
    checkFn,
    iterateFn,
    processFn
  };
}
const InitialState = [];
addState(InitialState, [_util.OPS.save, _util.OPS.transform, _util.OPS.paintInlineImageXObject, _util.OPS.restore], null, function iterateInlineImageGroup(context, i) {
  const fnArray = context.fnArray;
  const iFirstSave = context.iCurr - 3;
  const pos = (i - iFirstSave) % 4;
  switch (pos) {
    case 0:
      return fnArray[i] === _util.OPS.save;
    case 1:
      return fnArray[i] === _util.OPS.transform;
    case 2:
      return fnArray[i] === _util.OPS.paintInlineImageXObject;
    case 3:
      return fnArray[i] === _util.OPS.restore;
  }
  throw new Error(`iterateInlineImageGroup - invalid pos: ${pos}`);
}, function foundInlineImageGroup(context, i) {
  const MIN_IMAGES_IN_INLINE_IMAGES_BLOCK = 10;
  const MAX_IMAGES_IN_INLINE_IMAGES_BLOCK = 200;
  const MAX_WIDTH = 1000;
  const IMAGE_PADDING = 1;
  const fnArray = context.fnArray,
    argsArray = context.argsArray;
  const curr = context.iCurr;
  const iFirstSave = curr - 3;
  const iFirstTransform = curr - 2;
  const iFirstPIIXO = curr - 1;
  const count = Math.min(Math.floor((i - iFirstSave) / 4), MAX_IMAGES_IN_INLINE_IMAGES_BLOCK);
  if (count < MIN_IMAGES_IN_INLINE_IMAGES_BLOCK) {
    return i - (i - iFirstSave) % 4;
  }
  let maxX = 0;
  const map = [];
  let maxLineHeight = 0;
  let currentX = IMAGE_PADDING,
    currentY = IMAGE_PADDING;
  for (let q = 0; q < count; q++) {
    const transform = argsArray[iFirstTransform + (q << 2)];
    const img = argsArray[iFirstPIIXO + (q << 2)][0];
    if (currentX + img.width > MAX_WIDTH) {
      maxX = Math.max(maxX, currentX);
      currentY += maxLineHeight + 2 * IMAGE_PADDING;
      currentX = 0;
      maxLineHeight = 0;
    }
    map.push({
      transform,
      x: currentX,
      y: currentY,
      w: img.width,
      h: img.height
    });
    currentX += img.width + 2 * IMAGE_PADDING;
    maxLineHeight = Math.max(maxLineHeight, img.height);
  }
  const imgWidth = Math.max(maxX, currentX) + IMAGE_PADDING;
  const imgHeight = currentY + maxLineHeight + IMAGE_PADDING;
  const imgData = new Uint8Array(imgWidth * imgHeight * 4);
  const imgRowSize = imgWidth << 2;
  for (let q = 0; q < count; q++) {
    const data = argsArray[iFirstPIIXO + (q << 2)][0].data;
    const rowSize = map[q].w << 2;
    let dataOffset = 0;
    let offset = map[q].x + map[q].y * imgWidth << 2;
    imgData.set(data.subarray(0, rowSize), offset - imgRowSize);
    for (let k = 0, kk = map[q].h; k < kk; k++) {
      imgData.set(data.subarray(dataOffset, dataOffset + rowSize), offset);
      dataOffset += rowSize;
      offset += imgRowSize;
    }
    imgData.set(data.subarray(dataOffset - rowSize, dataOffset), offset);
    while (offset >= 0) {
      data[offset - 4] = data[offset];
      data[offset - 3] = data[offset + 1];
      data[offset - 2] = data[offset + 2];
      data[offset - 1] = data[offset + 3];
      data[offset + rowSize] = data[offset + rowSize - 4];
      data[offset + rowSize + 1] = data[offset + rowSize - 3];
      data[offset + rowSize + 2] = data[offset + rowSize - 2];
      data[offset + rowSize + 3] = data[offset + rowSize - 1];
      offset -= imgRowSize;
    }
  }
  const img = {
    width: imgWidth,
    height: imgHeight
  };
  if (context.isOffscreenCanvasSupported) {
    const canvas = new OffscreenCanvas(imgWidth, imgHeight);
    const ctx = canvas.getContext("2d");
    ctx.putImageData(new ImageData(new Uint8ClampedArray(imgData.buffer), imgWidth, imgHeight), 0, 0);
    img.bitmap = canvas.transferToImageBitmap();
    img.data = null;
  } else {
    img.kind = _util.ImageKind.RGBA_32BPP;
    img.data = imgData;
  }
  fnArray.splice(iFirstSave, count * 4, _util.OPS.paintInlineImageXObjectGroup);
  argsArray.splice(iFirstSave, count * 4, [img, map]);
  return iFirstSave + 1;
});
addState(InitialState, [_util.OPS.save, _util.OPS.transform, _util.OPS.paintImageMaskXObject, _util.OPS.restore], null, function iterateImageMaskGroup(context, i) {
  const fnArray = context.fnArray;
  const iFirstSave = context.iCurr - 3;
  const pos = (i - iFirstSave) % 4;
  switch (pos) {
    case 0:
      return fnArray[i] === _util.OPS.save;
    case 1:
      return fnArray[i] === _util.OPS.transform;
    case 2:
      return fnArray[i] === _util.OPS.paintImageMaskXObject;
    case 3:
      return fnArray[i] === _util.OPS.restore;
  }
  throw new Error(`iterateImageMaskGroup - invalid pos: ${pos}`);
}, function foundImageMaskGroup(context, i) {
  const MIN_IMAGES_IN_MASKS_BLOCK = 10;
  const MAX_IMAGES_IN_MASKS_BLOCK = 100;
  const MAX_SAME_IMAGES_IN_MASKS_BLOCK = 1000;
  const fnArray = context.fnArray,
    argsArray = context.argsArray;
  const curr = context.iCurr;
  const iFirstSave = curr - 3;
  const iFirstTransform = curr - 2;
  const iFirstPIMXO = curr - 1;
  let count = Math.floor((i - iFirstSave) / 4);
  if (count < MIN_IMAGES_IN_MASKS_BLOCK) {
    return i - (i - iFirstSave) % 4;
  }
  let isSameImage = false;
  let iTransform, transformArgs;
  const firstPIMXOArg0 = argsArray[iFirstPIMXO][0];
  const firstTransformArg0 = argsArray[iFirstTransform][0],
    firstTransformArg1 = argsArray[iFirstTransform][1],
    firstTransformArg2 = argsArray[iFirstTransform][2],
    firstTransformArg3 = argsArray[iFirstTransform][3];
  if (firstTransformArg1 === firstTransformArg2) {
    isSameImage = true;
    iTransform = iFirstTransform + 4;
    let iPIMXO = iFirstPIMXO + 4;
    for (let q = 1; q < count; q++, iTransform += 4, iPIMXO += 4) {
      transformArgs = argsArray[iTransform];
      if (argsArray[iPIMXO][0] !== firstPIMXOArg0 || transformArgs[0] !== firstTransformArg0 || transformArgs[1] !== firstTransformArg1 || transformArgs[2] !== firstTransformArg2 || transformArgs[3] !== firstTransformArg3) {
        if (q < MIN_IMAGES_IN_MASKS_BLOCK) {
          isSameImage = false;
        } else {
          count = q;
        }
        break;
      }
    }
  }
  if (isSameImage) {
    count = Math.min(count, MAX_SAME_IMAGES_IN_MASKS_BLOCK);
    const positions = new Float32Array(count * 2);
    iTransform = iFirstTransform;
    for (let q = 0; q < count; q++, iTransform += 4) {
      transformArgs = argsArray[iTransform];
      positions[q << 1] = transformArgs[4];
      positions[(q << 1) + 1] = transformArgs[5];
    }
    fnArray.splice(iFirstSave, count * 4, _util.OPS.paintImageMaskXObjectRepeat);
    argsArray.splice(iFirstSave, count * 4, [firstPIMXOArg0, firstTransformArg0, firstTransformArg1, firstTransformArg2, firstTransformArg3, positions]);
  } else {
    count = Math.min(count, MAX_IMAGES_IN_MASKS_BLOCK);
    const images = [];
    for (let q = 0; q < count; q++) {
      transformArgs = argsArray[iFirstTransform + (q << 2)];
      const maskParams = argsArray[iFirstPIMXO + (q << 2)][0];
      images.push({
        data: maskParams.data,
        width: maskParams.width,
        height: maskParams.height,
        interpolate: maskParams.interpolate,
        count: maskParams.count,
        transform: transformArgs
      });
    }
    fnArray.splice(iFirstSave, count * 4, _util.OPS.paintImageMaskXObjectGroup);
    argsArray.splice(iFirstSave, count * 4, [images]);
  }
  return iFirstSave + 1;
});
addState(InitialState, [_util.OPS.save, _util.OPS.transform, _util.OPS.paintImageXObject, _util.OPS.restore], function (context) {
  const argsArray = context.argsArray;
  const iFirstTransform = context.iCurr - 2;
  return argsArray[iFirstTransform][1] === 0 && argsArray[iFirstTransform][2] === 0;
}, function iterateImageGroup(context, i) {
  const fnArray = context.fnArray,
    argsArray = context.argsArray;
  const iFirstSave = context.iCurr - 3;
  const pos = (i - iFirstSave) % 4;
  switch (pos) {
    case 0:
      return fnArray[i] === _util.OPS.save;
    case 1:
      if (fnArray[i] !== _util.OPS.transform) {
        return false;
      }
      const iFirstTransform = context.iCurr - 2;
      const firstTransformArg0 = argsArray[iFirstTransform][0];
      const firstTransformArg3 = argsArray[iFirstTransform][3];
      if (argsArray[i][0] !== firstTransformArg0 || argsArray[i][1] !== 0 || argsArray[i][2] !== 0 || argsArray[i][3] !== firstTransformArg3) {
        return false;
      }
      return true;
    case 2:
      if (fnArray[i] !== _util.OPS.paintImageXObject) {
        return false;
      }
      const iFirstPIXO = context.iCurr - 1;
      const firstPIXOArg0 = argsArray[iFirstPIXO][0];
      if (argsArray[i][0] !== firstPIXOArg0) {
        return false;
      }
      return true;
    case 3:
      return fnArray[i] === _util.OPS.restore;
  }
  throw new Error(`iterateImageGroup - invalid pos: ${pos}`);
}, function (context, i) {
  const MIN_IMAGES_IN_BLOCK = 3;
  const MAX_IMAGES_IN_BLOCK = 1000;
  const fnArray = context.fnArray,
    argsArray = context.argsArray;
  const curr = context.iCurr;
  const iFirstSave = curr - 3;
  const iFirstTransform = curr - 2;
  const iFirstPIXO = curr - 1;
  const firstPIXOArg0 = argsArray[iFirstPIXO][0];
  const firstTransformArg0 = argsArray[iFirstTransform][0];
  const firstTransformArg3 = argsArray[iFirstTransform][3];
  const count = Math.min(Math.floor((i - iFirstSave) / 4), MAX_IMAGES_IN_BLOCK);
  if (count < MIN_IMAGES_IN_BLOCK) {
    return i - (i - iFirstSave) % 4;
  }
  const positions = new Float32Array(count * 2);
  let iTransform = iFirstTransform;
  for (let q = 0; q < count; q++, iTransform += 4) {
    const transformArgs = argsArray[iTransform];
    positions[q << 1] = transformArgs[4];
    positions[(q << 1) + 1] = transformArgs[5];
  }
  const args = [firstPIXOArg0, firstTransformArg0, firstTransformArg3, positions];
  fnArray.splice(iFirstSave, count * 4, _util.OPS.paintImageXObjectRepeat);
  argsArray.splice(iFirstSave, count * 4, args);
  return iFirstSave + 1;
});
addState(InitialState, [_util.OPS.beginText, _util.OPS.setFont, _util.OPS.setTextMatrix, _util.OPS.showText, _util.OPS.endText], null, function iterateShowTextGroup(context, i) {
  const fnArray = context.fnArray,
    argsArray = context.argsArray;
  const iFirstSave = context.iCurr - 4;
  const pos = (i - iFirstSave) % 5;
  switch (pos) {
    case 0:
      return fnArray[i] === _util.OPS.beginText;
    case 1:
      return fnArray[i] === _util.OPS.setFont;
    case 2:
      return fnArray[i] === _util.OPS.setTextMatrix;
    case 3:
      if (fnArray[i] !== _util.OPS.showText) {
        return false;
      }
      const iFirstSetFont = context.iCurr - 3;
      const firstSetFontArg0 = argsArray[iFirstSetFont][0];
      const firstSetFontArg1 = argsArray[iFirstSetFont][1];
      if (argsArray[i][0] !== firstSetFontArg0 || argsArray[i][1] !== firstSetFontArg1) {
        return false;
      }
      return true;
    case 4:
      return fnArray[i] === _util.OPS.endText;
  }
  throw new Error(`iterateShowTextGroup - invalid pos: ${pos}`);
}, function (context, i) {
  const MIN_CHARS_IN_BLOCK = 3;
  const MAX_CHARS_IN_BLOCK = 1000;
  const fnArray = context.fnArray,
    argsArray = context.argsArray;
  const curr = context.iCurr;
  const iFirstBeginText = curr - 4;
  const iFirstSetFont = curr - 3;
  const iFirstSetTextMatrix = curr - 2;
  const iFirstShowText = curr - 1;
  const iFirstEndText = curr;
  const firstSetFontArg0 = argsArray[iFirstSetFont][0];
  const firstSetFontArg1 = argsArray[iFirstSetFont][1];
  let count = Math.min(Math.floor((i - iFirstBeginText) / 5), MAX_CHARS_IN_BLOCK);
  if (count < MIN_CHARS_IN_BLOCK) {
    return i - (i - iFirstBeginText) % 5;
  }
  let iFirst = iFirstBeginText;
  if (iFirstBeginText >= 4 && fnArray[iFirstBeginText - 4] === fnArray[iFirstSetFont] && fnArray[iFirstBeginText - 3] === fnArray[iFirstSetTextMatrix] && fnArray[iFirstBeginText - 2] === fnArray[iFirstShowText] && fnArray[iFirstBeginText - 1] === fnArray[iFirstEndText] && argsArray[iFirstBeginText - 4][0] === firstSetFontArg0 && argsArray[iFirstBeginText - 4][1] === firstSetFontArg1) {
    count++;
    iFirst -= 5;
  }
  let iEndText = iFirst + 4;
  for (let q = 1; q < count; q++) {
    fnArray.splice(iEndText, 3);
    argsArray.splice(iEndText, 3);
    iEndText += 2;
  }
  return iEndText + 1;
});
class NullOptimizer {
  constructor(queue) {
    this.queue = queue;
  }
  _optimize() {}
  push(fn, args) {
    this.queue.fnArray.push(fn);
    this.queue.argsArray.push(args);
    this._optimize();
  }
  flush() {}
  reset() {}
}
class QueueOptimizer extends NullOptimizer {
  constructor(queue) {
    super(queue);
    this.state = null;
    this.context = {
      iCurr: 0,
      fnArray: queue.fnArray,
      argsArray: queue.argsArray,
      isOffscreenCanvasSupported: false
    };
    this.match = null;
    this.lastProcessed = 0;
  }
  set isOffscreenCanvasSupported(value) {
    this.context.isOffscreenCanvasSupported = value;
  }
  _optimize() {
    const fnArray = this.queue.fnArray;
    let i = this.lastProcessed,
      ii = fnArray.length;
    let state = this.state;
    let match = this.match;
    if (!state && !match && i + 1 === ii && !InitialState[fnArray[i]]) {
      this.lastProcessed = ii;
      return;
    }
    const context = this.context;
    while (i < ii) {
      if (match) {
        const iterate = (0, match.iterateFn)(context, i);
        if (iterate) {
          i++;
          continue;
        }
        i = (0, match.processFn)(context, i + 1);
        ii = fnArray.length;
        match = null;
        state = null;
        if (i >= ii) {
          break;
        }
      }
      state = (state || InitialState)[fnArray[i]];
      if (!state || Array.isArray(state)) {
        i++;
        continue;
      }
      context.iCurr = i;
      i++;
      if (state.checkFn && !(0, state.checkFn)(context)) {
        state = null;
        continue;
      }
      match = state;
      state = null;
    }
    this.state = state;
    this.match = match;
    this.lastProcessed = i;
  }
  flush() {
    while (this.match) {
      const length = this.queue.fnArray.length;
      this.lastProcessed = (0, this.match.processFn)(this.context, length);
      this.match = null;
      this.state = null;
      this._optimize();
    }
  }
  reset() {
    this.state = null;
    this.match = null;
    this.lastProcessed = 0;
  }
}
class OperatorList {
  static CHUNK_SIZE = 1000;
  static CHUNK_SIZE_ABOUT = this.CHUNK_SIZE - 5;
  constructor(intent = 0, streamSink) {
    this._streamSink = streamSink;
    this.fnArray = [];
    this.argsArray = [];
    this.optimizer = streamSink && !(intent & _util.RenderingIntentFlag.OPLIST) ? new QueueOptimizer(this) : new NullOptimizer(this);
    this.dependencies = new Set();
    this._totalLength = 0;
    this.weight = 0;
    this._resolved = streamSink ? null : Promise.resolve();
  }
  set isOffscreenCanvasSupported(value) {
    this.optimizer.isOffscreenCanvasSupported = value;
  }
  get length() {
    return this.argsArray.length;
  }
  get ready() {
    return this._resolved || this._streamSink.ready;
  }
  get totalLength() {
    return this._totalLength + this.length;
  }
  addOp(fn, args) {
    this.optimizer.push(fn, args);
    this.weight++;
    if (this._streamSink) {
      if (this.weight >= OperatorList.CHUNK_SIZE) {
        this.flush();
      } else if (this.weight >= OperatorList.CHUNK_SIZE_ABOUT && (fn === _util.OPS.restore || fn === _util.OPS.endText)) {
        this.flush();
      }
    }
  }
  addImageOps(fn, args, optionalContent) {
    if (optionalContent !== undefined) {
      this.addOp(_util.OPS.beginMarkedContentProps, ["OC", optionalContent]);
    }
    this.addOp(fn, args);
    if (optionalContent !== undefined) {
      this.addOp(_util.OPS.endMarkedContent, []);
    }
  }
  addDependency(dependency) {
    if (this.dependencies.has(dependency)) {
      return;
    }
    this.dependencies.add(dependency);
    this.addOp(_util.OPS.dependency, [dependency]);
  }
  addDependencies(dependencies) {
    for (const dependency of dependencies) {
      this.addDependency(dependency);
    }
  }
  addOpList(opList) {
    if (!(opList instanceof OperatorList)) {
      (0, _util.warn)('addOpList - ignoring invalid "opList" parameter.');
      return;
    }
    for (const dependency of opList.dependencies) {
      this.dependencies.add(dependency);
    }
    for (let i = 0, ii = opList.length; i < ii; i++) {
      this.addOp(opList.fnArray[i], opList.argsArray[i]);
    }
  }
  getIR() {
    return {
      fnArray: this.fnArray,
      argsArray: this.argsArray,
      length: this.length
    };
  }
  get _transfers() {
    const transfers = [];
    const {
      fnArray,
      argsArray,
      length
    } = this;
    for (let i = 0; i < length; i++) {
      switch (fnArray[i]) {
        case _util.OPS.paintInlineImageXObject:
        case _util.OPS.paintInlineImageXObjectGroup:
        case _util.OPS.paintImageMaskXObject:
          const arg = argsArray[i][0];
          if (!arg.cached && arg.data?.buffer instanceof ArrayBuffer) {
            transfers.push(arg.data.buffer);
          }
          break;
      }
    }
    return transfers;
  }
  flush(lastChunk = false, separateAnnots = null) {
    this.optimizer.flush();
    const length = this.length;
    this._totalLength += length;
    this._streamSink.enqueue({
      fnArray: this.fnArray,
      argsArray: this.argsArray,
      lastChunk,
      separateAnnots,
      length
    }, 1, this._transfers);
    this.dependencies.clear();
    this.fnArray.length = 0;
    this.argsArray.length = 0;
    this.weight = 0;
    this.optimizer.reset();
  }
}
exports.OperatorList = OperatorList;

/***/ }),
/* 65 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFImage = void 0;
var _util = __w_pdfjs_require__(2);
var _image_utils = __w_pdfjs_require__(28);
var _base_stream = __w_pdfjs_require__(5);
var _colorspace = __w_pdfjs_require__(12);
var _decode_stream = __w_pdfjs_require__(18);
var _image_resizer = __w_pdfjs_require__(62);
var _jpeg_stream = __w_pdfjs_require__(26);
var _jpx = __w_pdfjs_require__(30);
var _primitives = __w_pdfjs_require__(4);
function decodeAndClamp(value, addend, coefficient, max) {
  value = addend + value * coefficient;
  if (value < 0) {
    value = 0;
  } else if (value > max) {
    value = max;
  }
  return value;
}
function resizeImageMask(src, bpc, w1, h1, w2, h2) {
  const length = w2 * h2;
  let dest;
  if (bpc <= 8) {
    dest = new Uint8Array(length);
  } else if (bpc <= 16) {
    dest = new Uint16Array(length);
  } else {
    dest = new Uint32Array(length);
  }
  const xRatio = w1 / w2;
  const yRatio = h1 / h2;
  let i,
    j,
    py,
    newIndex = 0,
    oldIndex;
  const xScaled = new Uint16Array(w2);
  const w1Scanline = w1;
  for (i = 0; i < w2; i++) {
    xScaled[i] = Math.floor(i * xRatio);
  }
  for (i = 0; i < h2; i++) {
    py = Math.floor(i * yRatio) * w1Scanline;
    for (j = 0; j < w2; j++) {
      oldIndex = py + xScaled[j];
      dest[newIndex++] = src[oldIndex];
    }
  }
  return dest;
}
class PDFImage {
  constructor({
    xref,
    res,
    image,
    isInline = false,
    smask = null,
    mask = null,
    isMask = false,
    pdfFunctionFactory,
    localColorSpaceCache
  }) {
    this.image = image;
    const dict = image.dict;
    const filter = dict.get("F", "Filter");
    let filterName;
    if (filter instanceof _primitives.Name) {
      filterName = filter.name;
    } else if (Array.isArray(filter)) {
      const filterZero = xref.fetchIfRef(filter[0]);
      if (filterZero instanceof _primitives.Name) {
        filterName = filterZero.name;
      }
    }
    switch (filterName) {
      case "JPXDecode":
        const jpxImage = new _jpx.JpxImage();
        jpxImage.parseImageProperties(image.stream);
        image.stream.reset();
        image.width = jpxImage.width;
        image.height = jpxImage.height;
        image.bitsPerComponent = jpxImage.bitsPerComponent;
        image.numComps = jpxImage.componentsCount;
        break;
      case "JBIG2Decode":
        image.bitsPerComponent = 1;
        image.numComps = 1;
        break;
    }
    let width = dict.get("W", "Width");
    let height = dict.get("H", "Height");
    if (Number.isInteger(image.width) && image.width > 0 && Number.isInteger(image.height) && image.height > 0 && (image.width !== width || image.height !== height)) {
      (0, _util.warn)("PDFImage - using the Width/Height of the image data, " + "rather than the image dictionary.");
      width = image.width;
      height = image.height;
    }
    if (width < 1 || height < 1) {
      throw new _util.FormatError(`Invalid image width: ${width} or height: ${height}`);
    }
    this.width = width;
    this.height = height;
    this.interpolate = dict.get("I", "Interpolate");
    this.imageMask = dict.get("IM", "ImageMask") || false;
    this.matte = dict.get("Matte") || false;
    let bitsPerComponent = image.bitsPerComponent;
    if (!bitsPerComponent) {
      bitsPerComponent = dict.get("BPC", "BitsPerComponent");
      if (!bitsPerComponent) {
        if (this.imageMask) {
          bitsPerComponent = 1;
        } else {
          throw new _util.FormatError(`Bits per component missing in image: ${this.imageMask}`);
        }
      }
    }
    this.bpc = bitsPerComponent;
    if (!this.imageMask) {
      let colorSpace = dict.getRaw("CS") || dict.getRaw("ColorSpace");
      if (!colorSpace) {
        (0, _util.info)("JPX images (which do not require color spaces)");
        switch (image.numComps) {
          case 1:
            colorSpace = _primitives.Name.get("DeviceGray");
            break;
          case 3:
            colorSpace = _primitives.Name.get("DeviceRGB");
            break;
          case 4:
            colorSpace = _primitives.Name.get("DeviceCMYK");
            break;
          default:
            throw new Error(`JPX images with ${image.numComps} color components not supported.`);
        }
      }
      this.colorSpace = _colorspace.ColorSpace.parse({
        cs: colorSpace,
        xref,
        resources: isInline ? res : null,
        pdfFunctionFactory,
        localColorSpaceCache
      });
      this.numComps = this.colorSpace.numComps;
    }
    this.decode = dict.getArray("D", "Decode");
    this.needsDecode = false;
    if (this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, bitsPerComponent) || isMask && !_colorspace.ColorSpace.isDefaultDecode(this.decode, 1))) {
      this.needsDecode = true;
      const max = (1 << bitsPerComponent) - 1;
      this.decodeCoefficients = [];
      this.decodeAddends = [];
      const isIndexed = this.colorSpace?.name === "Indexed";
      for (let i = 0, j = 0; i < this.decode.length; i += 2, ++j) {
        const dmin = this.decode[i];
        const dmax = this.decode[i + 1];
        this.decodeCoefficients[j] = isIndexed ? (dmax - dmin) / max : dmax - dmin;
        this.decodeAddends[j] = isIndexed ? dmin : max * dmin;
      }
    }
    if (smask) {
      this.smask = new PDFImage({
        xref,
        res,
        image: smask,
        isInline,
        pdfFunctionFactory,
        localColorSpaceCache
      });
    } else if (mask) {
      if (mask instanceof _base_stream.BaseStream) {
        const maskDict = mask.dict,
          imageMask = maskDict.get("IM", "ImageMask");
        if (!imageMask) {
          (0, _util.warn)("Ignoring /Mask in image without /ImageMask.");
        } else {
          this.mask = new PDFImage({
            xref,
            res,
            image: mask,
            isInline,
            isMask: true,
            pdfFunctionFactory,
            localColorSpaceCache
          });
        }
      } else {
        this.mask = mask;
      }
    }
  }
  static async buildImage({
    xref,
    res,
    image,
    isInline = false,
    pdfFunctionFactory,
    localColorSpaceCache
  }) {
    const imageData = image;
    let smaskData = null;
    let maskData = null;
    const smask = image.dict.get("SMask");
    const mask = image.dict.get("Mask");
    if (smask) {
      if (smask instanceof _base_stream.BaseStream) {
        smaskData = smask;
      } else {
        (0, _util.warn)("Unsupported /SMask format.");
      }
    } else if (mask) {
      if (mask instanceof _base_stream.BaseStream || Array.isArray(mask)) {
        maskData = mask;
      } else {
        (0, _util.warn)("Unsupported /Mask format.");
      }
    }
    return new PDFImage({
      xref,
      res,
      image: imageData,
      isInline,
      smask: smaskData,
      mask: maskData,
      pdfFunctionFactory,
      localColorSpaceCache
    });
  }
  static createRawMask({
    imgArray,
    width,
    height,
    imageIsFromDecodeStream,
    inverseDecode,
    interpolate
  }) {
    const computedLength = (width + 7 >> 3) * height;
    const actualLength = imgArray.byteLength;
    const haveFullData = computedLength === actualLength;
    let data, i;
    if (imageIsFromDecodeStream && (!inverseDecode || haveFullData)) {
      data = imgArray;
    } else if (!inverseDecode) {
      data = new Uint8Array(imgArray);
    } else {
      data = new Uint8Array(computedLength);
      data.set(imgArray);
      data.fill(0xff, actualLength);
    }
    if (inverseDecode) {
      for (i = 0; i < actualLength; i++) {
        data[i] ^= 0xff;
      }
    }
    return {
      data,
      width,
      height,
      interpolate
    };
  }
  static async createMask({
    imgArray,
    width,
    height,
    imageIsFromDecodeStream,
    inverseDecode,
    interpolate,
    isOffscreenCanvasSupported = false
  }) {
    const isSingleOpaquePixel = width === 1 && height === 1 && inverseDecode === (imgArray.length === 0 || !!(imgArray[0] & 128));
    if (isSingleOpaquePixel) {
      return {
        isSingleOpaquePixel
      };
    }
    if (isOffscreenCanvasSupported) {
      if (_image_resizer.ImageResizer.needsToBeResized(width, height)) {
        const data = new Uint8ClampedArray(width * height * 4);
        (0, _image_utils.convertBlackAndWhiteToRGBA)({
          src: imgArray,
          dest: data,
          width,
          height,
          nonBlackColor: 0,
          inverseDecode
        });
        return _image_resizer.ImageResizer.createImage({
          kind: _util.ImageKind.RGBA_32BPP,
          data,
          width,
          height,
          interpolate
        });
      }
      const canvas = new OffscreenCanvas(width, height);
      const ctx = canvas.getContext("2d");
      const imgData = ctx.createImageData(width, height);
      (0, _image_utils.convertBlackAndWhiteToRGBA)({
        src: imgArray,
        dest: imgData.data,
        width,
        height,
        nonBlackColor: 0,
        inverseDecode
      });
      ctx.putImageData(imgData, 0, 0);
      const bitmap = canvas.transferToImageBitmap();
      return {
        data: null,
        width,
        height,
        interpolate,
        bitmap
      };
    }
    return this.createRawMask({
      imgArray,
      width,
      height,
      inverseDecode,
      imageIsFromDecodeStream,
      interpolate
    });
  }
  get drawWidth() {
    return Math.max(this.width, this.smask?.width || 0, this.mask?.width || 0);
  }
  get drawHeight() {
    return Math.max(this.height, this.smask?.height || 0, this.mask?.height || 0);
  }
  decodeBuffer(buffer) {
    const bpc = this.bpc;
    const numComps = this.numComps;
    const decodeAddends = this.decodeAddends;
    const decodeCoefficients = this.decodeCoefficients;
    const max = (1 << bpc) - 1;
    let i, ii;
    if (bpc === 1) {
      for (i = 0, ii = buffer.length; i < ii; i++) {
        buffer[i] = +!buffer[i];
      }
      return;
    }
    let index = 0;
    for (i = 0, ii = this.width * this.height; i < ii; i++) {
      for (let j = 0; j < numComps; j++) {
        buffer[index] = decodeAndClamp(buffer[index], decodeAddends[j], decodeCoefficients[j], max);
        index++;
      }
    }
  }
  getComponents(buffer) {
    const bpc = this.bpc;
    if (bpc === 8) {
      return buffer;
    }
    const width = this.width;
    const height = this.height;
    const numComps = this.numComps;
    const length = width * height * numComps;
    let bufferPos = 0;
    let output;
    if (bpc <= 8) {
      output = new Uint8Array(length);
    } else if (bpc <= 16) {
      output = new Uint16Array(length);
    } else {
      output = new Uint32Array(length);
    }
    const rowComps = width * numComps;
    const max = (1 << bpc) - 1;
    let i = 0,
      ii,
      buf;
    if (bpc === 1) {
      let mask, loop1End, loop2End;
      for (let j = 0; j < height; j++) {
        loop1End = i + (rowComps & ~7);
        loop2End = i + rowComps;
        while (i < loop1End) {
          buf = buffer[bufferPos++];
          output[i] = buf >> 7 & 1;
          output[i + 1] = buf >> 6 & 1;
          output[i + 2] = buf >> 5 & 1;
          output[i + 3] = buf >> 4 & 1;
          output[i + 4] = buf >> 3 & 1;
          output[i + 5] = buf >> 2 & 1;
          output[i + 6] = buf >> 1 & 1;
          output[i + 7] = buf & 1;
          i += 8;
        }
        if (i < loop2End) {
          buf = buffer[bufferPos++];
          mask = 128;
          while (i < loop2End) {
            output[i++] = +!!(buf & mask);
            mask >>= 1;
          }
        }
      }
    } else {
      let bits = 0;
      buf = 0;
      for (i = 0, ii = length; i < ii; ++i) {
        if (i % rowComps === 0) {
          buf = 0;
          bits = 0;
        }
        while (bits < bpc) {
          buf = buf << 8 | buffer[bufferPos++];
          bits += 8;
        }
        const remainingBits = bits - bpc;
        let value = buf >> remainingBits;
        if (value < 0) {
          value = 0;
        } else if (value > max) {
          value = max;
        }
        output[i] = value;
        buf &= (1 << remainingBits) - 1;
        bits = remainingBits;
      }
    }
    return output;
  }
  fillOpacity(rgbaBuf, width, height, actualHeight, image) {
    const smask = this.smask;
    const mask = this.mask;
    let alphaBuf, sw, sh, i, ii, j;
    if (smask) {
      sw = smask.width;
      sh = smask.height;
      alphaBuf = new Uint8ClampedArray(sw * sh);
      smask.fillGrayBuffer(alphaBuf);
      if (sw !== width || sh !== height) {
        alphaBuf = resizeImageMask(alphaBuf, smask.bpc, sw, sh, width, height);
      }
    } else if (mask) {
      if (mask instanceof PDFImage) {
        sw = mask.width;
        sh = mask.height;
        alphaBuf = new Uint8ClampedArray(sw * sh);
        mask.numComps = 1;
        mask.fillGrayBuffer(alphaBuf);
        for (i = 0, ii = sw * sh; i < ii; ++i) {
          alphaBuf[i] = 255 - alphaBuf[i];
        }
        if (sw !== width || sh !== height) {
          alphaBuf = resizeImageMask(alphaBuf, mask.bpc, sw, sh, width, height);
        }
      } else if (Array.isArray(mask)) {
        alphaBuf = new Uint8ClampedArray(width * height);
        const numComps = this.numComps;
        for (i = 0, ii = width * height; i < ii; ++i) {
          let opacity = 0;
          const imageOffset = i * numComps;
          for (j = 0; j < numComps; ++j) {
            const color = image[imageOffset + j];
            const maskOffset = j * 2;
            if (color < mask[maskOffset] || color > mask[maskOffset + 1]) {
              opacity = 255;
              break;
            }
          }
          alphaBuf[i] = opacity;
        }
      } else {
        throw new _util.FormatError("Unknown mask format.");
      }
    }
    if (alphaBuf) {
      for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {
        rgbaBuf[j] = alphaBuf[i];
      }
    } else {
      for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {
        rgbaBuf[j] = 255;
      }
    }
  }
  undoPreblend(buffer, width, height) {
    const matte = this.smask?.matte;
    if (!matte) {
      return;
    }
    const matteRgb = this.colorSpace.getRgb(matte, 0);
    const matteR = matteRgb[0];
    const matteG = matteRgb[1];
    const matteB = matteRgb[2];
    const length = width * height * 4;
    for (let i = 0; i < length; i += 4) {
      const alpha = buffer[i + 3];
      if (alpha === 0) {
        buffer[i] = 255;
        buffer[i + 1] = 255;
        buffer[i + 2] = 255;
        continue;
      }
      const k = 255 / alpha;
      buffer[i] = (buffer[i] - matteR) * k + matteR;
      buffer[i + 1] = (buffer[i + 1] - matteG) * k + matteG;
      buffer[i + 2] = (buffer[i + 2] - matteB) * k + matteB;
    }
  }
  async createImageData(forceRGBA = false, isOffscreenCanvasSupported = false) {
    const drawWidth = this.drawWidth;
    const drawHeight = this.drawHeight;
    const imgData = {
      width: drawWidth,
      height: drawHeight,
      interpolate: this.interpolate,
      kind: 0,
      data: null
    };
    const numComps = this.numComps;
    const originalWidth = this.width;
    const originalHeight = this.height;
    const bpc = this.bpc;
    const rowBytes = originalWidth * numComps * bpc + 7 >> 3;
    const mustBeResized = isOffscreenCanvasSupported && _image_resizer.ImageResizer.needsToBeResized(drawWidth, drawHeight);
    if (!forceRGBA) {
      let kind;
      if (this.colorSpace.name === "DeviceGray" && bpc === 1) {
        kind = _util.ImageKind.GRAYSCALE_1BPP;
      } else if (this.colorSpace.name === "DeviceRGB" && bpc === 8 && !this.needsDecode) {
        kind = _util.ImageKind.RGB_24BPP;
      }
      if (kind && !this.smask && !this.mask && drawWidth === originalWidth && drawHeight === originalHeight) {
        const data = this.getImageBytes(originalHeight * rowBytes, {});
        if (isOffscreenCanvasSupported) {
          if (mustBeResized) {
            return _image_resizer.ImageResizer.createImage({
              data,
              kind,
              width: drawWidth,
              height: drawHeight,
              interpolate: this.interpolate
            }, this.needsDecode);
          }
          return this.createBitmap(kind, originalWidth, originalHeight, data);
        }
        imgData.kind = kind;
        imgData.data = data;
        if (this.needsDecode) {
          (0, _util.assert)(kind === _util.ImageKind.GRAYSCALE_1BPP, "PDFImage.createImageData: The image must be grayscale.");
          const buffer = imgData.data;
          for (let i = 0, ii = buffer.length; i < ii; i++) {
            buffer[i] ^= 0xff;
          }
        }
        return imgData;
      }
      if (this.image instanceof _jpeg_stream.JpegStream && !this.smask && !this.mask && !this.needsDecode) {
        let imageLength = originalHeight * rowBytes;
        if (isOffscreenCanvasSupported && !mustBeResized) {
          let isHandled = false;
          switch (this.colorSpace.name) {
            case "DeviceGray":
              imageLength *= 4;
              isHandled = true;
              break;
            case "DeviceRGB":
              imageLength = imageLength / 3 * 4;
              isHandled = true;
              break;
            case "DeviceCMYK":
              isHandled = true;
              break;
          }
          if (isHandled) {
            const rgba = this.getImageBytes(imageLength, {
              drawWidth,
              drawHeight,
              forceRGBA: true
            });
            return this.createBitmap(_util.ImageKind.RGBA_32BPP, drawWidth, drawHeight, rgba);
          }
        } else {
          switch (this.colorSpace.name) {
            case "DeviceGray":
              imageLength *= 3;
            case "DeviceRGB":
            case "DeviceCMYK":
              imgData.kind = _util.ImageKind.RGB_24BPP;
              imgData.data = this.getImageBytes(imageLength, {
                drawWidth,
                drawHeight,
                forceRGB: true
              });
              if (mustBeResized) {
                return _image_resizer.ImageResizer.createImage(imgData);
              }
              return imgData;
          }
        }
      }
    }
    const imgArray = this.getImageBytes(originalHeight * rowBytes, {
      internal: true
    });
    const actualHeight = 0 | imgArray.length / rowBytes * drawHeight / originalHeight;
    const comps = this.getComponents(imgArray);
    let alpha01, maybeUndoPreblend;
    let canvas, ctx, canvasImgData, data;
    if (isOffscreenCanvasSupported && !mustBeResized) {
      canvas = new OffscreenCanvas(drawWidth, drawHeight);
      ctx = canvas.getContext("2d");
      canvasImgData = ctx.createImageData(drawWidth, drawHeight);
      data = canvasImgData.data;
    }
    imgData.kind = _util.ImageKind.RGBA_32BPP;
    if (!forceRGBA && !this.smask && !this.mask) {
      if (!isOffscreenCanvasSupported || mustBeResized) {
        imgData.kind = _util.ImageKind.RGB_24BPP;
        data = new Uint8ClampedArray(drawWidth * drawHeight * 3);
        alpha01 = 0;
      } else {
        const arr = new Uint32Array(data.buffer);
        arr.fill(_util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff);
        alpha01 = 1;
      }
      maybeUndoPreblend = false;
    } else {
      if (!isOffscreenCanvasSupported || mustBeResized) {
        data = new Uint8ClampedArray(drawWidth * drawHeight * 4);
      }
      alpha01 = 1;
      maybeUndoPreblend = true;
      this.fillOpacity(data, drawWidth, drawHeight, actualHeight, comps);
    }
    if (this.needsDecode) {
      this.decodeBuffer(comps);
    }
    this.colorSpace.fillRgb(data, originalWidth, originalHeight, drawWidth, drawHeight, actualHeight, bpc, comps, alpha01);
    if (maybeUndoPreblend) {
      this.undoPreblend(data, drawWidth, actualHeight);
    }
    if (isOffscreenCanvasSupported && !mustBeResized) {
      ctx.putImageData(canvasImgData, 0, 0);
      const bitmap = canvas.transferToImageBitmap();
      return {
        data: null,
        width: drawWidth,
        height: drawHeight,
        bitmap,
        interpolate: this.interpolate
      };
    }
    imgData.data = data;
    if (mustBeResized) {
      return _image_resizer.ImageResizer.createImage(imgData);
    }
    return imgData;
  }
  fillGrayBuffer(buffer) {
    const numComps = this.numComps;
    if (numComps !== 1) {
      throw new _util.FormatError(`Reading gray scale from a color image: ${numComps}`);
    }
    const width = this.width;
    const height = this.height;
    const bpc = this.bpc;
    const rowBytes = width * numComps * bpc + 7 >> 3;
    const imgArray = this.getImageBytes(height * rowBytes, {
      internal: true
    });
    const comps = this.getComponents(imgArray);
    let i, length;
    if (bpc === 1) {
      length = width * height;
      if (this.needsDecode) {
        for (i = 0; i < length; ++i) {
          buffer[i] = comps[i] - 1 & 255;
        }
      } else {
        for (i = 0; i < length; ++i) {
          buffer[i] = -comps[i] & 255;
        }
      }
      return;
    }
    if (this.needsDecode) {
      this.decodeBuffer(comps);
    }
    length = width * height;
    const scale = 255 / ((1 << bpc) - 1);
    for (i = 0; i < length; ++i) {
      buffer[i] = scale * comps[i];
    }
  }
  createBitmap(kind, width, height, src) {
    const canvas = new OffscreenCanvas(width, height);
    const ctx = canvas.getContext("2d");
    let imgData;
    if (kind === _util.ImageKind.RGBA_32BPP) {
      imgData = new ImageData(src, width, height);
    } else {
      imgData = ctx.createImageData(width, height);
      (0, _image_utils.convertToRGBA)({
        kind,
        src,
        dest: new Uint32Array(imgData.data.buffer),
        width,
        height,
        inverseDecode: this.needsDecode
      });
    }
    ctx.putImageData(imgData, 0, 0);
    const bitmap = canvas.transferToImageBitmap();
    return {
      data: null,
      width,
      height,
      bitmap,
      interpolate: this.interpolate
    };
  }
  getImageBytes(length, {
    drawWidth,
    drawHeight,
    forceRGBA = false,
    forceRGB = false,
    internal = false
  }) {
    this.image.reset();
    this.image.drawWidth = drawWidth || this.width;
    this.image.drawHeight = drawHeight || this.height;
    this.image.forceRGBA = !!forceRGBA;
    this.image.forceRGB = !!forceRGB;
    const imageBytes = this.image.getBytes(length);
    if (internal || this.image instanceof _decode_stream.DecodeStream) {
      return imageBytes;
    }
    (0, _util.assert)(imageBytes instanceof Uint8Array, 'PDFImage.getImageBytes: Unsupported "imageBytes" type.');
    return new Uint8Array(imageBytes);
  }
}
exports.PDFImage = PDFImage;

/***/ }),
/* 66 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Catalog = void 0;
var _core_utils = __w_pdfjs_require__(3);
var _util = __w_pdfjs_require__(2);
var _primitives = __w_pdfjs_require__(4);
var _name_number_tree = __w_pdfjs_require__(67);
var _base_stream = __w_pdfjs_require__(5);
var _cleanup_helper = __w_pdfjs_require__(68);
var _colorspace = __w_pdfjs_require__(12);
var _file_spec = __w_pdfjs_require__(69);
var _image_utils = __w_pdfjs_require__(59);
var _metadata_parser = __w_pdfjs_require__(70);
var _struct_tree = __w_pdfjs_require__(72);
function fetchDestination(dest) {
  if (dest instanceof _primitives.Dict) {
    dest = dest.get("D");
  }
  return Array.isArray(dest) ? dest : null;
}
class Catalog {
  constructor(pdfManager, xref) {
    this.pdfManager = pdfManager;
    this.xref = xref;
    this._catDict = xref.getCatalogObj();
    if (!(this._catDict instanceof _primitives.Dict)) {
      throw new _util.FormatError("Catalog object is not a dictionary.");
    }
    this.toplevelPagesDict;
    this._actualNumPages = null;
    this.fontCache = new _primitives.RefSetCache();
    this.builtInCMapCache = new Map();
    this.standardFontDataCache = new Map();
    this.globalImageCache = new _image_utils.GlobalImageCache();
    this.pageKidsCountCache = new _primitives.RefSetCache();
    this.pageIndexCache = new _primitives.RefSetCache();
    this.nonBlendModesSet = new _primitives.RefSet();
    this.systemFontCache = new Map();
  }
  cloneDict() {
    return this._catDict.clone();
  }
  get version() {
    const version = this._catDict.get("Version");
    if (version instanceof _primitives.Name) {
      if (_core_utils.PDF_VERSION_REGEXP.test(version.name)) {
        return (0, _util.shadow)(this, "version", version.name);
      }
      (0, _util.warn)(`Invalid PDF catalog version: ${version.name}`);
    }
    return (0, _util.shadow)(this, "version", null);
  }
  get lang() {
    const lang = this._catDict.get("Lang");
    return (0, _util.shadow)(this, "lang", typeof lang === "string" ? (0, _util.stringToPDFString)(lang) : null);
  }
  get needsRendering() {
    const needsRendering = this._catDict.get("NeedsRendering");
    return (0, _util.shadow)(this, "needsRendering", typeof needsRendering === "boolean" ? needsRendering : false);
  }
  get collection() {
    let collection = null;
    try {
      const obj = this._catDict.get("Collection");
      if (obj instanceof _primitives.Dict && obj.size > 0) {
        collection = obj;
      }
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }
      (0, _util.info)("Cannot fetch Collection entry; assuming no collection is present.");
    }
    return (0, _util.shadow)(this, "collection", collection);
  }
  get acroForm() {
    let acroForm = null;
    try {
      const obj = this._catDict.get("AcroForm");
      if (obj instanceof _primitives.Dict && obj.size > 0) {
        acroForm = obj;
      }
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }
      (0, _util.info)("Cannot fetch AcroForm entry; assuming no forms are present.");
    }
    return (0, _util.shadow)(this, "acroForm", acroForm);
  }
  get acroFormRef() {
    const value = this._catDict.getRaw("AcroForm");
    return (0, _util.shadow)(this, "acroFormRef", value instanceof _primitives.Ref ? value : null);
  }
  get metadata() {
    const streamRef = this._catDict.getRaw("Metadata");
    if (!(streamRef instanceof _primitives.Ref)) {
      return (0, _util.shadow)(this, "metadata", null);
    }
    let metadata = null;
    try {
      const stream = this.xref.fetch(streamRef, !this.xref.encrypt?.encryptMetadata);
      if (stream instanceof _base_stream.BaseStream && stream.dict instanceof _primitives.Dict) {
        const type = stream.dict.get("Type");
        const subtype = stream.dict.get("Subtype");
        if ((0, _primitives.isName)(type, "Metadata") && (0, _primitives.isName)(subtype, "XML")) {
          const data = (0, _util.stringToUTF8String)(stream.getString());
          if (data) {
            metadata = new _metadata_parser.MetadataParser(data).serializable;
          }
        }
      }
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }
      (0, _util.info)(`Skipping invalid Metadata: "${ex}".`);
    }
    return (0, _util.shadow)(this, "metadata", metadata);
  }
  get markInfo() {
    let markInfo = null;
    try {
      markInfo = this._readMarkInfo();
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }
      (0, _util.warn)("Unable to read mark info.");
    }
    return (0, _util.shadow)(this, "markInfo", markInfo);
  }
  _readMarkInfo() {
    const obj = this._catDict.get("MarkInfo");
    if (!(obj instanceof _primitives.Dict)) {
      return null;
    }
    const markInfo = {
      Marked: false,
      UserProperties: false,
      Suspects: false
    };
    for (const key in markInfo) {
      const value = obj.get(key);
      if (typeof value === "boolean") {
        markInfo[key] = value;
      }
    }
    return markInfo;
  }
  get structTreeRoot() {
    let structTree = null;
    try {
      structTree = this._readStructTreeRoot();
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }
      (0, _util.warn)("Unable read to structTreeRoot info.");
    }
    return (0, _util.shadow)(this, "structTreeRoot", structTree);
  }
  _readStructTreeRoot() {
    const rawObj = this._catDict.getRaw("StructTreeRoot");
    const obj = this.xref.fetchIfRef(rawObj);
    if (!(obj instanceof _primitives.Dict)) {
      return null;
    }
    const root = new _struct_tree.StructTreeRoot(obj, rawObj);
    root.init();
    return root;
  }
  get toplevelPagesDict() {
    const pagesObj = this._catDict.get("Pages");
    if (!(pagesObj instanceof _primitives.Dict)) {
      throw new _util.FormatError("Invalid top-level pages dictionary.");
    }
    return (0, _util.shadow)(this, "toplevelPagesDict", pagesObj);
  }
  get documentOutline() {
    let obj = null;
    try {
      obj = this._readDocumentOutline();
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }
      (0, _util.warn)("Unable to read document outline.");
    }
    return (0, _util.shadow)(this, "documentOutline", obj);
  }
  _readDocumentOutline() {
    let obj = this._catDict.get("Outlines");
    if (!(obj instanceof _primitives.Dict)) {
      return null;
    }
    obj = obj.getRaw("First");
    if (!(obj instanceof _primitives.Ref)) {
      return null;
    }
    const root = {
      items: []
    };
    const queue = [{
      obj,
      parent: root
    }];
    const processed = new _primitives.RefSet();
    processed.put(obj);
    const xref = this.xref,
      blackColor = new Uint8ClampedArray(3);
    while (queue.length > 0) {
      const i = queue.shift();
      const outlineDict = xref.fetchIfRef(i.obj);
      if (outlineDict === null) {
        continue;
      }
      if (!outlineDict.has("Title")) {
        throw new _util.FormatError("Invalid outline item encountered.");
      }
      const data = {
        url: null,
        dest: null,
        action: null
      };
      Catalog.parseDestDictionary({
        destDict: outlineDict,
        resultObj: data,
        docBaseUrl: this.baseUrl,
        docAttachments: this.attachments
      });
      const title = outlineDict.get("Title");
      const flags = outlineDict.get("F") || 0;
      const color = outlineDict.getArray("C");
      const count = outlineDict.get("Count");
      let rgbColor = blackColor;
      if (Array.isArray(color) && color.length === 3 && (color[0] !== 0 || color[1] !== 0 || color[2] !== 0)) {
        rgbColor = _colorspace.ColorSpace.singletons.rgb.getRgb(color, 0);
      }
      const outlineItem = {
        action: data.action,
        attachment: data.attachment,
        dest: data.dest,
        url: data.url,
        unsafeUrl: data.unsafeUrl,
        newWindow: data.newWindow,
        setOCGState: data.setOCGState,
        title: (0, _util.stringToPDFString)(title),
        color: rgbColor,
        count: Number.isInteger(count) ? count : undefined,
        bold: !!(flags & 2),
        italic: !!(flags & 1),
        items: []
      };
      i.parent.items.push(outlineItem);
      obj = outlineDict.getRaw("First");
      if (obj instanceof _primitives.Ref && !processed.has(obj)) {
        queue.push({
          obj,
          parent: outlineItem
        });
        processed.put(obj);
      }
      obj = outlineDict.getRaw("Next");
      if (obj instanceof _primitives.Ref && !processed.has(obj)) {
        queue.push({
          obj,
          parent: i.parent
        });
        processed.put(obj);
      }
    }
    return root.items.length > 0 ? root.items : null;
  }
  get permissions() {
    let permissions = null;
    try {
      permissions = this._readPermissions();
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }
      (0, _util.warn)("Unable to read permissions.");
    }
    return (0, _util.shadow)(this, "permissions", permissions);
  }
  _readPermissions() {
    const encrypt = this.xref.trailer.get("Encrypt");
    if (!(encrypt instanceof _primitives.Dict)) {
      return null;
    }
    let flags = encrypt.get("P");
    if (typeof flags !== "number") {
      return null;
    }
    flags += 2 ** 32;
    const permissions = [];
    for (const key in _util.PermissionFlag) {
      const value = _util.PermissionFlag[key];
      if (flags & value) {
        permissions.push(value);
      }
    }
    return permissions;
  }
  get optionalContentConfig() {
    let config = null;
    try {
      const properties = this._catDict.get("OCProperties");
      if (!properties) {
        return (0, _util.shadow)(this, "optionalContentConfig", null);
      }
      const defaultConfig = properties.get("D");
      if (!defaultConfig) {
        return (0, _util.shadow)(this, "optionalContentConfig", null);
      }
      const groupsData = properties.get("OCGs");
      if (!Array.isArray(groupsData)) {
        return (0, _util.shadow)(this, "optionalContentConfig", null);
      }
      const groups = [];
      const groupRefs = [];
      for (const groupRef of groupsData) {
        if (!(groupRef instanceof _primitives.Ref)) {
          continue;
        }
        groupRefs.push(groupRef);
        const group = this.xref.fetchIfRef(groupRef);
        groups.push({
          id: groupRef.toString(),
          name: typeof group.get("Name") === "string" ? (0, _util.stringToPDFString)(group.get("Name")) : null,
          intent: typeof group.get("Intent") === "string" ? (0, _util.stringToPDFString)(group.get("Intent")) : null
        });
      }
      config = this._readOptionalContentConfig(defaultConfig, groupRefs);
      config.groups = groups;
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }
      (0, _util.warn)(`Unable to read optional content config: ${ex}`);
    }
    return (0, _util.shadow)(this, "optionalContentConfig", config);
  }
  _readOptionalContentConfig(config, contentGroupRefs) {
    function parseOnOff(refs) {
      const onParsed = [];
      if (Array.isArray(refs)) {
        for (const value of refs) {
          if (!(value instanceof _primitives.Ref)) {
            continue;
          }
          if (contentGroupRefs.includes(value)) {
            onParsed.push(value.toString());
          }
        }
      }
      return onParsed;
    }
    function parseOrder(refs, nestedLevels = 0) {
      if (!Array.isArray(refs)) {
        return null;
      }
      const order = [];
      for (const value of refs) {
        if (value instanceof _primitives.Ref && contentGroupRefs.includes(value)) {
          parsedOrderRefs.put(value);
          order.push(value.toString());
          continue;
        }
        const nestedOrder = parseNestedOrder(value, nestedLevels);
        if (nestedOrder) {
          order.push(nestedOrder);
        }
      }
      if (nestedLevels > 0) {
        return order;
      }
      const hiddenGroups = [];
      for (const groupRef of contentGroupRefs) {
        if (parsedOrderRefs.has(groupRef)) {
          continue;
        }
        hiddenGroups.push(groupRef.toString());
      }
      if (hiddenGroups.length) {
        order.push({
          name: null,
          order: hiddenGroups
        });
      }
      return order;
    }
    function parseNestedOrder(ref, nestedLevels) {
      if (++nestedLevels > MAX_NESTED_LEVELS) {
        (0, _util.warn)("parseNestedOrder - reached MAX_NESTED_LEVELS.");
        return null;
      }
      const value = xref.fetchIfRef(ref);
      if (!Array.isArray(value)) {
        return null;
      }
      const nestedName = xref.fetchIfRef(value[0]);
      if (typeof nestedName !== "string") {
        return null;
      }
      const nestedOrder = parseOrder(value.slice(1), nestedLevels);
      if (!nestedOrder || !nestedOrder.length) {
        return null;
      }
      return {
        name: (0, _util.stringToPDFString)(nestedName),
        order: nestedOrder
      };
    }
    const xref = this.xref,
      parsedOrderRefs = new _primitives.RefSet(),
      MAX_NESTED_LEVELS = 10;
    return {
      name: typeof config.get("Name") === "string" ? (0, _util.stringToPDFString)(config.get("Name")) : null,
      creator: typeof config.get("Creator") === "string" ? (0, _util.stringToPDFString)(config.get("Creator")) : null,
      baseState: config.get("BaseState") instanceof _primitives.Name ? config.get("BaseState").name : null,
      on: parseOnOff(config.get("ON")),
      off: parseOnOff(config.get("OFF")),
      order: parseOrder(config.get("Order")),
      groups: null
    };
  }
  setActualNumPages(num = null) {
    this._actualNumPages = num;
  }
  get hasActualNumPages() {
    return this._actualNumPages !== null;
  }
  get _pagesCount() {
    const obj = this.toplevelPagesDict.get("Count");
    if (!Number.isInteger(obj)) {
      throw new _util.FormatError("Page count in top-level pages dictionary is not an integer.");
    }
    return (0, _util.shadow)(this, "_pagesCount", obj);
  }
  get numPages() {
    return this.hasActualNumPages ? this._actualNumPages : this._pagesCount;
  }
  get destinations() {
    const obj = this._readDests(),
      dests = Object.create(null);
    if (obj instanceof _name_number_tree.NameTree) {
      for (const [key, value] of obj.getAll()) {
        const dest = fetchDestination(value);
        if (dest) {
          dests[(0, _util.stringToPDFString)(key)] = dest;
        }
      }
    } else if (obj instanceof _primitives.Dict) {
      obj.forEach(function (key, value) {
        const dest = fetchDestination(value);
        if (dest) {
          dests[key] = dest;
        }
      });
    }
    return (0, _util.shadow)(this, "destinations", dests);
  }
  getDestination(id) {
    const obj = this._readDests();
    if (obj instanceof _name_number_tree.NameTree) {
      const dest = fetchDestination(obj.get(id));
      if (dest) {
        return dest;
      }
      const allDest = this.destinations[id];
      if (allDest) {
        (0, _util.warn)(`Found "${id}" at an incorrect position in the NameTree.`);
        return allDest;
      }
    } else if (obj instanceof _primitives.Dict) {
      const dest = fetchDestination(obj.get(id));
      if (dest) {
        return dest;
      }
    }
    return null;
  }
  _readDests() {
    const obj = this._catDict.get("Names");
    if (obj?.has("Dests")) {
      return new _name_number_tree.NameTree(obj.getRaw("Dests"), this.xref);
    } else if (this._catDict.has("Dests")) {
      return this._catDict.get("Dests");
    }
    return undefined;
  }
  get pageLabels() {
    let obj = null;
    try {
      obj = this._readPageLabels();
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }
      (0, _util.warn)("Unable to read page labels.");
    }
    return (0, _util.shadow)(this, "pageLabels", obj);
  }
  _readPageLabels() {
    const obj = this._catDict.getRaw("PageLabels");
    if (!obj) {
      return null;
    }
    const pageLabels = new Array(this.numPages);
    let style = null,
      prefix = "";
    const numberTree = new _name_number_tree.NumberTree(obj, this.xref);
    const nums = numberTree.getAll();
    let currentLabel = "",
      currentIndex = 1;
    for (let i = 0, ii = this.numPages; i < ii; i++) {
      const labelDict = nums.get(i);
      if (labelDict !== undefined) {
        if (!(labelDict instanceof _primitives.Dict)) {
          throw new _util.FormatError("PageLabel is not a dictionary.");
        }
        if (labelDict.has("Type") && !(0, _primitives.isName)(labelDict.get("Type"), "PageLabel")) {
          throw new _util.FormatError("Invalid type in PageLabel dictionary.");
        }
        if (labelDict.has("S")) {
          const s = labelDict.get("S");
          if (!(s instanceof _primitives.Name)) {
            throw new _util.FormatError("Invalid style in PageLabel dictionary.");
          }
          style = s.name;
        } else {
          style = null;
        }
        if (labelDict.has("P")) {
          const p = labelDict.get("P");
          if (typeof p !== "string") {
            throw new _util.FormatError("Invalid prefix in PageLabel dictionary.");
          }
          prefix = (0, _util.stringToPDFString)(p);
        } else {
          prefix = "";
        }
        if (labelDict.has("St")) {
          const st = labelDict.get("St");
          if (!(Number.isInteger(st) && st >= 1)) {
            throw new _util.FormatError("Invalid start in PageLabel dictionary.");
          }
          currentIndex = st;
        } else {
          currentIndex = 1;
        }
      }
      switch (style) {
        case "D":
          currentLabel = currentIndex;
          break;
        case "R":
        case "r":
          currentLabel = (0, _core_utils.toRomanNumerals)(currentIndex, style === "r");
          break;
        case "A":
        case "a":
          const LIMIT = 26;
          const A_UPPER_CASE = 0x41,
            A_LOWER_CASE = 0x61;
          const baseCharCode = style === "a" ? A_LOWER_CASE : A_UPPER_CASE;
          const letterIndex = currentIndex - 1;
          const character = String.fromCharCode(baseCharCode + letterIndex % LIMIT);
          currentLabel = character.repeat(Math.floor(letterIndex / LIMIT) + 1);
          break;
        default:
          if (style) {
            throw new _util.FormatError(`Invalid style "${style}" in PageLabel dictionary.`);
          }
          currentLabel = "";
      }
      pageLabels[i] = prefix + currentLabel;
      currentIndex++;
    }
    return pageLabels;
  }
  get pageLayout() {
    const obj = this._catDict.get("PageLayout");
    let pageLayout = "";
    if (obj instanceof _primitives.Name) {
      switch (obj.name) {
        case "SinglePage":
        case "OneColumn":
        case "TwoColumnLeft":
        case "TwoColumnRight":
        case "TwoPageLeft":
        case "TwoPageRight":
          pageLayout = obj.name;
      }
    }
    return (0, _util.shadow)(this, "pageLayout", pageLayout);
  }
  get pageMode() {
    const obj = this._catDict.get("PageMode");
    let pageMode = "UseNone";
    if (obj instanceof _primitives.Name) {
      switch (obj.name) {
        case "UseNone":
        case "UseOutlines":
        case "UseThumbs":
        case "FullScreen":
        case "UseOC":
        case "UseAttachments":
          pageMode = obj.name;
      }
    }
    return (0, _util.shadow)(this, "pageMode", pageMode);
  }
  get viewerPreferences() {
    const obj = this._catDict.get("ViewerPreferences");
    if (!(obj instanceof _primitives.Dict)) {
      return (0, _util.shadow)(this, "viewerPreferences", null);
    }
    let prefs = null;
    for (const key of obj.getKeys()) {
      const value = obj.get(key);
      let prefValue;
      switch (key) {
        case "HideToolbar":
        case "HideMenubar":
        case "HideWindowUI":
        case "FitWindow":
        case "CenterWindow":
        case "DisplayDocTitle":
        case "PickTrayByPDFSize":
          if (typeof value === "boolean") {
            prefValue = value;
          }
          break;
        case "NonFullScreenPageMode":
          if (value instanceof _primitives.Name) {
            switch (value.name) {
              case "UseNone":
              case "UseOutlines":
              case "UseThumbs":
              case "UseOC":
                prefValue = value.name;
                break;
              default:
                prefValue = "UseNone";
            }
          }
          break;
        case "Direction":
          if (value instanceof _primitives.Name) {
            switch (value.name) {
              case "L2R":
              case "R2L":
                prefValue = value.name;
                break;
              default:
                prefValue = "L2R";
            }
          }
          break;
        case "ViewArea":
        case "ViewClip":
        case "PrintArea":
        case "PrintClip":
          if (value instanceof _primitives.Name) {
            switch (value.name) {
              case "MediaBox":
              case "CropBox":
              case "BleedBox":
              case "TrimBox":
              case "ArtBox":
                prefValue = value.name;
                break;
              default:
                prefValue = "CropBox";
            }
          }
          break;
        case "PrintScaling":
          if (value instanceof _primitives.Name) {
            switch (value.name) {
              case "None":
              case "AppDefault":
                prefValue = value.name;
                break;
              default:
                prefValue = "AppDefault";
            }
          }
          break;
        case "Duplex":
          if (value instanceof _primitives.Name) {
            switch (value.name) {
              case "Simplex":
              case "DuplexFlipShortEdge":
              case "DuplexFlipLongEdge":
                prefValue = value.name;
                break;
              default:
                prefValue = "None";
            }
          }
          break;
        case "PrintPageRange":
          if (Array.isArray(value) && value.length % 2 === 0) {
            const isValid = value.every((page, i, arr) => {
              return Number.isInteger(page) && page > 0 && (i === 0 || page >= arr[i - 1]) && page <= this.numPages;
            });
            if (isValid) {
              prefValue = value;
            }
          }
          break;
        case "NumCopies":
          if (Number.isInteger(value) && value > 0) {
            prefValue = value;
          }
          break;
        default:
          (0, _util.warn)(`Ignoring non-standard key in ViewerPreferences: ${key}.`);
          continue;
      }
      if (prefValue === undefined) {
        (0, _util.warn)(`Bad value, for key "${key}", in ViewerPreferences: ${value}.`);
        continue;
      }
      if (!prefs) {
        prefs = Object.create(null);
      }
      prefs[key] = prefValue;
    }
    return (0, _util.shadow)(this, "viewerPreferences", prefs);
  }
  get openAction() {
    const obj = this._catDict.get("OpenAction");
    const openAction = Object.create(null);
    if (obj instanceof _primitives.Dict) {
      const destDict = new _primitives.Dict(this.xref);
      destDict.set("A", obj);
      const resultObj = {
        url: null,
        dest: null,
        action: null
      };
      Catalog.parseDestDictionary({
        destDict,
        resultObj
      });
      if (Array.isArray(resultObj.dest)) {
        openAction.dest = resultObj.dest;
      } else if (resultObj.action) {
        openAction.action = resultObj.action;
      }
    } else if (Array.isArray(obj)) {
      openAction.dest = obj;
    }
    return (0, _util.shadow)(this, "openAction", (0, _util.objectSize)(openAction) > 0 ? openAction : null);
  }
  get attachments() {
    const obj = this._catDict.get("Names");
    let attachments = null;
    if (obj instanceof _primitives.Dict && obj.has("EmbeddedFiles")) {
      const nameTree = new _name_number_tree.NameTree(obj.getRaw("EmbeddedFiles"), this.xref);
      for (const [key, value] of nameTree.getAll()) {
        const fs = new _file_spec.FileSpec(value, this.xref);
        if (!attachments) {
          attachments = Object.create(null);
        }
        attachments[(0, _util.stringToPDFString)(key)] = fs.serializable;
      }
    }
    return (0, _util.shadow)(this, "attachments", attachments);
  }
  get xfaImages() {
    const obj = this._catDict.get("Names");
    let xfaImages = null;
    if (obj instanceof _primitives.Dict && obj.has("XFAImages")) {
      const nameTree = new _name_number_tree.NameTree(obj.getRaw("XFAImages"), this.xref);
      for (const [key, value] of nameTree.getAll()) {
        if (!xfaImages) {
          xfaImages = new _primitives.Dict(this.xref);
        }
        xfaImages.set((0, _util.stringToPDFString)(key), value);
      }
    }
    return (0, _util.shadow)(this, "xfaImages", xfaImages);
  }
  _collectJavaScript() {
    const obj = this._catDict.get("Names");
    let javaScript = null;
    function appendIfJavaScriptDict(name, jsDict) {
      if (!(jsDict instanceof _primitives.Dict)) {
        return;
      }
      if (!(0, _primitives.isName)(jsDict.get("S"), "JavaScript")) {
        return;
      }
      let js = jsDict.get("JS");
      if (js instanceof _base_stream.BaseStream) {
        js = js.getString();
      } else if (typeof js !== "string") {
        return;
      }
      js = (0, _util.stringToPDFString)(js).replaceAll("\x00", "");
      if (js) {
        (javaScript ||= new Map()).set(name, js);
      }
    }
    if (obj instanceof _primitives.Dict && obj.has("JavaScript")) {
      const nameTree = new _name_number_tree.NameTree(obj.getRaw("JavaScript"), this.xref);
      for (const [key, value] of nameTree.getAll()) {
        appendIfJavaScriptDict((0, _util.stringToPDFString)(key), value);
      }
    }
    const openAction = this._catDict.get("OpenAction");
    if (openAction) {
      appendIfJavaScriptDict("OpenAction", openAction);
    }
    return javaScript;
  }
  get jsActions() {
    const javaScript = this._collectJavaScript();
    let actions = (0, _core_utils.collectActions)(this.xref, this._catDict, _util.DocumentActionEventType);
    if (javaScript) {
      actions ||= Object.create(null);
      for (const [key, val] of javaScript) {
        if (key in actions) {
          actions[key].push(val);
        } else {
          actions[key] = [val];
        }
      }
    }
    return (0, _util.shadow)(this, "jsActions", actions);
  }
  async fontFallback(id, handler) {
    const translatedFonts = await Promise.all(this.fontCache);
    for (const translatedFont of translatedFonts) {
      if (translatedFont.loadedName === id) {
        translatedFont.fallback(handler);
        return;
      }
    }
  }
  async cleanup(manuallyTriggered = false) {
    (0, _cleanup_helper.clearGlobalCaches)();
    this.globalImageCache.clear(manuallyTriggered);
    this.pageKidsCountCache.clear();
    this.pageIndexCache.clear();
    this.nonBlendModesSet.clear();
    const translatedFonts = await Promise.all(this.fontCache);
    for (const {
      dict
    } of translatedFonts) {
      delete dict.cacheKey;
    }
    this.fontCache.clear();
    this.builtInCMapCache.clear();
    this.standardFontDataCache.clear();
    this.systemFontCache.clear();
  }
  async getPageDict(pageIndex) {
    const nodesToVisit = [this.toplevelPagesDict];
    const visitedNodes = new _primitives.RefSet();
    const pagesRef = this._catDict.getRaw("Pages");
    if (pagesRef instanceof _primitives.Ref) {
      visitedNodes.put(pagesRef);
    }
    const xref = this.xref,
      pageKidsCountCache = this.pageKidsCountCache,
      pageIndexCache = this.pageIndexCache;
    let currentPageIndex = 0;
    while (nodesToVisit.length) {
      const currentNode = nodesToVisit.pop();
      if (currentNode instanceof _primitives.Ref) {
        const count = pageKidsCountCache.get(currentNode);
        if (count >= 0 && currentPageIndex + count <= pageIndex) {
          currentPageIndex += count;
          continue;
        }
        if (visitedNodes.has(currentNode)) {
          throw new _util.FormatError("Pages tree contains circular reference.");
        }
        visitedNodes.put(currentNode);
        const obj = await xref.fetchAsync(currentNode);
        if (obj instanceof _primitives.Dict) {
          let type = obj.getRaw("Type");
          if (type instanceof _primitives.Ref) {
            type = await xref.fetchAsync(type);
          }
          if ((0, _primitives.isName)(type, "Page") || !obj.has("Kids")) {
            if (!pageKidsCountCache.has(currentNode)) {
              pageKidsCountCache.put(currentNode, 1);
            }
            if (!pageIndexCache.has(currentNode)) {
              pageIndexCache.put(currentNode, currentPageIndex);
            }
            if (currentPageIndex === pageIndex) {
              return [obj, currentNode];
            }
            currentPageIndex++;
            continue;
          }
        }
        nodesToVisit.push(obj);
        continue;
      }
      if (!(currentNode instanceof _primitives.Dict)) {
        throw new _util.FormatError("Page dictionary kid reference points to wrong type of object.");
      }
      const {
        objId
      } = currentNode;
      let count = currentNode.getRaw("Count");
      if (count instanceof _primitives.Ref) {
        count = await xref.fetchAsync(count);
      }
      if (Number.isInteger(count) && count >= 0) {
        if (objId && !pageKidsCountCache.has(objId)) {
          pageKidsCountCache.put(objId, count);
        }
        if (currentPageIndex + count <= pageIndex) {
          currentPageIndex += count;
          continue;
        }
      }
      let kids = currentNode.getRaw("Kids");
      if (kids instanceof _primitives.Ref) {
        kids = await xref.fetchAsync(kids);
      }
      if (!Array.isArray(kids)) {
        let type = currentNode.getRaw("Type");
        if (type instanceof _primitives.Ref) {
          type = await xref.fetchAsync(type);
        }
        if ((0, _primitives.isName)(type, "Page") || !currentNode.has("Kids")) {
          if (currentPageIndex === pageIndex) {
            return [currentNode, null];
          }
          currentPageIndex++;
          continue;
        }
        throw new _util.FormatError("Page dictionary kids object is not an array.");
      }
      for (let last = kids.length - 1; last >= 0; last--) {
        nodesToVisit.push(kids[last]);
      }
    }
    throw new Error(`Page index ${pageIndex} not found.`);
  }
  async getAllPageDicts(recoveryMode = false) {
    const {
      ignoreErrors
    } = this.pdfManager.evaluatorOptions;
    const queue = [{
      currentNode: this.toplevelPagesDict,
      posInKids: 0
    }];
    const visitedNodes = new _primitives.RefSet();
    const pagesRef = this._catDict.getRaw("Pages");
    if (pagesRef instanceof _primitives.Ref) {
      visitedNodes.put(pagesRef);
    }
    const map = new Map(),
      xref = this.xref,
      pageIndexCache = this.pageIndexCache;
    let pageIndex = 0;
    function addPageDict(pageDict, pageRef) {
      if (pageRef && !pageIndexCache.has(pageRef)) {
        pageIndexCache.put(pageRef, pageIndex);
      }
      map.set(pageIndex++, [pageDict, pageRef]);
    }
    function addPageError(error) {
      if (error instanceof _core_utils.XRefEntryException && !recoveryMode) {
        throw error;
      }
      if (recoveryMode && ignoreErrors && pageIndex === 0) {
        (0, _util.warn)(`getAllPageDicts - Skipping invalid first page: "${error}".`);
        error = _primitives.Dict.empty;
      }
      map.set(pageIndex++, [error, null]);
    }
    while (queue.length > 0) {
      const queueItem = queue.at(-1);
      const {
        currentNode,
        posInKids
      } = queueItem;
      let kids = currentNode.getRaw("Kids");
      if (kids instanceof _primitives.Ref) {
        try {
          kids = await xref.fetchAsync(kids);
        } catch (ex) {
          addPageError(ex);
          break;
        }
      }
      if (!Array.isArray(kids)) {
        addPageError(new _util.FormatError("Page dictionary kids object is not an array."));
        break;
      }
      if (posInKids >= kids.length) {
        queue.pop();
        continue;
      }
      const kidObj = kids[posInKids];
      let obj;
      if (kidObj instanceof _primitives.Ref) {
        if (visitedNodes.has(kidObj)) {
          addPageError(new _util.FormatError("Pages tree contains circular reference."));
          break;
        }
        visitedNodes.put(kidObj);
        try {
          obj = await xref.fetchAsync(kidObj);
        } catch (ex) {
          addPageError(ex);
          break;
        }
      } else {
        obj = kidObj;
      }
      if (!(obj instanceof _primitives.Dict)) {
        addPageError(new _util.FormatError("Page dictionary kid reference points to wrong type of object."));
        break;
      }
      let type = obj.getRaw("Type");
      if (type instanceof _primitives.Ref) {
        try {
          type = await xref.fetchAsync(type);
        } catch (ex) {
          addPageError(ex);
          break;
        }
      }
      if ((0, _primitives.isName)(type, "Page") || !obj.has("Kids")) {
        addPageDict(obj, kidObj instanceof _primitives.Ref ? kidObj : null);
      } else {
        queue.push({
          currentNode: obj,
          posInKids: 0
        });
      }
      queueItem.posInKids++;
    }
    return map;
  }
  getPageIndex(pageRef) {
    const cachedPageIndex = this.pageIndexCache.get(pageRef);
    if (cachedPageIndex !== undefined) {
      return Promise.resolve(cachedPageIndex);
    }
    const xref = this.xref;
    function pagesBeforeRef(kidRef) {
      let total = 0,
        parentRef;
      return xref.fetchAsync(kidRef).then(function (node) {
        if ((0, _primitives.isRefsEqual)(kidRef, pageRef) && !(0, _primitives.isDict)(node, "Page") && !(node instanceof _primitives.Dict && !node.has("Type") && node.has("Contents"))) {
          throw new _util.FormatError("The reference does not point to a /Page dictionary.");
        }
        if (!node) {
          return null;
        }
        if (!(node instanceof _primitives.Dict)) {
          throw new _util.FormatError("Node must be a dictionary.");
        }
        parentRef = node.getRaw("Parent");
        return node.getAsync("Parent");
      }).then(function (parent) {
        if (!parent) {
          return null;
        }
        if (!(parent instanceof _primitives.Dict)) {
          throw new _util.FormatError("Parent must be a dictionary.");
        }
        return parent.getAsync("Kids");
      }).then(function (kids) {
        if (!kids) {
          return null;
        }
        const kidPromises = [];
        let found = false;
        for (const kid of kids) {
          if (!(kid instanceof _primitives.Ref)) {
            throw new _util.FormatError("Kid must be a reference.");
          }
          if ((0, _primitives.isRefsEqual)(kid, kidRef)) {
            found = true;
            break;
          }
          kidPromises.push(xref.fetchAsync(kid).then(function (obj) {
            if (!(obj instanceof _primitives.Dict)) {
              throw new _util.FormatError("Kid node must be a dictionary.");
            }
            if (obj.has("Count")) {
              total += obj.get("Count");
            } else {
              total++;
            }
          }));
        }
        if (!found) {
          throw new _util.FormatError("Kid reference not found in parent's kids.");
        }
        return Promise.all(kidPromises).then(function () {
          return [total, parentRef];
        });
      });
    }
    let total = 0;
    const next = ref => pagesBeforeRef(ref).then(args => {
      if (!args) {
        this.pageIndexCache.put(pageRef, total);
        return total;
      }
      const [count, parentRef] = args;
      total += count;
      return next(parentRef);
    });
    return next(pageRef);
  }
  get baseUrl() {
    const uri = this._catDict.get("URI");
    if (uri instanceof _primitives.Dict) {
      const base = uri.get("Base");
      if (typeof base === "string") {
        const absoluteUrl = (0, _util.createValidAbsoluteUrl)(base, null, {
          tryConvertEncoding: true
        });
        if (absoluteUrl) {
          return (0, _util.shadow)(this, "baseUrl", absoluteUrl.href);
        }
      }
    }
    return (0, _util.shadow)(this, "baseUrl", this.pdfManager.docBaseUrl);
  }
  static parseDestDictionary({
    destDict,
    resultObj,
    docBaseUrl = null,
    docAttachments = null
  }) {
    if (!(destDict instanceof _primitives.Dict)) {
      (0, _util.warn)("parseDestDictionary: `destDict` must be a dictionary.");
      return;
    }
    let action = destDict.get("A"),
      url,
      dest;
    if (!(action instanceof _primitives.Dict)) {
      if (destDict.has("Dest")) {
        action = destDict.get("Dest");
      } else {
        action = destDict.get("AA");
        if (action instanceof _primitives.Dict) {
          if (action.has("D")) {
            action = action.get("D");
          } else if (action.has("U")) {
            action = action.get("U");
          }
        }
      }
    }
    if (action instanceof _primitives.Dict) {
      const actionType = action.get("S");
      if (!(actionType instanceof _primitives.Name)) {
        (0, _util.warn)("parseDestDictionary: Invalid type in Action dictionary.");
        return;
      }
      const actionName = actionType.name;
      switch (actionName) {
        case "ResetForm":
          const flags = action.get("Flags");
          const include = ((typeof flags === "number" ? flags : 0) & 1) === 0;
          const fields = [];
          const refs = [];
          for (const obj of action.get("Fields") || []) {
            if (obj instanceof _primitives.Ref) {
              refs.push(obj.toString());
            } else if (typeof obj === "string") {
              fields.push((0, _util.stringToPDFString)(obj));
            }
          }
          resultObj.resetForm = {
            fields,
            refs,
            include
          };
          break;
        case "URI":
          url = action.get("URI");
          if (url instanceof _primitives.Name) {
            url = "/" + url.name;
          }
          break;
        case "GoTo":
          dest = action.get("D");
          break;
        case "Launch":
        case "GoToR":
          const urlDict = action.get("F");
          if (urlDict instanceof _primitives.Dict) {
            url = urlDict.get("F") || null;
          } else if (typeof urlDict === "string") {
            url = urlDict;
          }
          let remoteDest = action.get("D");
          if (remoteDest) {
            if (remoteDest instanceof _primitives.Name) {
              remoteDest = remoteDest.name;
            }
            if (typeof url === "string") {
              const baseUrl = url.split("#")[0];
              if (typeof remoteDest === "string") {
                url = baseUrl + "#" + remoteDest;
              } else if (Array.isArray(remoteDest)) {
                url = baseUrl + "#" + JSON.stringify(remoteDest);
              }
            }
          }
          const newWindow = action.get("NewWindow");
          if (typeof newWindow === "boolean") {
            resultObj.newWindow = newWindow;
          }
          break;
        case "GoToE":
          const target = action.get("T");
          let attachment;
          if (docAttachments && target instanceof _primitives.Dict) {
            const relationship = target.get("R");
            const name = target.get("N");
            if ((0, _primitives.isName)(relationship, "C") && typeof name === "string") {
              attachment = docAttachments[(0, _util.stringToPDFString)(name)];
            }
          }
          if (attachment) {
            resultObj.attachment = attachment;
          } else {
            (0, _util.warn)(`parseDestDictionary - unimplemented "GoToE" action.`);
          }
          break;
        case "Named":
          const namedAction = action.get("N");
          if (namedAction instanceof _primitives.Name) {
            resultObj.action = namedAction.name;
          }
          break;
        case "SetOCGState":
          const state = action.get("State");
          const preserveRB = action.get("PreserveRB");
          if (!Array.isArray(state) || state.length === 0) {
            break;
          }
          const stateArr = [];
          for (const elem of state) {
            if (elem instanceof _primitives.Name) {
              switch (elem.name) {
                case "ON":
                case "OFF":
                case "Toggle":
                  stateArr.push(elem.name);
                  break;
              }
            } else if (elem instanceof _primitives.Ref) {
              stateArr.push(elem.toString());
            }
          }
          if (stateArr.length !== state.length) {
            break;
          }
          resultObj.setOCGState = {
            state: stateArr,
            preserveRB: typeof preserveRB === "boolean" ? preserveRB : true
          };
          break;
        case "JavaScript":
          const jsAction = action.get("JS");
          let js;
          if (jsAction instanceof _base_stream.BaseStream) {
            js = jsAction.getString();
          } else if (typeof jsAction === "string") {
            js = jsAction;
          }
          const jsURL = js && (0, _core_utils.recoverJsURL)((0, _util.stringToPDFString)(js));
          if (jsURL) {
            url = jsURL.url;
            resultObj.newWindow = jsURL.newWindow;
            break;
          }
        default:
          if (actionName === "JavaScript" || actionName === "SubmitForm") {
            break;
          }
          (0, _util.warn)(`parseDestDictionary - unsupported action: "${actionName}".`);
          break;
      }
    } else if (destDict.has("Dest")) {
      dest = destDict.get("Dest");
    }
    if (typeof url === "string") {
      const absoluteUrl = (0, _util.createValidAbsoluteUrl)(url, docBaseUrl, {
        addDefaultProtocol: true,
        tryConvertEncoding: true
      });
      if (absoluteUrl) {
        resultObj.url = absoluteUrl.href;
      }
      resultObj.unsafeUrl = url;
    }
    if (dest) {
      if (dest instanceof _primitives.Name) {
        dest = dest.name;
      }
      if (typeof dest === "string") {
        resultObj.dest = (0, _util.stringToPDFString)(dest);
      } else if (Array.isArray(dest)) {
        resultObj.dest = dest;
      }
    }
  }
}
exports.Catalog = Catalog;

/***/ }),
/* 67 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.NumberTree = exports.NameTree = void 0;
var _primitives = __w_pdfjs_require__(4);
var _util = __w_pdfjs_require__(2);
class NameOrNumberTree {
  constructor(root, xref, type) {
    if (this.constructor === NameOrNumberTree) {
      (0, _util.unreachable)("Cannot initialize NameOrNumberTree.");
    }
    this.root = root;
    this.xref = xref;
    this._type = type;
  }
  getAll() {
    const map = new Map();
    if (!this.root) {
      return map;
    }
    const xref = this.xref;
    const processed = new _primitives.RefSet();
    processed.put(this.root);
    const queue = [this.root];
    while (queue.length > 0) {
      const obj = xref.fetchIfRef(queue.shift());
      if (!(obj instanceof _primitives.Dict)) {
        continue;
      }
      if (obj.has("Kids")) {
        const kids = obj.get("Kids");
        if (!Array.isArray(kids)) {
          continue;
        }
        for (const kid of kids) {
          if (processed.has(kid)) {
            throw new _util.FormatError(`Duplicate entry in "${this._type}" tree.`);
          }
          queue.push(kid);
          processed.put(kid);
        }
        continue;
      }
      const entries = obj.get(this._type);
      if (!Array.isArray(entries)) {
        continue;
      }
      for (let i = 0, ii = entries.length; i < ii; i += 2) {
        map.set(xref.fetchIfRef(entries[i]), xref.fetchIfRef(entries[i + 1]));
      }
    }
    return map;
  }
  get(key) {
    if (!this.root) {
      return null;
    }
    const xref = this.xref;
    let kidsOrEntries = xref.fetchIfRef(this.root);
    let loopCount = 0;
    const MAX_LEVELS = 10;
    while (kidsOrEntries.has("Kids")) {
      if (++loopCount > MAX_LEVELS) {
        (0, _util.warn)(`Search depth limit reached for "${this._type}" tree.`);
        return null;
      }
      const kids = kidsOrEntries.get("Kids");
      if (!Array.isArray(kids)) {
        return null;
      }
      let l = 0,
        r = kids.length - 1;
      while (l <= r) {
        const m = l + r >> 1;
        const kid = xref.fetchIfRef(kids[m]);
        const limits = kid.get("Limits");
        if (key < xref.fetchIfRef(limits[0])) {
          r = m - 1;
        } else if (key > xref.fetchIfRef(limits[1])) {
          l = m + 1;
        } else {
          kidsOrEntries = kid;
          break;
        }
      }
      if (l > r) {
        return null;
      }
    }
    const entries = kidsOrEntries.get(this._type);
    if (Array.isArray(entries)) {
      let l = 0,
        r = entries.length - 2;
      while (l <= r) {
        const tmp = l + r >> 1,
          m = tmp + (tmp & 1);
        const currentKey = xref.fetchIfRef(entries[m]);
        if (key < currentKey) {
          r = m - 2;
        } else if (key > currentKey) {
          l = m + 2;
        } else {
          return xref.fetchIfRef(entries[m + 1]);
        }
      }
    }
    return null;
  }
}
class NameTree extends NameOrNumberTree {
  constructor(root, xref) {
    super(root, xref, "Names");
  }
}
exports.NameTree = NameTree;
class NumberTree extends NameOrNumberTree {
  constructor(root, xref) {
    super(root, xref, "Nums");
  }
}
exports.NumberTree = NumberTree;

/***/ }),
/* 68 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.clearGlobalCaches = clearGlobalCaches;
var _pattern = __w_pdfjs_require__(50);
var _primitives = __w_pdfjs_require__(4);
var _unicode = __w_pdfjs_require__(40);
function clearGlobalCaches() {
  (0, _pattern.clearPatternCaches)();
  (0, _primitives.clearPrimitiveCaches)();
  (0, _unicode.clearUnicodeCaches)();
}

/***/ }),
/* 69 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FileSpec = void 0;
var _util = __w_pdfjs_require__(2);
var _base_stream = __w_pdfjs_require__(5);
var _primitives = __w_pdfjs_require__(4);
function pickPlatformItem(dict) {
  if (dict.has("UF")) {
    return dict.get("UF");
  } else if (dict.has("F")) {
    return dict.get("F");
  } else if (dict.has("Unix")) {
    return dict.get("Unix");
  } else if (dict.has("Mac")) {
    return dict.get("Mac");
  } else if (dict.has("DOS")) {
    return dict.get("DOS");
  }
  return null;
}
class FileSpec {
  constructor(root, xref) {
    if (!(root instanceof _primitives.Dict)) {
      return;
    }
    this.xref = xref;
    this.root = root;
    if (root.has("FS")) {
      this.fs = root.get("FS");
    }
    this.description = root.has("Desc") ? (0, _util.stringToPDFString)(root.get("Desc")) : "";
    if (root.has("RF")) {
      (0, _util.warn)("Related file specifications are not supported");
    }
    this.contentAvailable = true;
    if (!root.has("EF")) {
      this.contentAvailable = false;
      (0, _util.warn)("Non-embedded file specifications are not supported");
    }
  }
  get filename() {
    if (!this._filename && this.root) {
      const filename = pickPlatformItem(this.root) || "unnamed";
      this._filename = (0, _util.stringToPDFString)(filename).replaceAll("\\\\", "\\").replaceAll("\\/", "/").replaceAll("\\", "/");
    }
    return this._filename;
  }
  get content() {
    if (!this.contentAvailable) {
      return null;
    }
    if (!this.contentRef && this.root) {
      this.contentRef = pickPlatformItem(this.root.get("EF"));
    }
    let content = null;
    if (this.contentRef) {
      const fileObj = this.xref.fetchIfRef(this.contentRef);
      if (fileObj instanceof _base_stream.BaseStream) {
        content = fileObj.getBytes();
      } else {
        (0, _util.warn)("Embedded file specification points to non-existing/invalid content");
      }
    } else {
      (0, _util.warn)("Embedded file specification does not have a content");
    }
    return content;
  }
  get serializable() {
    return {
      filename: this.filename,
      content: this.content
    };
  }
}
exports.FileSpec = FileSpec;

/***/ }),
/* 70 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MetadataParser = void 0;
var _xml_parser = __w_pdfjs_require__(71);
class MetadataParser {
  constructor(data) {
    data = this._repair(data);
    const parser = new _xml_parser.SimpleXMLParser({
      lowerCaseName: true
    });
    const xmlDocument = parser.parseFromString(data);
    this._metadataMap = new Map();
    this._data = data;
    if (xmlDocument) {
      this._parse(xmlDocument);
    }
  }
  _repair(data) {
    return data.replace(/^[^<]+/, "").replaceAll(/>\\376\\377([^<]+)/g, function (all, codes) {
      const bytes = codes.replaceAll(/\\([0-3])([0-7])([0-7])/g, function (code, d1, d2, d3) {
        return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1);
      }).replaceAll(/&(amp|apos|gt|lt|quot);/g, function (str, name) {
        switch (name) {
          case "amp":
            return "&";
          case "apos":
            return "'";
          case "gt":
            return ">";
          case "lt":
            return "<";
          case "quot":
            return '"';
        }
        throw new Error(`_repair: ${name} isn't defined.`);
      });
      const charBuf = [">"];
      for (let i = 0, ii = bytes.length; i < ii; i += 2) {
        const code = bytes.charCodeAt(i) * 256 + bytes.charCodeAt(i + 1);
        if (code >= 32 && code < 127 && code !== 60 && code !== 62 && code !== 38) {
          charBuf.push(String.fromCharCode(code));
        } else {
          charBuf.push("&#x" + (0x10000 + code).toString(16).substring(1) + ";");
        }
      }
      return charBuf.join("");
    });
  }
  _getSequence(entry) {
    const name = entry.nodeName;
    if (name !== "rdf:bag" && name !== "rdf:seq" && name !== "rdf:alt") {
      return null;
    }
    return entry.childNodes.filter(node => node.nodeName === "rdf:li");
  }
  _parseArray(entry) {
    if (!entry.hasChildNodes()) {
      return;
    }
    const [seqNode] = entry.childNodes;
    const sequence = this._getSequence(seqNode) || [];
    this._metadataMap.set(entry.nodeName, sequence.map(node => node.textContent.trim()));
  }
  _parse(xmlDocument) {
    let rdf = xmlDocument.documentElement;
    if (rdf.nodeName !== "rdf:rdf") {
      rdf = rdf.firstChild;
      while (rdf && rdf.nodeName !== "rdf:rdf") {
        rdf = rdf.nextSibling;
      }
    }
    if (!rdf || rdf.nodeName !== "rdf:rdf" || !rdf.hasChildNodes()) {
      return;
    }
    for (const desc of rdf.childNodes) {
      if (desc.nodeName !== "rdf:description") {
        continue;
      }
      for (const entry of desc.childNodes) {
        const name = entry.nodeName;
        switch (name) {
          case "#text":
            continue;
          case "dc:creator":
          case "dc:subject":
            this._parseArray(entry);
            continue;
        }
        this._metadataMap.set(name, entry.textContent.trim());
      }
    }
  }
  get serializable() {
    return {
      parsedData: this._metadataMap,
      rawData: this._data
    };
  }
}
exports.MetadataParser = MetadataParser;

/***/ }),
/* 71 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XMLParserErrorCode = exports.XMLParserBase = exports.SimpleXMLParser = exports.SimpleDOMNode = void 0;
var _core_utils = __w_pdfjs_require__(3);
const XMLParserErrorCode = {
  NoError: 0,
  EndOfDocument: -1,
  UnterminatedCdat: -2,
  UnterminatedXmlDeclaration: -3,
  UnterminatedDoctypeDeclaration: -4,
  UnterminatedComment: -5,
  MalformedElement: -6,
  OutOfMemory: -7,
  UnterminatedAttributeValue: -8,
  UnterminatedElement: -9,
  ElementNeverBegun: -10
};
exports.XMLParserErrorCode = XMLParserErrorCode;
function isWhitespace(s, index) {
  const ch = s[index];
  return ch === " " || ch === "\n" || ch === "\r" || ch === "\t";
}
function isWhitespaceString(s) {
  for (let i = 0, ii = s.length; i < ii; i++) {
    if (!isWhitespace(s, i)) {
      return false;
    }
  }
  return true;
}
class XMLParserBase {
  _resolveEntities(s) {
    return s.replaceAll(/&([^;]+);/g, (all, entity) => {
      if (entity.substring(0, 2) === "#x") {
        return String.fromCodePoint(parseInt(entity.substring(2), 16));
      } else if (entity.substring(0, 1) === "#") {
        return String.fromCodePoint(parseInt(entity.substring(1), 10));
      }
      switch (entity) {
        case "lt":
          return "<";
        case "gt":
          return ">";
        case "amp":
          return "&";
        case "quot":
          return '"';
        case "apos":
          return "'";
      }
      return this.onResolveEntity(entity);
    });
  }
  _parseContent(s, start) {
    const attributes = [];
    let pos = start;
    function skipWs() {
      while (pos < s.length && isWhitespace(s, pos)) {
        ++pos;
      }
    }
    while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "/") {
      ++pos;
    }
    const name = s.substring(start, pos);
    skipWs();
    while (pos < s.length && s[pos] !== ">" && s[pos] !== "/" && s[pos] !== "?") {
      skipWs();
      let attrName = "",
        attrValue = "";
      while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== "=") {
        attrName += s[pos];
        ++pos;
      }
      skipWs();
      if (s[pos] !== "=") {
        return null;
      }
      ++pos;
      skipWs();
      const attrEndChar = s[pos];
      if (attrEndChar !== '"' && attrEndChar !== "'") {
        return null;
      }
      const attrEndIndex = s.indexOf(attrEndChar, ++pos);
      if (attrEndIndex < 0) {
        return null;
      }
      attrValue = s.substring(pos, attrEndIndex);
      attributes.push({
        name: attrName,
        value: this._resolveEntities(attrValue)
      });
      pos = attrEndIndex + 1;
      skipWs();
    }
    return {
      name,
      attributes,
      parsed: pos - start
    };
  }
  _parseProcessingInstruction(s, start) {
    let pos = start;
    function skipWs() {
      while (pos < s.length && isWhitespace(s, pos)) {
        ++pos;
      }
    }
    while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "?" && s[pos] !== "/") {
      ++pos;
    }
    const name = s.substring(start, pos);
    skipWs();
    const attrStart = pos;
    while (pos < s.length && (s[pos] !== "?" || s[pos + 1] !== ">")) {
      ++pos;
    }
    const value = s.substring(attrStart, pos);
    return {
      name,
      value,
      parsed: pos - start
    };
  }
  parseXml(s) {
    let i = 0;
    while (i < s.length) {
      const ch = s[i];
      let j = i;
      if (ch === "<") {
        ++j;
        const ch2 = s[j];
        let q;
        switch (ch2) {
          case "/":
            ++j;
            q = s.indexOf(">", j);
            if (q < 0) {
              this.onError(XMLParserErrorCode.UnterminatedElement);
              return;
            }
            this.onEndElement(s.substring(j, q));
            j = q + 1;
            break;
          case "?":
            ++j;
            const pi = this._parseProcessingInstruction(s, j);
            if (s.substring(j + pi.parsed, j + pi.parsed + 2) !== "?>") {
              this.onError(XMLParserErrorCode.UnterminatedXmlDeclaration);
              return;
            }
            this.onPi(pi.name, pi.value);
            j += pi.parsed + 2;
            break;
          case "!":
            if (s.substring(j + 1, j + 3) === "--") {
              q = s.indexOf("-->", j + 3);
              if (q < 0) {
                this.onError(XMLParserErrorCode.UnterminatedComment);
                return;
              }
              this.onComment(s.substring(j + 3, q));
              j = q + 3;
            } else if (s.substring(j + 1, j + 8) === "[CDATA[") {
              q = s.indexOf("]]>", j + 8);
              if (q < 0) {
                this.onError(XMLParserErrorCode.UnterminatedCdat);
                return;
              }
              this.onCdata(s.substring(j + 8, q));
              j = q + 3;
            } else if (s.substring(j + 1, j + 8) === "DOCTYPE") {
              const q2 = s.indexOf("[", j + 8);
              let complexDoctype = false;
              q = s.indexOf(">", j + 8);
              if (q < 0) {
                this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                return;
              }
              if (q2 > 0 && q > q2) {
                q = s.indexOf("]>", j + 8);
                if (q < 0) {
                  this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                  return;
                }
                complexDoctype = true;
              }
              const doctypeContent = s.substring(j + 8, q + (complexDoctype ? 1 : 0));
              this.onDoctype(doctypeContent);
              j = q + (complexDoctype ? 2 : 1);
            } else {
              this.onError(XMLParserErrorCode.MalformedElement);
              return;
            }
            break;
          default:
            const content = this._parseContent(s, j);
            if (content === null) {
              this.onError(XMLParserErrorCode.MalformedElement);
              return;
            }
            let isClosed = false;
            if (s.substring(j + content.parsed, j + content.parsed + 2) === "/>") {
              isClosed = true;
            } else if (s.substring(j + content.parsed, j + content.parsed + 1) !== ">") {
              this.onError(XMLParserErrorCode.UnterminatedElement);
              return;
            }
            this.onBeginElement(content.name, content.attributes, isClosed);
            j += content.parsed + (isClosed ? 2 : 1);
            break;
        }
      } else {
        while (j < s.length && s[j] !== "<") {
          j++;
        }
        const text = s.substring(i, j);
        this.onText(this._resolveEntities(text));
      }
      i = j;
    }
  }
  onResolveEntity(name) {
    return `&${name};`;
  }
  onPi(name, value) {}
  onComment(text) {}
  onCdata(text) {}
  onDoctype(doctypeContent) {}
  onText(text) {}
  onBeginElement(name, attributes, isEmpty) {}
  onEndElement(name) {}
  onError(code) {}
}
exports.XMLParserBase = XMLParserBase;
class SimpleDOMNode {
  constructor(nodeName, nodeValue) {
    this.nodeName = nodeName;
    this.nodeValue = nodeValue;
    Object.defineProperty(this, "parentNode", {
      value: null,
      writable: true
    });
  }
  get firstChild() {
    return this.childNodes?.[0];
  }
  get nextSibling() {
    const childNodes = this.parentNode.childNodes;
    if (!childNodes) {
      return undefined;
    }
    const index = childNodes.indexOf(this);
    if (index === -1) {
      return undefined;
    }
    return childNodes[index + 1];
  }
  get textContent() {
    if (!this.childNodes) {
      return this.nodeValue || "";
    }
    return this.childNodes.map(function (child) {
      return child.textContent;
    }).join("");
  }
  get children() {
    return this.childNodes || [];
  }
  hasChildNodes() {
    return this.childNodes?.length > 0;
  }
  searchNode(paths, pos) {
    if (pos >= paths.length) {
      return this;
    }
    const component = paths[pos];
    if (component.name.startsWith("#") && pos < paths.length - 1) {
      return this.searchNode(paths, pos + 1);
    }
    const stack = [];
    let node = this;
    while (true) {
      if (component.name === node.nodeName) {
        if (component.pos === 0) {
          const res = node.searchNode(paths, pos + 1);
          if (res !== null) {
            return res;
          }
        } else if (stack.length === 0) {
          return null;
        } else {
          const [parent] = stack.pop();
          let siblingPos = 0;
          for (const child of parent.childNodes) {
            if (component.name === child.nodeName) {
              if (siblingPos === component.pos) {
                return child.searchNode(paths, pos + 1);
              }
              siblingPos++;
            }
          }
          return node.searchNode(paths, pos + 1);
        }
      }
      if (node.childNodes?.length > 0) {
        stack.push([node, 0]);
        node = node.childNodes[0];
      } else if (stack.length === 0) {
        return null;
      } else {
        while (stack.length !== 0) {
          const [parent, currentPos] = stack.pop();
          const newPos = currentPos + 1;
          if (newPos < parent.childNodes.length) {
            stack.push([parent, newPos]);
            node = parent.childNodes[newPos];
            break;
          }
        }
        if (stack.length === 0) {
          return null;
        }
      }
    }
  }
  dump(buffer) {
    if (this.nodeName === "#text") {
      buffer.push((0, _core_utils.encodeToXmlString)(this.nodeValue));
      return;
    }
    buffer.push(`<${this.nodeName}`);
    if (this.attributes) {
      for (const attribute of this.attributes) {
        buffer.push(` ${attribute.name}="${(0, _core_utils.encodeToXmlString)(attribute.value)}"`);
      }
    }
    if (this.hasChildNodes()) {
      buffer.push(">");
      for (const child of this.childNodes) {
        child.dump(buffer);
      }
      buffer.push(`</${this.nodeName}>`);
    } else if (this.nodeValue) {
      buffer.push(`>${(0, _core_utils.encodeToXmlString)(this.nodeValue)}</${this.nodeName}>`);
    } else {
      buffer.push("/>");
    }
  }
}
exports.SimpleDOMNode = SimpleDOMNode;
class SimpleXMLParser extends XMLParserBase {
  constructor({
    hasAttributes = false,
    lowerCaseName = false
  }) {
    super();
    this._currentFragment = null;
    this._stack = null;
    this._errorCode = XMLParserErrorCode.NoError;
    this._hasAttributes = hasAttributes;
    this._lowerCaseName = lowerCaseName;
  }
  parseFromString(data) {
    this._currentFragment = [];
    this._stack = [];
    this._errorCode = XMLParserErrorCode.NoError;
    this.parseXml(data);
    if (this._errorCode !== XMLParserErrorCode.NoError) {
      return undefined;
    }
    const [documentElement] = this._currentFragment;
    if (!documentElement) {
      return undefined;
    }
    return {
      documentElement
    };
  }
  onText(text) {
    if (isWhitespaceString(text)) {
      return;
    }
    const node = new SimpleDOMNode("#text", text);
    this._currentFragment.push(node);
  }
  onCdata(text) {
    const node = new SimpleDOMNode("#text", text);
    this._currentFragment.push(node);
  }
  onBeginElement(name, attributes, isEmpty) {
    if (this._lowerCaseName) {
      name = name.toLowerCase();
    }
    const node = new SimpleDOMNode(name);
    node.childNodes = [];
    if (this._hasAttributes) {
      node.attributes = attributes;
    }
    this._currentFragment.push(node);
    if (isEmpty) {
      return;
    }
    this._stack.push(this._currentFragment);
    this._currentFragment = node.childNodes;
  }
  onEndElement(name) {
    this._currentFragment = this._stack.pop() || [];
    const lastElement = this._currentFragment.at(-1);
    if (!lastElement) {
      return null;
    }
    for (const childNode of lastElement.childNodes) {
      childNode.parentNode = lastElement;
    }
    return lastElement;
  }
  onError(code) {
    this._errorCode = code;
  }
}
exports.SimpleXMLParser = SimpleXMLParser;

/***/ }),
/* 72 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StructTreeRoot = exports.StructTreePage = void 0;
var _util = __w_pdfjs_require__(2);
var _primitives = __w_pdfjs_require__(4);
var _name_number_tree = __w_pdfjs_require__(67);
var _writer = __w_pdfjs_require__(73);
const MAX_DEPTH = 40;
const StructElementType = {
  PAGE_CONTENT: 1,
  STREAM_CONTENT: 2,
  OBJECT: 3,
  ANNOTATION: 4,
  ELEMENT: 5
};
class StructTreeRoot {
  constructor(rootDict, rootRef) {
    this.dict = rootDict;
    this.ref = rootRef instanceof _primitives.Ref ? rootRef : null;
    this.roleMap = new Map();
    this.structParentIds = null;
  }
  init() {
    this.readRoleMap();
  }
  #addIdToPage(pageRef, id, type) {
    if (!(pageRef instanceof _primitives.Ref) || id < 0) {
      return;
    }
    this.structParentIds ||= new _primitives.RefSetCache();
    let ids = this.structParentIds.get(pageRef);
    if (!ids) {
      ids = [];
      this.structParentIds.put(pageRef, ids);
    }
    ids.push([id, type]);
  }
  addAnnotationIdToPage(pageRef, id) {
    this.#addIdToPage(pageRef, id, StructElementType.ANNOTATION);
  }
  readRoleMap() {
    const roleMapDict = this.dict.get("RoleMap");
    if (!(roleMapDict instanceof _primitives.Dict)) {
      return;
    }
    roleMapDict.forEach((key, value) => {
      if (!(value instanceof _primitives.Name)) {
        return;
      }
      this.roleMap.set(key, value.name);
    });
  }
  static async canCreateStructureTree({
    catalogRef,
    pdfManager,
    newAnnotationsByPage
  }) {
    if (!(catalogRef instanceof _primitives.Ref)) {
      (0, _util.warn)("Cannot save the struct tree: no catalog reference.");
      return false;
    }
    let nextKey = 0;
    let hasNothingToUpdate = true;
    for (const [pageIndex, elements] of newAnnotationsByPage) {
      const {
        ref: pageRef
      } = await pdfManager.getPage(pageIndex);
      if (!(pageRef instanceof _primitives.Ref)) {
        (0, _util.warn)(`Cannot save the struct tree: page ${pageIndex} has no ref.`);
        hasNothingToUpdate = true;
        break;
      }
      for (const element of elements) {
        if (element.accessibilityData?.type) {
          element.parentTreeId = nextKey++;
          hasNothingToUpdate = false;
        }
      }
    }
    if (hasNothingToUpdate) {
      for (const elements of newAnnotationsByPage.values()) {
        for (const element of elements) {
          delete element.parentTreeId;
        }
      }
      return false;
    }
    return true;
  }
  static async createStructureTree({
    newAnnotationsByPage,
    xref,
    catalogRef,
    pdfManager,
    newRefs
  }) {
    const root = pdfManager.catalog.cloneDict();
    const structTreeRootRef = xref.getNewTemporaryRef();
    root.set("StructTreeRoot", structTreeRootRef);
    const buffer = [];
    await (0, _writer.writeObject)(catalogRef, root, buffer, xref);
    newRefs.push({
      ref: catalogRef,
      data: buffer.join("")
    });
    const structTreeRoot = new _primitives.Dict(xref);
    structTreeRoot.set("Type", _primitives.Name.get("StructTreeRoot"));
    const parentTreeRef = xref.getNewTemporaryRef();
    structTreeRoot.set("ParentTree", parentTreeRef);
    const kids = [];
    structTreeRoot.set("K", kids);
    const parentTree = new _primitives.Dict(xref);
    const nums = [];
    parentTree.set("Nums", nums);
    const nextKey = await this.#writeKids({
      newAnnotationsByPage,
      structTreeRootRef,
      kids,
      nums,
      xref,
      pdfManager,
      newRefs,
      buffer
    });
    structTreeRoot.set("ParentTreeNextKey", nextKey);
    buffer.length = 0;
    await (0, _writer.writeObject)(parentTreeRef, parentTree, buffer, xref);
    newRefs.push({
      ref: parentTreeRef,
      data: buffer.join("")
    });
    buffer.length = 0;
    await (0, _writer.writeObject)(structTreeRootRef, structTreeRoot, buffer, xref);
    newRefs.push({
      ref: structTreeRootRef,
      data: buffer.join("")
    });
  }
  async canUpdateStructTree({
    pdfManager,
    newAnnotationsByPage
  }) {
    if (!this.ref) {
      (0, _util.warn)("Cannot update the struct tree: no root reference.");
      return false;
    }
    let nextKey = this.dict.get("ParentTreeNextKey");
    if (!Number.isInteger(nextKey) || nextKey < 0) {
      (0, _util.warn)("Cannot update the struct tree: invalid next key.");
      return false;
    }
    const parentTree = this.dict.get("ParentTree");
    if (!(parentTree instanceof _primitives.Dict)) {
      (0, _util.warn)("Cannot update the struct tree: ParentTree isn't a dict.");
      return false;
    }
    const nums = parentTree.get("Nums");
    if (!Array.isArray(nums)) {
      (0, _util.warn)("Cannot update the struct tree: nums isn't an array.");
      return false;
    }
    const {
      numPages
    } = pdfManager.catalog;
    for (const pageIndex of newAnnotationsByPage.keys()) {
      const {
        pageDict,
        ref: pageRef
      } = await pdfManager.getPage(pageIndex);
      if (!(pageRef instanceof _primitives.Ref)) {
        (0, _util.warn)(`Cannot save the struct tree: page ${pageIndex} has no ref.`);
        return false;
      }
      const id = pageDict.get("StructParents");
      if (!Number.isInteger(id) || id < 0 || id >= numPages) {
        (0, _util.warn)(`Cannot save the struct tree: page ${pageIndex} has no id.`);
        return false;
      }
    }
    let hasNothingToUpdate = true;
    for (const [pageIndex, elements] of newAnnotationsByPage) {
      const {
        pageDict
      } = await pdfManager.getPage(pageIndex);
      StructTreeRoot.#collectParents({
        elements,
        xref: this.dict.xref,
        pageDict,
        parentTree
      });
      for (const element of elements) {
        if (element.accessibilityData?.type) {
          element.parentTreeId = nextKey++;
          hasNothingToUpdate = false;
        }
      }
    }
    if (hasNothingToUpdate) {
      for (const elements of newAnnotationsByPage.values()) {
        for (const element of elements) {
          delete element.parentTreeId;
          delete element.structTreeParent;
        }
      }
      return false;
    }
    return true;
  }
  async updateStructureTree({
    newAnnotationsByPage,
    pdfManager,
    newRefs
  }) {
    const xref = this.dict.xref;
    const structTreeRoot = this.dict.clone();
    const structTreeRootRef = this.ref;
    let parentTreeRef = structTreeRoot.getRaw("ParentTree");
    let parentTree;
    if (parentTreeRef instanceof _primitives.Ref) {
      parentTree = xref.fetch(parentTreeRef);
    } else {
      parentTree = parentTreeRef;
      parentTreeRef = xref.getNewTemporaryRef();
      structTreeRoot.set("ParentTree", parentTreeRef);
    }
    parentTree = parentTree.clone();
    let nums = parentTree.getRaw("Nums");
    let numsRef = null;
    if (nums instanceof _primitives.Ref) {
      numsRef = nums;
      nums = xref.fetch(numsRef);
    }
    nums = nums.slice();
    if (!numsRef) {
      parentTree.set("Nums", nums);
    }
    let kids = structTreeRoot.getRaw("K");
    let kidsRef = null;
    if (kids instanceof _primitives.Ref) {
      kidsRef = kids;
      kids = xref.fetch(kidsRef);
    } else {
      kidsRef = xref.getNewTemporaryRef();
      structTreeRoot.set("K", kidsRef);
    }
    kids = Array.isArray(kids) ? kids.slice() : [kids];
    const buffer = [];
    const newNextkey = await StructTreeRoot.#writeKids({
      newAnnotationsByPage,
      structTreeRootRef,
      kids,
      nums,
      xref,
      pdfManager,
      newRefs,
      buffer
    });
    structTreeRoot.set("ParentTreeNextKey", newNextkey);
    buffer.length = 0;
    await (0, _writer.writeObject)(kidsRef, kids, buffer, xref);
    newRefs.push({
      ref: kidsRef,
      data: buffer.join("")
    });
    if (numsRef) {
      buffer.length = 0;
      await (0, _writer.writeObject)(numsRef, nums, buffer, xref);
      newRefs.push({
        ref: numsRef,
        data: buffer.join("")
      });
    }
    buffer.length = 0;
    await (0, _writer.writeObject)(parentTreeRef, parentTree, buffer, xref);
    newRefs.push({
      ref: parentTreeRef,
      data: buffer.join("")
    });
    buffer.length = 0;
    await (0, _writer.writeObject)(structTreeRootRef, structTreeRoot, buffer, xref);
    newRefs.push({
      ref: structTreeRootRef,
      data: buffer.join("")
    });
  }
  static async #writeKids({
    newAnnotationsByPage,
    structTreeRootRef,
    kids,
    nums,
    xref,
    pdfManager,
    newRefs,
    buffer
  }) {
    const objr = _primitives.Name.get("OBJR");
    let nextKey = -Infinity;
    for (const [pageIndex, elements] of newAnnotationsByPage) {
      const {
        ref: pageRef
      } = await pdfManager.getPage(pageIndex);
      for (const {
        accessibilityData: {
          type,
          title,
          lang,
          alt,
          expanded,
          actualText
        },
        ref,
        parentTreeId,
        structTreeParent
      } of elements) {
        nextKey = Math.max(nextKey, parentTreeId);
        const tagRef = xref.getNewTemporaryRef();
        const tagDict = new _primitives.Dict(xref);
        tagDict.set("S", _primitives.Name.get(type));
        if (title) {
          tagDict.set("T", title);
        }
        if (lang) {
          tagDict.set("Lang", lang);
        }
        if (alt) {
          tagDict.set("Alt", alt);
        }
        if (expanded) {
          tagDict.set("E", expanded);
        }
        if (actualText) {
          tagDict.set("ActualText", actualText);
        }
        if (structTreeParent) {
          await this.#updateParentTag({
            structTreeParent,
            tagDict,
            newTagRef: tagRef,
            fallbackRef: structTreeRootRef,
            xref,
            newRefs,
            buffer
          });
        } else {
          tagDict.set("P", structTreeRootRef);
        }
        const objDict = new _primitives.Dict(xref);
        tagDict.set("K", objDict);
        objDict.set("Type", objr);
        objDict.set("Pg", pageRef);
        objDict.set("Obj", ref);
        buffer.length = 0;
        await (0, _writer.writeObject)(tagRef, tagDict, buffer, xref);
        newRefs.push({
          ref: tagRef,
          data: buffer.join("")
        });
        nums.push(parentTreeId, tagRef);
        kids.push(tagRef);
      }
    }
    return nextKey + 1;
  }
  static #collectParents({
    elements,
    xref,
    pageDict,
    parentTree
  }) {
    const idToElement = new Map();
    for (const element of elements) {
      if (element.structTreeParentId) {
        const id = parseInt(element.structTreeParentId.split("_mc")[1], 10);
        idToElement.set(id, element);
      }
    }
    const id = pageDict.get("StructParents");
    const numberTree = new _name_number_tree.NumberTree(parentTree, xref);
    const parentArray = numberTree.get(id);
    if (!Array.isArray(parentArray)) {
      return;
    }
    const updateElement = (kid, pageKid, kidRef) => {
      const element = idToElement.get(kid);
      if (element) {
        const parentRef = pageKid.getRaw("P");
        const parentDict = xref.fetchIfRef(parentRef);
        if (parentRef instanceof _primitives.Ref && parentDict instanceof _primitives.Dict) {
          element.structTreeParent = {
            ref: kidRef,
            dict: pageKid
          };
        }
        return true;
      }
      return false;
    };
    for (const kidRef of parentArray) {
      if (!(kidRef instanceof _primitives.Ref)) {
        continue;
      }
      const pageKid = xref.fetch(kidRef);
      const k = pageKid.get("K");
      if (Number.isInteger(k)) {
        updateElement(k, pageKid, kidRef);
        continue;
      }
      if (!Array.isArray(k)) {
        continue;
      }
      for (let kid of k) {
        kid = xref.fetchIfRef(kid);
        if (Number.isInteger(kid) && updateElement(kid, pageKid, kidRef)) {
          break;
        }
      }
    }
  }
  static async #updateParentTag({
    structTreeParent: {
      ref,
      dict
    },
    tagDict,
    newTagRef,
    fallbackRef,
    xref,
    newRefs,
    buffer
  }) {
    const parentRef = dict.getRaw("P");
    let parentDict = xref.fetchIfRef(parentRef);
    tagDict.set("P", parentRef);
    let saveParentDict = false;
    let parentKids;
    let parentKidsRef = parentDict.getRaw("K");
    if (!(parentKidsRef instanceof _primitives.Ref)) {
      parentKids = parentKidsRef;
      parentKidsRef = xref.getNewTemporaryRef();
      parentDict = parentDict.clone();
      parentDict.set("K", parentKidsRef);
      saveParentDict = true;
    } else {
      parentKids = xref.fetch(parentKidsRef);
    }
    if (Array.isArray(parentKids)) {
      const index = parentKids.indexOf(ref);
      if (index >= 0) {
        parentKids = parentKids.slice();
        parentKids.splice(index + 1, 0, newTagRef);
      } else {
        (0, _util.warn)("Cannot update the struct tree: parent kid not found.");
        tagDict.set("P", fallbackRef);
        return;
      }
    } else if (parentKids instanceof _primitives.Dict) {
      parentKids = [parentKidsRef, newTagRef];
      parentKidsRef = xref.getNewTemporaryRef();
      parentDict.set("K", parentKidsRef);
      saveParentDict = true;
    }
    buffer.length = 0;
    await (0, _writer.writeObject)(parentKidsRef, parentKids, buffer, xref);
    newRefs.push({
      ref: parentKidsRef,
      data: buffer.join("")
    });
    if (!saveParentDict) {
      return;
    }
    buffer.length = 0;
    await (0, _writer.writeObject)(parentRef, parentDict, buffer, xref);
    newRefs.push({
      ref: parentRef,
      data: buffer.join("")
    });
  }
}
exports.StructTreeRoot = StructTreeRoot;
class StructElementNode {
  constructor(tree, dict) {
    this.tree = tree;
    this.dict = dict;
    this.kids = [];
    this.parseKids();
  }
  get role() {
    const nameObj = this.dict.get("S");
    const name = nameObj instanceof _primitives.Name ? nameObj.name : "";
    const {
      root
    } = this.tree;
    if (root.roleMap.has(name)) {
      return root.roleMap.get(name);
    }
    return name;
  }
  parseKids() {
    let pageObjId = null;
    const objRef = this.dict.getRaw("Pg");
    if (objRef instanceof _primitives.Ref) {
      pageObjId = objRef.toString();
    }
    const kids = this.dict.get("K");
    if (Array.isArray(kids)) {
      for (const kid of kids) {
        const element = this.parseKid(pageObjId, kid);
        if (element) {
          this.kids.push(element);
        }
      }
    } else {
      const element = this.parseKid(pageObjId, kids);
      if (element) {
        this.kids.push(element);
      }
    }
  }
  parseKid(pageObjId, kid) {
    if (Number.isInteger(kid)) {
      if (this.tree.pageDict.objId !== pageObjId) {
        return null;
      }
      return new StructElement({
        type: StructElementType.PAGE_CONTENT,
        mcid: kid,
        pageObjId
      });
    }
    let kidDict = null;
    if (kid instanceof _primitives.Ref) {
      kidDict = this.dict.xref.fetch(kid);
    } else if (kid instanceof _primitives.Dict) {
      kidDict = kid;
    }
    if (!kidDict) {
      return null;
    }
    const pageRef = kidDict.getRaw("Pg");
    if (pageRef instanceof _primitives.Ref) {
      pageObjId = pageRef.toString();
    }
    const type = kidDict.get("Type") instanceof _primitives.Name ? kidDict.get("Type").name : null;
    if (type === "MCR") {
      if (this.tree.pageDict.objId !== pageObjId) {
        return null;
      }
      const kidRef = kidDict.getRaw("Stm");
      return new StructElement({
        type: StructElementType.STREAM_CONTENT,
        refObjId: kidRef instanceof _primitives.Ref ? kidRef.toString() : null,
        pageObjId,
        mcid: kidDict.get("MCID")
      });
    }
    if (type === "OBJR") {
      if (this.tree.pageDict.objId !== pageObjId) {
        return null;
      }
      const kidRef = kidDict.getRaw("Obj");
      return new StructElement({
        type: StructElementType.OBJECT,
        refObjId: kidRef instanceof _primitives.Ref ? kidRef.toString() : null,
        pageObjId
      });
    }
    return new StructElement({
      type: StructElementType.ELEMENT,
      dict: kidDict
    });
  }
}
class StructElement {
  constructor({
    type,
    dict = null,
    mcid = null,
    pageObjId = null,
    refObjId = null
  }) {
    this.type = type;
    this.dict = dict;
    this.mcid = mcid;
    this.pageObjId = pageObjId;
    this.refObjId = refObjId;
    this.parentNode = null;
  }
}
class StructTreePage {
  constructor(structTreeRoot, pageDict) {
    this.root = structTreeRoot;
    this.rootDict = structTreeRoot ? structTreeRoot.dict : null;
    this.pageDict = pageDict;
    this.nodes = [];
  }
  parse(pageRef) {
    if (!this.root || !this.rootDict) {
      return;
    }
    const parentTree = this.rootDict.get("ParentTree");
    if (!parentTree) {
      return;
    }
    const id = this.pageDict.get("StructParents");
    const ids = pageRef instanceof _primitives.Ref && this.root.structParentIds?.get(pageRef);
    if (!Number.isInteger(id) && !ids) {
      return;
    }
    const map = new Map();
    const numberTree = new _name_number_tree.NumberTree(parentTree, this.rootDict.xref);
    if (Number.isInteger(id)) {
      const parentArray = numberTree.get(id);
      if (Array.isArray(parentArray)) {
        for (const ref of parentArray) {
          if (ref instanceof _primitives.Ref) {
            this.addNode(this.rootDict.xref.fetch(ref), map);
          }
        }
      }
    }
    if (!ids) {
      return;
    }
    for (const [elemId, type] of ids) {
      const obj = numberTree.get(elemId);
      if (obj) {
        const elem = this.addNode(this.rootDict.xref.fetchIfRef(obj), map);
        if (elem?.kids?.length === 1 && elem.kids[0].type === StructElementType.OBJECT) {
          elem.kids[0].type = type;
        }
      }
    }
  }
  addNode(dict, map, level = 0) {
    if (level > MAX_DEPTH) {
      (0, _util.warn)("StructTree MAX_DEPTH reached.");
      return null;
    }
    if (map.has(dict)) {
      return map.get(dict);
    }
    const element = new StructElementNode(this, dict);
    map.set(dict, element);
    const parent = dict.get("P");
    if (!parent || (0, _primitives.isName)(parent.get("Type"), "StructTreeRoot")) {
      if (!this.addTopLevelNode(dict, element)) {
        map.delete(dict);
      }
      return element;
    }
    const parentNode = this.addNode(parent, map, level + 1);
    if (!parentNode) {
      return element;
    }
    let save = false;
    for (const kid of parentNode.kids) {
      if (kid.type === StructElementType.ELEMENT && kid.dict === dict) {
        kid.parentNode = element;
        save = true;
      }
    }
    if (!save) {
      map.delete(dict);
    }
    return element;
  }
  addTopLevelNode(dict, element) {
    const obj = this.rootDict.get("K");
    if (!obj) {
      return false;
    }
    if (obj instanceof _primitives.Dict) {
      if (obj.objId !== dict.objId) {
        return false;
      }
      this.nodes[0] = element;
      return true;
    }
    if (!Array.isArray(obj)) {
      return true;
    }
    let save = false;
    for (let i = 0; i < obj.length; i++) {
      const kidRef = obj[i];
      if (kidRef?.toString() === dict.objId) {
        this.nodes[i] = element;
        save = true;
      }
    }
    return save;
  }
  get serializable() {
    function nodeToSerializable(node, parent, level = 0) {
      if (level > MAX_DEPTH) {
        (0, _util.warn)("StructTree too deep to be fully serialized.");
        return;
      }
      const obj = Object.create(null);
      obj.role = node.role;
      obj.children = [];
      parent.children.push(obj);
      const alt = node.dict.get("Alt");
      if (typeof alt === "string") {
        obj.alt = (0, _util.stringToPDFString)(alt);
      }
      const lang = node.dict.get("Lang");
      if (typeof lang === "string") {
        obj.lang = (0, _util.stringToPDFString)(lang);
      }
      for (const kid of node.kids) {
        const kidElement = kid.type === StructElementType.ELEMENT ? kid.parentNode : null;
        if (kidElement) {
          nodeToSerializable(kidElement, obj, level + 1);
          continue;
        } else if (kid.type === StructElementType.PAGE_CONTENT || kid.type === StructElementType.STREAM_CONTENT) {
          obj.children.push({
            type: "content",
            id: `p${kid.pageObjId}_mc${kid.mcid}`
          });
        } else if (kid.type === StructElementType.OBJECT) {
          obj.children.push({
            type: "object",
            id: kid.refObjId
          });
        } else if (kid.type === StructElementType.ANNOTATION) {
          obj.children.push({
            type: "annotation",
            id: `${_util.AnnotationPrefix}${kid.refObjId}`
          });
        }
      }
    }
    const root = Object.create(null);
    root.children = [];
    root.role = "Root";
    for (const child of this.nodes) {
      if (!child) {
        continue;
      }
      nodeToSerializable(child, root);
    }
    return root;
  }
}
exports.StructTreePage = StructTreePage;

/***/ }),
/* 73 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.incrementalUpdate = incrementalUpdate;
exports.writeDict = writeDict;
exports.writeObject = writeObject;
var _util = __w_pdfjs_require__(2);
var _primitives = __w_pdfjs_require__(4);
var _core_utils = __w_pdfjs_require__(3);
var _xml_parser = __w_pdfjs_require__(71);
var _base_stream = __w_pdfjs_require__(5);
var _crypto = __w_pdfjs_require__(74);
async function writeObject(ref, obj, buffer, {
  encrypt = null
}) {
  const transform = encrypt?.createCipherTransform(ref.num, ref.gen);
  buffer.push(`${ref.num} ${ref.gen} obj\n`);
  if (obj instanceof _primitives.Dict) {
    await writeDict(obj, buffer, transform);
  } else if (obj instanceof _base_stream.BaseStream) {
    await writeStream(obj, buffer, transform);
  } else if (Array.isArray(obj)) {
    await writeArray(obj, buffer, transform);
  }
  buffer.push("\nendobj\n");
}
async function writeDict(dict, buffer, transform) {
  buffer.push("<<");
  for (const key of dict.getKeys()) {
    buffer.push(` /${(0, _core_utils.escapePDFName)(key)} `);
    await writeValue(dict.getRaw(key), buffer, transform);
  }
  buffer.push(">>");
}
async function writeStream(stream, buffer, transform) {
  let string = stream.getString();
  const {
    dict
  } = stream;
  const [filter, params] = await Promise.all([dict.getAsync("Filter"), dict.getAsync("DecodeParms")]);
  const filterZero = Array.isArray(filter) ? await dict.xref.fetchIfRefAsync(filter[0]) : filter;
  const isFilterZeroFlateDecode = (0, _primitives.isName)(filterZero, "FlateDecode");
  const MIN_LENGTH_FOR_COMPRESSING = 256;
  if (typeof CompressionStream !== "undefined" && (string.length >= MIN_LENGTH_FOR_COMPRESSING || isFilterZeroFlateDecode)) {
    try {
      const byteArray = (0, _util.stringToBytes)(string);
      const cs = new CompressionStream("deflate");
      const writer = cs.writable.getWriter();
      writer.write(byteArray);
      writer.close();
      const buf = await new Response(cs.readable).arrayBuffer();
      string = (0, _util.bytesToString)(new Uint8Array(buf));
      let newFilter, newParams;
      if (!filter) {
        newFilter = _primitives.Name.get("FlateDecode");
      } else if (!isFilterZeroFlateDecode) {
        newFilter = Array.isArray(filter) ? [_primitives.Name.get("FlateDecode"), ...filter] : [_primitives.Name.get("FlateDecode"), filter];
        if (params) {
          newParams = Array.isArray(params) ? [null, ...params] : [null, params];
        }
      }
      if (newFilter) {
        dict.set("Filter", newFilter);
      }
      if (newParams) {
        dict.set("DecodeParms", newParams);
      }
    } catch (ex) {
      (0, _util.info)(`writeStream - cannot compress data: "${ex}".`);
    }
  }
  if (transform) {
    string = transform.encryptString(string);
  }
  dict.set("Length", string.length);
  await writeDict(dict, buffer, transform);
  buffer.push(" stream\n", string, "\nendstream");
}
async function writeArray(array, buffer, transform) {
  buffer.push("[");
  let first = true;
  for (const val of array) {
    if (!first) {
      buffer.push(" ");
    } else {
      first = false;
    }
    await writeValue(val, buffer, transform);
  }
  buffer.push("]");
}
async function writeValue(value, buffer, transform) {
  if (value instanceof _primitives.Name) {
    buffer.push(`/${(0, _core_utils.escapePDFName)(value.name)}`);
  } else if (value instanceof _primitives.Ref) {
    buffer.push(`${value.num} ${value.gen} R`);
  } else if (Array.isArray(value)) {
    await writeArray(value, buffer, transform);
  } else if (typeof value === "string") {
    if (transform) {
      value = transform.encryptString(value);
    }
    buffer.push(`(${(0, _core_utils.escapeString)(value)})`);
  } else if (typeof value === "number") {
    buffer.push((0, _core_utils.numberToString)(value));
  } else if (typeof value === "boolean") {
    buffer.push(value.toString());
  } else if (value instanceof _primitives.Dict) {
    await writeDict(value, buffer, transform);
  } else if (value instanceof _base_stream.BaseStream) {
    await writeStream(value, buffer, transform);
  } else if (value === null) {
    buffer.push("null");
  } else {
    (0, _util.warn)(`Unhandled value in writer: ${typeof value}, please file a bug.`);
  }
}
function writeInt(number, size, offset, buffer) {
  for (let i = size + offset - 1; i > offset - 1; i--) {
    buffer[i] = number & 0xff;
    number >>= 8;
  }
  return offset + size;
}
function writeString(string, offset, buffer) {
  for (let i = 0, len = string.length; i < len; i++) {
    buffer[offset + i] = string.charCodeAt(i) & 0xff;
  }
}
function computeMD5(filesize, xrefInfo) {
  const time = Math.floor(Date.now() / 1000);
  const filename = xrefInfo.filename || "";
  const md5Buffer = [time.toString(), filename, filesize.toString()];
  let md5BufferLen = md5Buffer.reduce((a, str) => a + str.length, 0);
  for (const value of Object.values(xrefInfo.info)) {
    md5Buffer.push(value);
    md5BufferLen += value.length;
  }
  const array = new Uint8Array(md5BufferLen);
  let offset = 0;
  for (const str of md5Buffer) {
    writeString(str, offset, array);
    offset += str.length;
  }
  return (0, _util.bytesToString)((0, _crypto.calculateMD5)(array));
}
function writeXFADataForAcroform(str, newRefs) {
  const xml = new _xml_parser.SimpleXMLParser({
    hasAttributes: true
  }).parseFromString(str);
  for (const {
    xfa
  } of newRefs) {
    if (!xfa) {
      continue;
    }
    const {
      path,
      value
    } = xfa;
    if (!path) {
      continue;
    }
    const nodePath = (0, _core_utils.parseXFAPath)(path);
    let node = xml.documentElement.searchNode(nodePath, 0);
    if (!node && nodePath.length > 1) {
      node = xml.documentElement.searchNode([nodePath.at(-1)], 0);
    }
    if (node) {
      node.childNodes = Array.isArray(value) ? value.map(val => new _xml_parser.SimpleDOMNode("value", val)) : [new _xml_parser.SimpleDOMNode("#text", value)];
    } else {
      (0, _util.warn)(`Node not found for path: ${path}`);
    }
  }
  const buffer = [];
  xml.documentElement.dump(buffer);
  return buffer.join("");
}
async function updateAcroform({
  xref,
  acroForm,
  acroFormRef,
  hasXfa,
  hasXfaDatasetsEntry,
  xfaDatasetsRef,
  needAppearances,
  newRefs
}) {
  if (hasXfa && !hasXfaDatasetsEntry && !xfaDatasetsRef) {
    (0, _util.warn)("XFA - Cannot save it");
  }
  if (!needAppearances && (!hasXfa || !xfaDatasetsRef || hasXfaDatasetsEntry)) {
    return;
  }
  const dict = acroForm.clone();
  if (hasXfa && !hasXfaDatasetsEntry) {
    const newXfa = acroForm.get("XFA").slice();
    newXfa.splice(2, 0, "datasets");
    newXfa.splice(3, 0, xfaDatasetsRef);
    dict.set("XFA", newXfa);
  }
  if (needAppearances) {
    dict.set("NeedAppearances", true);
  }
  const buffer = [];
  await writeObject(acroFormRef, dict, buffer, xref);
  newRefs.push({
    ref: acroFormRef,
    data: buffer.join("")
  });
}
function updateXFA({
  xfaData,
  xfaDatasetsRef,
  newRefs,
  xref
}) {
  if (xfaData === null) {
    const datasets = xref.fetchIfRef(xfaDatasetsRef);
    xfaData = writeXFADataForAcroform(datasets.getString(), newRefs);
  }
  const encrypt = xref.encrypt;
  if (encrypt) {
    const transform = encrypt.createCipherTransform(xfaDatasetsRef.num, xfaDatasetsRef.gen);
    xfaData = transform.encryptString(xfaData);
  }
  const data = `${xfaDatasetsRef.num} ${xfaDatasetsRef.gen} obj\n` + `<< /Type /EmbeddedFile /Length ${xfaData.length}>>\nstream\n` + xfaData + "\nendstream\nendobj\n";
  newRefs.push({
    ref: xfaDatasetsRef,
    data
  });
}
async function incrementalUpdate({
  originalData,
  xrefInfo,
  newRefs,
  xref = null,
  hasXfa = false,
  xfaDatasetsRef = null,
  hasXfaDatasetsEntry = false,
  needAppearances,
  acroFormRef = null,
  acroForm = null,
  xfaData = null
}) {
  await updateAcroform({
    xref,
    acroForm,
    acroFormRef,
    hasXfa,
    hasXfaDatasetsEntry,
    xfaDatasetsRef,
    needAppearances,
    newRefs
  });
  if (hasXfa) {
    updateXFA({
      xfaData,
      xfaDatasetsRef,
      newRefs,
      xref
    });
  }
  const newXref = new _primitives.Dict(null);
  const refForXrefTable = xrefInfo.newRef;
  let buffer, baseOffset;
  const lastByte = originalData.at(-1);
  if (lastByte === 0x0a || lastByte === 0x0d) {
    buffer = [];
    baseOffset = originalData.length;
  } else {
    buffer = ["\n"];
    baseOffset = originalData.length + 1;
  }
  newXref.set("Size", refForXrefTable.num + 1);
  newXref.set("Prev", xrefInfo.startXRef);
  newXref.set("Type", _primitives.Name.get("XRef"));
  if (xrefInfo.rootRef !== null) {
    newXref.set("Root", xrefInfo.rootRef);
  }
  if (xrefInfo.infoRef !== null) {
    newXref.set("Info", xrefInfo.infoRef);
  }
  if (xrefInfo.encryptRef !== null) {
    newXref.set("Encrypt", xrefInfo.encryptRef);
  }
  newRefs.push({
    ref: refForXrefTable,
    data: ""
  });
  newRefs = newRefs.sort((a, b) => {
    return a.ref.num - b.ref.num;
  });
  const xrefTableData = [[0, 1, 0xffff]];
  const indexes = [0, 1];
  let maxOffset = 0;
  for (const {
    ref,
    data
  } of newRefs) {
    maxOffset = Math.max(maxOffset, baseOffset);
    xrefTableData.push([1, baseOffset, Math.min(ref.gen, 0xffff)]);
    baseOffset += data.length;
    indexes.push(ref.num, 1);
    buffer.push(data);
  }
  newXref.set("Index", indexes);
  if (Array.isArray(xrefInfo.fileIds) && xrefInfo.fileIds.length > 0) {
    const md5 = computeMD5(baseOffset, xrefInfo);
    newXref.set("ID", [xrefInfo.fileIds[0], md5]);
  }
  const offsetSize = Math.ceil(Math.log2(maxOffset) / 8);
  const sizes = [1, offsetSize, 2];
  const structSize = sizes[0] + sizes[1] + sizes[2];
  const tableLength = structSize * xrefTableData.length;
  newXref.set("W", sizes);
  newXref.set("Length", tableLength);
  buffer.push(`${refForXrefTable.num} ${refForXrefTable.gen} obj\n`);
  await writeDict(newXref, buffer, null);
  buffer.push(" stream\n");
  const bufferLen = buffer.reduce((a, str) => a + str.length, 0);
  const footer = `\nendstream\nendobj\nstartxref\n${baseOffset}\n%%EOF\n`;
  const array = new Uint8Array(originalData.length + bufferLen + tableLength + footer.length);
  array.set(originalData);
  let offset = originalData.length;
  for (const str of buffer) {
    writeString(str, offset, array);
    offset += str.length;
  }
  for (const [type, objOffset, gen] of xrefTableData) {
    offset = writeInt(type, sizes[0], offset, array);
    offset = writeInt(objOffset, sizes[1], offset, array);
    offset = writeInt(gen, sizes[2], offset, array);
  }
  writeString(footer, offset, array);
  return array;
}

/***/ }),
/* 74 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.calculateSHA256 = exports.calculateMD5 = exports.PDF20 = exports.PDF17 = exports.CipherTransformFactory = exports.ARCFourCipher = exports.AES256Cipher = exports.AES128Cipher = void 0;
exports.calculateSHA384 = calculateSHA384;
exports.calculateSHA512 = void 0;
var _util = __w_pdfjs_require__(2);
var _primitives = __w_pdfjs_require__(4);
var _decrypt_stream = __w_pdfjs_require__(75);
class ARCFourCipher {
  constructor(key) {
    this.a = 0;
    this.b = 0;
    const s = new Uint8Array(256);
    const keyLength = key.length;
    for (let i = 0; i < 256; ++i) {
      s[i] = i;
    }
    for (let i = 0, j = 0; i < 256; ++i) {
      const tmp = s[i];
      j = j + tmp + key[i % keyLength] & 0xff;
      s[i] = s[j];
      s[j] = tmp;
    }
    this.s = s;
  }
  encryptBlock(data) {
    let a = this.a,
      b = this.b;
    const s = this.s;
    const n = data.length;
    const output = new Uint8Array(n);
    for (let i = 0; i < n; ++i) {
      a = a + 1 & 0xff;
      const tmp = s[a];
      b = b + tmp & 0xff;
      const tmp2 = s[b];
      s[a] = tmp2;
      s[b] = tmp;
      output[i] = data[i] ^ s[tmp + tmp2 & 0xff];
    }
    this.a = a;
    this.b = b;
    return output;
  }
  decryptBlock(data) {
    return this.encryptBlock(data);
  }
  encrypt(data) {
    return this.encryptBlock(data);
  }
}
exports.ARCFourCipher = ARCFourCipher;
const calculateMD5 = function calculateMD5Closure() {
  const r = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]);
  const k = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);
  function hash(data, offset, length) {
    let h0 = 1732584193,
      h1 = -271733879,
      h2 = -1732584194,
      h3 = 271733878;
    const paddedLength = length + 72 & ~63;
    const padded = new Uint8Array(paddedLength);
    let i, j;
    for (i = 0; i < length; ++i) {
      padded[i] = data[offset++];
    }
    padded[i++] = 0x80;
    const n = paddedLength - 8;
    while (i < n) {
      padded[i++] = 0;
    }
    padded[i++] = length << 3 & 0xff;
    padded[i++] = length >> 5 & 0xff;
    padded[i++] = length >> 13 & 0xff;
    padded[i++] = length >> 21 & 0xff;
    padded[i++] = length >>> 29 & 0xff;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    const w = new Int32Array(16);
    for (i = 0; i < paddedLength;) {
      for (j = 0; j < 16; ++j, i += 4) {
        w[j] = padded[i] | padded[i + 1] << 8 | padded[i + 2] << 16 | padded[i + 3] << 24;
      }
      let a = h0,
        b = h1,
        c = h2,
        d = h3,
        f,
        g;
      for (j = 0; j < 64; ++j) {
        if (j < 16) {
          f = b & c | ~b & d;
          g = j;
        } else if (j < 32) {
          f = d & b | ~d & c;
          g = 5 * j + 1 & 15;
        } else if (j < 48) {
          f = b ^ c ^ d;
          g = 3 * j + 5 & 15;
        } else {
          f = c ^ (b | ~d);
          g = 7 * j & 15;
        }
        const tmp = d,
          rotateArg = a + f + k[j] + w[g] | 0,
          rotate = r[j];
        d = c;
        c = b;
        b = b + (rotateArg << rotate | rotateArg >>> 32 - rotate) | 0;
        a = tmp;
      }
      h0 = h0 + a | 0;
      h1 = h1 + b | 0;
      h2 = h2 + c | 0;
      h3 = h3 + d | 0;
    }
    return new Uint8Array([h0 & 0xFF, h0 >> 8 & 0xFF, h0 >> 16 & 0xFF, h0 >>> 24 & 0xFF, h1 & 0xFF, h1 >> 8 & 0xFF, h1 >> 16 & 0xFF, h1 >>> 24 & 0xFF, h2 & 0xFF, h2 >> 8 & 0xFF, h2 >> 16 & 0xFF, h2 >>> 24 & 0xFF, h3 & 0xFF, h3 >> 8 & 0xFF, h3 >> 16 & 0xFF, h3 >>> 24 & 0xFF]);
  }
  return hash;
}();
exports.calculateMD5 = calculateMD5;
class Word64 {
  constructor(highInteger, lowInteger) {
    this.high = highInteger | 0;
    this.low = lowInteger | 0;
  }
  and(word) {
    this.high &= word.high;
    this.low &= word.low;
  }
  xor(word) {
    this.high ^= word.high;
    this.low ^= word.low;
  }
  or(word) {
    this.high |= word.high;
    this.low |= word.low;
  }
  shiftRight(places) {
    if (places >= 32) {
      this.low = this.high >>> places - 32 | 0;
      this.high = 0;
    } else {
      this.low = this.low >>> places | this.high << 32 - places;
      this.high = this.high >>> places | 0;
    }
  }
  shiftLeft(places) {
    if (places >= 32) {
      this.high = this.low << places - 32;
      this.low = 0;
    } else {
      this.high = this.high << places | this.low >>> 32 - places;
      this.low <<= places;
    }
  }
  rotateRight(places) {
    let low, high;
    if (places & 32) {
      high = this.low;
      low = this.high;
    } else {
      low = this.low;
      high = this.high;
    }
    places &= 31;
    this.low = low >>> places | high << 32 - places;
    this.high = high >>> places | low << 32 - places;
  }
  not() {
    this.high = ~this.high;
    this.low = ~this.low;
  }
  add(word) {
    const lowAdd = (this.low >>> 0) + (word.low >>> 0);
    let highAdd = (this.high >>> 0) + (word.high >>> 0);
    if (lowAdd > 0xffffffff) {
      highAdd += 1;
    }
    this.low = lowAdd | 0;
    this.high = highAdd | 0;
  }
  copyTo(bytes, offset) {
    bytes[offset] = this.high >>> 24 & 0xff;
    bytes[offset + 1] = this.high >> 16 & 0xff;
    bytes[offset + 2] = this.high >> 8 & 0xff;
    bytes[offset + 3] = this.high & 0xff;
    bytes[offset + 4] = this.low >>> 24 & 0xff;
    bytes[offset + 5] = this.low >> 16 & 0xff;
    bytes[offset + 6] = this.low >> 8 & 0xff;
    bytes[offset + 7] = this.low & 0xff;
  }
  assign(word) {
    this.high = word.high;
    this.low = word.low;
  }
}
const calculateSHA256 = function calculateSHA256Closure() {
  function rotr(x, n) {
    return x >>> n | x << 32 - n;
  }
  function ch(x, y, z) {
    return x & y ^ ~x & z;
  }
  function maj(x, y, z) {
    return x & y ^ x & z ^ y & z;
  }
  function sigma(x) {
    return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22);
  }
  function sigmaPrime(x) {
    return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25);
  }
  function littleSigma(x) {
    return rotr(x, 7) ^ rotr(x, 18) ^ x >>> 3;
  }
  function littleSigmaPrime(x) {
    return rotr(x, 17) ^ rotr(x, 19) ^ x >>> 10;
  }
  const k = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];
  function hash(data, offset, length) {
    let h0 = 0x6a09e667,
      h1 = 0xbb67ae85,
      h2 = 0x3c6ef372,
      h3 = 0xa54ff53a,
      h4 = 0x510e527f,
      h5 = 0x9b05688c,
      h6 = 0x1f83d9ab,
      h7 = 0x5be0cd19;
    const paddedLength = Math.ceil((length + 9) / 64) * 64;
    const padded = new Uint8Array(paddedLength);
    let i, j;
    for (i = 0; i < length; ++i) {
      padded[i] = data[offset++];
    }
    padded[i++] = 0x80;
    const n = paddedLength - 8;
    while (i < n) {
      padded[i++] = 0;
    }
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = length >>> 29 & 0xff;
    padded[i++] = length >> 21 & 0xff;
    padded[i++] = length >> 13 & 0xff;
    padded[i++] = length >> 5 & 0xff;
    padded[i++] = length << 3 & 0xff;
    const w = new Uint32Array(64);
    for (i = 0; i < paddedLength;) {
      for (j = 0; j < 16; ++j) {
        w[j] = padded[i] << 24 | padded[i + 1] << 16 | padded[i + 2] << 8 | padded[i + 3];
        i += 4;
      }
      for (j = 16; j < 64; ++j) {
        w[j] = littleSigmaPrime(w[j - 2]) + w[j - 7] + littleSigma(w[j - 15]) + w[j - 16] | 0;
      }
      let a = h0,
        b = h1,
        c = h2,
        d = h3,
        e = h4,
        f = h5,
        g = h6,
        h = h7,
        t1,
        t2;
      for (j = 0; j < 64; ++j) {
        t1 = h + sigmaPrime(e) + ch(e, f, g) + k[j] + w[j];
        t2 = sigma(a) + maj(a, b, c);
        h = g;
        g = f;
        f = e;
        e = d + t1 | 0;
        d = c;
        c = b;
        b = a;
        a = t1 + t2 | 0;
      }
      h0 = h0 + a | 0;
      h1 = h1 + b | 0;
      h2 = h2 + c | 0;
      h3 = h3 + d | 0;
      h4 = h4 + e | 0;
      h5 = h5 + f | 0;
      h6 = h6 + g | 0;
      h7 = h7 + h | 0;
    }
    return new Uint8Array([h0 >> 24 & 0xFF, h0 >> 16 & 0xFF, h0 >> 8 & 0xFF, h0 & 0xFF, h1 >> 24 & 0xFF, h1 >> 16 & 0xFF, h1 >> 8 & 0xFF, h1 & 0xFF, h2 >> 24 & 0xFF, h2 >> 16 & 0xFF, h2 >> 8 & 0xFF, h2 & 0xFF, h3 >> 24 & 0xFF, h3 >> 16 & 0xFF, h3 >> 8 & 0xFF, h3 & 0xFF, h4 >> 24 & 0xFF, h4 >> 16 & 0xFF, h4 >> 8 & 0xFF, h4 & 0xFF, h5 >> 24 & 0xFF, h5 >> 16 & 0xFF, h5 >> 8 & 0xFF, h5 & 0xFF, h6 >> 24 & 0xFF, h6 >> 16 & 0xFF, h6 >> 8 & 0xFF, h6 & 0xFF, h7 >> 24 & 0xFF, h7 >> 16 & 0xFF, h7 >> 8 & 0xFF, h7 & 0xFF]);
  }
  return hash;
}();
exports.calculateSHA256 = calculateSHA256;
const calculateSHA512 = function calculateSHA512Closure() {
  function ch(result, x, y, z, tmp) {
    result.assign(x);
    result.and(y);
    tmp.assign(x);
    tmp.not();
    tmp.and(z);
    result.xor(tmp);
  }
  function maj(result, x, y, z, tmp) {
    result.assign(x);
    result.and(y);
    tmp.assign(x);
    tmp.and(z);
    result.xor(tmp);
    tmp.assign(y);
    tmp.and(z);
    result.xor(tmp);
  }
  function sigma(result, x, tmp) {
    result.assign(x);
    result.rotateRight(28);
    tmp.assign(x);
    tmp.rotateRight(34);
    result.xor(tmp);
    tmp.assign(x);
    tmp.rotateRight(39);
    result.xor(tmp);
  }
  function sigmaPrime(result, x, tmp) {
    result.assign(x);
    result.rotateRight(14);
    tmp.assign(x);
    tmp.rotateRight(18);
    result.xor(tmp);
    tmp.assign(x);
    tmp.rotateRight(41);
    result.xor(tmp);
  }
  function littleSigma(result, x, tmp) {
    result.assign(x);
    result.rotateRight(1);
    tmp.assign(x);
    tmp.rotateRight(8);
    result.xor(tmp);
    tmp.assign(x);
    tmp.shiftRight(7);
    result.xor(tmp);
  }
  function littleSigmaPrime(result, x, tmp) {
    result.assign(x);
    result.rotateRight(19);
    tmp.assign(x);
    tmp.rotateRight(61);
    result.xor(tmp);
    tmp.assign(x);
    tmp.shiftRight(6);
    result.xor(tmp);
  }
  const k = [new Word64(0x428a2f98, 0xd728ae22), new Word64(0x71374491, 0x23ef65cd), new Word64(0xb5c0fbcf, 0xec4d3b2f), new Word64(0xe9b5dba5, 0x8189dbbc), new Word64(0x3956c25b, 0xf348b538), new Word64(0x59f111f1, 0xb605d019), new Word64(0x923f82a4, 0xaf194f9b), new Word64(0xab1c5ed5, 0xda6d8118), new Word64(0xd807aa98, 0xa3030242), new Word64(0x12835b01, 0x45706fbe), new Word64(0x243185be, 0x4ee4b28c), new Word64(0x550c7dc3, 0xd5ffb4e2), new Word64(0x72be5d74, 0xf27b896f), new Word64(0x80deb1fe, 0x3b1696b1), new Word64(0x9bdc06a7, 0x25c71235), new Word64(0xc19bf174, 0xcf692694), new Word64(0xe49b69c1, 0x9ef14ad2), new Word64(0xefbe4786, 0x384f25e3), new Word64(0x0fc19dc6, 0x8b8cd5b5), new Word64(0x240ca1cc, 0x77ac9c65), new Word64(0x2de92c6f, 0x592b0275), new Word64(0x4a7484aa, 0x6ea6e483), new Word64(0x5cb0a9dc, 0xbd41fbd4), new Word64(0x76f988da, 0x831153b5), new Word64(0x983e5152, 0xee66dfab), new Word64(0xa831c66d, 0x2db43210), new Word64(0xb00327c8, 0x98fb213f), new Word64(0xbf597fc7, 0xbeef0ee4), new Word64(0xc6e00bf3, 0x3da88fc2), new Word64(0xd5a79147, 0x930aa725), new Word64(0x06ca6351, 0xe003826f), new Word64(0x14292967, 0x0a0e6e70), new Word64(0x27b70a85, 0x46d22ffc), new Word64(0x2e1b2138, 0x5c26c926), new Word64(0x4d2c6dfc, 0x5ac42aed), new Word64(0x53380d13, 0x9d95b3df), new Word64(0x650a7354, 0x8baf63de), new Word64(0x766a0abb, 0x3c77b2a8), new Word64(0x81c2c92e, 0x47edaee6), new Word64(0x92722c85, 0x1482353b), new Word64(0xa2bfe8a1, 0x4cf10364), new Word64(0xa81a664b, 0xbc423001), new Word64(0xc24b8b70, 0xd0f89791), new Word64(0xc76c51a3, 0x0654be30), new Word64(0xd192e819, 0xd6ef5218), new Word64(0xd6990624, 0x5565a910), new Word64(0xf40e3585, 0x5771202a), new Word64(0x106aa070, 0x32bbd1b8), new Word64(0x19a4c116, 0xb8d2d0c8), new Word64(0x1e376c08, 0x5141ab53), new Word64(0x2748774c, 0xdf8eeb99), new Word64(0x34b0bcb5, 0xe19b48a8), new Word64(0x391c0cb3, 0xc5c95a63), new Word64(0x4ed8aa4a, 0xe3418acb), new Word64(0x5b9cca4f, 0x7763e373), new Word64(0x682e6ff3, 0xd6b2b8a3), new Word64(0x748f82ee, 0x5defb2fc), new Word64(0x78a5636f, 0x43172f60), new Word64(0x84c87814, 0xa1f0ab72), new Word64(0x8cc70208, 0x1a6439ec), new Word64(0x90befffa, 0x23631e28), new Word64(0xa4506ceb, 0xde82bde9), new Word64(0xbef9a3f7, 0xb2c67915), new Word64(0xc67178f2, 0xe372532b), new Word64(0xca273ece, 0xea26619c), new Word64(0xd186b8c7, 0x21c0c207), new Word64(0xeada7dd6, 0xcde0eb1e), new Word64(0xf57d4f7f, 0xee6ed178), new Word64(0x06f067aa, 0x72176fba), new Word64(0x0a637dc5, 0xa2c898a6), new Word64(0x113f9804, 0xbef90dae), new Word64(0x1b710b35, 0x131c471b), new Word64(0x28db77f5, 0x23047d84), new Word64(0x32caab7b, 0x40c72493), new Word64(0x3c9ebe0a, 0x15c9bebc), new Word64(0x431d67c4, 0x9c100d4c), new Word64(0x4cc5d4be, 0xcb3e42b6), new Word64(0x597f299c, 0xfc657e2a), new Word64(0x5fcb6fab, 0x3ad6faec), new Word64(0x6c44198c, 0x4a475817)];
  function hash(data, offset, length, mode384 = false) {
    let h0, h1, h2, h3, h4, h5, h6, h7;
    if (!mode384) {
      h0 = new Word64(0x6a09e667, 0xf3bcc908);
      h1 = new Word64(0xbb67ae85, 0x84caa73b);
      h2 = new Word64(0x3c6ef372, 0xfe94f82b);
      h3 = new Word64(0xa54ff53a, 0x5f1d36f1);
      h4 = new Word64(0x510e527f, 0xade682d1);
      h5 = new Word64(0x9b05688c, 0x2b3e6c1f);
      h6 = new Word64(0x1f83d9ab, 0xfb41bd6b);
      h7 = new Word64(0x5be0cd19, 0x137e2179);
    } else {
      h0 = new Word64(0xcbbb9d5d, 0xc1059ed8);
      h1 = new Word64(0x629a292a, 0x367cd507);
      h2 = new Word64(0x9159015a, 0x3070dd17);
      h3 = new Word64(0x152fecd8, 0xf70e5939);
      h4 = new Word64(0x67332667, 0xffc00b31);
      h5 = new Word64(0x8eb44a87, 0x68581511);
      h6 = new Word64(0xdb0c2e0d, 0x64f98fa7);
      h7 = new Word64(0x47b5481d, 0xbefa4fa4);
    }
    const paddedLength = Math.ceil((length + 17) / 128) * 128;
    const padded = new Uint8Array(paddedLength);
    let i, j;
    for (i = 0; i < length; ++i) {
      padded[i] = data[offset++];
    }
    padded[i++] = 0x80;
    const n = paddedLength - 16;
    while (i < n) {
      padded[i++] = 0;
    }
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = length >>> 29 & 0xff;
    padded[i++] = length >> 21 & 0xff;
    padded[i++] = length >> 13 & 0xff;
    padded[i++] = length >> 5 & 0xff;
    padded[i++] = length << 3 & 0xff;
    const w = new Array(80);
    for (i = 0; i < 80; i++) {
      w[i] = new Word64(0, 0);
    }
    let a = new Word64(0, 0),
      b = new Word64(0, 0),
      c = new Word64(0, 0);
    let d = new Word64(0, 0),
      e = new Word64(0, 0),
      f = new Word64(0, 0);
    let g = new Word64(0, 0),
      h = new Word64(0, 0);
    const t1 = new Word64(0, 0),
      t2 = new Word64(0, 0);
    const tmp1 = new Word64(0, 0),
      tmp2 = new Word64(0, 0);
    let tmp3;
    for (i = 0; i < paddedLength;) {
      for (j = 0; j < 16; ++j) {
        w[j].high = padded[i] << 24 | padded[i + 1] << 16 | padded[i + 2] << 8 | padded[i + 3];
        w[j].low = padded[i + 4] << 24 | padded[i + 5] << 16 | padded[i + 6] << 8 | padded[i + 7];
        i += 8;
      }
      for (j = 16; j < 80; ++j) {
        tmp3 = w[j];
        littleSigmaPrime(tmp3, w[j - 2], tmp2);
        tmp3.add(w[j - 7]);
        littleSigma(tmp1, w[j - 15], tmp2);
        tmp3.add(tmp1);
        tmp3.add(w[j - 16]);
      }
      a.assign(h0);
      b.assign(h1);
      c.assign(h2);
      d.assign(h3);
      e.assign(h4);
      f.assign(h5);
      g.assign(h6);
      h.assign(h7);
      for (j = 0; j < 80; ++j) {
        t1.assign(h);
        sigmaPrime(tmp1, e, tmp2);
        t1.add(tmp1);
        ch(tmp1, e, f, g, tmp2);
        t1.add(tmp1);
        t1.add(k[j]);
        t1.add(w[j]);
        sigma(t2, a, tmp2);
        maj(tmp1, a, b, c, tmp2);
        t2.add(tmp1);
        tmp3 = h;
        h = g;
        g = f;
        f = e;
        d.add(t1);
        e = d;
        d = c;
        c = b;
        b = a;
        tmp3.assign(t1);
        tmp3.add(t2);
        a = tmp3;
      }
      h0.add(a);
      h1.add(b);
      h2.add(c);
      h3.add(d);
      h4.add(e);
      h5.add(f);
      h6.add(g);
      h7.add(h);
    }
    let result;
    if (!mode384) {
      result = new Uint8Array(64);
      h0.copyTo(result, 0);
      h1.copyTo(result, 8);
      h2.copyTo(result, 16);
      h3.copyTo(result, 24);
      h4.copyTo(result, 32);
      h5.copyTo(result, 40);
      h6.copyTo(result, 48);
      h7.copyTo(result, 56);
    } else {
      result = new Uint8Array(48);
      h0.copyTo(result, 0);
      h1.copyTo(result, 8);
      h2.copyTo(result, 16);
      h3.copyTo(result, 24);
      h4.copyTo(result, 32);
      h5.copyTo(result, 40);
    }
    return result;
  }
  return hash;
}();
exports.calculateSHA512 = calculateSHA512;
function calculateSHA384(data, offset, length) {
  return calculateSHA512(data, offset, length, true);
}
class NullCipher {
  decryptBlock(data) {
    return data;
  }
  encrypt(data) {
    return data;
  }
}
class AESBaseCipher {
  constructor() {
    if (this.constructor === AESBaseCipher) {
      (0, _util.unreachable)("Cannot initialize AESBaseCipher.");
    }
    this._s = new Uint8Array([0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16]);
    this._inv_s = new Uint8Array([0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d]);
    this._mix = new Uint32Array([0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3]);
    this._mixCol = new Uint8Array(256);
    for (let i = 0; i < 256; i++) {
      this._mixCol[i] = i < 128 ? i << 1 : i << 1 ^ 0x1b;
    }
    this.buffer = new Uint8Array(16);
    this.bufferPosition = 0;
  }
  _expandKey(cipherKey) {
    (0, _util.unreachable)("Cannot call `_expandKey` on the base class");
  }
  _decrypt(input, key) {
    let t, u, v;
    const state = new Uint8Array(16);
    state.set(input);
    for (let j = 0, k = this._keySize; j < 16; ++j, ++k) {
      state[j] ^= key[k];
    }
    for (let i = this._cyclesOfRepetition - 1; i >= 1; --i) {
      t = state[13];
      state[13] = state[9];
      state[9] = state[5];
      state[5] = state[1];
      state[1] = t;
      t = state[14];
      u = state[10];
      state[14] = state[6];
      state[10] = state[2];
      state[6] = t;
      state[2] = u;
      t = state[15];
      u = state[11];
      v = state[7];
      state[15] = state[3];
      state[11] = t;
      state[7] = u;
      state[3] = v;
      for (let j = 0; j < 16; ++j) {
        state[j] = this._inv_s[state[j]];
      }
      for (let j = 0, k = i * 16; j < 16; ++j, ++k) {
        state[j] ^= key[k];
      }
      for (let j = 0; j < 16; j += 4) {
        const s0 = this._mix[state[j]];
        const s1 = this._mix[state[j + 1]];
        const s2 = this._mix[state[j + 2]];
        const s3 = this._mix[state[j + 3]];
        t = s0 ^ s1 >>> 8 ^ s1 << 24 ^ s2 >>> 16 ^ s2 << 16 ^ s3 >>> 24 ^ s3 << 8;
        state[j] = t >>> 24 & 0xff;
        state[j + 1] = t >> 16 & 0xff;
        state[j + 2] = t >> 8 & 0xff;
        state[j + 3] = t & 0xff;
      }
    }
    t = state[13];
    state[13] = state[9];
    state[9] = state[5];
    state[5] = state[1];
    state[1] = t;
    t = state[14];
    u = state[10];
    state[14] = state[6];
    state[10] = state[2];
    state[6] = t;
    state[2] = u;
    t = state[15];
    u = state[11];
    v = state[7];
    state[15] = state[3];
    state[11] = t;
    state[7] = u;
    state[3] = v;
    for (let j = 0; j < 16; ++j) {
      state[j] = this._inv_s[state[j]];
      state[j] ^= key[j];
    }
    return state;
  }
  _encrypt(input, key) {
    const s = this._s;
    let t, u, v;
    const state = new Uint8Array(16);
    state.set(input);
    for (let j = 0; j < 16; ++j) {
      state[j] ^= key[j];
    }
    for (let i = 1; i < this._cyclesOfRepetition; i++) {
      for (let j = 0; j < 16; ++j) {
        state[j] = s[state[j]];
      }
      v = state[1];
      state[1] = state[5];
      state[5] = state[9];
      state[9] = state[13];
      state[13] = v;
      v = state[2];
      u = state[6];
      state[2] = state[10];
      state[6] = state[14];
      state[10] = v;
      state[14] = u;
      v = state[3];
      u = state[7];
      t = state[11];
      state[3] = state[15];
      state[7] = v;
      state[11] = u;
      state[15] = t;
      for (let j = 0; j < 16; j += 4) {
        const s0 = state[j + 0];
        const s1 = state[j + 1];
        const s2 = state[j + 2];
        const s3 = state[j + 3];
        t = s0 ^ s1 ^ s2 ^ s3;
        state[j + 0] ^= t ^ this._mixCol[s0 ^ s1];
        state[j + 1] ^= t ^ this._mixCol[s1 ^ s2];
        state[j + 2] ^= t ^ this._mixCol[s2 ^ s3];
        state[j + 3] ^= t ^ this._mixCol[s3 ^ s0];
      }
      for (let j = 0, k = i * 16; j < 16; ++j, ++k) {
        state[j] ^= key[k];
      }
    }
    for (let j = 0; j < 16; ++j) {
      state[j] = s[state[j]];
    }
    v = state[1];
    state[1] = state[5];
    state[5] = state[9];
    state[9] = state[13];
    state[13] = v;
    v = state[2];
    u = state[6];
    state[2] = state[10];
    state[6] = state[14];
    state[10] = v;
    state[14] = u;
    v = state[3];
    u = state[7];
    t = state[11];
    state[3] = state[15];
    state[7] = v;
    state[11] = u;
    state[15] = t;
    for (let j = 0, k = this._keySize; j < 16; ++j, ++k) {
      state[j] ^= key[k];
    }
    return state;
  }
  _decryptBlock2(data, finalize) {
    const sourceLength = data.length;
    let buffer = this.buffer,
      bufferLength = this.bufferPosition;
    const result = [];
    let iv = this.iv;
    for (let i = 0; i < sourceLength; ++i) {
      buffer[bufferLength] = data[i];
      ++bufferLength;
      if (bufferLength < 16) {
        continue;
      }
      const plain = this._decrypt(buffer, this._key);
      for (let j = 0; j < 16; ++j) {
        plain[j] ^= iv[j];
      }
      iv = buffer;
      result.push(plain);
      buffer = new Uint8Array(16);
      bufferLength = 0;
    }
    this.buffer = buffer;
    this.bufferLength = bufferLength;
    this.iv = iv;
    if (result.length === 0) {
      return new Uint8Array(0);
    }
    let outputLength = 16 * result.length;
    if (finalize) {
      const lastBlock = result.at(-1);
      let psLen = lastBlock[15];
      if (psLen <= 16) {
        for (let i = 15, ii = 16 - psLen; i >= ii; --i) {
          if (lastBlock[i] !== psLen) {
            psLen = 0;
            break;
          }
        }
        outputLength -= psLen;
        result[result.length - 1] = lastBlock.subarray(0, 16 - psLen);
      }
    }
    const output = new Uint8Array(outputLength);
    for (let i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {
      output.set(result[i], j);
    }
    return output;
  }
  decryptBlock(data, finalize, iv = null) {
    const sourceLength = data.length;
    const buffer = this.buffer;
    let bufferLength = this.bufferPosition;
    if (iv) {
      this.iv = iv;
    } else {
      for (let i = 0; bufferLength < 16 && i < sourceLength; ++i, ++bufferLength) {
        buffer[bufferLength] = data[i];
      }
      if (bufferLength < 16) {
        this.bufferLength = bufferLength;
        return new Uint8Array(0);
      }
      this.iv = buffer;
      data = data.subarray(16);
    }
    this.buffer = new Uint8Array(16);
    this.bufferLength = 0;
    this.decryptBlock = this._decryptBlock2;
    return this.decryptBlock(data, finalize);
  }
  encrypt(data, iv) {
    const sourceLength = data.length;
    let buffer = this.buffer,
      bufferLength = this.bufferPosition;
    const result = [];
    if (!iv) {
      iv = new Uint8Array(16);
    }
    for (let i = 0; i < sourceLength; ++i) {
      buffer[bufferLength] = data[i];
      ++bufferLength;
      if (bufferLength < 16) {
        continue;
      }
      for (let j = 0; j < 16; ++j) {
        buffer[j] ^= iv[j];
      }
      const cipher = this._encrypt(buffer, this._key);
      iv = cipher;
      result.push(cipher);
      buffer = new Uint8Array(16);
      bufferLength = 0;
    }
    this.buffer = buffer;
    this.bufferLength = bufferLength;
    this.iv = iv;
    if (result.length === 0) {
      return new Uint8Array(0);
    }
    const outputLength = 16 * result.length;
    const output = new Uint8Array(outputLength);
    for (let i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {
      output.set(result[i], j);
    }
    return output;
  }
}
class AES128Cipher extends AESBaseCipher {
  constructor(key) {
    super();
    this._cyclesOfRepetition = 10;
    this._keySize = 160;
    this._rcon = new Uint8Array([0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d]);
    this._key = this._expandKey(key);
  }
  _expandKey(cipherKey) {
    const b = 176;
    const s = this._s;
    const rcon = this._rcon;
    const result = new Uint8Array(b);
    result.set(cipherKey);
    for (let j = 16, i = 1; j < b; ++i) {
      let t1 = result[j - 3];
      let t2 = result[j - 2];
      let t3 = result[j - 1];
      let t4 = result[j - 4];
      t1 = s[t1];
      t2 = s[t2];
      t3 = s[t3];
      t4 = s[t4];
      t1 ^= rcon[i];
      for (let n = 0; n < 4; ++n) {
        result[j] = t1 ^= result[j - 16];
        j++;
        result[j] = t2 ^= result[j - 16];
        j++;
        result[j] = t3 ^= result[j - 16];
        j++;
        result[j] = t4 ^= result[j - 16];
        j++;
      }
    }
    return result;
  }
}
exports.AES128Cipher = AES128Cipher;
class AES256Cipher extends AESBaseCipher {
  constructor(key) {
    super();
    this._cyclesOfRepetition = 14;
    this._keySize = 224;
    this._key = this._expandKey(key);
  }
  _expandKey(cipherKey) {
    const b = 240;
    const s = this._s;
    const result = new Uint8Array(b);
    result.set(cipherKey);
    let r = 1;
    let t1, t2, t3, t4;
    for (let j = 32, i = 1; j < b; ++i) {
      if (j % 32 === 16) {
        t1 = s[t1];
        t2 = s[t2];
        t3 = s[t3];
        t4 = s[t4];
      } else if (j % 32 === 0) {
        t1 = result[j - 3];
        t2 = result[j - 2];
        t3 = result[j - 1];
        t4 = result[j - 4];
        t1 = s[t1];
        t2 = s[t2];
        t3 = s[t3];
        t4 = s[t4];
        t1 ^= r;
        if ((r <<= 1) >= 256) {
          r = (r ^ 0x1b) & 0xff;
        }
      }
      for (let n = 0; n < 4; ++n) {
        result[j] = t1 ^= result[j - 32];
        j++;
        result[j] = t2 ^= result[j - 32];
        j++;
        result[j] = t3 ^= result[j - 32];
        j++;
        result[j] = t4 ^= result[j - 32];
        j++;
      }
    }
    return result;
  }
}
exports.AES256Cipher = AES256Cipher;
class PDF17 {
  checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
    const hashData = new Uint8Array(password.length + 56);
    hashData.set(password, 0);
    hashData.set(ownerValidationSalt, password.length);
    hashData.set(userBytes, password.length + ownerValidationSalt.length);
    const result = calculateSHA256(hashData, 0, hashData.length);
    return (0, _util.isArrayEqual)(result, ownerPassword);
  }
  checkUserPassword(password, userValidationSalt, userPassword) {
    const hashData = new Uint8Array(password.length + 8);
    hashData.set(password, 0);
    hashData.set(userValidationSalt, password.length);
    const result = calculateSHA256(hashData, 0, hashData.length);
    return (0, _util.isArrayEqual)(result, userPassword);
  }
  getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
    const hashData = new Uint8Array(password.length + 56);
    hashData.set(password, 0);
    hashData.set(ownerKeySalt, password.length);
    hashData.set(userBytes, password.length + ownerKeySalt.length);
    const key = calculateSHA256(hashData, 0, hashData.length);
    const cipher = new AES256Cipher(key);
    return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));
  }
  getUserKey(password, userKeySalt, userEncryption) {
    const hashData = new Uint8Array(password.length + 8);
    hashData.set(password, 0);
    hashData.set(userKeySalt, password.length);
    const key = calculateSHA256(hashData, 0, hashData.length);
    const cipher = new AES256Cipher(key);
    return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));
  }
}
exports.PDF17 = PDF17;
class PDF20 {
  _hash(password, input, userBytes) {
    let k = calculateSHA256(input, 0, input.length).subarray(0, 32);
    let e = [0];
    let i = 0;
    while (i < 64 || e.at(-1) > i - 32) {
      const combinedLength = password.length + k.length + userBytes.length,
        combinedArray = new Uint8Array(combinedLength);
      let writeOffset = 0;
      combinedArray.set(password, writeOffset);
      writeOffset += password.length;
      combinedArray.set(k, writeOffset);
      writeOffset += k.length;
      combinedArray.set(userBytes, writeOffset);
      const k1 = new Uint8Array(combinedLength * 64);
      for (let j = 0, pos = 0; j < 64; j++, pos += combinedLength) {
        k1.set(combinedArray, pos);
      }
      const cipher = new AES128Cipher(k.subarray(0, 16));
      e = cipher.encrypt(k1, k.subarray(16, 32));
      const remainder = e.slice(0, 16).reduce((a, b) => a + b, 0) % 3;
      if (remainder === 0) {
        k = calculateSHA256(e, 0, e.length);
      } else if (remainder === 1) {
        k = calculateSHA384(e, 0, e.length);
      } else if (remainder === 2) {
        k = calculateSHA512(e, 0, e.length);
      }
      i++;
    }
    return k.subarray(0, 32);
  }
  checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
    const hashData = new Uint8Array(password.length + 56);
    hashData.set(password, 0);
    hashData.set(ownerValidationSalt, password.length);
    hashData.set(userBytes, password.length + ownerValidationSalt.length);
    const result = this._hash(password, hashData, userBytes);
    return (0, _util.isArrayEqual)(result, ownerPassword);
  }
  checkUserPassword(password, userValidationSalt, userPassword) {
    const hashData = new Uint8Array(password.length + 8);
    hashData.set(password, 0);
    hashData.set(userValidationSalt, password.length);
    const result = this._hash(password, hashData, []);
    return (0, _util.isArrayEqual)(result, userPassword);
  }
  getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
    const hashData = new Uint8Array(password.length + 56);
    hashData.set(password, 0);
    hashData.set(ownerKeySalt, password.length);
    hashData.set(userBytes, password.length + ownerKeySalt.length);
    const key = this._hash(password, hashData, userBytes);
    const cipher = new AES256Cipher(key);
    return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));
  }
  getUserKey(password, userKeySalt, userEncryption) {
    const hashData = new Uint8Array(password.length + 8);
    hashData.set(password, 0);
    hashData.set(userKeySalt, password.length);
    const key = this._hash(password, hashData, []);
    const cipher = new AES256Cipher(key);
    return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));
  }
}
exports.PDF20 = PDF20;
class CipherTransform {
  constructor(stringCipherConstructor, streamCipherConstructor) {
    this.StringCipherConstructor = stringCipherConstructor;
    this.StreamCipherConstructor = streamCipherConstructor;
  }
  createStream(stream, length) {
    const cipher = new this.StreamCipherConstructor();
    return new _decrypt_stream.DecryptStream(stream, length, function cipherTransformDecryptStream(data, finalize) {
      return cipher.decryptBlock(data, finalize);
    });
  }
  decryptString(s) {
    const cipher = new this.StringCipherConstructor();
    let data = (0, _util.stringToBytes)(s);
    data = cipher.decryptBlock(data, true);
    return (0, _util.bytesToString)(data);
  }
  encryptString(s) {
    const cipher = new this.StringCipherConstructor();
    if (cipher instanceof AESBaseCipher) {
      const strLen = s.length;
      const pad = 16 - strLen % 16;
      s += String.fromCharCode(pad).repeat(pad);
      const iv = new Uint8Array(16);
      if (typeof crypto !== "undefined") {
        crypto.getRandomValues(iv);
      } else {
        for (let i = 0; i < 16; i++) {
          iv[i] = Math.floor(256 * Math.random());
        }
      }
      let data = (0, _util.stringToBytes)(s);
      data = cipher.encrypt(data, iv);
      const buf = new Uint8Array(16 + data.length);
      buf.set(iv);
      buf.set(data, 16);
      return (0, _util.bytesToString)(buf);
    }
    let data = (0, _util.stringToBytes)(s);
    data = cipher.encrypt(data);
    return (0, _util.bytesToString)(data);
  }
}
class CipherTransformFactory {
  static #defaultPasswordBytes = new Uint8Array([0x28, 0xbf, 0x4e, 0x5e, 0x4e, 0x75, 0x8a, 0x41, 0x64, 0x00, 0x4e, 0x56, 0xff, 0xfa, 0x01, 0x08, 0x2e, 0x2e, 0x00, 0xb6, 0xd0, 0x68, 0x3e, 0x80, 0x2f, 0x0c, 0xa9, 0xfe, 0x64, 0x53, 0x69, 0x7a]);
  #createEncryptionKey20(revision, password, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms) {
    if (password) {
      const passwordLength = Math.min(127, password.length);
      password = password.subarray(0, passwordLength);
    } else {
      password = [];
    }
    const pdfAlgorithm = revision === 6 ? new PDF20() : new PDF17();
    if (pdfAlgorithm.checkUserPassword(password, userValidationSalt, userPassword)) {
      return pdfAlgorithm.getUserKey(password, userKeySalt, userEncryption);
    } else if (password.length && pdfAlgorithm.checkOwnerPassword(password, ownerValidationSalt, uBytes, ownerPassword)) {
      return pdfAlgorithm.getOwnerKey(password, ownerKeySalt, uBytes, ownerEncryption);
    }
    return null;
  }
  #prepareKeyData(fileId, password, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata) {
    const hashDataSize = 40 + ownerPassword.length + fileId.length;
    const hashData = new Uint8Array(hashDataSize);
    let i = 0,
      j,
      n;
    if (password) {
      n = Math.min(32, password.length);
      for (; i < n; ++i) {
        hashData[i] = password[i];
      }
    }
    j = 0;
    while (i < 32) {
      hashData[i++] = CipherTransformFactory.#defaultPasswordBytes[j++];
    }
    for (j = 0, n = ownerPassword.length; j < n; ++j) {
      hashData[i++] = ownerPassword[j];
    }
    hashData[i++] = flags & 0xff;
    hashData[i++] = flags >> 8 & 0xff;
    hashData[i++] = flags >> 16 & 0xff;
    hashData[i++] = flags >>> 24 & 0xff;
    for (j = 0, n = fileId.length; j < n; ++j) {
      hashData[i++] = fileId[j];
    }
    if (revision >= 4 && !encryptMetadata) {
      hashData[i++] = 0xff;
      hashData[i++] = 0xff;
      hashData[i++] = 0xff;
      hashData[i++] = 0xff;
    }
    let hash = calculateMD5(hashData, 0, i);
    const keyLengthInBytes = keyLength >> 3;
    if (revision >= 3) {
      for (j = 0; j < 50; ++j) {
        hash = calculateMD5(hash, 0, keyLengthInBytes);
      }
    }
    const encryptionKey = hash.subarray(0, keyLengthInBytes);
    let cipher, checkData;
    if (revision >= 3) {
      for (i = 0; i < 32; ++i) {
        hashData[i] = CipherTransformFactory.#defaultPasswordBytes[i];
      }
      for (j = 0, n = fileId.length; j < n; ++j) {
        hashData[i++] = fileId[j];
      }
      cipher = new ARCFourCipher(encryptionKey);
      checkData = cipher.encryptBlock(calculateMD5(hashData, 0, i));
      n = encryptionKey.length;
      const derivedKey = new Uint8Array(n);
      for (j = 1; j <= 19; ++j) {
        for (let k = 0; k < n; ++k) {
          derivedKey[k] = encryptionKey[k] ^ j;
        }
        cipher = new ARCFourCipher(derivedKey);
        checkData = cipher.encryptBlock(checkData);
      }
      for (j = 0, n = checkData.length; j < n; ++j) {
        if (userPassword[j] !== checkData[j]) {
          return null;
        }
      }
    } else {
      cipher = new ARCFourCipher(encryptionKey);
      checkData = cipher.encryptBlock(CipherTransformFactory.#defaultPasswordBytes);
      for (j = 0, n = checkData.length; j < n; ++j) {
        if (userPassword[j] !== checkData[j]) {
          return null;
        }
      }
    }
    return encryptionKey;
  }
  #decodeUserPassword(password, ownerPassword, revision, keyLength) {
    const hashData = new Uint8Array(32);
    let i = 0;
    const n = Math.min(32, password.length);
    for (; i < n; ++i) {
      hashData[i] = password[i];
    }
    let j = 0;
    while (i < 32) {
      hashData[i++] = CipherTransformFactory.#defaultPasswordBytes[j++];
    }
    let hash = calculateMD5(hashData, 0, i);
    const keyLengthInBytes = keyLength >> 3;
    if (revision >= 3) {
      for (j = 0; j < 50; ++j) {
        hash = calculateMD5(hash, 0, hash.length);
      }
    }
    let cipher, userPassword;
    if (revision >= 3) {
      userPassword = ownerPassword;
      const derivedKey = new Uint8Array(keyLengthInBytes);
      for (j = 19; j >= 0; j--) {
        for (let k = 0; k < keyLengthInBytes; ++k) {
          derivedKey[k] = hash[k] ^ j;
        }
        cipher = new ARCFourCipher(derivedKey);
        userPassword = cipher.encryptBlock(userPassword);
      }
    } else {
      cipher = new ARCFourCipher(hash.subarray(0, keyLengthInBytes));
      userPassword = cipher.encryptBlock(ownerPassword);
    }
    return userPassword;
  }
  #buildObjectKey(num, gen, encryptionKey, isAes = false) {
    const key = new Uint8Array(encryptionKey.length + 9);
    const n = encryptionKey.length;
    let i;
    for (i = 0; i < n; ++i) {
      key[i] = encryptionKey[i];
    }
    key[i++] = num & 0xff;
    key[i++] = num >> 8 & 0xff;
    key[i++] = num >> 16 & 0xff;
    key[i++] = gen & 0xff;
    key[i++] = gen >> 8 & 0xff;
    if (isAes) {
      key[i++] = 0x73;
      key[i++] = 0x41;
      key[i++] = 0x6c;
      key[i++] = 0x54;
    }
    const hash = calculateMD5(key, 0, i);
    return hash.subarray(0, Math.min(encryptionKey.length + 5, 16));
  }
  #buildCipherConstructor(cf, name, num, gen, key) {
    if (!(name instanceof _primitives.Name)) {
      throw new _util.FormatError("Invalid crypt filter name.");
    }
    const self = this;
    const cryptFilter = cf.get(name.name);
    const cfm = cryptFilter?.get("CFM");
    if (!cfm || cfm.name === "None") {
      return function () {
        return new NullCipher();
      };
    }
    if (cfm.name === "V2") {
      return function () {
        return new ARCFourCipher(self.#buildObjectKey(num, gen, key, false));
      };
    }
    if (cfm.name === "AESV2") {
      return function () {
        return new AES128Cipher(self.#buildObjectKey(num, gen, key, true));
      };
    }
    if (cfm.name === "AESV3") {
      return function () {
        return new AES256Cipher(key);
      };
    }
    throw new _util.FormatError("Unknown crypto method");
  }
  constructor(dict, fileId, password) {
    const filter = dict.get("Filter");
    if (!(0, _primitives.isName)(filter, "Standard")) {
      throw new _util.FormatError("unknown encryption method");
    }
    this.filterName = filter.name;
    this.dict = dict;
    const algorithm = dict.get("V");
    if (!Number.isInteger(algorithm) || algorithm !== 1 && algorithm !== 2 && algorithm !== 4 && algorithm !== 5) {
      throw new _util.FormatError("unsupported encryption algorithm");
    }
    this.algorithm = algorithm;
    let keyLength = dict.get("Length");
    if (!keyLength) {
      if (algorithm <= 3) {
        keyLength = 40;
      } else {
        const cfDict = dict.get("CF");
        const streamCryptoName = dict.get("StmF");
        if (cfDict instanceof _primitives.Dict && streamCryptoName instanceof _primitives.Name) {
          cfDict.suppressEncryption = true;
          const handlerDict = cfDict.get(streamCryptoName.name);
          keyLength = handlerDict?.get("Length") || 128;
          if (keyLength < 40) {
            keyLength <<= 3;
          }
        }
      }
    }
    if (!Number.isInteger(keyLength) || keyLength < 40 || keyLength % 8 !== 0) {
      throw new _util.FormatError("invalid key length");
    }
    const ownerBytes = (0, _util.stringToBytes)(dict.get("O")),
      userBytes = (0, _util.stringToBytes)(dict.get("U"));
    const ownerPassword = ownerBytes.subarray(0, 32);
    const userPassword = userBytes.subarray(0, 32);
    const flags = dict.get("P");
    const revision = dict.get("R");
    const encryptMetadata = (algorithm === 4 || algorithm === 5) && dict.get("EncryptMetadata") !== false;
    this.encryptMetadata = encryptMetadata;
    const fileIdBytes = (0, _util.stringToBytes)(fileId);
    let passwordBytes;
    if (password) {
      if (revision === 6) {
        try {
          password = (0, _util.utf8StringToString)(password);
        } catch {
          (0, _util.warn)("CipherTransformFactory: Unable to convert UTF8 encoded password.");
        }
      }
      passwordBytes = (0, _util.stringToBytes)(password);
    }
    let encryptionKey;
    if (algorithm !== 5) {
      encryptionKey = this.#prepareKeyData(fileIdBytes, passwordBytes, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);
    } else {
      const ownerValidationSalt = ownerBytes.subarray(32, 40);
      const ownerKeySalt = ownerBytes.subarray(40, 48);
      const uBytes = userBytes.subarray(0, 48);
      const userValidationSalt = userBytes.subarray(32, 40);
      const userKeySalt = userBytes.subarray(40, 48);
      const ownerEncryption = (0, _util.stringToBytes)(dict.get("OE"));
      const userEncryption = (0, _util.stringToBytes)(dict.get("UE"));
      const perms = (0, _util.stringToBytes)(dict.get("Perms"));
      encryptionKey = this.#createEncryptionKey20(revision, passwordBytes, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms);
    }
    if (!encryptionKey && !password) {
      throw new _util.PasswordException("No password given", _util.PasswordResponses.NEED_PASSWORD);
    } else if (!encryptionKey && password) {
      const decodedPassword = this.#decodeUserPassword(passwordBytes, ownerPassword, revision, keyLength);
      encryptionKey = this.#prepareKeyData(fileIdBytes, decodedPassword, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);
    }
    if (!encryptionKey) {
      throw new _util.PasswordException("Incorrect Password", _util.PasswordResponses.INCORRECT_PASSWORD);
    }
    this.encryptionKey = encryptionKey;
    if (algorithm >= 4) {
      const cf = dict.get("CF");
      if (cf instanceof _primitives.Dict) {
        cf.suppressEncryption = true;
      }
      this.cf = cf;
      this.stmf = dict.get("StmF") || _primitives.Name.get("Identity");
      this.strf = dict.get("StrF") || _primitives.Name.get("Identity");
      this.eff = dict.get("EFF") || this.stmf;
    }
  }
  createCipherTransform(num, gen) {
    if (this.algorithm === 4 || this.algorithm === 5) {
      return new CipherTransform(this.#buildCipherConstructor(this.cf, this.strf, num, gen, this.encryptionKey), this.#buildCipherConstructor(this.cf, this.stmf, num, gen, this.encryptionKey));
    }
    const key = this.#buildObjectKey(num, gen, this.encryptionKey, false);
    const cipherConstructor = function () {
      return new ARCFourCipher(key);
    };
    return new CipherTransform(cipherConstructor, cipherConstructor);
  }
}
exports.CipherTransformFactory = CipherTransformFactory;

/***/ }),
/* 75 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DecryptStream = void 0;
var _decode_stream = __w_pdfjs_require__(18);
const chunkSize = 512;
class DecryptStream extends _decode_stream.DecodeStream {
  constructor(str, maybeLength, decrypt) {
    super(maybeLength);
    this.str = str;
    this.dict = str.dict;
    this.decrypt = decrypt;
    this.nextChunk = null;
    this.initialized = false;
  }
  readBlock() {
    let chunk;
    if (this.initialized) {
      chunk = this.nextChunk;
    } else {
      chunk = this.str.getBytes(chunkSize);
      this.initialized = true;
    }
    if (!chunk || chunk.length === 0) {
      this.eof = true;
      return;
    }
    this.nextChunk = this.str.getBytes(chunkSize);
    const hasMoreData = this.nextChunk?.length > 0;
    const decrypt = this.decrypt;
    chunk = decrypt(chunk, !hasMoreData);
    const bufferLength = this.bufferLength,
      newLength = bufferLength + chunk.length,
      buffer = this.ensureBuffer(newLength);
    buffer.set(chunk, bufferLength);
    this.bufferLength = newLength;
  }
}
exports.DecryptStream = DecryptStream;

/***/ }),
/* 76 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ObjectLoader = void 0;
var _primitives = __w_pdfjs_require__(4);
var _base_stream = __w_pdfjs_require__(5);
var _core_utils = __w_pdfjs_require__(3);
var _util = __w_pdfjs_require__(2);
function mayHaveChildren(value) {
  return value instanceof _primitives.Ref || value instanceof _primitives.Dict || value instanceof _base_stream.BaseStream || Array.isArray(value);
}
function addChildren(node, nodesToVisit) {
  if (node instanceof _primitives.Dict) {
    node = node.getRawValues();
  } else if (node instanceof _base_stream.BaseStream) {
    node = node.dict.getRawValues();
  } else if (!Array.isArray(node)) {
    return;
  }
  for (const rawValue of node) {
    if (mayHaveChildren(rawValue)) {
      nodesToVisit.push(rawValue);
    }
  }
}
class ObjectLoader {
  constructor(dict, keys, xref) {
    this.dict = dict;
    this.keys = keys;
    this.xref = xref;
    this.refSet = null;
  }
  async load() {
    if (this.xref.stream.isDataLoaded) {
      return undefined;
    }
    const {
      keys,
      dict
    } = this;
    this.refSet = new _primitives.RefSet();
    const nodesToVisit = [];
    for (const key of keys) {
      const rawValue = dict.getRaw(key);
      if (rawValue !== undefined) {
        nodesToVisit.push(rawValue);
      }
    }
    return this._walk(nodesToVisit);
  }
  async _walk(nodesToVisit) {
    const nodesToRevisit = [];
    const pendingRequests = [];
    while (nodesToVisit.length) {
      let currentNode = nodesToVisit.pop();
      if (currentNode instanceof _primitives.Ref) {
        if (this.refSet.has(currentNode)) {
          continue;
        }
        try {
          this.refSet.put(currentNode);
          currentNode = this.xref.fetch(currentNode);
        } catch (ex) {
          if (!(ex instanceof _core_utils.MissingDataException)) {
            (0, _util.warn)(`ObjectLoader._walk - requesting all data: "${ex}".`);
            this.refSet = null;
            const {
              manager
            } = this.xref.stream;
            return manager.requestAllChunks();
          }
          nodesToRevisit.push(currentNode);
          pendingRequests.push({
            begin: ex.begin,
            end: ex.end
          });
        }
      }
      if (currentNode instanceof _base_stream.BaseStream) {
        const baseStreams = currentNode.getBaseStreams();
        if (baseStreams) {
          let foundMissingData = false;
          for (const stream of baseStreams) {
            if (stream.isDataLoaded) {
              continue;
            }
            foundMissingData = true;
            pendingRequests.push({
              begin: stream.start,
              end: stream.end
            });
          }
          if (foundMissingData) {
            nodesToRevisit.push(currentNode);
          }
        }
      }
      addChildren(currentNode, nodesToVisit);
    }
    if (pendingRequests.length) {
      await this.xref.stream.manager.requestRanges(pendingRequests);
      for (const node of nodesToRevisit) {
        if (node instanceof _primitives.Ref) {
          this.refSet.remove(node);
        }
      }
      return this._walk(nodesToRevisit);
    }
    this.refSet = null;
    return undefined;
  }
}
exports.ObjectLoader = ObjectLoader;

/***/ }),
/* 77 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XFAFactory = void 0;
var _symbol_utils = __w_pdfjs_require__(78);
var _bind = __w_pdfjs_require__(79);
var _data = __w_pdfjs_require__(89);
var _fonts = __w_pdfjs_require__(85);
var _utils = __w_pdfjs_require__(84);
var _util = __w_pdfjs_require__(2);
var _parser = __w_pdfjs_require__(90);
var _xhtml = __w_pdfjs_require__(100);
class XFAFactory {
  constructor(data) {
    try {
      this.root = new _parser.XFAParser().parse(XFAFactory._createDocument(data));
      const binder = new _bind.Binder(this.root);
      this.form = binder.bind();
      this.dataHandler = new _data.DataHandler(this.root, binder.getData());
      this.form[_symbol_utils.$globalData].template = this.form;
    } catch (e) {
      (0, _util.warn)(`XFA - an error occurred during parsing and binding: ${e}`);
    }
  }
  isValid() {
    return this.root && this.form;
  }
  _createPagesHelper() {
    const iterator = this.form[_symbol_utils.$toPages]();
    return new Promise((resolve, reject) => {
      const nextIteration = () => {
        try {
          const value = iterator.next();
          if (value.done) {
            resolve(value.value);
          } else {
            setTimeout(nextIteration, 0);
          }
        } catch (e) {
          reject(e);
        }
      };
      setTimeout(nextIteration, 0);
    });
  }
  async _createPages() {
    try {
      this.pages = await this._createPagesHelper();
      this.dims = this.pages.children.map(c => {
        const {
          width,
          height
        } = c.attributes.style;
        return [0, 0, parseInt(width), parseInt(height)];
      });
    } catch (e) {
      (0, _util.warn)(`XFA - an error occurred during layout: ${e}`);
    }
  }
  getBoundingBox(pageIndex) {
    return this.dims[pageIndex];
  }
  async getNumPages() {
    if (!this.pages) {
      await this._createPages();
    }
    return this.dims.length;
  }
  setImages(images) {
    this.form[_symbol_utils.$globalData].images = images;
  }
  setFonts(fonts) {
    this.form[_symbol_utils.$globalData].fontFinder = new _fonts.FontFinder(fonts);
    const missingFonts = [];
    for (let typeface of this.form[_symbol_utils.$globalData].usedTypefaces) {
      typeface = (0, _utils.stripQuotes)(typeface);
      const font = this.form[_symbol_utils.$globalData].fontFinder.find(typeface);
      if (!font) {
        missingFonts.push(typeface);
      }
    }
    if (missingFonts.length > 0) {
      return missingFonts;
    }
    return null;
  }
  appendFonts(fonts, reallyMissingFonts) {
    this.form[_symbol_utils.$globalData].fontFinder.add(fonts, reallyMissingFonts);
  }
  async getPages() {
    if (!this.pages) {
      await this._createPages();
    }
    const pages = this.pages;
    this.pages = null;
    return pages;
  }
  serializeData(storage) {
    return this.dataHandler.serialize(storage);
  }
  static _createDocument(data) {
    if (!data["/xdp:xdp"]) {
      return data["xdp:xdp"];
    }
    return Object.values(data).join("");
  }
  static getRichTextAsHtml(rc) {
    if (!rc || typeof rc !== "string") {
      return null;
    }
    try {
      let root = new _parser.XFAParser(_xhtml.XhtmlNamespace, true).parse(rc);
      if (!["body", "xhtml"].includes(root[_symbol_utils.$nodeName])) {
        const newRoot = _xhtml.XhtmlNamespace.body({});
        newRoot[_symbol_utils.$appendChild](root);
        root = newRoot;
      }
      const result = root[_symbol_utils.$toHTML]();
      if (!result.success) {
        return null;
      }
      const {
        html
      } = result;
      const {
        attributes
      } = html;
      if (attributes) {
        if (attributes.class) {
          attributes.class = attributes.class.filter(attr => !attr.startsWith("xfa"));
        }
        attributes.dir = "auto";
      }
      return {
        html,
        str: root[_symbol_utils.$text]()
      };
    } catch (e) {
      (0, _util.warn)(`XFA - an error occurred during parsing of rich text: ${e}`);
    }
    return null;
  }
}
exports.XFAFactory = XFAFactory;

/***/ }),
/* 78 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.$uid = exports.$toStyle = exports.$toString = exports.$toPages = exports.$toHTML = exports.$text = exports.$tabIndex = exports.$setValue = exports.$setSetAttributes = exports.$setId = exports.$searchNode = exports.$root = exports.$resolvePrototypes = exports.$removeChild = exports.$pushPara = exports.$pushGlyphs = exports.$popPara = exports.$onText = exports.$onChildCheck = exports.$onChild = exports.$nsAttributes = exports.$nodeName = exports.$namespaceId = exports.$lastAttribute = exports.$isUsable = exports.$isTransparent = exports.$isThereMoreWidth = exports.$isSplittable = exports.$isNsAgnostic = exports.$isDescendent = exports.$isDataValue = exports.$isCDATAXml = exports.$isBindable = exports.$insertAt = exports.$indexOf = exports.$ids = exports.$hasSettableValue = exports.$globalData = exports.$getTemplateRoot = exports.$getSubformParent = exports.$getRealChildrenByNameIt = exports.$getParent = exports.$getNextPage = exports.$getExtra = exports.$getDataValue = exports.$getContainedChildren = exports.$getChildrenByNameIt = exports.$getChildrenByName = exports.$getChildrenByClass = exports.$getChildren = exports.$getAvailableSpace = exports.$getAttributes = exports.$getAttributeIt = exports.$flushHTML = exports.$finalize = exports.$extra = exports.$dump = exports.$data = exports.$content = exports.$consumed = exports.$clone = exports.$cleanup = exports.$cleanPage = exports.$clean = exports.$childrenToHTML = exports.$appendChild = exports.$addHTML = exports.$acceptWhitespace = void 0;
const $acceptWhitespace = Symbol();
exports.$acceptWhitespace = $acceptWhitespace;
const $addHTML = Symbol();
exports.$addHTML = $addHTML;
const $appendChild = Symbol();
exports.$appendChild = $appendChild;
const $childrenToHTML = Symbol();
exports.$childrenToHTML = $childrenToHTML;
const $clean = Symbol();
exports.$clean = $clean;
const $cleanPage = Symbol();
exports.$cleanPage = $cleanPage;
const $cleanup = Symbol();
exports.$cleanup = $cleanup;
const $clone = Symbol();
exports.$clone = $clone;
const $consumed = Symbol();
exports.$consumed = $consumed;
const $content = Symbol("content");
exports.$content = $content;
const $data = Symbol("data");
exports.$data = $data;
const $dump = Symbol();
exports.$dump = $dump;
const $extra = Symbol("extra");
exports.$extra = $extra;
const $finalize = Symbol();
exports.$finalize = $finalize;
const $flushHTML = Symbol();
exports.$flushHTML = $flushHTML;
const $getAttributeIt = Symbol();
exports.$getAttributeIt = $getAttributeIt;
const $getAttributes = Symbol();
exports.$getAttributes = $getAttributes;
const $getAvailableSpace = Symbol();
exports.$getAvailableSpace = $getAvailableSpace;
const $getChildrenByClass = Symbol();
exports.$getChildrenByClass = $getChildrenByClass;
const $getChildrenByName = Symbol();
exports.$getChildrenByName = $getChildrenByName;
const $getChildrenByNameIt = Symbol();
exports.$getChildrenByNameIt = $getChildrenByNameIt;
const $getDataValue = Symbol();
exports.$getDataValue = $getDataValue;
const $getExtra = Symbol();
exports.$getExtra = $getExtra;
const $getRealChildrenByNameIt = Symbol();
exports.$getRealChildrenByNameIt = $getRealChildrenByNameIt;
const $getChildren = Symbol();
exports.$getChildren = $getChildren;
const $getContainedChildren = Symbol();
exports.$getContainedChildren = $getContainedChildren;
const $getNextPage = Symbol();
exports.$getNextPage = $getNextPage;
const $getSubformParent = Symbol();
exports.$getSubformParent = $getSubformParent;
const $getParent = Symbol();
exports.$getParent = $getParent;
const $getTemplateRoot = Symbol();
exports.$getTemplateRoot = $getTemplateRoot;
const $globalData = Symbol();
exports.$globalData = $globalData;
const $hasSettableValue = Symbol();
exports.$hasSettableValue = $hasSettableValue;
const $ids = Symbol();
exports.$ids = $ids;
const $indexOf = Symbol();
exports.$indexOf = $indexOf;
const $insertAt = Symbol();
exports.$insertAt = $insertAt;
const $isCDATAXml = Symbol();
exports.$isCDATAXml = $isCDATAXml;
const $isBindable = Symbol();
exports.$isBindable = $isBindable;
const $isDataValue = Symbol();
exports.$isDataValue = $isDataValue;
const $isDescendent = Symbol();
exports.$isDescendent = $isDescendent;
const $isNsAgnostic = Symbol();
exports.$isNsAgnostic = $isNsAgnostic;
const $isSplittable = Symbol();
exports.$isSplittable = $isSplittable;
const $isThereMoreWidth = Symbol();
exports.$isThereMoreWidth = $isThereMoreWidth;
const $isTransparent = Symbol();
exports.$isTransparent = $isTransparent;
const $isUsable = Symbol();
exports.$isUsable = $isUsable;
const $lastAttribute = Symbol();
exports.$lastAttribute = $lastAttribute;
const $namespaceId = Symbol("namespaceId");
exports.$namespaceId = $namespaceId;
const $nodeName = Symbol("nodeName");
exports.$nodeName = $nodeName;
const $nsAttributes = Symbol();
exports.$nsAttributes = $nsAttributes;
const $onChild = Symbol();
exports.$onChild = $onChild;
const $onChildCheck = Symbol();
exports.$onChildCheck = $onChildCheck;
const $onText = Symbol();
exports.$onText = $onText;
const $pushGlyphs = Symbol();
exports.$pushGlyphs = $pushGlyphs;
const $popPara = Symbol();
exports.$popPara = $popPara;
const $pushPara = Symbol();
exports.$pushPara = $pushPara;
const $removeChild = Symbol();
exports.$removeChild = $removeChild;
const $root = Symbol("root");
exports.$root = $root;
const $resolvePrototypes = Symbol();
exports.$resolvePrototypes = $resolvePrototypes;
const $searchNode = Symbol();
exports.$searchNode = $searchNode;
const $setId = Symbol();
exports.$setId = $setId;
const $setSetAttributes = Symbol();
exports.$setSetAttributes = $setSetAttributes;
const $setValue = Symbol();
exports.$setValue = $setValue;
const $tabIndex = Symbol();
exports.$tabIndex = $tabIndex;
const $text = Symbol();
exports.$text = $text;
const $toPages = Symbol();
exports.$toPages = $toPages;
const $toHTML = Symbol();
exports.$toHTML = $toHTML;
const $toString = Symbol();
exports.$toString = $toString;
const $toStyle = Symbol();
exports.$toStyle = $toStyle;
const $uid = Symbol("uid");
exports.$uid = $uid;

/***/ }),
/* 79 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Binder = void 0;
var _symbol_utils = __w_pdfjs_require__(78);
var _template = __w_pdfjs_require__(80);
var _som = __w_pdfjs_require__(88);
var _xfa_object = __w_pdfjs_require__(87);
var _namespaces = __w_pdfjs_require__(81);
var _util = __w_pdfjs_require__(2);
const NS_DATASETS = _namespaces.NamespaceIds.datasets.id;
function createText(content) {
  const node = new _template.Text({});
  node[_symbol_utils.$content] = content;
  return node;
}
class Binder {
  constructor(root) {
    this.root = root;
    this.datasets = root.datasets;
    this.data = root.datasets?.data || new _xfa_object.XmlObject(_namespaces.NamespaceIds.datasets.id, "data");
    this.emptyMerge = this.data[_symbol_utils.$getChildren]().length === 0;
    this.root.form = this.form = root.template[_symbol_utils.$clone]();
  }
  _isConsumeData() {
    return !this.emptyMerge && this._mergeMode;
  }
  _isMatchTemplate() {
    return !this._isConsumeData();
  }
  bind() {
    this._bindElement(this.form, this.data);
    return this.form;
  }
  getData() {
    return this.data;
  }
  _bindValue(formNode, data, picture) {
    formNode[_symbol_utils.$data] = data;
    if (formNode[_symbol_utils.$hasSettableValue]()) {
      if (data[_symbol_utils.$isDataValue]()) {
        const value = data[_symbol_utils.$getDataValue]();
        formNode[_symbol_utils.$setValue](createText(value));
      } else if (formNode instanceof _template.Field && formNode.ui?.choiceList?.open === "multiSelect") {
        const value = data[_symbol_utils.$getChildren]().map(child => child[_symbol_utils.$content].trim()).join("\n");
        formNode[_symbol_utils.$setValue](createText(value));
      } else if (this._isConsumeData()) {
        (0, _util.warn)(`XFA - Nodes haven't the same type.`);
      }
    } else if (!data[_symbol_utils.$isDataValue]() || this._isMatchTemplate()) {
      this._bindElement(formNode, data);
    } else {
      (0, _util.warn)(`XFA - Nodes haven't the same type.`);
    }
  }
  _findDataByNameToConsume(name, isValue, dataNode, global) {
    if (!name) {
      return null;
    }
    let generator, match;
    for (let i = 0; i < 3; i++) {
      generator = dataNode[_symbol_utils.$getRealChildrenByNameIt](name, false, true);
      while (true) {
        match = generator.next().value;
        if (!match) {
          break;
        }
        if (isValue === match[_symbol_utils.$isDataValue]()) {
          return match;
        }
      }
      if (dataNode[_symbol_utils.$namespaceId] === _namespaces.NamespaceIds.datasets.id && dataNode[_symbol_utils.$nodeName] === "data") {
        break;
      }
      dataNode = dataNode[_symbol_utils.$getParent]();
    }
    if (!global) {
      return null;
    }
    generator = this.data[_symbol_utils.$getRealChildrenByNameIt](name, true, false);
    match = generator.next().value;
    if (match) {
      return match;
    }
    generator = this.data[_symbol_utils.$getAttributeIt](name, true);
    match = generator.next().value;
    if (match?.[_symbol_utils.$isDataValue]()) {
      return match;
    }
    return null;
  }
  _setProperties(formNode, dataNode) {
    if (!formNode.hasOwnProperty("setProperty")) {
      return;
    }
    for (const {
      ref,
      target,
      connection
    } of formNode.setProperty.children) {
      if (connection) {
        continue;
      }
      if (!ref) {
        continue;
      }
      const nodes = (0, _som.searchNode)(this.root, dataNode, ref, false, false);
      if (!nodes) {
        (0, _util.warn)(`XFA - Invalid reference: ${ref}.`);
        continue;
      }
      const [node] = nodes;
      if (!node[_symbol_utils.$isDescendent](this.data)) {
        (0, _util.warn)(`XFA - Invalid node: must be a data node.`);
        continue;
      }
      const targetNodes = (0, _som.searchNode)(this.root, formNode, target, false, false);
      if (!targetNodes) {
        (0, _util.warn)(`XFA - Invalid target: ${target}.`);
        continue;
      }
      const [targetNode] = targetNodes;
      if (!targetNode[_symbol_utils.$isDescendent](formNode)) {
        (0, _util.warn)(`XFA - Invalid target: must be a property or subproperty.`);
        continue;
      }
      const targetParent = targetNode[_symbol_utils.$getParent]();
      if (targetNode instanceof _template.SetProperty || targetParent instanceof _template.SetProperty) {
        (0, _util.warn)(`XFA - Invalid target: cannot be a setProperty or one of its properties.`);
        continue;
      }
      if (targetNode instanceof _template.BindItems || targetParent instanceof _template.BindItems) {
        (0, _util.warn)(`XFA - Invalid target: cannot be a bindItems or one of its properties.`);
        continue;
      }
      const content = node[_symbol_utils.$text]();
      const name = targetNode[_symbol_utils.$nodeName];
      if (targetNode instanceof _xfa_object.XFAAttribute) {
        const attrs = Object.create(null);
        attrs[name] = content;
        const obj = Reflect.construct(Object.getPrototypeOf(targetParent).constructor, [attrs]);
        targetParent[name] = obj[name];
        continue;
      }
      if (!targetNode.hasOwnProperty(_symbol_utils.$content)) {
        (0, _util.warn)(`XFA - Invalid node to use in setProperty`);
        continue;
      }
      targetNode[_symbol_utils.$data] = node;
      targetNode[_symbol_utils.$content] = content;
      targetNode[_symbol_utils.$finalize]();
    }
  }
  _bindItems(formNode, dataNode) {
    if (!formNode.hasOwnProperty("items") || !formNode.hasOwnProperty("bindItems") || formNode.bindItems.isEmpty()) {
      return;
    }
    for (const item of formNode.items.children) {
      formNode[_symbol_utils.$removeChild](item);
    }
    formNode.items.clear();
    const labels = new _template.Items({});
    const values = new _template.Items({});
    formNode[_symbol_utils.$appendChild](labels);
    formNode.items.push(labels);
    formNode[_symbol_utils.$appendChild](values);
    formNode.items.push(values);
    for (const {
      ref,
      labelRef,
      valueRef,
      connection
    } of formNode.bindItems.children) {
      if (connection) {
        continue;
      }
      if (!ref) {
        continue;
      }
      const nodes = (0, _som.searchNode)(this.root, dataNode, ref, false, false);
      if (!nodes) {
        (0, _util.warn)(`XFA - Invalid reference: ${ref}.`);
        continue;
      }
      for (const node of nodes) {
        if (!node[_symbol_utils.$isDescendent](this.datasets)) {
          (0, _util.warn)(`XFA - Invalid ref (${ref}): must be a datasets child.`);
          continue;
        }
        const labelNodes = (0, _som.searchNode)(this.root, node, labelRef, true, false);
        if (!labelNodes) {
          (0, _util.warn)(`XFA - Invalid label: ${labelRef}.`);
          continue;
        }
        const [labelNode] = labelNodes;
        if (!labelNode[_symbol_utils.$isDescendent](this.datasets)) {
          (0, _util.warn)(`XFA - Invalid label: must be a datasets child.`);
          continue;
        }
        const valueNodes = (0, _som.searchNode)(this.root, node, valueRef, true, false);
        if (!valueNodes) {
          (0, _util.warn)(`XFA - Invalid value: ${valueRef}.`);
          continue;
        }
        const [valueNode] = valueNodes;
        if (!valueNode[_symbol_utils.$isDescendent](this.datasets)) {
          (0, _util.warn)(`XFA - Invalid value: must be a datasets child.`);
          continue;
        }
        const label = createText(labelNode[_symbol_utils.$text]());
        const value = createText(valueNode[_symbol_utils.$text]());
        labels[_symbol_utils.$appendChild](label);
        labels.text.push(label);
        values[_symbol_utils.$appendChild](value);
        values.text.push(value);
      }
    }
  }
  _bindOccurrences(formNode, matches, picture) {
    let baseClone;
    if (matches.length > 1) {
      baseClone = formNode[_symbol_utils.$clone]();
      baseClone[_symbol_utils.$removeChild](baseClone.occur);
      baseClone.occur = null;
    }
    this._bindValue(formNode, matches[0], picture);
    this._setProperties(formNode, matches[0]);
    this._bindItems(formNode, matches[0]);
    if (matches.length === 1) {
      return;
    }
    const parent = formNode[_symbol_utils.$getParent]();
    const name = formNode[_symbol_utils.$nodeName];
    const pos = parent[_symbol_utils.$indexOf](formNode);
    for (let i = 1, ii = matches.length; i < ii; i++) {
      const match = matches[i];
      const clone = baseClone[_symbol_utils.$clone]();
      parent[name].push(clone);
      parent[_symbol_utils.$insertAt](pos + i, clone);
      this._bindValue(clone, match, picture);
      this._setProperties(clone, match);
      this._bindItems(clone, match);
    }
  }
  _createOccurrences(formNode) {
    if (!this.emptyMerge) {
      return;
    }
    const {
      occur
    } = formNode;
    if (!occur || occur.initial <= 1) {
      return;
    }
    const parent = formNode[_symbol_utils.$getParent]();
    const name = formNode[_symbol_utils.$nodeName];
    if (!(parent[name] instanceof _xfa_object.XFAObjectArray)) {
      return;
    }
    let currentNumber;
    if (formNode.name) {
      currentNumber = parent[name].children.filter(e => e.name === formNode.name).length;
    } else {
      currentNumber = parent[name].children.length;
    }
    const pos = parent[_symbol_utils.$indexOf](formNode) + 1;
    const ii = occur.initial - currentNumber;
    if (ii) {
      const nodeClone = formNode[_symbol_utils.$clone]();
      nodeClone[_symbol_utils.$removeChild](nodeClone.occur);
      nodeClone.occur = null;
      parent[name].push(nodeClone);
      parent[_symbol_utils.$insertAt](pos, nodeClone);
      for (let i = 1; i < ii; i++) {
        const clone = nodeClone[_symbol_utils.$clone]();
        parent[name].push(clone);
        parent[_symbol_utils.$insertAt](pos + i, clone);
      }
    }
  }
  _getOccurInfo(formNode) {
    const {
      name,
      occur
    } = formNode;
    if (!occur || !name) {
      return [1, 1];
    }
    const max = occur.max === -1 ? Infinity : occur.max;
    return [occur.min, max];
  }
  _setAndBind(formNode, dataNode) {
    this._setProperties(formNode, dataNode);
    this._bindItems(formNode, dataNode);
    this._bindElement(formNode, dataNode);
  }
  _bindElement(formNode, dataNode) {
    const uselessNodes = [];
    this._createOccurrences(formNode);
    for (const child of formNode[_symbol_utils.$getChildren]()) {
      if (child[_symbol_utils.$data]) {
        continue;
      }
      if (this._mergeMode === undefined && child[_symbol_utils.$nodeName] === "subform") {
        this._mergeMode = child.mergeMode === "consumeData";
        const dataChildren = dataNode[_symbol_utils.$getChildren]();
        if (dataChildren.length > 0) {
          this._bindOccurrences(child, [dataChildren[0]], null);
        } else if (this.emptyMerge) {
          const nsId = dataNode[_symbol_utils.$namespaceId] === NS_DATASETS ? -1 : dataNode[_symbol_utils.$namespaceId];
          const dataChild = child[_symbol_utils.$data] = new _xfa_object.XmlObject(nsId, child.name || "root");
          dataNode[_symbol_utils.$appendChild](dataChild);
          this._bindElement(child, dataChild);
        }
        continue;
      }
      if (!child[_symbol_utils.$isBindable]()) {
        continue;
      }
      let global = false;
      let picture = null;
      let ref = null;
      let match = null;
      if (child.bind) {
        switch (child.bind.match) {
          case "none":
            this._setAndBind(child, dataNode);
            continue;
          case "global":
            global = true;
            break;
          case "dataRef":
            if (!child.bind.ref) {
              (0, _util.warn)(`XFA - ref is empty in node ${child[_symbol_utils.$nodeName]}.`);
              this._setAndBind(child, dataNode);
              continue;
            }
            ref = child.bind.ref;
            break;
          default:
            break;
        }
        if (child.bind.picture) {
          picture = child.bind.picture[_symbol_utils.$content];
        }
      }
      const [min, max] = this._getOccurInfo(child);
      if (ref) {
        match = (0, _som.searchNode)(this.root, dataNode, ref, true, false);
        if (match === null) {
          match = (0, _som.createDataNode)(this.data, dataNode, ref);
          if (!match) {
            continue;
          }
          if (this._isConsumeData()) {
            match[_symbol_utils.$consumed] = true;
          }
          this._setAndBind(child, match);
          continue;
        } else {
          if (this._isConsumeData()) {
            match = match.filter(node => !node[_symbol_utils.$consumed]);
          }
          if (match.length > max) {
            match = match.slice(0, max);
          } else if (match.length === 0) {
            match = null;
          }
          if (match && this._isConsumeData()) {
            match.forEach(node => {
              node[_symbol_utils.$consumed] = true;
            });
          }
        }
      } else {
        if (!child.name) {
          this._setAndBind(child, dataNode);
          continue;
        }
        if (this._isConsumeData()) {
          const matches = [];
          while (matches.length < max) {
            const found = this._findDataByNameToConsume(child.name, child[_symbol_utils.$hasSettableValue](), dataNode, global);
            if (!found) {
              break;
            }
            found[_symbol_utils.$consumed] = true;
            matches.push(found);
          }
          match = matches.length > 0 ? matches : null;
        } else {
          match = dataNode[_symbol_utils.$getRealChildrenByNameIt](child.name, false, this.emptyMerge).next().value;
          if (!match) {
            if (min === 0) {
              uselessNodes.push(child);
              continue;
            }
            const nsId = dataNode[_symbol_utils.$namespaceId] === NS_DATASETS ? -1 : dataNode[_symbol_utils.$namespaceId];
            match = child[_symbol_utils.$data] = new _xfa_object.XmlObject(nsId, child.name);
            if (this.emptyMerge) {
              match[_symbol_utils.$consumed] = true;
            }
            dataNode[_symbol_utils.$appendChild](match);
            this._setAndBind(child, match);
            continue;
          }
          if (this.emptyMerge) {
            match[_symbol_utils.$consumed] = true;
          }
          match = [match];
        }
      }
      if (match) {
        this._bindOccurrences(child, match, picture);
      } else if (min > 0) {
        this._setAndBind(child, dataNode);
      } else {
        uselessNodes.push(child);
      }
    }
    uselessNodes.forEach(node => node[_symbol_utils.$getParent]()[_symbol_utils.$removeChild](node));
  }
}
exports.Binder = Binder;

/***/ }),
/* 80 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Value = exports.Text = exports.TemplateNamespace = exports.Template = exports.SetProperty = exports.Items = exports.Field = exports.BindItems = void 0;
var _symbol_utils = __w_pdfjs_require__(78);
var _namespaces = __w_pdfjs_require__(81);
var _layout = __w_pdfjs_require__(82);
var _html_utils = __w_pdfjs_require__(83);
var _xfa_object = __w_pdfjs_require__(87);
var _utils = __w_pdfjs_require__(84);
var _util = __w_pdfjs_require__(2);
var _fonts = __w_pdfjs_require__(85);
var _core_utils = __w_pdfjs_require__(3);
var _som = __w_pdfjs_require__(88);
const TEMPLATE_NS_ID = _namespaces.NamespaceIds.template.id;
const SVG_NS = "http://www.w3.org/2000/svg";
const MAX_ATTEMPTS_FOR_LRTB_LAYOUT = 2;
const MAX_EMPTY_PAGES = 3;
const DEFAULT_TAB_INDEX = 5000;
const HEADING_PATTERN = /^H(\d+)$/;
const MIMES = new Set(["image/gif", "image/jpeg", "image/jpg", "image/pjpeg", "image/png", "image/apng", "image/x-png", "image/bmp", "image/x-ms-bmp", "image/tiff", "image/tif", "application/octet-stream"]);
const IMAGES_HEADERS = [[[0x42, 0x4d], "image/bmp"], [[0xff, 0xd8, 0xff], "image/jpeg"], [[0x49, 0x49, 0x2a, 0x00], "image/tiff"], [[0x4d, 0x4d, 0x00, 0x2a], "image/tiff"], [[0x47, 0x49, 0x46, 0x38, 0x39, 0x61], "image/gif"], [[0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a], "image/png"]];
function getBorderDims(node) {
  if (!node || !node.border) {
    return {
      w: 0,
      h: 0
    };
  }
  const borderExtra = node.border[_symbol_utils.$getExtra]();
  if (!borderExtra) {
    return {
      w: 0,
      h: 0
    };
  }
  return {
    w: borderExtra.widths[0] + borderExtra.widths[2] + borderExtra.insets[0] + borderExtra.insets[2],
    h: borderExtra.widths[1] + borderExtra.widths[3] + borderExtra.insets[1] + borderExtra.insets[3]
  };
}
function hasMargin(node) {
  return node.margin && (node.margin.topInset || node.margin.rightInset || node.margin.bottomInset || node.margin.leftInset);
}
function _setValue(templateNode, value) {
  if (!templateNode.value) {
    const nodeValue = new Value({});
    templateNode[_symbol_utils.$appendChild](nodeValue);
    templateNode.value = nodeValue;
  }
  templateNode.value[_symbol_utils.$setValue](value);
}
function* getContainedChildren(node) {
  for (const child of node[_symbol_utils.$getChildren]()) {
    if (child instanceof SubformSet) {
      yield* child[_symbol_utils.$getContainedChildren]();
      continue;
    }
    yield child;
  }
}
function isRequired(node) {
  return node.validate?.nullTest === "error";
}
function setTabIndex(node) {
  while (node) {
    if (!node.traversal) {
      node[_symbol_utils.$tabIndex] = node[_symbol_utils.$getParent]()[_symbol_utils.$tabIndex];
      return;
    }
    if (node[_symbol_utils.$tabIndex]) {
      return;
    }
    let next = null;
    for (const child of node.traversal[_symbol_utils.$getChildren]()) {
      if (child.operation === "next") {
        next = child;
        break;
      }
    }
    if (!next || !next.ref) {
      node[_symbol_utils.$tabIndex] = node[_symbol_utils.$getParent]()[_symbol_utils.$tabIndex];
      return;
    }
    const root = node[_symbol_utils.$getTemplateRoot]();
    node[_symbol_utils.$tabIndex] = ++root[_symbol_utils.$tabIndex];
    const ref = root[_symbol_utils.$searchNode](next.ref, node);
    if (!ref) {
      return;
    }
    node = ref[0];
  }
}
function applyAssist(obj, attributes) {
  const assist = obj.assist;
  if (assist) {
    const assistTitle = assist[_symbol_utils.$toHTML]();
    if (assistTitle) {
      attributes.title = assistTitle;
    }
    const role = assist.role;
    const match = role.match(HEADING_PATTERN);
    if (match) {
      const ariaRole = "heading";
      const ariaLevel = match[1];
      attributes.role = ariaRole;
      attributes["aria-level"] = ariaLevel;
    }
  }
  if (obj.layout === "table") {
    attributes.role = "table";
  } else if (obj.layout === "row") {
    attributes.role = "row";
  } else {
    const parent = obj[_symbol_utils.$getParent]();
    if (parent.layout === "row") {
      attributes.role = parent.assist?.role === "TH" ? "columnheader" : "cell";
    }
  }
}
function ariaLabel(obj) {
  if (!obj.assist) {
    return null;
  }
  const assist = obj.assist;
  if (assist.speak && assist.speak[_symbol_utils.$content] !== "") {
    return assist.speak[_symbol_utils.$content];
  }
  if (assist.toolTip) {
    return assist.toolTip[_symbol_utils.$content];
  }
  return null;
}
function valueToHtml(value) {
  return _utils.HTMLResult.success({
    name: "div",
    attributes: {
      class: ["xfaRich"],
      style: Object.create(null)
    },
    children: [{
      name: "span",
      attributes: {
        style: Object.create(null)
      },
      value
    }]
  });
}
function setFirstUnsplittable(node) {
  const root = node[_symbol_utils.$getTemplateRoot]();
  if (root[_symbol_utils.$extra].firstUnsplittable === null) {
    root[_symbol_utils.$extra].firstUnsplittable = node;
    root[_symbol_utils.$extra].noLayoutFailure = true;
  }
}
function unsetFirstUnsplittable(node) {
  const root = node[_symbol_utils.$getTemplateRoot]();
  if (root[_symbol_utils.$extra].firstUnsplittable === node) {
    root[_symbol_utils.$extra].noLayoutFailure = false;
  }
}
function handleBreak(node) {
  if (node[_symbol_utils.$extra]) {
    return false;
  }
  node[_symbol_utils.$extra] = Object.create(null);
  if (node.targetType === "auto") {
    return false;
  }
  const root = node[_symbol_utils.$getTemplateRoot]();
  let target = null;
  if (node.target) {
    target = root[_symbol_utils.$searchNode](node.target, node[_symbol_utils.$getParent]());
    if (!target) {
      return false;
    }
    target = target[0];
  }
  const {
    currentPageArea,
    currentContentArea
  } = root[_symbol_utils.$extra];
  if (node.targetType === "pageArea") {
    if (!(target instanceof PageArea)) {
      target = null;
    }
    if (node.startNew) {
      node[_symbol_utils.$extra].target = target || currentPageArea;
      return true;
    } else if (target && target !== currentPageArea) {
      node[_symbol_utils.$extra].target = target;
      return true;
    }
    return false;
  }
  if (!(target instanceof ContentArea)) {
    target = null;
  }
  const pageArea = target && target[_symbol_utils.$getParent]();
  let index;
  let nextPageArea = pageArea;
  if (node.startNew) {
    if (target) {
      const contentAreas = pageArea.contentArea.children;
      const indexForCurrent = contentAreas.indexOf(currentContentArea);
      const indexForTarget = contentAreas.indexOf(target);
      if (indexForCurrent !== -1 && indexForCurrent < indexForTarget) {
        nextPageArea = null;
      }
      index = indexForTarget - 1;
    } else {
      index = currentPageArea.contentArea.children.indexOf(currentContentArea);
    }
  } else if (target && target !== currentContentArea) {
    const contentAreas = pageArea.contentArea.children;
    index = contentAreas.indexOf(target) - 1;
    nextPageArea = pageArea === currentPageArea ? null : pageArea;
  } else {
    return false;
  }
  node[_symbol_utils.$extra].target = nextPageArea;
  node[_symbol_utils.$extra].index = index;
  return true;
}
function handleOverflow(node, extraNode, space) {
  const root = node[_symbol_utils.$getTemplateRoot]();
  const saved = root[_symbol_utils.$extra].noLayoutFailure;
  const savedMethod = extraNode[_symbol_utils.$getSubformParent];
  extraNode[_symbol_utils.$getSubformParent] = () => node;
  root[_symbol_utils.$extra].noLayoutFailure = true;
  const res = extraNode[_symbol_utils.$toHTML](space);
  node[_symbol_utils.$addHTML](res.html, res.bbox);
  root[_symbol_utils.$extra].noLayoutFailure = saved;
  extraNode[_symbol_utils.$getSubformParent] = savedMethod;
}
class AppearanceFilter extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "appearanceFilter");
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Arc extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "arc", true);
    this.circular = (0, _utils.getInteger)({
      data: attributes.circular,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.hand = (0, _utils.getStringOption)(attributes.hand, ["even", "left", "right"]);
    this.id = attributes.id || "";
    this.startAngle = (0, _utils.getFloat)({
      data: attributes.startAngle,
      defaultValue: 0,
      validate: x => true
    });
    this.sweepAngle = (0, _utils.getFloat)({
      data: attributes.sweepAngle,
      defaultValue: 360,
      validate: x => true
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.edge = null;
    this.fill = null;
  }
  [_symbol_utils.$toHTML]() {
    const edge = this.edge || new Edge({});
    const edgeStyle = edge[_symbol_utils.$toStyle]();
    const style = Object.create(null);
    if (this.fill?.presence === "visible") {
      Object.assign(style, this.fill[_symbol_utils.$toStyle]());
    } else {
      style.fill = "transparent";
    }
    style.strokeWidth = (0, _html_utils.measureToString)(edge.presence === "visible" ? edge.thickness : 0);
    style.stroke = edgeStyle.color;
    let arc;
    const attributes = {
      xmlns: SVG_NS,
      style: {
        width: "100%",
        height: "100%",
        overflow: "visible"
      }
    };
    if (this.sweepAngle === 360) {
      arc = {
        name: "ellipse",
        attributes: {
          xmlns: SVG_NS,
          cx: "50%",
          cy: "50%",
          rx: "50%",
          ry: "50%",
          style
        }
      };
    } else {
      const startAngle = this.startAngle * Math.PI / 180;
      const sweepAngle = this.sweepAngle * Math.PI / 180;
      const largeArc = this.sweepAngle > 180 ? 1 : 0;
      const [x1, y1, x2, y2] = [50 * (1 + Math.cos(startAngle)), 50 * (1 - Math.sin(startAngle)), 50 * (1 + Math.cos(startAngle + sweepAngle)), 50 * (1 - Math.sin(startAngle + sweepAngle))];
      arc = {
        name: "path",
        attributes: {
          xmlns: SVG_NS,
          d: `M ${x1} ${y1} A 50 50 0 ${largeArc} 0 ${x2} ${y2}`,
          vectorEffect: "non-scaling-stroke",
          style
        }
      };
      Object.assign(attributes, {
        viewBox: "0 0 100 100",
        preserveAspectRatio: "none"
      });
    }
    const svg = {
      name: "svg",
      children: [arc],
      attributes
    };
    const parent = this[_symbol_utils.$getParent]()[_symbol_utils.$getParent]();
    if (hasMargin(parent)) {
      return _utils.HTMLResult.success({
        name: "div",
        attributes: {
          style: {
            display: "inline",
            width: "100%",
            height: "100%"
          }
        },
        children: [svg]
      });
    }
    svg.attributes.style.position = "absolute";
    return _utils.HTMLResult.success(svg);
  }
}
class Area extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "area", true);
    this.colSpan = (0, _utils.getInteger)({
      data: attributes.colSpan,
      defaultValue: 1,
      validate: n => n >= 1 || n === -1
    });
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
    this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
    this.desc = null;
    this.extras = null;
    this.area = new _xfa_object.XFAObjectArray();
    this.draw = new _xfa_object.XFAObjectArray();
    this.exObject = new _xfa_object.XFAObjectArray();
    this.exclGroup = new _xfa_object.XFAObjectArray();
    this.field = new _xfa_object.XFAObjectArray();
    this.subform = new _xfa_object.XFAObjectArray();
    this.subformSet = new _xfa_object.XFAObjectArray();
  }
  *[_symbol_utils.$getContainedChildren]() {
    yield* getContainedChildren(this);
  }
  [_symbol_utils.$isTransparent]() {
    return true;
  }
  [_symbol_utils.$isBindable]() {
    return true;
  }
  [_symbol_utils.$addHTML](html, bbox) {
    const [x, y, w, h] = bbox;
    this[_symbol_utils.$extra].width = Math.max(this[_symbol_utils.$extra].width, x + w);
    this[_symbol_utils.$extra].height = Math.max(this[_symbol_utils.$extra].height, y + h);
    this[_symbol_utils.$extra].children.push(html);
  }
  [_symbol_utils.$getAvailableSpace]() {
    return this[_symbol_utils.$extra].availableSpace;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    const style = (0, _html_utils.toStyle)(this, "position");
    const attributes = {
      style,
      id: this[_symbol_utils.$uid],
      class: ["xfaArea"]
    };
    if ((0, _html_utils.isPrintOnly)(this)) {
      attributes.class.push("xfaPrintOnly");
    }
    if (this.name) {
      attributes.xfaName = this.name;
    }
    const children = [];
    this[_symbol_utils.$extra] = {
      children,
      width: 0,
      height: 0,
      availableSpace
    };
    const result = this[_symbol_utils.$childrenToHTML]({
      filter: new Set(["area", "draw", "field", "exclGroup", "subform", "subformSet"]),
      include: true
    });
    if (!result.success) {
      if (result.isBreak()) {
        return result;
      }
      delete this[_symbol_utils.$extra];
      return _utils.HTMLResult.FAILURE;
    }
    style.width = (0, _html_utils.measureToString)(this[_symbol_utils.$extra].width);
    style.height = (0, _html_utils.measureToString)(this[_symbol_utils.$extra].height);
    const html = {
      name: "div",
      attributes,
      children
    };
    const bbox = [this.x, this.y, this[_symbol_utils.$extra].width, this[_symbol_utils.$extra].height];
    delete this[_symbol_utils.$extra];
    return _utils.HTMLResult.success(html, bbox);
  }
}
class Assist extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "assist", true);
    this.id = attributes.id || "";
    this.role = attributes.role || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.speak = null;
    this.toolTip = null;
  }
  [_symbol_utils.$toHTML]() {
    return this.toolTip?.[_symbol_utils.$content] || null;
  }
}
class Barcode extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "barcode", true);
    this.charEncoding = (0, _utils.getKeyword)({
      data: attributes.charEncoding ? attributes.charEncoding.toLowerCase() : "",
      defaultValue: "",
      validate: k => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(k) || k.match(/iso-8859-\d{2}/)
    });
    this.checksum = (0, _utils.getStringOption)(attributes.checksum, ["none", "1mod10", "1mod10_1mod11", "2mod10", "auto"]);
    this.dataColumnCount = (0, _utils.getInteger)({
      data: attributes.dataColumnCount,
      defaultValue: -1,
      validate: x => x >= 0
    });
    this.dataLength = (0, _utils.getInteger)({
      data: attributes.dataLength,
      defaultValue: -1,
      validate: x => x >= 0
    });
    this.dataPrep = (0, _utils.getStringOption)(attributes.dataPrep, ["none", "flateCompress"]);
    this.dataRowCount = (0, _utils.getInteger)({
      data: attributes.dataRowCount,
      defaultValue: -1,
      validate: x => x >= 0
    });
    this.endChar = attributes.endChar || "";
    this.errorCorrectionLevel = (0, _utils.getInteger)({
      data: attributes.errorCorrectionLevel,
      defaultValue: -1,
      validate: x => x >= 0 && x <= 8
    });
    this.id = attributes.id || "";
    this.moduleHeight = (0, _utils.getMeasurement)(attributes.moduleHeight, "5mm");
    this.moduleWidth = (0, _utils.getMeasurement)(attributes.moduleWidth, "0.25mm");
    this.printCheckDigit = (0, _utils.getInteger)({
      data: attributes.printCheckDigit,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.rowColumnRatio = (0, _utils.getRatio)(attributes.rowColumnRatio);
    this.startChar = attributes.startChar || "";
    this.textLocation = (0, _utils.getStringOption)(attributes.textLocation, ["below", "above", "aboveEmbedded", "belowEmbedded", "none"]);
    this.truncate = (0, _utils.getInteger)({
      data: attributes.truncate,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.type = (0, _utils.getStringOption)(attributes.type ? attributes.type.toLowerCase() : "", ["aztec", "codabar", "code2of5industrial", "code2of5interleaved", "code2of5matrix", "code2of5standard", "code3of9", "code3of9extended", "code11", "code49", "code93", "code128", "code128a", "code128b", "code128c", "code128sscc", "datamatrix", "ean8", "ean8add2", "ean8add5", "ean13", "ean13add2", "ean13add5", "ean13pwcd", "fim", "logmars", "maxicode", "msi", "pdf417", "pdf417macro", "plessey", "postauscust2", "postauscust3", "postausreplypaid", "postausstandard", "postukrm4scc", "postusdpbc", "postusimb", "postusstandard", "postus5zip", "qrcode", "rfid", "rss14", "rss14expanded", "rss14limited", "rss14stacked", "rss14stackedomni", "rss14truncated", "telepen", "ucc128", "ucc128random", "ucc128sscc", "upca", "upcaadd2", "upcaadd5", "upcapwcd", "upce", "upceadd2", "upceadd5", "upcean2", "upcean5", "upsmaxicode"]);
    this.upsMode = (0, _utils.getStringOption)(attributes.upsMode, ["usCarrier", "internationalCarrier", "secureSymbol", "standardSymbol"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.wideNarrowRatio = (0, _utils.getRatio)(attributes.wideNarrowRatio);
    this.encrypt = null;
    this.extras = null;
  }
}
class Bind extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "bind", true);
    this.match = (0, _utils.getStringOption)(attributes.match, ["once", "dataRef", "global", "none"]);
    this.ref = attributes.ref || "";
    this.picture = null;
  }
}
class BindItems extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "bindItems");
    this.connection = attributes.connection || "";
    this.labelRef = attributes.labelRef || "";
    this.ref = attributes.ref || "";
    this.valueRef = attributes.valueRef || "";
  }
}
exports.BindItems = BindItems;
class Bookend extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "bookend");
    this.id = attributes.id || "";
    this.leader = attributes.leader || "";
    this.trailer = attributes.trailer || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class BooleanElement extends _xfa_object.Option01 {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "boolean");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [_symbol_utils.$toHTML](availableSpace) {
    return valueToHtml(this[_symbol_utils.$content] === 1 ? "1" : "0");
  }
}
class Border extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "border", true);
    this.break = (0, _utils.getStringOption)(attributes.break, ["close", "open"]);
    this.hand = (0, _utils.getStringOption)(attributes.hand, ["even", "left", "right"]);
    this.id = attributes.id || "";
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.corner = new _xfa_object.XFAObjectArray(4);
    this.edge = new _xfa_object.XFAObjectArray(4);
    this.extras = null;
    this.fill = null;
    this.margin = null;
  }
  [_symbol_utils.$getExtra]() {
    if (!this[_symbol_utils.$extra]) {
      const edges = this.edge.children.slice();
      if (edges.length < 4) {
        const defaultEdge = edges.at(-1) || new Edge({});
        for (let i = edges.length; i < 4; i++) {
          edges.push(defaultEdge);
        }
      }
      const widths = edges.map(edge => edge.thickness);
      const insets = [0, 0, 0, 0];
      if (this.margin) {
        insets[0] = this.margin.topInset;
        insets[1] = this.margin.rightInset;
        insets[2] = this.margin.bottomInset;
        insets[3] = this.margin.leftInset;
      }
      this[_symbol_utils.$extra] = {
        widths,
        insets,
        edges
      };
    }
    return this[_symbol_utils.$extra];
  }
  [_symbol_utils.$toStyle]() {
    const {
      edges
    } = this[_symbol_utils.$getExtra]();
    const edgeStyles = edges.map(node => {
      const style = node[_symbol_utils.$toStyle]();
      style.color ||= "#000000";
      return style;
    });
    const style = Object.create(null);
    if (this.margin) {
      Object.assign(style, this.margin[_symbol_utils.$toStyle]());
    }
    if (this.fill?.presence === "visible") {
      Object.assign(style, this.fill[_symbol_utils.$toStyle]());
    }
    if (this.corner.children.some(node => node.radius !== 0)) {
      const cornerStyles = this.corner.children.map(node => node[_symbol_utils.$toStyle]());
      if (cornerStyles.length === 2 || cornerStyles.length === 3) {
        const last = cornerStyles.at(-1);
        for (let i = cornerStyles.length; i < 4; i++) {
          cornerStyles.push(last);
        }
      }
      style.borderRadius = cornerStyles.map(s => s.radius).join(" ");
    }
    switch (this.presence) {
      case "invisible":
      case "hidden":
        style.borderStyle = "";
        break;
      case "inactive":
        style.borderStyle = "none";
        break;
      default:
        style.borderStyle = edgeStyles.map(s => s.style).join(" ");
        break;
    }
    style.borderWidth = edgeStyles.map(s => s.width).join(" ");
    style.borderColor = edgeStyles.map(s => s.color).join(" ");
    return style;
  }
}
class Break extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "break", true);
    this.after = (0, _utils.getStringOption)(attributes.after, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]);
    this.afterTarget = attributes.afterTarget || "";
    this.before = (0, _utils.getStringOption)(attributes.before, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]);
    this.beforeTarget = attributes.beforeTarget || "";
    this.bookendLeader = attributes.bookendLeader || "";
    this.bookendTrailer = attributes.bookendTrailer || "";
    this.id = attributes.id || "";
    this.overflowLeader = attributes.overflowLeader || "";
    this.overflowTarget = attributes.overflowTarget || "";
    this.overflowTrailer = attributes.overflowTrailer || "";
    this.startNew = (0, _utils.getInteger)({
      data: attributes.startNew,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
  }
}
class BreakAfter extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "breakAfter", true);
    this.id = attributes.id || "";
    this.leader = attributes.leader || "";
    this.startNew = (0, _utils.getInteger)({
      data: attributes.startNew,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.target = attributes.target || "";
    this.targetType = (0, _utils.getStringOption)(attributes.targetType, ["auto", "contentArea", "pageArea"]);
    this.trailer = attributes.trailer || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.script = null;
  }
}
class BreakBefore extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "breakBefore", true);
    this.id = attributes.id || "";
    this.leader = attributes.leader || "";
    this.startNew = (0, _utils.getInteger)({
      data: attributes.startNew,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.target = attributes.target || "";
    this.targetType = (0, _utils.getStringOption)(attributes.targetType, ["auto", "contentArea", "pageArea"]);
    this.trailer = attributes.trailer || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.script = null;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    this[_symbol_utils.$extra] = {};
    return _utils.HTMLResult.FAILURE;
  }
}
class Button extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "button", true);
    this.highlight = (0, _utils.getStringOption)(attributes.highlight, ["inverted", "none", "outline", "push"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    const parent = this[_symbol_utils.$getParent]();
    const grandpa = parent[_symbol_utils.$getParent]();
    const htmlButton = {
      name: "button",
      attributes: {
        id: this[_symbol_utils.$uid],
        class: ["xfaButton"],
        style: {}
      },
      children: []
    };
    for (const event of grandpa.event.children) {
      if (event.activity !== "click" || !event.script) {
        continue;
      }
      const jsURL = (0, _core_utils.recoverJsURL)(event.script[_symbol_utils.$content]);
      if (!jsURL) {
        continue;
      }
      const href = (0, _html_utils.fixURL)(jsURL.url);
      if (!href) {
        continue;
      }
      htmlButton.children.push({
        name: "a",
        attributes: {
          id: "link" + this[_symbol_utils.$uid],
          href,
          newWindow: jsURL.newWindow,
          class: ["xfaLink"],
          style: {}
        },
        children: []
      });
    }
    return _utils.HTMLResult.success(htmlButton);
  }
}
class Calculate extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "calculate", true);
    this.id = attributes.id || "";
    this.override = (0, _utils.getStringOption)(attributes.override, ["disabled", "error", "ignore", "warning"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.message = null;
    this.script = null;
  }
}
class Caption extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "caption", true);
    this.id = attributes.id || "";
    this.placement = (0, _utils.getStringOption)(attributes.placement, ["left", "bottom", "inline", "right", "top"]);
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.reserve = Math.ceil((0, _utils.getMeasurement)(attributes.reserve));
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.font = null;
    this.margin = null;
    this.para = null;
    this.value = null;
  }
  [_symbol_utils.$setValue](value) {
    _setValue(this, value);
  }
  [_symbol_utils.$getExtra](availableSpace) {
    if (!this[_symbol_utils.$extra]) {
      let {
        width,
        height
      } = availableSpace;
      switch (this.placement) {
        case "left":
        case "right":
        case "inline":
          width = this.reserve <= 0 ? width : this.reserve;
          break;
        case "top":
        case "bottom":
          height = this.reserve <= 0 ? height : this.reserve;
          break;
      }
      this[_symbol_utils.$extra] = (0, _html_utils.layoutNode)(this, {
        width,
        height
      });
    }
    return this[_symbol_utils.$extra];
  }
  [_symbol_utils.$toHTML](availableSpace) {
    if (!this.value) {
      return _utils.HTMLResult.EMPTY;
    }
    this[_symbol_utils.$pushPara]();
    const value = this.value[_symbol_utils.$toHTML](availableSpace).html;
    if (!value) {
      this[_symbol_utils.$popPara]();
      return _utils.HTMLResult.EMPTY;
    }
    const savedReserve = this.reserve;
    if (this.reserve <= 0) {
      const {
        w,
        h
      } = this[_symbol_utils.$getExtra](availableSpace);
      switch (this.placement) {
        case "left":
        case "right":
        case "inline":
          this.reserve = w;
          break;
        case "top":
        case "bottom":
          this.reserve = h;
          break;
      }
    }
    const children = [];
    if (typeof value === "string") {
      children.push({
        name: "#text",
        value
      });
    } else {
      children.push(value);
    }
    const style = (0, _html_utils.toStyle)(this, "font", "margin", "visibility");
    switch (this.placement) {
      case "left":
      case "right":
        if (this.reserve > 0) {
          style.width = (0, _html_utils.measureToString)(this.reserve);
        }
        break;
      case "top":
      case "bottom":
        if (this.reserve > 0) {
          style.height = (0, _html_utils.measureToString)(this.reserve);
        }
        break;
    }
    (0, _html_utils.setPara)(this, null, value);
    this[_symbol_utils.$popPara]();
    this.reserve = savedReserve;
    return _utils.HTMLResult.success({
      name: "div",
      attributes: {
        style,
        class: ["xfaCaption"]
      },
      children
    });
  }
}
class Certificate extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "certificate");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Certificates extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "certificates", true);
    this.credentialServerPolicy = (0, _utils.getStringOption)(attributes.credentialServerPolicy, ["optional", "required"]);
    this.id = attributes.id || "";
    this.url = attributes.url || "";
    this.urlPolicy = attributes.urlPolicy || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.encryption = null;
    this.issuers = null;
    this.keyUsage = null;
    this.oids = null;
    this.signing = null;
    this.subjectDNs = null;
  }
}
class CheckButton extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "checkButton", true);
    this.id = attributes.id || "";
    this.mark = (0, _utils.getStringOption)(attributes.mark, ["default", "check", "circle", "cross", "diamond", "square", "star"]);
    this.shape = (0, _utils.getStringOption)(attributes.shape, ["square", "round"]);
    this.size = (0, _utils.getMeasurement)(attributes.size, "10pt");
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.border = null;
    this.extras = null;
    this.margin = null;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    const style = (0, _html_utils.toStyle)("margin");
    const size = (0, _html_utils.measureToString)(this.size);
    style.width = style.height = size;
    let type;
    let className;
    let groupId;
    const field = this[_symbol_utils.$getParent]()[_symbol_utils.$getParent]();
    const items = field.items.children.length && field.items.children[0][_symbol_utils.$toHTML]().html || [];
    const exportedValue = {
      on: (items[0] !== undefined ? items[0] : "on").toString(),
      off: (items[1] !== undefined ? items[1] : "off").toString()
    };
    const value = field.value?.[_symbol_utils.$text]() || "off";
    const checked = value === exportedValue.on || undefined;
    const container = field[_symbol_utils.$getSubformParent]();
    const fieldId = field[_symbol_utils.$uid];
    let dataId;
    if (container instanceof ExclGroup) {
      groupId = container[_symbol_utils.$uid];
      type = "radio";
      className = "xfaRadio";
      dataId = container[_symbol_utils.$data]?.[_symbol_utils.$uid] || container[_symbol_utils.$uid];
    } else {
      type = "checkbox";
      className = "xfaCheckbox";
      dataId = field[_symbol_utils.$data]?.[_symbol_utils.$uid] || field[_symbol_utils.$uid];
    }
    const input = {
      name: "input",
      attributes: {
        class: [className],
        style,
        fieldId,
        dataId,
        type,
        checked,
        xfaOn: exportedValue.on,
        xfaOff: exportedValue.off,
        "aria-label": ariaLabel(field),
        "aria-required": false
      }
    };
    if (groupId) {
      input.attributes.name = groupId;
    }
    if (isRequired(field)) {
      input.attributes["aria-required"] = true;
      input.attributes.required = true;
    }
    return _utils.HTMLResult.success({
      name: "label",
      attributes: {
        class: ["xfaLabel"]
      },
      children: [input]
    });
  }
}
class ChoiceList extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "choiceList", true);
    this.commitOn = (0, _utils.getStringOption)(attributes.commitOn, ["select", "exit"]);
    this.id = attributes.id || "";
    this.open = (0, _utils.getStringOption)(attributes.open, ["userControl", "always", "multiSelect", "onEntry"]);
    this.textEntry = (0, _utils.getInteger)({
      data: attributes.textEntry,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.border = null;
    this.extras = null;
    this.margin = null;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    const style = (0, _html_utils.toStyle)(this, "border", "margin");
    const ui = this[_symbol_utils.$getParent]();
    const field = ui[_symbol_utils.$getParent]();
    const fontSize = field.font?.size || 10;
    const optionStyle = {
      fontSize: `calc(${fontSize}px * var(--scale-factor))`
    };
    const children = [];
    if (field.items.children.length > 0) {
      const items = field.items;
      let displayedIndex = 0;
      let saveIndex = 0;
      if (items.children.length === 2) {
        displayedIndex = items.children[0].save;
        saveIndex = 1 - displayedIndex;
      }
      const displayed = items.children[displayedIndex][_symbol_utils.$toHTML]().html;
      const values = items.children[saveIndex][_symbol_utils.$toHTML]().html;
      let selected = false;
      const value = field.value?.[_symbol_utils.$text]() || "";
      for (let i = 0, ii = displayed.length; i < ii; i++) {
        const option = {
          name: "option",
          attributes: {
            value: values[i] || displayed[i],
            style: optionStyle
          },
          value: displayed[i]
        };
        if (values[i] === value) {
          option.attributes.selected = selected = true;
        }
        children.push(option);
      }
      if (!selected) {
        children.splice(0, 0, {
          name: "option",
          attributes: {
            hidden: true,
            selected: true
          },
          value: " "
        });
      }
    }
    const selectAttributes = {
      class: ["xfaSelect"],
      fieldId: field[_symbol_utils.$uid],
      dataId: field[_symbol_utils.$data]?.[_symbol_utils.$uid] || field[_symbol_utils.$uid],
      style,
      "aria-label": ariaLabel(field),
      "aria-required": false
    };
    if (isRequired(field)) {
      selectAttributes["aria-required"] = true;
      selectAttributes.required = true;
    }
    if (this.open === "multiSelect") {
      selectAttributes.multiple = true;
    }
    return _utils.HTMLResult.success({
      name: "label",
      attributes: {
        class: ["xfaLabel"]
      },
      children: [{
        name: "select",
        children,
        attributes: selectAttributes
      }]
    });
  }
}
class Color extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "color", true);
    this.cSpace = (0, _utils.getStringOption)(attributes.cSpace, ["SRGB"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.value = attributes.value ? (0, _utils.getColor)(attributes.value) : "";
    this.extras = null;
  }
  [_symbol_utils.$hasSettableValue]() {
    return false;
  }
  [_symbol_utils.$toStyle]() {
    return this.value ? _util.Util.makeHexColor(this.value.r, this.value.g, this.value.b) : null;
  }
}
class Comb extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "comb");
    this.id = attributes.id || "";
    this.numberOfCells = (0, _utils.getInteger)({
      data: attributes.numberOfCells,
      defaultValue: 0,
      validate: x => x >= 0
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Connect extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "connect", true);
    this.connection = attributes.connection || "";
    this.id = attributes.id || "";
    this.ref = attributes.ref || "";
    this.usage = (0, _utils.getStringOption)(attributes.usage, ["exportAndImport", "exportOnly", "importOnly"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.picture = null;
  }
}
class ContentArea extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "contentArea", true);
    this.h = (0, _utils.getMeasurement)(attributes.h);
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.w = (0, _utils.getMeasurement)(attributes.w);
    this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
    this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
    this.desc = null;
    this.extras = null;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    const left = (0, _html_utils.measureToString)(this.x);
    const top = (0, _html_utils.measureToString)(this.y);
    const style = {
      left,
      top,
      width: (0, _html_utils.measureToString)(this.w),
      height: (0, _html_utils.measureToString)(this.h)
    };
    const classNames = ["xfaContentarea"];
    if ((0, _html_utils.isPrintOnly)(this)) {
      classNames.push("xfaPrintOnly");
    }
    return _utils.HTMLResult.success({
      name: "div",
      children: [],
      attributes: {
        style,
        class: classNames,
        id: this[_symbol_utils.$uid]
      }
    });
  }
}
class Corner extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "corner", true);
    this.id = attributes.id || "";
    this.inverted = (0, _utils.getInteger)({
      data: attributes.inverted,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.join = (0, _utils.getStringOption)(attributes.join, ["square", "round"]);
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.radius = (0, _utils.getMeasurement)(attributes.radius);
    this.stroke = (0, _utils.getStringOption)(attributes.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]);
    this.thickness = (0, _utils.getMeasurement)(attributes.thickness, "0.5pt");
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [_symbol_utils.$toStyle]() {
    const style = (0, _html_utils.toStyle)(this, "visibility");
    style.radius = (0, _html_utils.measureToString)(this.join === "square" ? 0 : this.radius);
    return style;
  }
}
class DateElement extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "date");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [_symbol_utils.$finalize]() {
    const date = this[_symbol_utils.$content].trim();
    this[_symbol_utils.$content] = date ? new Date(date) : null;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    return valueToHtml(this[_symbol_utils.$content] ? this[_symbol_utils.$content].toString() : "");
  }
}
class DateTime extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "dateTime");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [_symbol_utils.$finalize]() {
    const date = this[_symbol_utils.$content].trim();
    this[_symbol_utils.$content] = date ? new Date(date) : null;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    return valueToHtml(this[_symbol_utils.$content] ? this[_symbol_utils.$content].toString() : "");
  }
}
class DateTimeEdit extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "dateTimeEdit", true);
    this.hScrollPolicy = (0, _utils.getStringOption)(attributes.hScrollPolicy, ["auto", "off", "on"]);
    this.id = attributes.id || "";
    this.picker = (0, _utils.getStringOption)(attributes.picker, ["host", "none"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.border = null;
    this.comb = null;
    this.extras = null;
    this.margin = null;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    const style = (0, _html_utils.toStyle)(this, "border", "font", "margin");
    const field = this[_symbol_utils.$getParent]()[_symbol_utils.$getParent]();
    const html = {
      name: "input",
      attributes: {
        type: "text",
        fieldId: field[_symbol_utils.$uid],
        dataId: field[_symbol_utils.$data]?.[_symbol_utils.$uid] || field[_symbol_utils.$uid],
        class: ["xfaTextfield"],
        style,
        "aria-label": ariaLabel(field),
        "aria-required": false
      }
    };
    if (isRequired(field)) {
      html.attributes["aria-required"] = true;
      html.attributes.required = true;
    }
    return _utils.HTMLResult.success({
      name: "label",
      attributes: {
        class: ["xfaLabel"]
      },
      children: [html]
    });
  }
}
class Decimal extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "decimal");
    this.fracDigits = (0, _utils.getInteger)({
      data: attributes.fracDigits,
      defaultValue: 2,
      validate: x => true
    });
    this.id = attributes.id || "";
    this.leadDigits = (0, _utils.getInteger)({
      data: attributes.leadDigits,
      defaultValue: -1,
      validate: x => true
    });
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [_symbol_utils.$finalize]() {
    const number = parseFloat(this[_symbol_utils.$content].trim());
    this[_symbol_utils.$content] = isNaN(number) ? null : number;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    return valueToHtml(this[_symbol_utils.$content] !== null ? this[_symbol_utils.$content].toString() : "");
  }
}
class DefaultUi extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "defaultUi", true);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
  }
}
class Desc extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "desc", true);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.boolean = new _xfa_object.XFAObjectArray();
    this.date = new _xfa_object.XFAObjectArray();
    this.dateTime = new _xfa_object.XFAObjectArray();
    this.decimal = new _xfa_object.XFAObjectArray();
    this.exData = new _xfa_object.XFAObjectArray();
    this.float = new _xfa_object.XFAObjectArray();
    this.image = new _xfa_object.XFAObjectArray();
    this.integer = new _xfa_object.XFAObjectArray();
    this.text = new _xfa_object.XFAObjectArray();
    this.time = new _xfa_object.XFAObjectArray();
  }
}
class DigestMethod extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "digestMethod", ["", "SHA1", "SHA256", "SHA512", "RIPEMD160"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class DigestMethods extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "digestMethods", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.digestMethod = new _xfa_object.XFAObjectArray();
  }
}
class Draw extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "draw", true);
    this.anchorType = (0, _utils.getStringOption)(attributes.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
    this.colSpan = (0, _utils.getInteger)({
      data: attributes.colSpan,
      defaultValue: 1,
      validate: n => n >= 1 || n === -1
    });
    this.h = attributes.h ? (0, _utils.getMeasurement)(attributes.h) : "";
    this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = attributes.id || "";
    this.locale = attributes.locale || "";
    this.maxH = (0, _utils.getMeasurement)(attributes.maxH, "0pt");
    this.maxW = (0, _utils.getMeasurement)(attributes.maxW, "0pt");
    this.minH = (0, _utils.getMeasurement)(attributes.minH, "0pt");
    this.minW = (0, _utils.getMeasurement)(attributes.minW, "0pt");
    this.name = attributes.name || "";
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.rotate = (0, _utils.getInteger)({
      data: attributes.rotate,
      defaultValue: 0,
      validate: x => x % 90 === 0
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.w = attributes.w ? (0, _utils.getMeasurement)(attributes.w) : "";
    this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
    this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
    this.assist = null;
    this.border = null;
    this.caption = null;
    this.desc = null;
    this.extras = null;
    this.font = null;
    this.keep = null;
    this.margin = null;
    this.para = null;
    this.traversal = null;
    this.ui = null;
    this.value = null;
    this.setProperty = new _xfa_object.XFAObjectArray();
  }
  [_symbol_utils.$setValue](value) {
    _setValue(this, value);
  }
  [_symbol_utils.$toHTML](availableSpace) {
    setTabIndex(this);
    if (this.presence === "hidden" || this.presence === "inactive") {
      return _utils.HTMLResult.EMPTY;
    }
    (0, _html_utils.fixDimensions)(this);
    this[_symbol_utils.$pushPara]();
    const savedW = this.w;
    const savedH = this.h;
    const {
      w,
      h,
      isBroken
    } = (0, _html_utils.layoutNode)(this, availableSpace);
    if (w && this.w === "") {
      if (isBroken && this[_symbol_utils.$getSubformParent]()[_symbol_utils.$isThereMoreWidth]()) {
        this[_symbol_utils.$popPara]();
        return _utils.HTMLResult.FAILURE;
      }
      this.w = w;
    }
    if (h && this.h === "") {
      this.h = h;
    }
    setFirstUnsplittable(this);
    if (!(0, _layout.checkDimensions)(this, availableSpace)) {
      this.w = savedW;
      this.h = savedH;
      this[_symbol_utils.$popPara]();
      return _utils.HTMLResult.FAILURE;
    }
    unsetFirstUnsplittable(this);
    const style = (0, _html_utils.toStyle)(this, "font", "hAlign", "dimensions", "position", "presence", "rotate", "anchorType", "border", "margin");
    (0, _html_utils.setMinMaxDimensions)(this, style);
    if (style.margin) {
      style.padding = style.margin;
      delete style.margin;
    }
    const classNames = ["xfaDraw"];
    if (this.font) {
      classNames.push("xfaFont");
    }
    if ((0, _html_utils.isPrintOnly)(this)) {
      classNames.push("xfaPrintOnly");
    }
    const attributes = {
      style,
      id: this[_symbol_utils.$uid],
      class: classNames
    };
    if (this.name) {
      attributes.xfaName = this.name;
    }
    const html = {
      name: "div",
      attributes,
      children: []
    };
    applyAssist(this, attributes);
    const bbox = (0, _html_utils.computeBbox)(this, html, availableSpace);
    const value = this.value ? this.value[_symbol_utils.$toHTML](availableSpace).html : null;
    if (value === null) {
      this.w = savedW;
      this.h = savedH;
      this[_symbol_utils.$popPara]();
      return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox);
    }
    html.children.push(value);
    (0, _html_utils.setPara)(this, style, value);
    this.w = savedW;
    this.h = savedH;
    this[_symbol_utils.$popPara]();
    return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox);
  }
}
class Edge extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "edge", true);
    this.cap = (0, _utils.getStringOption)(attributes.cap, ["square", "butt", "round"]);
    this.id = attributes.id || "";
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.stroke = (0, _utils.getStringOption)(attributes.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]);
    this.thickness = (0, _utils.getMeasurement)(attributes.thickness, "0.5pt");
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [_symbol_utils.$toStyle]() {
    const style = (0, _html_utils.toStyle)(this, "visibility");
    Object.assign(style, {
      linecap: this.cap,
      width: (0, _html_utils.measureToString)(this.thickness),
      color: this.color ? this.color[_symbol_utils.$toStyle]() : "#000000",
      style: ""
    });
    if (this.presence !== "visible") {
      style.style = "none";
    } else {
      switch (this.stroke) {
        case "solid":
          style.style = "solid";
          break;
        case "dashDot":
          style.style = "dashed";
          break;
        case "dashDotDot":
          style.style = "dashed";
          break;
        case "dashed":
          style.style = "dashed";
          break;
        case "dotted":
          style.style = "dotted";
          break;
        case "embossed":
          style.style = "ridge";
          break;
        case "etched":
          style.style = "groove";
          break;
        case "lowered":
          style.style = "inset";
          break;
        case "raised":
          style.style = "outset";
          break;
      }
    }
    return style;
  }
}
class Encoding extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "encoding", ["adbe.x509.rsa_sha1", "adbe.pkcs7.detached", "adbe.pkcs7.sha1"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Encodings extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "encodings", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.encoding = new _xfa_object.XFAObjectArray();
  }
}
class Encrypt extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "encrypt", true);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.certificate = null;
  }
}
class EncryptData extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "encryptData", true);
    this.id = attributes.id || "";
    this.operation = (0, _utils.getStringOption)(attributes.operation, ["encrypt", "decrypt"]);
    this.target = attributes.target || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.filter = null;
    this.manifest = null;
  }
}
class Encryption extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "encryption", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.certificate = new _xfa_object.XFAObjectArray();
  }
}
class EncryptionMethod extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "encryptionMethod", ["", "AES256-CBC", "TRIPLEDES-CBC", "AES128-CBC", "AES192-CBC"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class EncryptionMethods extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "encryptionMethods", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.encryptionMethod = new _xfa_object.XFAObjectArray();
  }
}
class Event extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "event", true);
    this.activity = (0, _utils.getStringOption)(attributes.activity, ["click", "change", "docClose", "docReady", "enter", "exit", "full", "indexChange", "initialize", "mouseDown", "mouseEnter", "mouseExit", "mouseUp", "postExecute", "postOpen", "postPrint", "postSave", "postSign", "postSubmit", "preExecute", "preOpen", "prePrint", "preSave", "preSign", "preSubmit", "ready", "validationState"]);
    this.id = attributes.id || "";
    this.listen = (0, _utils.getStringOption)(attributes.listen, ["refOnly", "refAndDescendents"]);
    this.name = attributes.name || "";
    this.ref = attributes.ref || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.encryptData = null;
    this.execute = null;
    this.script = null;
    this.signData = null;
    this.submit = null;
  }
}
class ExData extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "exData");
    this.contentType = attributes.contentType || "";
    this.href = attributes.href || "";
    this.id = attributes.id || "";
    this.maxLength = (0, _utils.getInteger)({
      data: attributes.maxLength,
      defaultValue: -1,
      validate: x => x >= -1
    });
    this.name = attributes.name || "";
    this.rid = attributes.rid || "";
    this.transferEncoding = (0, _utils.getStringOption)(attributes.transferEncoding, ["none", "base64", "package"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [_symbol_utils.$isCDATAXml]() {
    return this.contentType === "text/html";
  }
  [_symbol_utils.$onChild](child) {
    if (this.contentType === "text/html" && child[_symbol_utils.$namespaceId] === _namespaces.NamespaceIds.xhtml.id) {
      this[_symbol_utils.$content] = child;
      return true;
    }
    if (this.contentType === "text/xml") {
      this[_symbol_utils.$content] = child;
      return true;
    }
    return false;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    if (this.contentType !== "text/html" || !this[_symbol_utils.$content]) {
      return _utils.HTMLResult.EMPTY;
    }
    return this[_symbol_utils.$content][_symbol_utils.$toHTML](availableSpace);
  }
}
class ExObject extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "exObject", true);
    this.archive = attributes.archive || "";
    this.classId = attributes.classId || "";
    this.codeBase = attributes.codeBase || "";
    this.codeType = attributes.codeType || "";
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.boolean = new _xfa_object.XFAObjectArray();
    this.date = new _xfa_object.XFAObjectArray();
    this.dateTime = new _xfa_object.XFAObjectArray();
    this.decimal = new _xfa_object.XFAObjectArray();
    this.exData = new _xfa_object.XFAObjectArray();
    this.exObject = new _xfa_object.XFAObjectArray();
    this.float = new _xfa_object.XFAObjectArray();
    this.image = new _xfa_object.XFAObjectArray();
    this.integer = new _xfa_object.XFAObjectArray();
    this.text = new _xfa_object.XFAObjectArray();
    this.time = new _xfa_object.XFAObjectArray();
  }
}
class ExclGroup extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "exclGroup", true);
    this.access = (0, _utils.getStringOption)(attributes.access, ["open", "nonInteractive", "protected", "readOnly"]);
    this.accessKey = attributes.accessKey || "";
    this.anchorType = (0, _utils.getStringOption)(attributes.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
    this.colSpan = (0, _utils.getInteger)({
      data: attributes.colSpan,
      defaultValue: 1,
      validate: n => n >= 1 || n === -1
    });
    this.h = attributes.h ? (0, _utils.getMeasurement)(attributes.h) : "";
    this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = attributes.id || "";
    this.layout = (0, _utils.getStringOption)(attributes.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]);
    this.maxH = (0, _utils.getMeasurement)(attributes.maxH, "0pt");
    this.maxW = (0, _utils.getMeasurement)(attributes.maxW, "0pt");
    this.minH = (0, _utils.getMeasurement)(attributes.minH, "0pt");
    this.minW = (0, _utils.getMeasurement)(attributes.minW, "0pt");
    this.name = attributes.name || "";
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.w = attributes.w ? (0, _utils.getMeasurement)(attributes.w) : "";
    this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
    this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
    this.assist = null;
    this.bind = null;
    this.border = null;
    this.calculate = null;
    this.caption = null;
    this.desc = null;
    this.extras = null;
    this.margin = null;
    this.para = null;
    this.traversal = null;
    this.validate = null;
    this.connect = new _xfa_object.XFAObjectArray();
    this.event = new _xfa_object.XFAObjectArray();
    this.field = new _xfa_object.XFAObjectArray();
    this.setProperty = new _xfa_object.XFAObjectArray();
  }
  [_symbol_utils.$isBindable]() {
    return true;
  }
  [_symbol_utils.$hasSettableValue]() {
    return true;
  }
  [_symbol_utils.$setValue](value) {
    for (const field of this.field.children) {
      if (!field.value) {
        const nodeValue = new Value({});
        field[_symbol_utils.$appendChild](nodeValue);
        field.value = nodeValue;
      }
      field.value[_symbol_utils.$setValue](value);
    }
  }
  [_symbol_utils.$isThereMoreWidth]() {
    return this.layout.endsWith("-tb") && this[_symbol_utils.$extra].attempt === 0 && this[_symbol_utils.$extra].numberInLine > 0 || this[_symbol_utils.$getParent]()[_symbol_utils.$isThereMoreWidth]();
  }
  [_symbol_utils.$isSplittable]() {
    const parent = this[_symbol_utils.$getSubformParent]();
    if (!parent[_symbol_utils.$isSplittable]()) {
      return false;
    }
    if (this[_symbol_utils.$extra]._isSplittable !== undefined) {
      return this[_symbol_utils.$extra]._isSplittable;
    }
    if (this.layout === "position" || this.layout.includes("row")) {
      this[_symbol_utils.$extra]._isSplittable = false;
      return false;
    }
    if (parent.layout?.endsWith("-tb") && parent[_symbol_utils.$extra].numberInLine !== 0) {
      return false;
    }
    this[_symbol_utils.$extra]._isSplittable = true;
    return true;
  }
  [_symbol_utils.$flushHTML]() {
    return (0, _layout.flushHTML)(this);
  }
  [_symbol_utils.$addHTML](html, bbox) {
    (0, _layout.addHTML)(this, html, bbox);
  }
  [_symbol_utils.$getAvailableSpace]() {
    return (0, _layout.getAvailableSpace)(this);
  }
  [_symbol_utils.$toHTML](availableSpace) {
    setTabIndex(this);
    if (this.presence === "hidden" || this.presence === "inactive" || this.h === 0 || this.w === 0) {
      return _utils.HTMLResult.EMPTY;
    }
    (0, _html_utils.fixDimensions)(this);
    const children = [];
    const attributes = {
      id: this[_symbol_utils.$uid],
      class: []
    };
    (0, _html_utils.setAccess)(this, attributes.class);
    if (!this[_symbol_utils.$extra]) {
      this[_symbol_utils.$extra] = Object.create(null);
    }
    Object.assign(this[_symbol_utils.$extra], {
      children,
      attributes,
      attempt: 0,
      line: null,
      numberInLine: 0,
      availableSpace: {
        width: Math.min(this.w || Infinity, availableSpace.width),
        height: Math.min(this.h || Infinity, availableSpace.height)
      },
      width: 0,
      height: 0,
      prevHeight: 0,
      currentWidth: 0
    });
    const isSplittable = this[_symbol_utils.$isSplittable]();
    if (!isSplittable) {
      setFirstUnsplittable(this);
    }
    if (!(0, _layout.checkDimensions)(this, availableSpace)) {
      return _utils.HTMLResult.FAILURE;
    }
    const filter = new Set(["field"]);
    if (this.layout.includes("row")) {
      const columnWidths = this[_symbol_utils.$getSubformParent]().columnWidths;
      if (Array.isArray(columnWidths) && columnWidths.length > 0) {
        this[_symbol_utils.$extra].columnWidths = columnWidths;
        this[_symbol_utils.$extra].currentColumn = 0;
      }
    }
    const style = (0, _html_utils.toStyle)(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign");
    const classNames = ["xfaExclgroup"];
    const cl = (0, _html_utils.layoutClass)(this);
    if (cl) {
      classNames.push(cl);
    }
    if ((0, _html_utils.isPrintOnly)(this)) {
      classNames.push("xfaPrintOnly");
    }
    attributes.style = style;
    attributes.class = classNames;
    if (this.name) {
      attributes.xfaName = this.name;
    }
    this[_symbol_utils.$pushPara]();
    const isLrTb = this.layout === "lr-tb" || this.layout === "rl-tb";
    const maxRun = isLrTb ? MAX_ATTEMPTS_FOR_LRTB_LAYOUT : 1;
    for (; this[_symbol_utils.$extra].attempt < maxRun; this[_symbol_utils.$extra].attempt++) {
      if (isLrTb && this[_symbol_utils.$extra].attempt === MAX_ATTEMPTS_FOR_LRTB_LAYOUT - 1) {
        this[_symbol_utils.$extra].numberInLine = 0;
      }
      const result = this[_symbol_utils.$childrenToHTML]({
        filter,
        include: true
      });
      if (result.success) {
        break;
      }
      if (result.isBreak()) {
        this[_symbol_utils.$popPara]();
        return result;
      }
      if (isLrTb && this[_symbol_utils.$extra].attempt === 0 && this[_symbol_utils.$extra].numberInLine === 0 && !this[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].noLayoutFailure) {
        this[_symbol_utils.$extra].attempt = maxRun;
        break;
      }
    }
    this[_symbol_utils.$popPara]();
    if (!isSplittable) {
      unsetFirstUnsplittable(this);
    }
    if (this[_symbol_utils.$extra].attempt === maxRun) {
      if (!isSplittable) {
        delete this[_symbol_utils.$extra];
      }
      return _utils.HTMLResult.FAILURE;
    }
    let marginH = 0;
    let marginV = 0;
    if (this.margin) {
      marginH = this.margin.leftInset + this.margin.rightInset;
      marginV = this.margin.topInset + this.margin.bottomInset;
    }
    const width = Math.max(this[_symbol_utils.$extra].width + marginH, this.w || 0);
    const height = Math.max(this[_symbol_utils.$extra].height + marginV, this.h || 0);
    const bbox = [this.x, this.y, width, height];
    if (this.w === "") {
      style.width = (0, _html_utils.measureToString)(width);
    }
    if (this.h === "") {
      style.height = (0, _html_utils.measureToString)(height);
    }
    const html = {
      name: "div",
      attributes,
      children
    };
    applyAssist(this, attributes);
    delete this[_symbol_utils.$extra];
    return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox);
  }
}
class Execute extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "execute");
    this.connection = attributes.connection || "";
    this.executeType = (0, _utils.getStringOption)(attributes.executeType, ["import", "remerge"]);
    this.id = attributes.id || "";
    this.runAt = (0, _utils.getStringOption)(attributes.runAt, ["client", "both", "server"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Extras extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "extras", true);
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.boolean = new _xfa_object.XFAObjectArray();
    this.date = new _xfa_object.XFAObjectArray();
    this.dateTime = new _xfa_object.XFAObjectArray();
    this.decimal = new _xfa_object.XFAObjectArray();
    this.exData = new _xfa_object.XFAObjectArray();
    this.extras = new _xfa_object.XFAObjectArray();
    this.float = new _xfa_object.XFAObjectArray();
    this.image = new _xfa_object.XFAObjectArray();
    this.integer = new _xfa_object.XFAObjectArray();
    this.text = new _xfa_object.XFAObjectArray();
    this.time = new _xfa_object.XFAObjectArray();
  }
}
class Field extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "field", true);
    this.access = (0, _utils.getStringOption)(attributes.access, ["open", "nonInteractive", "protected", "readOnly"]);
    this.accessKey = attributes.accessKey || "";
    this.anchorType = (0, _utils.getStringOption)(attributes.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
    this.colSpan = (0, _utils.getInteger)({
      data: attributes.colSpan,
      defaultValue: 1,
      validate: n => n >= 1 || n === -1
    });
    this.h = attributes.h ? (0, _utils.getMeasurement)(attributes.h) : "";
    this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = attributes.id || "";
    this.locale = attributes.locale || "";
    this.maxH = (0, _utils.getMeasurement)(attributes.maxH, "0pt");
    this.maxW = (0, _utils.getMeasurement)(attributes.maxW, "0pt");
    this.minH = (0, _utils.getMeasurement)(attributes.minH, "0pt");
    this.minW = (0, _utils.getMeasurement)(attributes.minW, "0pt");
    this.name = attributes.name || "";
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.rotate = (0, _utils.getInteger)({
      data: attributes.rotate,
      defaultValue: 0,
      validate: x => x % 90 === 0
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.w = attributes.w ? (0, _utils.getMeasurement)(attributes.w) : "";
    this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
    this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
    this.assist = null;
    this.bind = null;
    this.border = null;
    this.calculate = null;
    this.caption = null;
    this.desc = null;
    this.extras = null;
    this.font = null;
    this.format = null;
    this.items = new _xfa_object.XFAObjectArray(2);
    this.keep = null;
    this.margin = null;
    this.para = null;
    this.traversal = null;
    this.ui = null;
    this.validate = null;
    this.value = null;
    this.bindItems = new _xfa_object.XFAObjectArray();
    this.connect = new _xfa_object.XFAObjectArray();
    this.event = new _xfa_object.XFAObjectArray();
    this.setProperty = new _xfa_object.XFAObjectArray();
  }
  [_symbol_utils.$isBindable]() {
    return true;
  }
  [_symbol_utils.$setValue](value) {
    _setValue(this, value);
  }
  [_symbol_utils.$toHTML](availableSpace) {
    setTabIndex(this);
    if (!this.ui) {
      this.ui = new Ui({});
      this.ui[_symbol_utils.$globalData] = this[_symbol_utils.$globalData];
      this[_symbol_utils.$appendChild](this.ui);
      let node;
      switch (this.items.children.length) {
        case 0:
          node = new TextEdit({});
          this.ui.textEdit = node;
          break;
        case 1:
          node = new CheckButton({});
          this.ui.checkButton = node;
          break;
        case 2:
          node = new ChoiceList({});
          this.ui.choiceList = node;
          break;
      }
      this.ui[_symbol_utils.$appendChild](node);
    }
    if (!this.ui || this.presence === "hidden" || this.presence === "inactive" || this.h === 0 || this.w === 0) {
      return _utils.HTMLResult.EMPTY;
    }
    if (this.caption) {
      delete this.caption[_symbol_utils.$extra];
    }
    this[_symbol_utils.$pushPara]();
    const caption = this.caption ? this.caption[_symbol_utils.$toHTML](availableSpace).html : null;
    const savedW = this.w;
    const savedH = this.h;
    let marginH = 0;
    let marginV = 0;
    if (this.margin) {
      marginH = this.margin.leftInset + this.margin.rightInset;
      marginV = this.margin.topInset + this.margin.bottomInset;
    }
    let borderDims = null;
    if (this.w === "" || this.h === "") {
      let width = null;
      let height = null;
      let uiW = 0;
      let uiH = 0;
      if (this.ui.checkButton) {
        uiW = uiH = this.ui.checkButton.size;
      } else {
        const {
          w,
          h
        } = (0, _html_utils.layoutNode)(this, availableSpace);
        if (w !== null) {
          uiW = w;
          uiH = h;
        } else {
          uiH = (0, _fonts.getMetrics)(this.font, true).lineNoGap;
        }
      }
      borderDims = getBorderDims(this.ui[_symbol_utils.$getExtra]());
      uiW += borderDims.w;
      uiH += borderDims.h;
      if (this.caption) {
        const {
          w,
          h,
          isBroken
        } = this.caption[_symbol_utils.$getExtra](availableSpace);
        if (isBroken && this[_symbol_utils.$getSubformParent]()[_symbol_utils.$isThereMoreWidth]()) {
          this[_symbol_utils.$popPara]();
          return _utils.HTMLResult.FAILURE;
        }
        width = w;
        height = h;
        switch (this.caption.placement) {
          case "left":
          case "right":
          case "inline":
            width += uiW;
            break;
          case "top":
          case "bottom":
            height += uiH;
            break;
        }
      } else {
        width = uiW;
        height = uiH;
      }
      if (width && this.w === "") {
        width += marginH;
        this.w = Math.min(this.maxW <= 0 ? Infinity : this.maxW, this.minW + 1 < width ? width : this.minW);
      }
      if (height && this.h === "") {
        height += marginV;
        this.h = Math.min(this.maxH <= 0 ? Infinity : this.maxH, this.minH + 1 < height ? height : this.minH);
      }
    }
    this[_symbol_utils.$popPara]();
    (0, _html_utils.fixDimensions)(this);
    setFirstUnsplittable(this);
    if (!(0, _layout.checkDimensions)(this, availableSpace)) {
      this.w = savedW;
      this.h = savedH;
      this[_symbol_utils.$popPara]();
      return _utils.HTMLResult.FAILURE;
    }
    unsetFirstUnsplittable(this);
    const style = (0, _html_utils.toStyle)(this, "font", "dimensions", "position", "rotate", "anchorType", "presence", "margin", "hAlign");
    (0, _html_utils.setMinMaxDimensions)(this, style);
    const classNames = ["xfaField"];
    if (this.font) {
      classNames.push("xfaFont");
    }
    if ((0, _html_utils.isPrintOnly)(this)) {
      classNames.push("xfaPrintOnly");
    }
    const attributes = {
      style,
      id: this[_symbol_utils.$uid],
      class: classNames
    };
    if (style.margin) {
      style.padding = style.margin;
      delete style.margin;
    }
    (0, _html_utils.setAccess)(this, classNames);
    if (this.name) {
      attributes.xfaName = this.name;
    }
    const children = [];
    const html = {
      name: "div",
      attributes,
      children
    };
    applyAssist(this, attributes);
    const borderStyle = this.border ? this.border[_symbol_utils.$toStyle]() : null;
    const bbox = (0, _html_utils.computeBbox)(this, html, availableSpace);
    const ui = this.ui[_symbol_utils.$toHTML]().html;
    if (!ui) {
      Object.assign(style, borderStyle);
      return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox);
    }
    if (this[_symbol_utils.$tabIndex]) {
      if (ui.children?.[0]) {
        ui.children[0].attributes.tabindex = this[_symbol_utils.$tabIndex];
      } else {
        ui.attributes.tabindex = this[_symbol_utils.$tabIndex];
      }
    }
    if (!ui.attributes.style) {
      ui.attributes.style = Object.create(null);
    }
    let aElement = null;
    if (this.ui.button) {
      if (ui.children.length === 1) {
        [aElement] = ui.children.splice(0, 1);
      }
      Object.assign(ui.attributes.style, borderStyle);
    } else {
      Object.assign(style, borderStyle);
    }
    children.push(ui);
    if (this.value) {
      if (this.ui.imageEdit) {
        ui.children.push(this.value[_symbol_utils.$toHTML]().html);
      } else if (!this.ui.button) {
        let value = "";
        if (this.value.exData) {
          value = this.value.exData[_symbol_utils.$text]();
        } else if (this.value.text) {
          value = this.value.text[_symbol_utils.$getExtra]();
        } else {
          const htmlValue = this.value[_symbol_utils.$toHTML]().html;
          if (htmlValue !== null) {
            value = htmlValue.children[0].value;
          }
        }
        if (this.ui.textEdit && this.value.text?.maxChars) {
          ui.children[0].attributes.maxLength = this.value.text.maxChars;
        }
        if (value) {
          if (this.ui.numericEdit) {
            value = parseFloat(value);
            value = isNaN(value) ? "" : value.toString();
          }
          if (ui.children[0].name === "textarea") {
            ui.children[0].attributes.textContent = value;
          } else {
            ui.children[0].attributes.value = value;
          }
        }
      }
    }
    if (!this.ui.imageEdit && ui.children?.[0] && this.h) {
      borderDims = borderDims || getBorderDims(this.ui[_symbol_utils.$getExtra]());
      let captionHeight = 0;
      if (this.caption && ["top", "bottom"].includes(this.caption.placement)) {
        captionHeight = this.caption.reserve;
        if (captionHeight <= 0) {
          captionHeight = this.caption[_symbol_utils.$getExtra](availableSpace).h;
        }
        const inputHeight = this.h - captionHeight - marginV - borderDims.h;
        ui.children[0].attributes.style.height = (0, _html_utils.measureToString)(inputHeight);
      } else {
        ui.children[0].attributes.style.height = "100%";
      }
    }
    if (aElement) {
      ui.children.push(aElement);
    }
    if (!caption) {
      if (ui.attributes.class) {
        ui.attributes.class.push("xfaLeft");
      }
      this.w = savedW;
      this.h = savedH;
      return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox);
    }
    if (this.ui.button) {
      if (style.padding) {
        delete style.padding;
      }
      if (caption.name === "div") {
        caption.name = "span";
      }
      ui.children.push(caption);
      return _utils.HTMLResult.success(html, bbox);
    } else if (this.ui.checkButton) {
      caption.attributes.class[0] = "xfaCaptionForCheckButton";
    }
    if (!ui.attributes.class) {
      ui.attributes.class = [];
    }
    ui.children.splice(0, 0, caption);
    switch (this.caption.placement) {
      case "left":
        ui.attributes.class.push("xfaLeft");
        break;
      case "right":
        ui.attributes.class.push("xfaRight");
        break;
      case "top":
        ui.attributes.class.push("xfaTop");
        break;
      case "bottom":
        ui.attributes.class.push("xfaBottom");
        break;
      case "inline":
        ui.attributes.class.push("xfaLeft");
        break;
    }
    this.w = savedW;
    this.h = savedH;
    return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox);
  }
}
exports.Field = Field;
class Fill extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "fill", true);
    this.id = attributes.id || "";
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.color = null;
    this.extras = null;
    this.linear = null;
    this.pattern = null;
    this.radial = null;
    this.solid = null;
    this.stipple = null;
  }
  [_symbol_utils.$toStyle]() {
    const parent = this[_symbol_utils.$getParent]();
    const grandpa = parent[_symbol_utils.$getParent]();
    const ggrandpa = grandpa[_symbol_utils.$getParent]();
    const style = Object.create(null);
    let propName = "color";
    let altPropName = propName;
    if (parent instanceof Border) {
      propName = "background-color";
      altPropName = "background";
      if (ggrandpa instanceof Ui) {
        style.backgroundColor = "white";
      }
    }
    if (parent instanceof Rectangle || parent instanceof Arc) {
      propName = altPropName = "fill";
      style.fill = "white";
    }
    for (const name of Object.getOwnPropertyNames(this)) {
      if (name === "extras" || name === "color") {
        continue;
      }
      const obj = this[name];
      if (!(obj instanceof _xfa_object.XFAObject)) {
        continue;
      }
      const color = obj[_symbol_utils.$toStyle](this.color);
      if (color) {
        style[color.startsWith("#") ? propName : altPropName] = color;
      }
      return style;
    }
    if (this.color?.value) {
      const color = this.color[_symbol_utils.$toStyle]();
      style[color.startsWith("#") ? propName : altPropName] = color;
    }
    return style;
  }
}
class Filter extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "filter", true);
    this.addRevocationInfo = (0, _utils.getStringOption)(attributes.addRevocationInfo, ["", "required", "optional", "none"]);
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.version = (0, _utils.getInteger)({
      data: this.version,
      defaultValue: 5,
      validate: x => x >= 1 && x <= 5
    });
    this.appearanceFilter = null;
    this.certificates = null;
    this.digestMethods = null;
    this.encodings = null;
    this.encryptionMethods = null;
    this.handler = null;
    this.lockDocument = null;
    this.mdp = null;
    this.reasons = null;
    this.timeStamp = null;
  }
}
class Float extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "float");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [_symbol_utils.$finalize]() {
    const number = parseFloat(this[_symbol_utils.$content].trim());
    this[_symbol_utils.$content] = isNaN(number) ? null : number;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    return valueToHtml(this[_symbol_utils.$content] !== null ? this[_symbol_utils.$content].toString() : "");
  }
}
class Font extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "font", true);
    this.baselineShift = (0, _utils.getMeasurement)(attributes.baselineShift);
    this.fontHorizontalScale = (0, _utils.getFloat)({
      data: attributes.fontHorizontalScale,
      defaultValue: 100,
      validate: x => x >= 0
    });
    this.fontVerticalScale = (0, _utils.getFloat)({
      data: attributes.fontVerticalScale,
      defaultValue: 100,
      validate: x => x >= 0
    });
    this.id = attributes.id || "";
    this.kerningMode = (0, _utils.getStringOption)(attributes.kerningMode, ["none", "pair"]);
    this.letterSpacing = (0, _utils.getMeasurement)(attributes.letterSpacing, "0");
    this.lineThrough = (0, _utils.getInteger)({
      data: attributes.lineThrough,
      defaultValue: 0,
      validate: x => x === 1 || x === 2
    });
    this.lineThroughPeriod = (0, _utils.getStringOption)(attributes.lineThroughPeriod, ["all", "word"]);
    this.overline = (0, _utils.getInteger)({
      data: attributes.overline,
      defaultValue: 0,
      validate: x => x === 1 || x === 2
    });
    this.overlinePeriod = (0, _utils.getStringOption)(attributes.overlinePeriod, ["all", "word"]);
    this.posture = (0, _utils.getStringOption)(attributes.posture, ["normal", "italic"]);
    this.size = (0, _utils.getMeasurement)(attributes.size, "10pt");
    this.typeface = attributes.typeface || "Courier";
    this.underline = (0, _utils.getInteger)({
      data: attributes.underline,
      defaultValue: 0,
      validate: x => x === 1 || x === 2
    });
    this.underlinePeriod = (0, _utils.getStringOption)(attributes.underlinePeriod, ["all", "word"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.weight = (0, _utils.getStringOption)(attributes.weight, ["normal", "bold"]);
    this.extras = null;
    this.fill = null;
  }
  [_symbol_utils.$clean](builder) {
    super[_symbol_utils.$clean](builder);
    this[_symbol_utils.$globalData].usedTypefaces.add(this.typeface);
  }
  [_symbol_utils.$toStyle]() {
    const style = (0, _html_utils.toStyle)(this, "fill");
    const color = style.color;
    if (color) {
      if (color === "#000000") {
        delete style.color;
      } else if (!color.startsWith("#")) {
        style.background = color;
        style.backgroundClip = "text";
        style.color = "transparent";
      }
    }
    if (this.baselineShift) {
      style.verticalAlign = (0, _html_utils.measureToString)(this.baselineShift);
    }
    style.fontKerning = this.kerningMode === "none" ? "none" : "normal";
    style.letterSpacing = (0, _html_utils.measureToString)(this.letterSpacing);
    if (this.lineThrough !== 0) {
      style.textDecoration = "line-through";
      if (this.lineThrough === 2) {
        style.textDecorationStyle = "double";
      }
    }
    if (this.overline !== 0) {
      style.textDecoration = "overline";
      if (this.overline === 2) {
        style.textDecorationStyle = "double";
      }
    }
    style.fontStyle = this.posture;
    style.fontSize = (0, _html_utils.measureToString)(0.99 * this.size);
    (0, _html_utils.setFontFamily)(this, this, this[_symbol_utils.$globalData].fontFinder, style);
    if (this.underline !== 0) {
      style.textDecoration = "underline";
      if (this.underline === 2) {
        style.textDecorationStyle = "double";
      }
    }
    style.fontWeight = this.weight;
    return style;
  }
}
class Format extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "format", true);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.picture = null;
  }
}
class Handler extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "handler");
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Hyphenation extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "hyphenation");
    this.excludeAllCaps = (0, _utils.getInteger)({
      data: attributes.excludeAllCaps,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.excludeInitialCap = (0, _utils.getInteger)({
      data: attributes.excludeInitialCap,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.hyphenate = (0, _utils.getInteger)({
      data: attributes.hyphenate,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.id = attributes.id || "";
    this.pushCharacterCount = (0, _utils.getInteger)({
      data: attributes.pushCharacterCount,
      defaultValue: 3,
      validate: x => x >= 0
    });
    this.remainCharacterCount = (0, _utils.getInteger)({
      data: attributes.remainCharacterCount,
      defaultValue: 3,
      validate: x => x >= 0
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.wordCharacterCount = (0, _utils.getInteger)({
      data: attributes.wordCharacterCount,
      defaultValue: 7,
      validate: x => x >= 0
    });
  }
}
class Image extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "image");
    this.aspect = (0, _utils.getStringOption)(attributes.aspect, ["fit", "actual", "height", "none", "width"]);
    this.contentType = attributes.contentType || "";
    this.href = attributes.href || "";
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.transferEncoding = (0, _utils.getStringOption)(attributes.transferEncoding, ["base64", "none", "package"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [_symbol_utils.$toHTML]() {
    if (this.contentType && !MIMES.has(this.contentType.toLowerCase())) {
      return _utils.HTMLResult.EMPTY;
    }
    let buffer = this[_symbol_utils.$globalData].images && this[_symbol_utils.$globalData].images.get(this.href);
    if (!buffer && (this.href || !this[_symbol_utils.$content])) {
      return _utils.HTMLResult.EMPTY;
    }
    if (!buffer && this.transferEncoding === "base64") {
      buffer = (0, _util.stringToBytes)(atob(this[_symbol_utils.$content]));
    }
    if (!buffer) {
      return _utils.HTMLResult.EMPTY;
    }
    if (!this.contentType) {
      for (const [header, type] of IMAGES_HEADERS) {
        if (buffer.length > header.length && header.every((x, i) => x === buffer[i])) {
          this.contentType = type;
          break;
        }
      }
      if (!this.contentType) {
        return _utils.HTMLResult.EMPTY;
      }
    }
    const blob = new Blob([buffer], {
      type: this.contentType
    });
    let style;
    switch (this.aspect) {
      case "fit":
      case "actual":
        break;
      case "height":
        style = {
          height: "100%",
          objectFit: "fill"
        };
        break;
      case "none":
        style = {
          width: "100%",
          height: "100%",
          objectFit: "fill"
        };
        break;
      case "width":
        style = {
          width: "100%",
          objectFit: "fill"
        };
        break;
    }
    const parent = this[_symbol_utils.$getParent]();
    return _utils.HTMLResult.success({
      name: "img",
      attributes: {
        class: ["xfaImage"],
        style,
        src: URL.createObjectURL(blob),
        alt: parent ? ariaLabel(parent[_symbol_utils.$getParent]()) : null
      }
    });
  }
}
class ImageEdit extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "imageEdit", true);
    this.data = (0, _utils.getStringOption)(attributes.data, ["link", "embed"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.border = null;
    this.extras = null;
    this.margin = null;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    if (this.data === "embed") {
      return _utils.HTMLResult.success({
        name: "div",
        children: [],
        attributes: {}
      });
    }
    return _utils.HTMLResult.EMPTY;
  }
}
class Integer extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "integer");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [_symbol_utils.$finalize]() {
    const number = parseInt(this[_symbol_utils.$content].trim(), 10);
    this[_symbol_utils.$content] = isNaN(number) ? null : number;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    return valueToHtml(this[_symbol_utils.$content] !== null ? this[_symbol_utils.$content].toString() : "");
  }
}
class Issuers extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "issuers", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.certificate = new _xfa_object.XFAObjectArray();
  }
}
class Items extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "items", true);
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.ref = attributes.ref || "";
    this.save = (0, _utils.getInteger)({
      data: attributes.save,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.boolean = new _xfa_object.XFAObjectArray();
    this.date = new _xfa_object.XFAObjectArray();
    this.dateTime = new _xfa_object.XFAObjectArray();
    this.decimal = new _xfa_object.XFAObjectArray();
    this.exData = new _xfa_object.XFAObjectArray();
    this.float = new _xfa_object.XFAObjectArray();
    this.image = new _xfa_object.XFAObjectArray();
    this.integer = new _xfa_object.XFAObjectArray();
    this.text = new _xfa_object.XFAObjectArray();
    this.time = new _xfa_object.XFAObjectArray();
  }
  [_symbol_utils.$toHTML]() {
    const output = [];
    for (const child of this[_symbol_utils.$getChildren]()) {
      output.push(child[_symbol_utils.$text]());
    }
    return _utils.HTMLResult.success(output);
  }
}
exports.Items = Items;
class Keep extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "keep", true);
    this.id = attributes.id || "";
    const options = ["none", "contentArea", "pageArea"];
    this.intact = (0, _utils.getStringOption)(attributes.intact, options);
    this.next = (0, _utils.getStringOption)(attributes.next, options);
    this.previous = (0, _utils.getStringOption)(attributes.previous, options);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
  }
}
class KeyUsage extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "keyUsage");
    const options = ["", "yes", "no"];
    this.crlSign = (0, _utils.getStringOption)(attributes.crlSign, options);
    this.dataEncipherment = (0, _utils.getStringOption)(attributes.dataEncipherment, options);
    this.decipherOnly = (0, _utils.getStringOption)(attributes.decipherOnly, options);
    this.digitalSignature = (0, _utils.getStringOption)(attributes.digitalSignature, options);
    this.encipherOnly = (0, _utils.getStringOption)(attributes.encipherOnly, options);
    this.id = attributes.id || "";
    this.keyAgreement = (0, _utils.getStringOption)(attributes.keyAgreement, options);
    this.keyCertSign = (0, _utils.getStringOption)(attributes.keyCertSign, options);
    this.keyEncipherment = (0, _utils.getStringOption)(attributes.keyEncipherment, options);
    this.nonRepudiation = (0, _utils.getStringOption)(attributes.nonRepudiation, options);
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Line extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "line", true);
    this.hand = (0, _utils.getStringOption)(attributes.hand, ["even", "left", "right"]);
    this.id = attributes.id || "";
    this.slope = (0, _utils.getStringOption)(attributes.slope, ["\\", "/"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.edge = null;
  }
  [_symbol_utils.$toHTML]() {
    const parent = this[_symbol_utils.$getParent]()[_symbol_utils.$getParent]();
    const edge = this.edge || new Edge({});
    const edgeStyle = edge[_symbol_utils.$toStyle]();
    const style = Object.create(null);
    const thickness = edge.presence === "visible" ? edge.thickness : 0;
    style.strokeWidth = (0, _html_utils.measureToString)(thickness);
    style.stroke = edgeStyle.color;
    let x1, y1, x2, y2;
    let width = "100%";
    let height = "100%";
    if (parent.w <= thickness) {
      [x1, y1, x2, y2] = ["50%", 0, "50%", "100%"];
      width = style.strokeWidth;
    } else if (parent.h <= thickness) {
      [x1, y1, x2, y2] = [0, "50%", "100%", "50%"];
      height = style.strokeWidth;
    } else if (this.slope === "\\") {
      [x1, y1, x2, y2] = [0, 0, "100%", "100%"];
    } else {
      [x1, y1, x2, y2] = [0, "100%", "100%", 0];
    }
    const line = {
      name: "line",
      attributes: {
        xmlns: SVG_NS,
        x1,
        y1,
        x2,
        y2,
        style
      }
    };
    const svg = {
      name: "svg",
      children: [line],
      attributes: {
        xmlns: SVG_NS,
        width,
        height,
        style: {
          overflow: "visible"
        }
      }
    };
    if (hasMargin(parent)) {
      return _utils.HTMLResult.success({
        name: "div",
        attributes: {
          style: {
            display: "inline",
            width: "100%",
            height: "100%"
          }
        },
        children: [svg]
      });
    }
    svg.attributes.style.position = "absolute";
    return _utils.HTMLResult.success(svg);
  }
}
class Linear extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "linear", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["toRight", "toBottom", "toLeft", "toTop"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [_symbol_utils.$toStyle](startColor) {
    startColor = startColor ? startColor[_symbol_utils.$toStyle]() : "#FFFFFF";
    const transf = this.type.replace(/([RBLT])/, " $1").toLowerCase();
    const endColor = this.color ? this.color[_symbol_utils.$toStyle]() : "#000000";
    return `linear-gradient(${transf}, ${startColor}, ${endColor})`;
  }
}
class LockDocument extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "lockDocument");
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [_symbol_utils.$finalize]() {
    this[_symbol_utils.$content] = (0, _utils.getStringOption)(this[_symbol_utils.$content], ["auto", "0", "1"]);
  }
}
class Manifest extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "manifest", true);
    this.action = (0, _utils.getStringOption)(attributes.action, ["include", "all", "exclude"]);
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.ref = new _xfa_object.XFAObjectArray();
  }
}
class Margin extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "margin", true);
    this.bottomInset = (0, _utils.getMeasurement)(attributes.bottomInset, "0");
    this.id = attributes.id || "";
    this.leftInset = (0, _utils.getMeasurement)(attributes.leftInset, "0");
    this.rightInset = (0, _utils.getMeasurement)(attributes.rightInset, "0");
    this.topInset = (0, _utils.getMeasurement)(attributes.topInset, "0");
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
  }
  [_symbol_utils.$toStyle]() {
    return {
      margin: (0, _html_utils.measureToString)(this.topInset) + " " + (0, _html_utils.measureToString)(this.rightInset) + " " + (0, _html_utils.measureToString)(this.bottomInset) + " " + (0, _html_utils.measureToString)(this.leftInset)
    };
  }
}
class Mdp extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "mdp");
    this.id = attributes.id || "";
    this.permissions = (0, _utils.getInteger)({
      data: attributes.permissions,
      defaultValue: 2,
      validate: x => x === 1 || x === 3
    });
    this.signatureType = (0, _utils.getStringOption)(attributes.signatureType, ["filler", "author"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Medium extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "medium");
    this.id = attributes.id || "";
    this.imagingBBox = (0, _utils.getBBox)(attributes.imagingBBox);
    this.long = (0, _utils.getMeasurement)(attributes.long);
    this.orientation = (0, _utils.getStringOption)(attributes.orientation, ["portrait", "landscape"]);
    this.short = (0, _utils.getMeasurement)(attributes.short);
    this.stock = attributes.stock || "";
    this.trayIn = (0, _utils.getStringOption)(attributes.trayIn, ["auto", "delegate", "pageFront"]);
    this.trayOut = (0, _utils.getStringOption)(attributes.trayOut, ["auto", "delegate"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Message extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "message", true);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.text = new _xfa_object.XFAObjectArray();
  }
}
class NumericEdit extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "numericEdit", true);
    this.hScrollPolicy = (0, _utils.getStringOption)(attributes.hScrollPolicy, ["auto", "off", "on"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.border = null;
    this.comb = null;
    this.extras = null;
    this.margin = null;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    const style = (0, _html_utils.toStyle)(this, "border", "font", "margin");
    const field = this[_symbol_utils.$getParent]()[_symbol_utils.$getParent]();
    const html = {
      name: "input",
      attributes: {
        type: "text",
        fieldId: field[_symbol_utils.$uid],
        dataId: field[_symbol_utils.$data]?.[_symbol_utils.$uid] || field[_symbol_utils.$uid],
        class: ["xfaTextfield"],
        style,
        "aria-label": ariaLabel(field),
        "aria-required": false
      }
    };
    if (isRequired(field)) {
      html.attributes["aria-required"] = true;
      html.attributes.required = true;
    }
    return _utils.HTMLResult.success({
      name: "label",
      attributes: {
        class: ["xfaLabel"]
      },
      children: [html]
    });
  }
}
class Occur extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "occur", true);
    this.id = attributes.id || "";
    this.initial = attributes.initial !== "" ? (0, _utils.getInteger)({
      data: attributes.initial,
      defaultValue: "",
      validate: x => true
    }) : "";
    this.max = attributes.max !== "" ? (0, _utils.getInteger)({
      data: attributes.max,
      defaultValue: 1,
      validate: x => true
    }) : "";
    this.min = attributes.min !== "" ? (0, _utils.getInteger)({
      data: attributes.min,
      defaultValue: 1,
      validate: x => true
    }) : "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
  }
  [_symbol_utils.$clean]() {
    const parent = this[_symbol_utils.$getParent]();
    const originalMin = this.min;
    if (this.min === "") {
      this.min = parent instanceof PageArea || parent instanceof PageSet ? 0 : 1;
    }
    if (this.max === "") {
      if (originalMin === "") {
        this.max = parent instanceof PageArea || parent instanceof PageSet ? -1 : 1;
      } else {
        this.max = this.min;
      }
    }
    if (this.max !== -1 && this.max < this.min) {
      this.max = this.min;
    }
    if (this.initial === "") {
      this.initial = parent instanceof Template ? 1 : this.min;
    }
  }
}
class Oid extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "oid");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Oids extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "oids", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.oid = new _xfa_object.XFAObjectArray();
  }
}
class Overflow extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "overflow");
    this.id = attributes.id || "";
    this.leader = attributes.leader || "";
    this.target = attributes.target || "";
    this.trailer = attributes.trailer || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [_symbol_utils.$getExtra]() {
    if (!this[_symbol_utils.$extra]) {
      const parent = this[_symbol_utils.$getParent]();
      const root = this[_symbol_utils.$getTemplateRoot]();
      const target = root[_symbol_utils.$searchNode](this.target, parent);
      const leader = root[_symbol_utils.$searchNode](this.leader, parent);
      const trailer = root[_symbol_utils.$searchNode](this.trailer, parent);
      this[_symbol_utils.$extra] = {
        target: target?.[0] || null,
        leader: leader?.[0] || null,
        trailer: trailer?.[0] || null,
        addLeader: false,
        addTrailer: false
      };
    }
    return this[_symbol_utils.$extra];
  }
}
class PageArea extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "pageArea", true);
    this.blankOrNotBlank = (0, _utils.getStringOption)(attributes.blankOrNotBlank, ["any", "blank", "notBlank"]);
    this.id = attributes.id || "";
    this.initialNumber = (0, _utils.getInteger)({
      data: attributes.initialNumber,
      defaultValue: 1,
      validate: x => true
    });
    this.name = attributes.name || "";
    this.numbered = (0, _utils.getInteger)({
      data: attributes.numbered,
      defaultValue: 1,
      validate: x => true
    });
    this.oddOrEven = (0, _utils.getStringOption)(attributes.oddOrEven, ["any", "even", "odd"]);
    this.pagePosition = (0, _utils.getStringOption)(attributes.pagePosition, ["any", "first", "last", "only", "rest"]);
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.desc = null;
    this.extras = null;
    this.medium = null;
    this.occur = null;
    this.area = new _xfa_object.XFAObjectArray();
    this.contentArea = new _xfa_object.XFAObjectArray();
    this.draw = new _xfa_object.XFAObjectArray();
    this.exclGroup = new _xfa_object.XFAObjectArray();
    this.field = new _xfa_object.XFAObjectArray();
    this.subform = new _xfa_object.XFAObjectArray();
  }
  [_symbol_utils.$isUsable]() {
    if (!this[_symbol_utils.$extra]) {
      this[_symbol_utils.$extra] = {
        numberOfUse: 0
      };
      return true;
    }
    return !this.occur || this.occur.max === -1 || this[_symbol_utils.$extra].numberOfUse < this.occur.max;
  }
  [_symbol_utils.$cleanPage]() {
    delete this[_symbol_utils.$extra];
  }
  [_symbol_utils.$getNextPage]() {
    if (!this[_symbol_utils.$extra]) {
      this[_symbol_utils.$extra] = {
        numberOfUse: 0
      };
    }
    const parent = this[_symbol_utils.$getParent]();
    if (parent.relation === "orderedOccurrence") {
      if (this[_symbol_utils.$isUsable]()) {
        this[_symbol_utils.$extra].numberOfUse += 1;
        return this;
      }
    }
    return parent[_symbol_utils.$getNextPage]();
  }
  [_symbol_utils.$getAvailableSpace]() {
    return this[_symbol_utils.$extra].space || {
      width: 0,
      height: 0
    };
  }
  [_symbol_utils.$toHTML]() {
    if (!this[_symbol_utils.$extra]) {
      this[_symbol_utils.$extra] = {
        numberOfUse: 1
      };
    }
    const children = [];
    this[_symbol_utils.$extra].children = children;
    const style = Object.create(null);
    if (this.medium && this.medium.short && this.medium.long) {
      style.width = (0, _html_utils.measureToString)(this.medium.short);
      style.height = (0, _html_utils.measureToString)(this.medium.long);
      this[_symbol_utils.$extra].space = {
        width: this.medium.short,
        height: this.medium.long
      };
      if (this.medium.orientation === "landscape") {
        const x = style.width;
        style.width = style.height;
        style.height = x;
        this[_symbol_utils.$extra].space = {
          width: this.medium.long,
          height: this.medium.short
        };
      }
    } else {
      (0, _util.warn)("XFA - No medium specified in pageArea: please file a bug.");
    }
    this[_symbol_utils.$childrenToHTML]({
      filter: new Set(["area", "draw", "field", "subform"]),
      include: true
    });
    this[_symbol_utils.$childrenToHTML]({
      filter: new Set(["contentArea"]),
      include: true
    });
    return _utils.HTMLResult.success({
      name: "div",
      children,
      attributes: {
        class: ["xfaPage"],
        id: this[_symbol_utils.$uid],
        style,
        xfaName: this.name
      }
    });
  }
}
class PageSet extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "pageSet", true);
    this.duplexImposition = (0, _utils.getStringOption)(attributes.duplexImposition, ["longEdge", "shortEdge"]);
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.relation = (0, _utils.getStringOption)(attributes.relation, ["orderedOccurrence", "duplexPaginated", "simplexPaginated"]);
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.occur = null;
    this.pageArea = new _xfa_object.XFAObjectArray();
    this.pageSet = new _xfa_object.XFAObjectArray();
  }
  [_symbol_utils.$cleanPage]() {
    for (const page of this.pageArea.children) {
      page[_symbol_utils.$cleanPage]();
    }
    for (const page of this.pageSet.children) {
      page[_symbol_utils.$cleanPage]();
    }
  }
  [_symbol_utils.$isUsable]() {
    return !this.occur || this.occur.max === -1 || this[_symbol_utils.$extra].numberOfUse < this.occur.max;
  }
  [_symbol_utils.$getNextPage]() {
    if (!this[_symbol_utils.$extra]) {
      this[_symbol_utils.$extra] = {
        numberOfUse: 1,
        pageIndex: -1,
        pageSetIndex: -1
      };
    }
    if (this.relation === "orderedOccurrence") {
      if (this[_symbol_utils.$extra].pageIndex + 1 < this.pageArea.children.length) {
        this[_symbol_utils.$extra].pageIndex += 1;
        const pageArea = this.pageArea.children[this[_symbol_utils.$extra].pageIndex];
        return pageArea[_symbol_utils.$getNextPage]();
      }
      if (this[_symbol_utils.$extra].pageSetIndex + 1 < this.pageSet.children.length) {
        this[_symbol_utils.$extra].pageSetIndex += 1;
        return this.pageSet.children[this[_symbol_utils.$extra].pageSetIndex][_symbol_utils.$getNextPage]();
      }
      if (this[_symbol_utils.$isUsable]()) {
        this[_symbol_utils.$extra].numberOfUse += 1;
        this[_symbol_utils.$extra].pageIndex = -1;
        this[_symbol_utils.$extra].pageSetIndex = -1;
        return this[_symbol_utils.$getNextPage]();
      }
      const parent = this[_symbol_utils.$getParent]();
      if (parent instanceof PageSet) {
        return parent[_symbol_utils.$getNextPage]();
      }
      this[_symbol_utils.$cleanPage]();
      return this[_symbol_utils.$getNextPage]();
    }
    const pageNumber = this[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].pageNumber;
    const parity = pageNumber % 2 === 0 ? "even" : "odd";
    const position = pageNumber === 0 ? "first" : "rest";
    let page = this.pageArea.children.find(p => p.oddOrEven === parity && p.pagePosition === position);
    if (page) {
      return page;
    }
    page = this.pageArea.children.find(p => p.oddOrEven === "any" && p.pagePosition === position);
    if (page) {
      return page;
    }
    page = this.pageArea.children.find(p => p.oddOrEven === "any" && p.pagePosition === "any");
    if (page) {
      return page;
    }
    return this.pageArea.children[0];
  }
}
class Para extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "para", true);
    this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = attributes.id || "";
    this.lineHeight = attributes.lineHeight ? (0, _utils.getMeasurement)(attributes.lineHeight, "0pt") : "";
    this.marginLeft = attributes.marginLeft ? (0, _utils.getMeasurement)(attributes.marginLeft, "0pt") : "";
    this.marginRight = attributes.marginRight ? (0, _utils.getMeasurement)(attributes.marginRight, "0pt") : "";
    this.orphans = (0, _utils.getInteger)({
      data: attributes.orphans,
      defaultValue: 0,
      validate: x => x >= 0
    });
    this.preserve = attributes.preserve || "";
    this.radixOffset = attributes.radixOffset ? (0, _utils.getMeasurement)(attributes.radixOffset, "0pt") : "";
    this.spaceAbove = attributes.spaceAbove ? (0, _utils.getMeasurement)(attributes.spaceAbove, "0pt") : "";
    this.spaceBelow = attributes.spaceBelow ? (0, _utils.getMeasurement)(attributes.spaceBelow, "0pt") : "";
    this.tabDefault = attributes.tabDefault ? (0, _utils.getMeasurement)(this.tabDefault) : "";
    this.tabStops = (attributes.tabStops || "").trim().split(/\s+/).map((x, i) => i % 2 === 1 ? (0, _utils.getMeasurement)(x) : x);
    this.textIndent = attributes.textIndent ? (0, _utils.getMeasurement)(attributes.textIndent, "0pt") : "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.vAlign = (0, _utils.getStringOption)(attributes.vAlign, ["top", "bottom", "middle"]);
    this.widows = (0, _utils.getInteger)({
      data: attributes.widows,
      defaultValue: 0,
      validate: x => x >= 0
    });
    this.hyphenation = null;
  }
  [_symbol_utils.$toStyle]() {
    const style = (0, _html_utils.toStyle)(this, "hAlign");
    if (this.marginLeft !== "") {
      style.paddingLeft = (0, _html_utils.measureToString)(this.marginLeft);
    }
    if (this.marginRight !== "") {
      style.paddingight = (0, _html_utils.measureToString)(this.marginRight);
    }
    if (this.spaceAbove !== "") {
      style.paddingTop = (0, _html_utils.measureToString)(this.spaceAbove);
    }
    if (this.spaceBelow !== "") {
      style.paddingBottom = (0, _html_utils.measureToString)(this.spaceBelow);
    }
    if (this.textIndent !== "") {
      style.textIndent = (0, _html_utils.measureToString)(this.textIndent);
      (0, _html_utils.fixTextIndent)(style);
    }
    if (this.lineHeight > 0) {
      style.lineHeight = (0, _html_utils.measureToString)(this.lineHeight);
    }
    if (this.tabDefault !== "") {
      style.tabSize = (0, _html_utils.measureToString)(this.tabDefault);
    }
    if (this.tabStops.length > 0) {}
    if (this.hyphenatation) {
      Object.assign(style, this.hyphenatation[_symbol_utils.$toStyle]());
    }
    return style;
  }
}
class PasswordEdit extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "passwordEdit", true);
    this.hScrollPolicy = (0, _utils.getStringOption)(attributes.hScrollPolicy, ["auto", "off", "on"]);
    this.id = attributes.id || "";
    this.passwordChar = attributes.passwordChar || "*";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.border = null;
    this.extras = null;
    this.margin = null;
  }
}
class Pattern extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "pattern", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["crossHatch", "crossDiagonal", "diagonalLeft", "diagonalRight", "horizontal", "vertical"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [_symbol_utils.$toStyle](startColor) {
    startColor = startColor ? startColor[_symbol_utils.$toStyle]() : "#FFFFFF";
    const endColor = this.color ? this.color[_symbol_utils.$toStyle]() : "#000000";
    const width = 5;
    const cmd = "repeating-linear-gradient";
    const colors = `${startColor},${startColor} ${width}px,${endColor} ${width}px,${endColor} ${2 * width}px`;
    switch (this.type) {
      case "crossHatch":
        return `${cmd}(to top,${colors}) ${cmd}(to right,${colors})`;
      case "crossDiagonal":
        return `${cmd}(45deg,${colors}) ${cmd}(-45deg,${colors})`;
      case "diagonalLeft":
        return `${cmd}(45deg,${colors})`;
      case "diagonalRight":
        return `${cmd}(-45deg,${colors})`;
      case "horizontal":
        return `${cmd}(to top,${colors})`;
      case "vertical":
        return `${cmd}(to right,${colors})`;
    }
    return "";
  }
}
class Picture extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "picture");
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Proto extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "proto", true);
    this.appearanceFilter = new _xfa_object.XFAObjectArray();
    this.arc = new _xfa_object.XFAObjectArray();
    this.area = new _xfa_object.XFAObjectArray();
    this.assist = new _xfa_object.XFAObjectArray();
    this.barcode = new _xfa_object.XFAObjectArray();
    this.bindItems = new _xfa_object.XFAObjectArray();
    this.bookend = new _xfa_object.XFAObjectArray();
    this.boolean = new _xfa_object.XFAObjectArray();
    this.border = new _xfa_object.XFAObjectArray();
    this.break = new _xfa_object.XFAObjectArray();
    this.breakAfter = new _xfa_object.XFAObjectArray();
    this.breakBefore = new _xfa_object.XFAObjectArray();
    this.button = new _xfa_object.XFAObjectArray();
    this.calculate = new _xfa_object.XFAObjectArray();
    this.caption = new _xfa_object.XFAObjectArray();
    this.certificate = new _xfa_object.XFAObjectArray();
    this.certificates = new _xfa_object.XFAObjectArray();
    this.checkButton = new _xfa_object.XFAObjectArray();
    this.choiceList = new _xfa_object.XFAObjectArray();
    this.color = new _xfa_object.XFAObjectArray();
    this.comb = new _xfa_object.XFAObjectArray();
    this.connect = new _xfa_object.XFAObjectArray();
    this.contentArea = new _xfa_object.XFAObjectArray();
    this.corner = new _xfa_object.XFAObjectArray();
    this.date = new _xfa_object.XFAObjectArray();
    this.dateTime = new _xfa_object.XFAObjectArray();
    this.dateTimeEdit = new _xfa_object.XFAObjectArray();
    this.decimal = new _xfa_object.XFAObjectArray();
    this.defaultUi = new _xfa_object.XFAObjectArray();
    this.desc = new _xfa_object.XFAObjectArray();
    this.digestMethod = new _xfa_object.XFAObjectArray();
    this.digestMethods = new _xfa_object.XFAObjectArray();
    this.draw = new _xfa_object.XFAObjectArray();
    this.edge = new _xfa_object.XFAObjectArray();
    this.encoding = new _xfa_object.XFAObjectArray();
    this.encodings = new _xfa_object.XFAObjectArray();
    this.encrypt = new _xfa_object.XFAObjectArray();
    this.encryptData = new _xfa_object.XFAObjectArray();
    this.encryption = new _xfa_object.XFAObjectArray();
    this.encryptionMethod = new _xfa_object.XFAObjectArray();
    this.encryptionMethods = new _xfa_object.XFAObjectArray();
    this.event = new _xfa_object.XFAObjectArray();
    this.exData = new _xfa_object.XFAObjectArray();
    this.exObject = new _xfa_object.XFAObjectArray();
    this.exclGroup = new _xfa_object.XFAObjectArray();
    this.execute = new _xfa_object.XFAObjectArray();
    this.extras = new _xfa_object.XFAObjectArray();
    this.field = new _xfa_object.XFAObjectArray();
    this.fill = new _xfa_object.XFAObjectArray();
    this.filter = new _xfa_object.XFAObjectArray();
    this.float = new _xfa_object.XFAObjectArray();
    this.font = new _xfa_object.XFAObjectArray();
    this.format = new _xfa_object.XFAObjectArray();
    this.handler = new _xfa_object.XFAObjectArray();
    this.hyphenation = new _xfa_object.XFAObjectArray();
    this.image = new _xfa_object.XFAObjectArray();
    this.imageEdit = new _xfa_object.XFAObjectArray();
    this.integer = new _xfa_object.XFAObjectArray();
    this.issuers = new _xfa_object.XFAObjectArray();
    this.items = new _xfa_object.XFAObjectArray();
    this.keep = new _xfa_object.XFAObjectArray();
    this.keyUsage = new _xfa_object.XFAObjectArray();
    this.line = new _xfa_object.XFAObjectArray();
    this.linear = new _xfa_object.XFAObjectArray();
    this.lockDocument = new _xfa_object.XFAObjectArray();
    this.manifest = new _xfa_object.XFAObjectArray();
    this.margin = new _xfa_object.XFAObjectArray();
    this.mdp = new _xfa_object.XFAObjectArray();
    this.medium = new _xfa_object.XFAObjectArray();
    this.message = new _xfa_object.XFAObjectArray();
    this.numericEdit = new _xfa_object.XFAObjectArray();
    this.occur = new _xfa_object.XFAObjectArray();
    this.oid = new _xfa_object.XFAObjectArray();
    this.oids = new _xfa_object.XFAObjectArray();
    this.overflow = new _xfa_object.XFAObjectArray();
    this.pageArea = new _xfa_object.XFAObjectArray();
    this.pageSet = new _xfa_object.XFAObjectArray();
    this.para = new _xfa_object.XFAObjectArray();
    this.passwordEdit = new _xfa_object.XFAObjectArray();
    this.pattern = new _xfa_object.XFAObjectArray();
    this.picture = new _xfa_object.XFAObjectArray();
    this.radial = new _xfa_object.XFAObjectArray();
    this.reason = new _xfa_object.XFAObjectArray();
    this.reasons = new _xfa_object.XFAObjectArray();
    this.rectangle = new _xfa_object.XFAObjectArray();
    this.ref = new _xfa_object.XFAObjectArray();
    this.script = new _xfa_object.XFAObjectArray();
    this.setProperty = new _xfa_object.XFAObjectArray();
    this.signData = new _xfa_object.XFAObjectArray();
    this.signature = new _xfa_object.XFAObjectArray();
    this.signing = new _xfa_object.XFAObjectArray();
    this.solid = new _xfa_object.XFAObjectArray();
    this.speak = new _xfa_object.XFAObjectArray();
    this.stipple = new _xfa_object.XFAObjectArray();
    this.subform = new _xfa_object.XFAObjectArray();
    this.subformSet = new _xfa_object.XFAObjectArray();
    this.subjectDN = new _xfa_object.XFAObjectArray();
    this.subjectDNs = new _xfa_object.XFAObjectArray();
    this.submit = new _xfa_object.XFAObjectArray();
    this.text = new _xfa_object.XFAObjectArray();
    this.textEdit = new _xfa_object.XFAObjectArray();
    this.time = new _xfa_object.XFAObjectArray();
    this.timeStamp = new _xfa_object.XFAObjectArray();
    this.toolTip = new _xfa_object.XFAObjectArray();
    this.traversal = new _xfa_object.XFAObjectArray();
    this.traverse = new _xfa_object.XFAObjectArray();
    this.ui = new _xfa_object.XFAObjectArray();
    this.validate = new _xfa_object.XFAObjectArray();
    this.value = new _xfa_object.XFAObjectArray();
    this.variables = new _xfa_object.XFAObjectArray();
  }
}
class Radial extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "radial", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["toEdge", "toCenter"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [_symbol_utils.$toStyle](startColor) {
    startColor = startColor ? startColor[_symbol_utils.$toStyle]() : "#FFFFFF";
    const endColor = this.color ? this.color[_symbol_utils.$toStyle]() : "#000000";
    const colors = this.type === "toEdge" ? `${startColor},${endColor}` : `${endColor},${startColor}`;
    return `radial-gradient(circle at center, ${colors})`;
  }
}
class Reason extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "reason");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Reasons extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "reasons", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.reason = new _xfa_object.XFAObjectArray();
  }
}
class Rectangle extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "rectangle", true);
    this.hand = (0, _utils.getStringOption)(attributes.hand, ["even", "left", "right"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.corner = new _xfa_object.XFAObjectArray(4);
    this.edge = new _xfa_object.XFAObjectArray(4);
    this.fill = null;
  }
  [_symbol_utils.$toHTML]() {
    const edge = this.edge.children.length ? this.edge.children[0] : new Edge({});
    const edgeStyle = edge[_symbol_utils.$toStyle]();
    const style = Object.create(null);
    if (this.fill?.presence === "visible") {
      Object.assign(style, this.fill[_symbol_utils.$toStyle]());
    } else {
      style.fill = "transparent";
    }
    style.strokeWidth = (0, _html_utils.measureToString)(edge.presence === "visible" ? edge.thickness : 0);
    style.stroke = edgeStyle.color;
    const corner = this.corner.children.length ? this.corner.children[0] : new Corner({});
    const cornerStyle = corner[_symbol_utils.$toStyle]();
    const rect = {
      name: "rect",
      attributes: {
        xmlns: SVG_NS,
        width: "100%",
        height: "100%",
        x: 0,
        y: 0,
        rx: cornerStyle.radius,
        ry: cornerStyle.radius,
        style
      }
    };
    const svg = {
      name: "svg",
      children: [rect],
      attributes: {
        xmlns: SVG_NS,
        style: {
          overflow: "visible"
        },
        width: "100%",
        height: "100%"
      }
    };
    const parent = this[_symbol_utils.$getParent]()[_symbol_utils.$getParent]();
    if (hasMargin(parent)) {
      return _utils.HTMLResult.success({
        name: "div",
        attributes: {
          style: {
            display: "inline",
            width: "100%",
            height: "100%"
          }
        },
        children: [svg]
      });
    }
    svg.attributes.style.position = "absolute";
    return _utils.HTMLResult.success(svg);
  }
}
class RefElement extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "ref");
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Script extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "script");
    this.binding = attributes.binding || "";
    this.contentType = attributes.contentType || "";
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.runAt = (0, _utils.getStringOption)(attributes.runAt, ["client", "both", "server"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class SetProperty extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "setProperty");
    this.connection = attributes.connection || "";
    this.ref = attributes.ref || "";
    this.target = attributes.target || "";
  }
}
exports.SetProperty = SetProperty;
class SignData extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "signData", true);
    this.id = attributes.id || "";
    this.operation = (0, _utils.getStringOption)(attributes.operation, ["sign", "clear", "verify"]);
    this.ref = attributes.ref || "";
    this.target = attributes.target || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.filter = null;
    this.manifest = null;
  }
}
class Signature extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "signature", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["PDF1.3", "PDF1.6"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.border = null;
    this.extras = null;
    this.filter = null;
    this.manifest = null;
    this.margin = null;
  }
}
class Signing extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "signing", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.certificate = new _xfa_object.XFAObjectArray();
  }
}
class Solid extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "solid", true);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
  }
  [_symbol_utils.$toStyle](startColor) {
    return startColor ? startColor[_symbol_utils.$toStyle]() : "#FFFFFF";
  }
}
class Speak extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "speak");
    this.disable = (0, _utils.getInteger)({
      data: attributes.disable,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.id = attributes.id || "";
    this.priority = (0, _utils.getStringOption)(attributes.priority, ["custom", "caption", "name", "toolTip"]);
    this.rid = attributes.rid || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Stipple extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "stipple", true);
    this.id = attributes.id || "";
    this.rate = (0, _utils.getInteger)({
      data: attributes.rate,
      defaultValue: 50,
      validate: x => x >= 0 && x <= 100
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [_symbol_utils.$toStyle](bgColor) {
    const alpha = this.rate / 100;
    return _util.Util.makeHexColor(Math.round(bgColor.value.r * (1 - alpha) + this.value.r * alpha), Math.round(bgColor.value.g * (1 - alpha) + this.value.g * alpha), Math.round(bgColor.value.b * (1 - alpha) + this.value.b * alpha));
  }
}
class Subform extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "subform", true);
    this.access = (0, _utils.getStringOption)(attributes.access, ["open", "nonInteractive", "protected", "readOnly"]);
    this.allowMacro = (0, _utils.getInteger)({
      data: attributes.allowMacro,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.anchorType = (0, _utils.getStringOption)(attributes.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
    this.colSpan = (0, _utils.getInteger)({
      data: attributes.colSpan,
      defaultValue: 1,
      validate: n => n >= 1 || n === -1
    });
    this.columnWidths = (attributes.columnWidths || "").trim().split(/\s+/).map(x => x === "-1" ? -1 : (0, _utils.getMeasurement)(x));
    this.h = attributes.h ? (0, _utils.getMeasurement)(attributes.h) : "";
    this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = attributes.id || "";
    this.layout = (0, _utils.getStringOption)(attributes.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]);
    this.locale = attributes.locale || "";
    this.maxH = (0, _utils.getMeasurement)(attributes.maxH, "0pt");
    this.maxW = (0, _utils.getMeasurement)(attributes.maxW, "0pt");
    this.mergeMode = (0, _utils.getStringOption)(attributes.mergeMode, ["consumeData", "matchTemplate"]);
    this.minH = (0, _utils.getMeasurement)(attributes.minH, "0pt");
    this.minW = (0, _utils.getMeasurement)(attributes.minW, "0pt");
    this.name = attributes.name || "";
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.restoreState = (0, _utils.getStringOption)(attributes.restoreState, ["manual", "auto"]);
    this.scope = (0, _utils.getStringOption)(attributes.scope, ["name", "none"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.w = attributes.w ? (0, _utils.getMeasurement)(attributes.w) : "";
    this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
    this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
    this.assist = null;
    this.bind = null;
    this.bookend = null;
    this.border = null;
    this.break = null;
    this.calculate = null;
    this.desc = null;
    this.extras = null;
    this.keep = null;
    this.margin = null;
    this.occur = null;
    this.overflow = null;
    this.pageSet = null;
    this.para = null;
    this.traversal = null;
    this.validate = null;
    this.variables = null;
    this.area = new _xfa_object.XFAObjectArray();
    this.breakAfter = new _xfa_object.XFAObjectArray();
    this.breakBefore = new _xfa_object.XFAObjectArray();
    this.connect = new _xfa_object.XFAObjectArray();
    this.draw = new _xfa_object.XFAObjectArray();
    this.event = new _xfa_object.XFAObjectArray();
    this.exObject = new _xfa_object.XFAObjectArray();
    this.exclGroup = new _xfa_object.XFAObjectArray();
    this.field = new _xfa_object.XFAObjectArray();
    this.proto = new _xfa_object.XFAObjectArray();
    this.setProperty = new _xfa_object.XFAObjectArray();
    this.subform = new _xfa_object.XFAObjectArray();
    this.subformSet = new _xfa_object.XFAObjectArray();
  }
  [_symbol_utils.$getSubformParent]() {
    const parent = this[_symbol_utils.$getParent]();
    if (parent instanceof SubformSet) {
      return parent[_symbol_utils.$getSubformParent]();
    }
    return parent;
  }
  [_symbol_utils.$isBindable]() {
    return true;
  }
  [_symbol_utils.$isThereMoreWidth]() {
    return this.layout.endsWith("-tb") && this[_symbol_utils.$extra].attempt === 0 && this[_symbol_utils.$extra].numberInLine > 0 || this[_symbol_utils.$getParent]()[_symbol_utils.$isThereMoreWidth]();
  }
  *[_symbol_utils.$getContainedChildren]() {
    yield* getContainedChildren(this);
  }
  [_symbol_utils.$flushHTML]() {
    return (0, _layout.flushHTML)(this);
  }
  [_symbol_utils.$addHTML](html, bbox) {
    (0, _layout.addHTML)(this, html, bbox);
  }
  [_symbol_utils.$getAvailableSpace]() {
    return (0, _layout.getAvailableSpace)(this);
  }
  [_symbol_utils.$isSplittable]() {
    const parent = this[_symbol_utils.$getSubformParent]();
    if (!parent[_symbol_utils.$isSplittable]()) {
      return false;
    }
    if (this[_symbol_utils.$extra]._isSplittable !== undefined) {
      return this[_symbol_utils.$extra]._isSplittable;
    }
    if (this.layout === "position" || this.layout.includes("row")) {
      this[_symbol_utils.$extra]._isSplittable = false;
      return false;
    }
    if (this.keep && this.keep.intact !== "none") {
      this[_symbol_utils.$extra]._isSplittable = false;
      return false;
    }
    if (parent.layout?.endsWith("-tb") && parent[_symbol_utils.$extra].numberInLine !== 0) {
      return false;
    }
    this[_symbol_utils.$extra]._isSplittable = true;
    return true;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    setTabIndex(this);
    if (this.break) {
      if (this.break.after !== "auto" || this.break.afterTarget !== "") {
        const node = new BreakAfter({
          targetType: this.break.after,
          target: this.break.afterTarget,
          startNew: this.break.startNew.toString()
        });
        node[_symbol_utils.$globalData] = this[_symbol_utils.$globalData];
        this[_symbol_utils.$appendChild](node);
        this.breakAfter.push(node);
      }
      if (this.break.before !== "auto" || this.break.beforeTarget !== "") {
        const node = new BreakBefore({
          targetType: this.break.before,
          target: this.break.beforeTarget,
          startNew: this.break.startNew.toString()
        });
        node[_symbol_utils.$globalData] = this[_symbol_utils.$globalData];
        this[_symbol_utils.$appendChild](node);
        this.breakBefore.push(node);
      }
      if (this.break.overflowTarget !== "") {
        const node = new Overflow({
          target: this.break.overflowTarget,
          leader: this.break.overflowLeader,
          trailer: this.break.overflowTrailer
        });
        node[_symbol_utils.$globalData] = this[_symbol_utils.$globalData];
        this[_symbol_utils.$appendChild](node);
        this.overflow.push(node);
      }
      this[_symbol_utils.$removeChild](this.break);
      this.break = null;
    }
    if (this.presence === "hidden" || this.presence === "inactive") {
      return _utils.HTMLResult.EMPTY;
    }
    if (this.breakBefore.children.length > 1 || this.breakAfter.children.length > 1) {
      (0, _util.warn)("XFA - Several breakBefore or breakAfter in subforms: please file a bug.");
    }
    if (this.breakBefore.children.length >= 1) {
      const breakBefore = this.breakBefore.children[0];
      if (handleBreak(breakBefore)) {
        return _utils.HTMLResult.breakNode(breakBefore);
      }
    }
    if (this[_symbol_utils.$extra]?.afterBreakAfter) {
      return _utils.HTMLResult.EMPTY;
    }
    (0, _html_utils.fixDimensions)(this);
    const children = [];
    const attributes = {
      id: this[_symbol_utils.$uid],
      class: []
    };
    (0, _html_utils.setAccess)(this, attributes.class);
    if (!this[_symbol_utils.$extra]) {
      this[_symbol_utils.$extra] = Object.create(null);
    }
    Object.assign(this[_symbol_utils.$extra], {
      children,
      line: null,
      attributes,
      attempt: 0,
      numberInLine: 0,
      availableSpace: {
        width: Math.min(this.w || Infinity, availableSpace.width),
        height: Math.min(this.h || Infinity, availableSpace.height)
      },
      width: 0,
      height: 0,
      prevHeight: 0,
      currentWidth: 0
    });
    const root = this[_symbol_utils.$getTemplateRoot]();
    const savedNoLayoutFailure = root[_symbol_utils.$extra].noLayoutFailure;
    const isSplittable = this[_symbol_utils.$isSplittable]();
    if (!isSplittable) {
      setFirstUnsplittable(this);
    }
    if (!(0, _layout.checkDimensions)(this, availableSpace)) {
      return _utils.HTMLResult.FAILURE;
    }
    const filter = new Set(["area", "draw", "exclGroup", "field", "subform", "subformSet"]);
    if (this.layout.includes("row")) {
      const columnWidths = this[_symbol_utils.$getSubformParent]().columnWidths;
      if (Array.isArray(columnWidths) && columnWidths.length > 0) {
        this[_symbol_utils.$extra].columnWidths = columnWidths;
        this[_symbol_utils.$extra].currentColumn = 0;
      }
    }
    const style = (0, _html_utils.toStyle)(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign");
    const classNames = ["xfaSubform"];
    const cl = (0, _html_utils.layoutClass)(this);
    if (cl) {
      classNames.push(cl);
    }
    attributes.style = style;
    attributes.class = classNames;
    if (this.name) {
      attributes.xfaName = this.name;
    }
    if (this.overflow) {
      const overflowExtra = this.overflow[_symbol_utils.$getExtra]();
      if (overflowExtra.addLeader) {
        overflowExtra.addLeader = false;
        handleOverflow(this, overflowExtra.leader, availableSpace);
      }
    }
    this[_symbol_utils.$pushPara]();
    const isLrTb = this.layout === "lr-tb" || this.layout === "rl-tb";
    const maxRun = isLrTb ? MAX_ATTEMPTS_FOR_LRTB_LAYOUT : 1;
    for (; this[_symbol_utils.$extra].attempt < maxRun; this[_symbol_utils.$extra].attempt++) {
      if (isLrTb && this[_symbol_utils.$extra].attempt === MAX_ATTEMPTS_FOR_LRTB_LAYOUT - 1) {
        this[_symbol_utils.$extra].numberInLine = 0;
      }
      const result = this[_symbol_utils.$childrenToHTML]({
        filter,
        include: true
      });
      if (result.success) {
        break;
      }
      if (result.isBreak()) {
        this[_symbol_utils.$popPara]();
        return result;
      }
      if (isLrTb && this[_symbol_utils.$extra].attempt === 0 && this[_symbol_utils.$extra].numberInLine === 0 && !root[_symbol_utils.$extra].noLayoutFailure) {
        this[_symbol_utils.$extra].attempt = maxRun;
        break;
      }
    }
    this[_symbol_utils.$popPara]();
    if (!isSplittable) {
      unsetFirstUnsplittable(this);
    }
    root[_symbol_utils.$extra].noLayoutFailure = savedNoLayoutFailure;
    if (this[_symbol_utils.$extra].attempt === maxRun) {
      if (this.overflow) {
        this[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].overflowNode = this.overflow;
      }
      if (!isSplittable) {
        delete this[_symbol_utils.$extra];
      }
      return _utils.HTMLResult.FAILURE;
    }
    if (this.overflow) {
      const overflowExtra = this.overflow[_symbol_utils.$getExtra]();
      if (overflowExtra.addTrailer) {
        overflowExtra.addTrailer = false;
        handleOverflow(this, overflowExtra.trailer, availableSpace);
      }
    }
    let marginH = 0;
    let marginV = 0;
    if (this.margin) {
      marginH = this.margin.leftInset + this.margin.rightInset;
      marginV = this.margin.topInset + this.margin.bottomInset;
    }
    const width = Math.max(this[_symbol_utils.$extra].width + marginH, this.w || 0);
    const height = Math.max(this[_symbol_utils.$extra].height + marginV, this.h || 0);
    const bbox = [this.x, this.y, width, height];
    if (this.w === "") {
      style.width = (0, _html_utils.measureToString)(width);
    }
    if (this.h === "") {
      style.height = (0, _html_utils.measureToString)(height);
    }
    if ((style.width === "0px" || style.height === "0px") && children.length === 0) {
      return _utils.HTMLResult.EMPTY;
    }
    const html = {
      name: "div",
      attributes,
      children
    };
    applyAssist(this, attributes);
    const result = _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox);
    if (this.breakAfter.children.length >= 1) {
      const breakAfter = this.breakAfter.children[0];
      if (handleBreak(breakAfter)) {
        this[_symbol_utils.$extra].afterBreakAfter = result;
        return _utils.HTMLResult.breakNode(breakAfter);
      }
    }
    delete this[_symbol_utils.$extra];
    return result;
  }
}
class SubformSet extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "subformSet", true);
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.relation = (0, _utils.getStringOption)(attributes.relation, ["ordered", "choice", "unordered"]);
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.bookend = null;
    this.break = null;
    this.desc = null;
    this.extras = null;
    this.occur = null;
    this.overflow = null;
    this.breakAfter = new _xfa_object.XFAObjectArray();
    this.breakBefore = new _xfa_object.XFAObjectArray();
    this.subform = new _xfa_object.XFAObjectArray();
    this.subformSet = new _xfa_object.XFAObjectArray();
  }
  *[_symbol_utils.$getContainedChildren]() {
    yield* getContainedChildren(this);
  }
  [_symbol_utils.$getSubformParent]() {
    let parent = this[_symbol_utils.$getParent]();
    while (!(parent instanceof Subform)) {
      parent = parent[_symbol_utils.$getParent]();
    }
    return parent;
  }
  [_symbol_utils.$isBindable]() {
    return true;
  }
}
class SubjectDN extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "subjectDN");
    this.delimiter = attributes.delimiter || ",";
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [_symbol_utils.$finalize]() {
    this[_symbol_utils.$content] = new Map(this[_symbol_utils.$content].split(this.delimiter).map(kv => {
      kv = kv.split("=", 2);
      kv[0] = kv[0].trim();
      return kv;
    }));
  }
}
class SubjectDNs extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "subjectDNs", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.subjectDN = new _xfa_object.XFAObjectArray();
  }
}
class Submit extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "submit", true);
    this.embedPDF = (0, _utils.getInteger)({
      data: attributes.embedPDF,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.format = (0, _utils.getStringOption)(attributes.format, ["xdp", "formdata", "pdf", "urlencoded", "xfd", "xml"]);
    this.id = attributes.id || "";
    this.target = attributes.target || "";
    this.textEncoding = (0, _utils.getKeyword)({
      data: attributes.textEncoding ? attributes.textEncoding.toLowerCase() : "",
      defaultValue: "",
      validate: k => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(k) || k.match(/iso-8859-\d{2}/)
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.xdpContent = attributes.xdpContent || "";
    this.encrypt = null;
    this.encryptData = new _xfa_object.XFAObjectArray();
    this.signData = new _xfa_object.XFAObjectArray();
  }
}
class Template extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "template", true);
    this.baseProfile = (0, _utils.getStringOption)(attributes.baseProfile, ["full", "interactiveForms"]);
    this.extras = null;
    this.subform = new _xfa_object.XFAObjectArray();
  }
  [_symbol_utils.$finalize]() {
    if (this.subform.children.length === 0) {
      (0, _util.warn)("XFA - No subforms in template node.");
    }
    if (this.subform.children.length >= 2) {
      (0, _util.warn)("XFA - Several subforms in template node: please file a bug.");
    }
    this[_symbol_utils.$tabIndex] = DEFAULT_TAB_INDEX;
  }
  [_symbol_utils.$isSplittable]() {
    return true;
  }
  [_symbol_utils.$searchNode](expr, container) {
    if (expr.startsWith("#")) {
      return [this[_symbol_utils.$ids].get(expr.slice(1))];
    }
    return (0, _som.searchNode)(this, container, expr, true, true);
  }
  *[_symbol_utils.$toPages]() {
    if (!this.subform.children.length) {
      return _utils.HTMLResult.success({
        name: "div",
        children: []
      });
    }
    this[_symbol_utils.$extra] = {
      overflowNode: null,
      firstUnsplittable: null,
      currentContentArea: null,
      currentPageArea: null,
      noLayoutFailure: false,
      pageNumber: 1,
      pagePosition: "first",
      oddOrEven: "odd",
      blankOrNotBlank: "nonBlank",
      paraStack: []
    };
    const root = this.subform.children[0];
    root.pageSet[_symbol_utils.$cleanPage]();
    const pageAreas = root.pageSet.pageArea.children;
    const mainHtml = {
      name: "div",
      children: []
    };
    let pageArea = null;
    let breakBefore = null;
    let breakBeforeTarget = null;
    if (root.breakBefore.children.length >= 1) {
      breakBefore = root.breakBefore.children[0];
      breakBeforeTarget = breakBefore.target;
    } else if (root.subform.children.length >= 1 && root.subform.children[0].breakBefore.children.length >= 1) {
      breakBefore = root.subform.children[0].breakBefore.children[0];
      breakBeforeTarget = breakBefore.target;
    } else if (root.break?.beforeTarget) {
      breakBefore = root.break;
      breakBeforeTarget = breakBefore.beforeTarget;
    } else if (root.subform.children.length >= 1 && root.subform.children[0].break?.beforeTarget) {
      breakBefore = root.subform.children[0].break;
      breakBeforeTarget = breakBefore.beforeTarget;
    }
    if (breakBefore) {
      const target = this[_symbol_utils.$searchNode](breakBeforeTarget, breakBefore[_symbol_utils.$getParent]());
      if (target instanceof PageArea) {
        pageArea = target;
        breakBefore[_symbol_utils.$extra] = {};
      }
    }
    if (!pageArea) {
      pageArea = pageAreas[0];
    }
    pageArea[_symbol_utils.$extra] = {
      numberOfUse: 1
    };
    const pageAreaParent = pageArea[_symbol_utils.$getParent]();
    pageAreaParent[_symbol_utils.$extra] = {
      numberOfUse: 1,
      pageIndex: pageAreaParent.pageArea.children.indexOf(pageArea),
      pageSetIndex: 0
    };
    let targetPageArea;
    let leader = null;
    let trailer = null;
    let hasSomething = true;
    let hasSomethingCounter = 0;
    let startIndex = 0;
    while (true) {
      if (!hasSomething) {
        mainHtml.children.pop();
        if (++hasSomethingCounter === MAX_EMPTY_PAGES) {
          (0, _util.warn)("XFA - Something goes wrong: please file a bug.");
          return mainHtml;
        }
      } else {
        hasSomethingCounter = 0;
      }
      targetPageArea = null;
      this[_symbol_utils.$extra].currentPageArea = pageArea;
      const page = pageArea[_symbol_utils.$toHTML]().html;
      mainHtml.children.push(page);
      if (leader) {
        this[_symbol_utils.$extra].noLayoutFailure = true;
        page.children.push(leader[_symbol_utils.$toHTML](pageArea[_symbol_utils.$extra].space).html);
        leader = null;
      }
      if (trailer) {
        this[_symbol_utils.$extra].noLayoutFailure = true;
        page.children.push(trailer[_symbol_utils.$toHTML](pageArea[_symbol_utils.$extra].space).html);
        trailer = null;
      }
      const contentAreas = pageArea.contentArea.children;
      const htmlContentAreas = page.children.filter(node => node.attributes.class.includes("xfaContentarea"));
      hasSomething = false;
      this[_symbol_utils.$extra].firstUnsplittable = null;
      this[_symbol_utils.$extra].noLayoutFailure = false;
      const flush = index => {
        const html = root[_symbol_utils.$flushHTML]();
        if (html) {
          hasSomething ||= html.children?.length > 0;
          htmlContentAreas[index].children.push(html);
        }
      };
      for (let i = startIndex, ii = contentAreas.length; i < ii; i++) {
        const contentArea = this[_symbol_utils.$extra].currentContentArea = contentAreas[i];
        const space = {
          width: contentArea.w,
          height: contentArea.h
        };
        startIndex = 0;
        if (leader) {
          htmlContentAreas[i].children.push(leader[_symbol_utils.$toHTML](space).html);
          leader = null;
        }
        if (trailer) {
          htmlContentAreas[i].children.push(trailer[_symbol_utils.$toHTML](space).html);
          trailer = null;
        }
        const html = root[_symbol_utils.$toHTML](space);
        if (html.success) {
          if (html.html) {
            hasSomething ||= html.html.children?.length > 0;
            htmlContentAreas[i].children.push(html.html);
          } else if (!hasSomething && mainHtml.children.length > 1) {
            mainHtml.children.pop();
          }
          return mainHtml;
        }
        if (html.isBreak()) {
          const node = html.breakNode;
          flush(i);
          if (node.targetType === "auto") {
            continue;
          }
          if (node.leader) {
            leader = this[_symbol_utils.$searchNode](node.leader, node[_symbol_utils.$getParent]());
            leader = leader ? leader[0] : null;
          }
          if (node.trailer) {
            trailer = this[_symbol_utils.$searchNode](node.trailer, node[_symbol_utils.$getParent]());
            trailer = trailer ? trailer[0] : null;
          }
          if (node.targetType === "pageArea") {
            targetPageArea = node[_symbol_utils.$extra].target;
            i = Infinity;
          } else if (!node[_symbol_utils.$extra].target) {
            i = node[_symbol_utils.$extra].index;
          } else {
            targetPageArea = node[_symbol_utils.$extra].target;
            startIndex = node[_symbol_utils.$extra].index + 1;
            i = Infinity;
          }
          continue;
        }
        if (this[_symbol_utils.$extra].overflowNode) {
          const node = this[_symbol_utils.$extra].overflowNode;
          this[_symbol_utils.$extra].overflowNode = null;
          const overflowExtra = node[_symbol_utils.$getExtra]();
          const target = overflowExtra.target;
          overflowExtra.addLeader = overflowExtra.leader !== null;
          overflowExtra.addTrailer = overflowExtra.trailer !== null;
          flush(i);
          const currentIndex = i;
          i = Infinity;
          if (target instanceof PageArea) {
            targetPageArea = target;
          } else if (target instanceof ContentArea) {
            const index = contentAreas.indexOf(target);
            if (index !== -1) {
              if (index > currentIndex) {
                i = index - 1;
              } else {
                startIndex = index;
              }
            } else {
              targetPageArea = target[_symbol_utils.$getParent]();
              startIndex = targetPageArea.contentArea.children.indexOf(target);
            }
          }
          continue;
        }
        flush(i);
      }
      this[_symbol_utils.$extra].pageNumber += 1;
      if (targetPageArea) {
        if (targetPageArea[_symbol_utils.$isUsable]()) {
          targetPageArea[_symbol_utils.$extra].numberOfUse += 1;
        } else {
          targetPageArea = null;
        }
      }
      pageArea = targetPageArea || pageArea[_symbol_utils.$getNextPage]();
      yield null;
    }
  }
}
exports.Template = Template;
class Text extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "text");
    this.id = attributes.id || "";
    this.maxChars = (0, _utils.getInteger)({
      data: attributes.maxChars,
      defaultValue: 0,
      validate: x => x >= 0
    });
    this.name = attributes.name || "";
    this.rid = attributes.rid || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [_symbol_utils.$acceptWhitespace]() {
    return true;
  }
  [_symbol_utils.$onChild](child) {
    if (child[_symbol_utils.$namespaceId] === _namespaces.NamespaceIds.xhtml.id) {
      this[_symbol_utils.$content] = child;
      return true;
    }
    (0, _util.warn)(`XFA - Invalid content in Text: ${child[_symbol_utils.$nodeName]}.`);
    return false;
  }
  [_symbol_utils.$onText](str) {
    if (this[_symbol_utils.$content] instanceof _xfa_object.XFAObject) {
      return;
    }
    super[_symbol_utils.$onText](str);
  }
  [_symbol_utils.$finalize]() {
    if (typeof this[_symbol_utils.$content] === "string") {
      this[_symbol_utils.$content] = this[_symbol_utils.$content].replaceAll("\r\n", "\n");
    }
  }
  [_symbol_utils.$getExtra]() {
    if (typeof this[_symbol_utils.$content] === "string") {
      return this[_symbol_utils.$content].split(/[\u2029\u2028\n]/).reduce((acc, line) => {
        if (line) {
          acc.push(line);
        }
        return acc;
      }, []).join("\n");
    }
    return this[_symbol_utils.$content][_symbol_utils.$text]();
  }
  [_symbol_utils.$toHTML](availableSpace) {
    if (typeof this[_symbol_utils.$content] === "string") {
      const html = valueToHtml(this[_symbol_utils.$content]).html;
      if (this[_symbol_utils.$content].includes("\u2029")) {
        html.name = "div";
        html.children = [];
        this[_symbol_utils.$content].split("\u2029").map(para => para.split(/[\u2028\n]/).reduce((acc, line) => {
          acc.push({
            name: "span",
            value: line
          }, {
            name: "br"
          });
          return acc;
        }, [])).forEach(lines => {
          html.children.push({
            name: "p",
            children: lines
          });
        });
      } else if (/[\u2028\n]/.test(this[_symbol_utils.$content])) {
        html.name = "div";
        html.children = [];
        this[_symbol_utils.$content].split(/[\u2028\n]/).forEach(line => {
          html.children.push({
            name: "span",
            value: line
          }, {
            name: "br"
          });
        });
      }
      return _utils.HTMLResult.success(html);
    }
    return this[_symbol_utils.$content][_symbol_utils.$toHTML](availableSpace);
  }
}
exports.Text = Text;
class TextEdit extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "textEdit", true);
    this.allowRichText = (0, _utils.getInteger)({
      data: attributes.allowRichText,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.hScrollPolicy = (0, _utils.getStringOption)(attributes.hScrollPolicy, ["auto", "off", "on"]);
    this.id = attributes.id || "";
    this.multiLine = (0, _utils.getInteger)({
      data: attributes.multiLine,
      defaultValue: "",
      validate: x => x === 0 || x === 1
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.vScrollPolicy = (0, _utils.getStringOption)(attributes.vScrollPolicy, ["auto", "off", "on"]);
    this.border = null;
    this.comb = null;
    this.extras = null;
    this.margin = null;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    const style = (0, _html_utils.toStyle)(this, "border", "font", "margin");
    let html;
    const field = this[_symbol_utils.$getParent]()[_symbol_utils.$getParent]();
    if (this.multiLine === "") {
      this.multiLine = field instanceof Draw ? 1 : 0;
    }
    if (this.multiLine === 1) {
      html = {
        name: "textarea",
        attributes: {
          dataId: field[_symbol_utils.$data]?.[_symbol_utils.$uid] || field[_symbol_utils.$uid],
          fieldId: field[_symbol_utils.$uid],
          class: ["xfaTextfield"],
          style,
          "aria-label": ariaLabel(field),
          "aria-required": false
        }
      };
    } else {
      html = {
        name: "input",
        attributes: {
          type: "text",
          dataId: field[_symbol_utils.$data]?.[_symbol_utils.$uid] || field[_symbol_utils.$uid],
          fieldId: field[_symbol_utils.$uid],
          class: ["xfaTextfield"],
          style,
          "aria-label": ariaLabel(field),
          "aria-required": false
        }
      };
    }
    if (isRequired(field)) {
      html.attributes["aria-required"] = true;
      html.attributes.required = true;
    }
    return _utils.HTMLResult.success({
      name: "label",
      attributes: {
        class: ["xfaLabel"]
      },
      children: [html]
    });
  }
}
class Time extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "time");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [_symbol_utils.$finalize]() {
    const date = this[_symbol_utils.$content].trim();
    this[_symbol_utils.$content] = date ? new Date(date) : null;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    return valueToHtml(this[_symbol_utils.$content] ? this[_symbol_utils.$content].toString() : "");
  }
}
class TimeStamp extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "timeStamp");
    this.id = attributes.id || "";
    this.server = attributes.server || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class ToolTip extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "toolTip");
    this.id = attributes.id || "";
    this.rid = attributes.rid || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Traversal extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "traversal", true);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.traverse = new _xfa_object.XFAObjectArray();
  }
}
class Traverse extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "traverse", true);
    this.id = attributes.id || "";
    this.operation = (0, _utils.getStringOption)(attributes.operation, ["next", "back", "down", "first", "left", "right", "up"]);
    this.ref = attributes.ref || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.script = null;
  }
  get name() {
    return this.operation;
  }
  [_symbol_utils.$isTransparent]() {
    return false;
  }
}
class Ui extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "ui", true);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.picture = null;
    this.barcode = null;
    this.button = null;
    this.checkButton = null;
    this.choiceList = null;
    this.dateTimeEdit = null;
    this.defaultUi = null;
    this.imageEdit = null;
    this.numericEdit = null;
    this.passwordEdit = null;
    this.signature = null;
    this.textEdit = null;
  }
  [_symbol_utils.$getExtra]() {
    if (this[_symbol_utils.$extra] === undefined) {
      for (const name of Object.getOwnPropertyNames(this)) {
        if (name === "extras" || name === "picture") {
          continue;
        }
        const obj = this[name];
        if (!(obj instanceof _xfa_object.XFAObject)) {
          continue;
        }
        this[_symbol_utils.$extra] = obj;
        return obj;
      }
      this[_symbol_utils.$extra] = null;
    }
    return this[_symbol_utils.$extra];
  }
  [_symbol_utils.$toHTML](availableSpace) {
    const obj = this[_symbol_utils.$getExtra]();
    if (obj) {
      return obj[_symbol_utils.$toHTML](availableSpace);
    }
    return _utils.HTMLResult.EMPTY;
  }
}
class Validate extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "validate", true);
    this.formatTest = (0, _utils.getStringOption)(attributes.formatTest, ["warning", "disabled", "error"]);
    this.id = attributes.id || "";
    this.nullTest = (0, _utils.getStringOption)(attributes.nullTest, ["disabled", "error", "warning"]);
    this.scriptTest = (0, _utils.getStringOption)(attributes.scriptTest, ["error", "disabled", "warning"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.message = null;
    this.picture = null;
    this.script = null;
  }
}
class Value extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "value", true);
    this.id = attributes.id || "";
    this.override = (0, _utils.getInteger)({
      data: attributes.override,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.arc = null;
    this.boolean = null;
    this.date = null;
    this.dateTime = null;
    this.decimal = null;
    this.exData = null;
    this.float = null;
    this.image = null;
    this.integer = null;
    this.line = null;
    this.rectangle = null;
    this.text = null;
    this.time = null;
  }
  [_symbol_utils.$setValue](value) {
    const parent = this[_symbol_utils.$getParent]();
    if (parent instanceof Field) {
      if (parent.ui?.imageEdit) {
        if (!this.image) {
          this.image = new Image({});
          this[_symbol_utils.$appendChild](this.image);
        }
        this.image[_symbol_utils.$content] = value[_symbol_utils.$content];
        return;
      }
    }
    const valueName = value[_symbol_utils.$nodeName];
    if (this[valueName] !== null) {
      this[valueName][_symbol_utils.$content] = value[_symbol_utils.$content];
      return;
    }
    for (const name of Object.getOwnPropertyNames(this)) {
      const obj = this[name];
      if (obj instanceof _xfa_object.XFAObject) {
        this[name] = null;
        this[_symbol_utils.$removeChild](obj);
      }
    }
    this[value[_symbol_utils.$nodeName]] = value;
    this[_symbol_utils.$appendChild](value);
  }
  [_symbol_utils.$text]() {
    if (this.exData) {
      if (typeof this.exData[_symbol_utils.$content] === "string") {
        return this.exData[_symbol_utils.$content].trim();
      }
      return this.exData[_symbol_utils.$content][_symbol_utils.$text]().trim();
    }
    for (const name of Object.getOwnPropertyNames(this)) {
      if (name === "image") {
        continue;
      }
      const obj = this[name];
      if (obj instanceof _xfa_object.XFAObject) {
        return (obj[_symbol_utils.$content] || "").toString().trim();
      }
    }
    return null;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    for (const name of Object.getOwnPropertyNames(this)) {
      const obj = this[name];
      if (!(obj instanceof _xfa_object.XFAObject)) {
        continue;
      }
      return obj[_symbol_utils.$toHTML](availableSpace);
    }
    return _utils.HTMLResult.EMPTY;
  }
}
exports.Value = Value;
class Variables extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "variables", true);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.boolean = new _xfa_object.XFAObjectArray();
    this.date = new _xfa_object.XFAObjectArray();
    this.dateTime = new _xfa_object.XFAObjectArray();
    this.decimal = new _xfa_object.XFAObjectArray();
    this.exData = new _xfa_object.XFAObjectArray();
    this.float = new _xfa_object.XFAObjectArray();
    this.image = new _xfa_object.XFAObjectArray();
    this.integer = new _xfa_object.XFAObjectArray();
    this.manifest = new _xfa_object.XFAObjectArray();
    this.script = new _xfa_object.XFAObjectArray();
    this.text = new _xfa_object.XFAObjectArray();
    this.time = new _xfa_object.XFAObjectArray();
  }
  [_symbol_utils.$isTransparent]() {
    return true;
  }
}
class TemplateNamespace {
  static [_namespaces.$buildXFAObject](name, attributes) {
    if (TemplateNamespace.hasOwnProperty(name)) {
      const node = TemplateNamespace[name](attributes);
      node[_symbol_utils.$setSetAttributes](attributes);
      return node;
    }
    return undefined;
  }
  static appearanceFilter(attrs) {
    return new AppearanceFilter(attrs);
  }
  static arc(attrs) {
    return new Arc(attrs);
  }
  static area(attrs) {
    return new Area(attrs);
  }
  static assist(attrs) {
    return new Assist(attrs);
  }
  static barcode(attrs) {
    return new Barcode(attrs);
  }
  static bind(attrs) {
    return new Bind(attrs);
  }
  static bindItems(attrs) {
    return new BindItems(attrs);
  }
  static bookend(attrs) {
    return new Bookend(attrs);
  }
  static boolean(attrs) {
    return new BooleanElement(attrs);
  }
  static border(attrs) {
    return new Border(attrs);
  }
  static break(attrs) {
    return new Break(attrs);
  }
  static breakAfter(attrs) {
    return new BreakAfter(attrs);
  }
  static breakBefore(attrs) {
    return new BreakBefore(attrs);
  }
  static button(attrs) {
    return new Button(attrs);
  }
  static calculate(attrs) {
    return new Calculate(attrs);
  }
  static caption(attrs) {
    return new Caption(attrs);
  }
  static certificate(attrs) {
    return new Certificate(attrs);
  }
  static certificates(attrs) {
    return new Certificates(attrs);
  }
  static checkButton(attrs) {
    return new CheckButton(attrs);
  }
  static choiceList(attrs) {
    return new ChoiceList(attrs);
  }
  static color(attrs) {
    return new Color(attrs);
  }
  static comb(attrs) {
    return new Comb(attrs);
  }
  static connect(attrs) {
    return new Connect(attrs);
  }
  static contentArea(attrs) {
    return new ContentArea(attrs);
  }
  static corner(attrs) {
    return new Corner(attrs);
  }
  static date(attrs) {
    return new DateElement(attrs);
  }
  static dateTime(attrs) {
    return new DateTime(attrs);
  }
  static dateTimeEdit(attrs) {
    return new DateTimeEdit(attrs);
  }
  static decimal(attrs) {
    return new Decimal(attrs);
  }
  static defaultUi(attrs) {
    return new DefaultUi(attrs);
  }
  static desc(attrs) {
    return new Desc(attrs);
  }
  static digestMethod(attrs) {
    return new DigestMethod(attrs);
  }
  static digestMethods(attrs) {
    return new DigestMethods(attrs);
  }
  static draw(attrs) {
    return new Draw(attrs);
  }
  static edge(attrs) {
    return new Edge(attrs);
  }
  static encoding(attrs) {
    return new Encoding(attrs);
  }
  static encodings(attrs) {
    return new Encodings(attrs);
  }
  static encrypt(attrs) {
    return new Encrypt(attrs);
  }
  static encryptData(attrs) {
    return new EncryptData(attrs);
  }
  static encryption(attrs) {
    return new Encryption(attrs);
  }
  static encryptionMethod(attrs) {
    return new EncryptionMethod(attrs);
  }
  static encryptionMethods(attrs) {
    return new EncryptionMethods(attrs);
  }
  static event(attrs) {
    return new Event(attrs);
  }
  static exData(attrs) {
    return new ExData(attrs);
  }
  static exObject(attrs) {
    return new ExObject(attrs);
  }
  static exclGroup(attrs) {
    return new ExclGroup(attrs);
  }
  static execute(attrs) {
    return new Execute(attrs);
  }
  static extras(attrs) {
    return new Extras(attrs);
  }
  static field(attrs) {
    return new Field(attrs);
  }
  static fill(attrs) {
    return new Fill(attrs);
  }
  static filter(attrs) {
    return new Filter(attrs);
  }
  static float(attrs) {
    return new Float(attrs);
  }
  static font(attrs) {
    return new Font(attrs);
  }
  static format(attrs) {
    return new Format(attrs);
  }
  static handler(attrs) {
    return new Handler(attrs);
  }
  static hyphenation(attrs) {
    return new Hyphenation(attrs);
  }
  static image(attrs) {
    return new Image(attrs);
  }
  static imageEdit(attrs) {
    return new ImageEdit(attrs);
  }
  static integer(attrs) {
    return new Integer(attrs);
  }
  static issuers(attrs) {
    return new Issuers(attrs);
  }
  static items(attrs) {
    return new Items(attrs);
  }
  static keep(attrs) {
    return new Keep(attrs);
  }
  static keyUsage(attrs) {
    return new KeyUsage(attrs);
  }
  static line(attrs) {
    return new Line(attrs);
  }
  static linear(attrs) {
    return new Linear(attrs);
  }
  static lockDocument(attrs) {
    return new LockDocument(attrs);
  }
  static manifest(attrs) {
    return new Manifest(attrs);
  }
  static margin(attrs) {
    return new Margin(attrs);
  }
  static mdp(attrs) {
    return new Mdp(attrs);
  }
  static medium(attrs) {
    return new Medium(attrs);
  }
  static message(attrs) {
    return new Message(attrs);
  }
  static numericEdit(attrs) {
    return new NumericEdit(attrs);
  }
  static occur(attrs) {
    return new Occur(attrs);
  }
  static oid(attrs) {
    return new Oid(attrs);
  }
  static oids(attrs) {
    return new Oids(attrs);
  }
  static overflow(attrs) {
    return new Overflow(attrs);
  }
  static pageArea(attrs) {
    return new PageArea(attrs);
  }
  static pageSet(attrs) {
    return new PageSet(attrs);
  }
  static para(attrs) {
    return new Para(attrs);
  }
  static passwordEdit(attrs) {
    return new PasswordEdit(attrs);
  }
  static pattern(attrs) {
    return new Pattern(attrs);
  }
  static picture(attrs) {
    return new Picture(attrs);
  }
  static proto(attrs) {
    return new Proto(attrs);
  }
  static radial(attrs) {
    return new Radial(attrs);
  }
  static reason(attrs) {
    return new Reason(attrs);
  }
  static reasons(attrs) {
    return new Reasons(attrs);
  }
  static rectangle(attrs) {
    return new Rectangle(attrs);
  }
  static ref(attrs) {
    return new RefElement(attrs);
  }
  static script(attrs) {
    return new Script(attrs);
  }
  static setProperty(attrs) {
    return new SetProperty(attrs);
  }
  static signData(attrs) {
    return new SignData(attrs);
  }
  static signature(attrs) {
    return new Signature(attrs);
  }
  static signing(attrs) {
    return new Signing(attrs);
  }
  static solid(attrs) {
    return new Solid(attrs);
  }
  static speak(attrs) {
    return new Speak(attrs);
  }
  static stipple(attrs) {
    return new Stipple(attrs);
  }
  static subform(attrs) {
    return new Subform(attrs);
  }
  static subformSet(attrs) {
    return new SubformSet(attrs);
  }
  static subjectDN(attrs) {
    return new SubjectDN(attrs);
  }
  static subjectDNs(attrs) {
    return new SubjectDNs(attrs);
  }
  static submit(attrs) {
    return new Submit(attrs);
  }
  static template(attrs) {
    return new Template(attrs);
  }
  static text(attrs) {
    return new Text(attrs);
  }
  static textEdit(attrs) {
    return new TextEdit(attrs);
  }
  static time(attrs) {
    return new Time(attrs);
  }
  static timeStamp(attrs) {
    return new TimeStamp(attrs);
  }
  static toolTip(attrs) {
    return new ToolTip(attrs);
  }
  static traversal(attrs) {
    return new Traversal(attrs);
  }
  static traverse(attrs) {
    return new Traverse(attrs);
  }
  static ui(attrs) {
    return new Ui(attrs);
  }
  static validate(attrs) {
    return new Validate(attrs);
  }
  static value(attrs) {
    return new Value(attrs);
  }
  static variables(attrs) {
    return new Variables(attrs);
  }
}
exports.TemplateNamespace = TemplateNamespace;

/***/ }),
/* 81 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.NamespaceIds = exports.$buildXFAObject = void 0;
const $buildXFAObject = Symbol();
exports.$buildXFAObject = $buildXFAObject;
const NamespaceIds = {
  config: {
    id: 0,
    check: ns => ns.startsWith("http://www.xfa.org/schema/xci/")
  },
  connectionSet: {
    id: 1,
    check: ns => ns.startsWith("http://www.xfa.org/schema/xfa-connection-set/")
  },
  datasets: {
    id: 2,
    check: ns => ns.startsWith("http://www.xfa.org/schema/xfa-data/")
  },
  form: {
    id: 3,
    check: ns => ns.startsWith("http://www.xfa.org/schema/xfa-form/")
  },
  localeSet: {
    id: 4,
    check: ns => ns.startsWith("http://www.xfa.org/schema/xfa-locale-set/")
  },
  pdf: {
    id: 5,
    check: ns => ns === "http://ns.adobe.com/xdp/pdf/"
  },
  signature: {
    id: 6,
    check: ns => ns === "http://www.w3.org/2000/09/xmldsig#"
  },
  sourceSet: {
    id: 7,
    check: ns => ns.startsWith("http://www.xfa.org/schema/xfa-source-set/")
  },
  stylesheet: {
    id: 8,
    check: ns => ns === "http://www.w3.org/1999/XSL/Transform"
  },
  template: {
    id: 9,
    check: ns => ns.startsWith("http://www.xfa.org/schema/xfa-template/")
  },
  xdc: {
    id: 10,
    check: ns => ns.startsWith("http://www.xfa.org/schema/xdc/")
  },
  xdp: {
    id: 11,
    check: ns => ns === "http://ns.adobe.com/xdp/"
  },
  xfdf: {
    id: 12,
    check: ns => ns === "http://ns.adobe.com/xfdf/"
  },
  xhtml: {
    id: 13,
    check: ns => ns === "http://www.w3.org/1999/xhtml"
  },
  xmpmeta: {
    id: 14,
    check: ns => ns === "http://ns.adobe.com/xmpmeta/"
  }
};
exports.NamespaceIds = NamespaceIds;

/***/ }),
/* 82 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.addHTML = addHTML;
exports.checkDimensions = checkDimensions;
exports.flushHTML = flushHTML;
exports.getAvailableSpace = getAvailableSpace;
var _symbol_utils = __w_pdfjs_require__(78);
var _html_utils = __w_pdfjs_require__(83);
function createLine(node, children) {
  return {
    name: "div",
    attributes: {
      class: [node.layout === "lr-tb" ? "xfaLr" : "xfaRl"]
    },
    children
  };
}
function flushHTML(node) {
  if (!node[_symbol_utils.$extra]) {
    return null;
  }
  const attributes = node[_symbol_utils.$extra].attributes;
  const html = {
    name: "div",
    attributes,
    children: node[_symbol_utils.$extra].children
  };
  if (node[_symbol_utils.$extra].failingNode) {
    const htmlFromFailing = node[_symbol_utils.$extra].failingNode[_symbol_utils.$flushHTML]();
    if (htmlFromFailing) {
      if (node.layout.endsWith("-tb")) {
        html.children.push(createLine(node, [htmlFromFailing]));
      } else {
        html.children.push(htmlFromFailing);
      }
    }
  }
  if (html.children.length === 0) {
    return null;
  }
  return html;
}
function addHTML(node, html, bbox) {
  const extra = node[_symbol_utils.$extra];
  const availableSpace = extra.availableSpace;
  const [x, y, w, h] = bbox;
  switch (node.layout) {
    case "position":
      {
        extra.width = Math.max(extra.width, x + w);
        extra.height = Math.max(extra.height, y + h);
        extra.children.push(html);
        break;
      }
    case "lr-tb":
    case "rl-tb":
      if (!extra.line || extra.attempt === 1) {
        extra.line = createLine(node, []);
        extra.children.push(extra.line);
        extra.numberInLine = 0;
      }
      extra.numberInLine += 1;
      extra.line.children.push(html);
      if (extra.attempt === 0) {
        extra.currentWidth += w;
        extra.height = Math.max(extra.height, extra.prevHeight + h);
      } else {
        extra.currentWidth = w;
        extra.prevHeight = extra.height;
        extra.height += h;
        extra.attempt = 0;
      }
      extra.width = Math.max(extra.width, extra.currentWidth);
      break;
    case "rl-row":
    case "row":
      {
        extra.children.push(html);
        extra.width += w;
        extra.height = Math.max(extra.height, h);
        const height = (0, _html_utils.measureToString)(extra.height);
        for (const child of extra.children) {
          child.attributes.style.height = height;
        }
        break;
      }
    case "table":
      {
        extra.width = Math.min(availableSpace.width, Math.max(extra.width, w));
        extra.height += h;
        extra.children.push(html);
        break;
      }
    case "tb":
      {
        extra.width = Math.min(availableSpace.width, Math.max(extra.width, w));
        extra.height += h;
        extra.children.push(html);
        break;
      }
  }
}
function getAvailableSpace(node) {
  const availableSpace = node[_symbol_utils.$extra].availableSpace;
  const marginV = node.margin ? node.margin.topInset + node.margin.bottomInset : 0;
  const marginH = node.margin ? node.margin.leftInset + node.margin.rightInset : 0;
  switch (node.layout) {
    case "lr-tb":
    case "rl-tb":
      if (node[_symbol_utils.$extra].attempt === 0) {
        return {
          width: availableSpace.width - marginH - node[_symbol_utils.$extra].currentWidth,
          height: availableSpace.height - marginV - node[_symbol_utils.$extra].prevHeight
        };
      }
      return {
        width: availableSpace.width - marginH,
        height: availableSpace.height - marginV - node[_symbol_utils.$extra].height
      };
    case "rl-row":
    case "row":
      const width = node[_symbol_utils.$extra].columnWidths.slice(node[_symbol_utils.$extra].currentColumn).reduce((a, x) => a + x);
      return {
        width,
        height: availableSpace.height - marginH
      };
    case "table":
    case "tb":
      return {
        width: availableSpace.width - marginH,
        height: availableSpace.height - marginV - node[_symbol_utils.$extra].height
      };
    case "position":
    default:
      return availableSpace;
  }
}
function getTransformedBBox(node) {
  let w = node.w === "" ? NaN : node.w;
  let h = node.h === "" ? NaN : node.h;
  let [centerX, centerY] = [0, 0];
  switch (node.anchorType || "") {
    case "bottomCenter":
      [centerX, centerY] = [w / 2, h];
      break;
    case "bottomLeft":
      [centerX, centerY] = [0, h];
      break;
    case "bottomRight":
      [centerX, centerY] = [w, h];
      break;
    case "middleCenter":
      [centerX, centerY] = [w / 2, h / 2];
      break;
    case "middleLeft":
      [centerX, centerY] = [0, h / 2];
      break;
    case "middleRight":
      [centerX, centerY] = [w, h / 2];
      break;
    case "topCenter":
      [centerX, centerY] = [w / 2, 0];
      break;
    case "topRight":
      [centerX, centerY] = [w, 0];
      break;
  }
  let x, y;
  switch (node.rotate || 0) {
    case 0:
      [x, y] = [-centerX, -centerY];
      break;
    case 90:
      [x, y] = [-centerY, centerX];
      [w, h] = [h, -w];
      break;
    case 180:
      [x, y] = [centerX, centerY];
      [w, h] = [-w, -h];
      break;
    case 270:
      [x, y] = [centerY, -centerX];
      [w, h] = [-h, w];
      break;
  }
  return [node.x + x + Math.min(0, w), node.y + y + Math.min(0, h), Math.abs(w), Math.abs(h)];
}
function checkDimensions(node, space) {
  if (node[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].firstUnsplittable === null) {
    return true;
  }
  if (node.w === 0 || node.h === 0) {
    return true;
  }
  const ERROR = 2;
  const parent = node[_symbol_utils.$getSubformParent]();
  const attempt = parent[_symbol_utils.$extra]?.attempt || 0;
  const [, y, w, h] = getTransformedBBox(node);
  switch (parent.layout) {
    case "lr-tb":
    case "rl-tb":
      if (attempt === 0) {
        if (!node[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].noLayoutFailure) {
          if (node.h !== "" && Math.round(h - space.height) > ERROR) {
            return false;
          }
          if (node.w !== "") {
            if (Math.round(w - space.width) <= ERROR) {
              return true;
            }
            if (parent[_symbol_utils.$extra].numberInLine === 0) {
              return space.height > ERROR;
            }
            return false;
          }
          return space.width > ERROR;
        }
        if (node.w !== "") {
          return Math.round(w - space.width) <= ERROR;
        }
        return space.width > ERROR;
      }
      if (node[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].noLayoutFailure) {
        return true;
      }
      if (node.h !== "" && Math.round(h - space.height) > ERROR) {
        return false;
      }
      if (node.w === "" || Math.round(w - space.width) <= ERROR) {
        return space.height > ERROR;
      }
      if (parent[_symbol_utils.$isThereMoreWidth]()) {
        return false;
      }
      return space.height > ERROR;
    case "table":
    case "tb":
      if (node[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].noLayoutFailure) {
        return true;
      }
      if (node.h !== "" && !node[_symbol_utils.$isSplittable]()) {
        return Math.round(h - space.height) <= ERROR;
      }
      if (node.w === "" || Math.round(w - space.width) <= ERROR) {
        return space.height > ERROR;
      }
      if (parent[_symbol_utils.$isThereMoreWidth]()) {
        return false;
      }
      return space.height > ERROR;
    case "position":
      if (node[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].noLayoutFailure) {
        return true;
      }
      if (node.h === "" || Math.round(h + y - space.height) <= ERROR) {
        return true;
      }
      const area = node[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].currentContentArea;
      return h + y > area.h;
    case "rl-row":
    case "row":
      if (node[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].noLayoutFailure) {
        return true;
      }
      if (node.h !== "") {
        return Math.round(h - space.height) <= ERROR;
      }
      return true;
    default:
      return true;
  }
}

/***/ }),
/* 83 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.computeBbox = computeBbox;
exports.createWrapper = createWrapper;
exports.fixDimensions = fixDimensions;
exports.fixTextIndent = fixTextIndent;
exports.fixURL = fixURL;
exports.isPrintOnly = isPrintOnly;
exports.layoutClass = layoutClass;
exports.layoutNode = layoutNode;
exports.measureToString = measureToString;
exports.setAccess = setAccess;
exports.setFontFamily = setFontFamily;
exports.setMinMaxDimensions = setMinMaxDimensions;
exports.setPara = setPara;
exports.toStyle = toStyle;
var _symbol_utils = __w_pdfjs_require__(78);
var _util = __w_pdfjs_require__(2);
var _utils = __w_pdfjs_require__(84);
var _fonts = __w_pdfjs_require__(85);
var _text = __w_pdfjs_require__(86);
var _xfa_object = __w_pdfjs_require__(87);
function measureToString(m) {
  if (typeof m === "string") {
    return "0px";
  }
  return Number.isInteger(m) ? `${m}px` : `${m.toFixed(2)}px`;
}
const converters = {
  anchorType(node, style) {
    const parent = node[_symbol_utils.$getSubformParent]();
    if (!parent || parent.layout && parent.layout !== "position") {
      return;
    }
    if (!("transform" in style)) {
      style.transform = "";
    }
    switch (node.anchorType) {
      case "bottomCenter":
        style.transform += "translate(-50%, -100%)";
        break;
      case "bottomLeft":
        style.transform += "translate(0,-100%)";
        break;
      case "bottomRight":
        style.transform += "translate(-100%,-100%)";
        break;
      case "middleCenter":
        style.transform += "translate(-50%,-50%)";
        break;
      case "middleLeft":
        style.transform += "translate(0,-50%)";
        break;
      case "middleRight":
        style.transform += "translate(-100%,-50%)";
        break;
      case "topCenter":
        style.transform += "translate(-50%,0)";
        break;
      case "topRight":
        style.transform += "translate(-100%,0)";
        break;
    }
  },
  dimensions(node, style) {
    const parent = node[_symbol_utils.$getSubformParent]();
    let width = node.w;
    const height = node.h;
    if (parent.layout?.includes("row")) {
      const extra = parent[_symbol_utils.$extra];
      const colSpan = node.colSpan;
      let w;
      if (colSpan === -1) {
        w = extra.columnWidths.slice(extra.currentColumn).reduce((a, x) => a + x, 0);
        extra.currentColumn = 0;
      } else {
        w = extra.columnWidths.slice(extra.currentColumn, extra.currentColumn + colSpan).reduce((a, x) => a + x, 0);
        extra.currentColumn = (extra.currentColumn + node.colSpan) % extra.columnWidths.length;
      }
      if (!isNaN(w)) {
        width = node.w = w;
      }
    }
    style.width = width !== "" ? measureToString(width) : "auto";
    style.height = height !== "" ? measureToString(height) : "auto";
  },
  position(node, style) {
    const parent = node[_symbol_utils.$getSubformParent]();
    if (parent?.layout && parent.layout !== "position") {
      return;
    }
    style.position = "absolute";
    style.left = measureToString(node.x);
    style.top = measureToString(node.y);
  },
  rotate(node, style) {
    if (node.rotate) {
      if (!("transform" in style)) {
        style.transform = "";
      }
      style.transform += `rotate(-${node.rotate}deg)`;
      style.transformOrigin = "top left";
    }
  },
  presence(node, style) {
    switch (node.presence) {
      case "invisible":
        style.visibility = "hidden";
        break;
      case "hidden":
      case "inactive":
        style.display = "none";
        break;
    }
  },
  hAlign(node, style) {
    if (node[_symbol_utils.$nodeName] === "para") {
      switch (node.hAlign) {
        case "justifyAll":
          style.textAlign = "justify-all";
          break;
        case "radix":
          style.textAlign = "left";
          break;
        default:
          style.textAlign = node.hAlign;
      }
    } else {
      switch (node.hAlign) {
        case "left":
          style.alignSelf = "start";
          break;
        case "center":
          style.alignSelf = "center";
          break;
        case "right":
          style.alignSelf = "end";
          break;
      }
    }
  },
  margin(node, style) {
    if (node.margin) {
      style.margin = node.margin[_symbol_utils.$toStyle]().margin;
    }
  }
};
function setMinMaxDimensions(node, style) {
  const parent = node[_symbol_utils.$getSubformParent]();
  if (parent.layout === "position") {
    if (node.minW > 0) {
      style.minWidth = measureToString(node.minW);
    }
    if (node.maxW > 0) {
      style.maxWidth = measureToString(node.maxW);
    }
    if (node.minH > 0) {
      style.minHeight = measureToString(node.minH);
    }
    if (node.maxH > 0) {
      style.maxHeight = measureToString(node.maxH);
    }
  }
}
function layoutText(text, xfaFont, margin, lineHeight, fontFinder, width) {
  const measure = new _text.TextMeasure(xfaFont, margin, lineHeight, fontFinder);
  if (typeof text === "string") {
    measure.addString(text);
  } else {
    text[_symbol_utils.$pushGlyphs](measure);
  }
  return measure.compute(width);
}
function layoutNode(node, availableSpace) {
  let height = null;
  let width = null;
  let isBroken = false;
  if ((!node.w || !node.h) && node.value) {
    let marginH = 0;
    let marginV = 0;
    if (node.margin) {
      marginH = node.margin.leftInset + node.margin.rightInset;
      marginV = node.margin.topInset + node.margin.bottomInset;
    }
    let lineHeight = null;
    let margin = null;
    if (node.para) {
      margin = Object.create(null);
      lineHeight = node.para.lineHeight === "" ? null : node.para.lineHeight;
      margin.top = node.para.spaceAbove === "" ? 0 : node.para.spaceAbove;
      margin.bottom = node.para.spaceBelow === "" ? 0 : node.para.spaceBelow;
      margin.left = node.para.marginLeft === "" ? 0 : node.para.marginLeft;
      margin.right = node.para.marginRight === "" ? 0 : node.para.marginRight;
    }
    let font = node.font;
    if (!font) {
      const root = node[_symbol_utils.$getTemplateRoot]();
      let parent = node[_symbol_utils.$getParent]();
      while (parent && parent !== root) {
        if (parent.font) {
          font = parent.font;
          break;
        }
        parent = parent[_symbol_utils.$getParent]();
      }
    }
    const maxWidth = (node.w || availableSpace.width) - marginH;
    const fontFinder = node[_symbol_utils.$globalData].fontFinder;
    if (node.value.exData && node.value.exData[_symbol_utils.$content] && node.value.exData.contentType === "text/html") {
      const res = layoutText(node.value.exData[_symbol_utils.$content], font, margin, lineHeight, fontFinder, maxWidth);
      width = res.width;
      height = res.height;
      isBroken = res.isBroken;
    } else {
      const text = node.value[_symbol_utils.$text]();
      if (text) {
        const res = layoutText(text, font, margin, lineHeight, fontFinder, maxWidth);
        width = res.width;
        height = res.height;
        isBroken = res.isBroken;
      }
    }
    if (width !== null && !node.w) {
      width += marginH;
    }
    if (height !== null && !node.h) {
      height += marginV;
    }
  }
  return {
    w: width,
    h: height,
    isBroken
  };
}
function computeBbox(node, html, availableSpace) {
  let bbox;
  if (node.w !== "" && node.h !== "") {
    bbox = [node.x, node.y, node.w, node.h];
  } else {
    if (!availableSpace) {
      return null;
    }
    let width = node.w;
    if (width === "") {
      if (node.maxW === 0) {
        const parent = node[_symbol_utils.$getSubformParent]();
        width = parent.layout === "position" && parent.w !== "" ? 0 : node.minW;
      } else {
        width = Math.min(node.maxW, availableSpace.width);
      }
      html.attributes.style.width = measureToString(width);
    }
    let height = node.h;
    if (height === "") {
      if (node.maxH === 0) {
        const parent = node[_symbol_utils.$getSubformParent]();
        height = parent.layout === "position" && parent.h !== "" ? 0 : node.minH;
      } else {
        height = Math.min(node.maxH, availableSpace.height);
      }
      html.attributes.style.height = measureToString(height);
    }
    bbox = [node.x, node.y, width, height];
  }
  return bbox;
}
function fixDimensions(node) {
  const parent = node[_symbol_utils.$getSubformParent]();
  if (parent.layout?.includes("row")) {
    const extra = parent[_symbol_utils.$extra];
    const colSpan = node.colSpan;
    let width;
    if (colSpan === -1) {
      width = extra.columnWidths.slice(extra.currentColumn).reduce((a, w) => a + w, 0);
    } else {
      width = extra.columnWidths.slice(extra.currentColumn, extra.currentColumn + colSpan).reduce((a, w) => a + w, 0);
    }
    if (!isNaN(width)) {
      node.w = width;
    }
  }
  if (parent.layout && parent.layout !== "position") {
    node.x = node.y = 0;
  }
  if (node.layout === "table") {
    if (node.w === "" && Array.isArray(node.columnWidths)) {
      node.w = node.columnWidths.reduce((a, x) => a + x, 0);
    }
  }
}
function layoutClass(node) {
  switch (node.layout) {
    case "position":
      return "xfaPosition";
    case "lr-tb":
      return "xfaLrTb";
    case "rl-row":
      return "xfaRlRow";
    case "rl-tb":
      return "xfaRlTb";
    case "row":
      return "xfaRow";
    case "table":
      return "xfaTable";
    case "tb":
      return "xfaTb";
    default:
      return "xfaPosition";
  }
}
function toStyle(node, ...names) {
  const style = Object.create(null);
  for (const name of names) {
    const value = node[name];
    if (value === null) {
      continue;
    }
    if (converters.hasOwnProperty(name)) {
      converters[name](node, style);
      continue;
    }
    if (value instanceof _xfa_object.XFAObject) {
      const newStyle = value[_symbol_utils.$toStyle]();
      if (newStyle) {
        Object.assign(style, newStyle);
      } else {
        (0, _util.warn)(`(DEBUG) - XFA - style for ${name} not implemented yet`);
      }
    }
  }
  return style;
}
function createWrapper(node, html) {
  const {
    attributes
  } = html;
  const {
    style
  } = attributes;
  const wrapper = {
    name: "div",
    attributes: {
      class: ["xfaWrapper"],
      style: Object.create(null)
    },
    children: []
  };
  attributes.class.push("xfaWrapped");
  if (node.border) {
    const {
      widths,
      insets
    } = node.border[_symbol_utils.$extra];
    let width, height;
    let top = insets[0];
    let left = insets[3];
    const insetsH = insets[0] + insets[2];
    const insetsW = insets[1] + insets[3];
    switch (node.border.hand) {
      case "even":
        top -= widths[0] / 2;
        left -= widths[3] / 2;
        width = `calc(100% + ${(widths[1] + widths[3]) / 2 - insetsW}px)`;
        height = `calc(100% + ${(widths[0] + widths[2]) / 2 - insetsH}px)`;
        break;
      case "left":
        top -= widths[0];
        left -= widths[3];
        width = `calc(100% + ${widths[1] + widths[3] - insetsW}px)`;
        height = `calc(100% + ${widths[0] + widths[2] - insetsH}px)`;
        break;
      case "right":
        width = insetsW ? `calc(100% - ${insetsW}px)` : "100%";
        height = insetsH ? `calc(100% - ${insetsH}px)` : "100%";
        break;
    }
    const classNames = ["xfaBorder"];
    if (isPrintOnly(node.border)) {
      classNames.push("xfaPrintOnly");
    }
    const border = {
      name: "div",
      attributes: {
        class: classNames,
        style: {
          top: `${top}px`,
          left: `${left}px`,
          width,
          height
        }
      },
      children: []
    };
    for (const key of ["border", "borderWidth", "borderColor", "borderRadius", "borderStyle"]) {
      if (style[key] !== undefined) {
        border.attributes.style[key] = style[key];
        delete style[key];
      }
    }
    wrapper.children.push(border, html);
  } else {
    wrapper.children.push(html);
  }
  for (const key of ["background", "backgroundClip", "top", "left", "width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "transform", "transformOrigin", "visibility"]) {
    if (style[key] !== undefined) {
      wrapper.attributes.style[key] = style[key];
      delete style[key];
    }
  }
  wrapper.attributes.style.position = style.position === "absolute" ? "absolute" : "relative";
  delete style.position;
  if (style.alignSelf) {
    wrapper.attributes.style.alignSelf = style.alignSelf;
    delete style.alignSelf;
  }
  return wrapper;
}
function fixTextIndent(styles) {
  const indent = (0, _utils.getMeasurement)(styles.textIndent, "0px");
  if (indent >= 0) {
    return;
  }
  const align = styles.textAlign === "right" ? "right" : "left";
  const name = "padding" + (align === "left" ? "Left" : "Right");
  const padding = (0, _utils.getMeasurement)(styles[name], "0px");
  styles[name] = `${padding - indent}px`;
}
function setAccess(node, classNames) {
  switch (node.access) {
    case "nonInteractive":
      classNames.push("xfaNonInteractive");
      break;
    case "readOnly":
      classNames.push("xfaReadOnly");
      break;
    case "protected":
      classNames.push("xfaDisabled");
      break;
  }
}
function isPrintOnly(node) {
  return node.relevant.length > 0 && !node.relevant[0].excluded && node.relevant[0].viewname === "print";
}
function getCurrentPara(node) {
  const stack = node[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].paraStack;
  return stack.length ? stack.at(-1) : null;
}
function setPara(node, nodeStyle, value) {
  if (value.attributes.class?.includes("xfaRich")) {
    if (nodeStyle) {
      if (node.h === "") {
        nodeStyle.height = "auto";
      }
      if (node.w === "") {
        nodeStyle.width = "auto";
      }
    }
    const para = getCurrentPara(node);
    if (para) {
      const valueStyle = value.attributes.style;
      valueStyle.display = "flex";
      valueStyle.flexDirection = "column";
      switch (para.vAlign) {
        case "top":
          valueStyle.justifyContent = "start";
          break;
        case "bottom":
          valueStyle.justifyContent = "end";
          break;
        case "middle":
          valueStyle.justifyContent = "center";
          break;
      }
      const paraStyle = para[_symbol_utils.$toStyle]();
      for (const [key, val] of Object.entries(paraStyle)) {
        if (!(key in valueStyle)) {
          valueStyle[key] = val;
        }
      }
    }
  }
}
function setFontFamily(xfaFont, node, fontFinder, style) {
  if (!fontFinder) {
    delete style.fontFamily;
    return;
  }
  const name = (0, _utils.stripQuotes)(xfaFont.typeface);
  style.fontFamily = `"${name}"`;
  const typeface = fontFinder.find(name);
  if (typeface) {
    const {
      fontFamily
    } = typeface.regular.cssFontInfo;
    if (fontFamily !== name) {
      style.fontFamily = `"${fontFamily}"`;
    }
    const para = getCurrentPara(node);
    if (para && para.lineHeight !== "") {
      return;
    }
    if (style.lineHeight) {
      return;
    }
    const pdfFont = (0, _fonts.selectFont)(xfaFont, typeface);
    if (pdfFont) {
      style.lineHeight = Math.max(1.2, pdfFont.lineHeight);
    }
  }
}
function fixURL(str) {
  const absoluteUrl = (0, _util.createValidAbsoluteUrl)(str, null, {
    addDefaultProtocol: true,
    tryConvertEncoding: true
  });
  return absoluteUrl ? absoluteUrl.href : null;
}

/***/ }),
/* 84 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.HTMLResult = void 0;
exports.getBBox = getBBox;
exports.getColor = getColor;
exports.getFloat = getFloat;
exports.getInteger = getInteger;
exports.getKeyword = getKeyword;
exports.getMeasurement = getMeasurement;
exports.getRatio = getRatio;
exports.getRelevant = getRelevant;
exports.getStringOption = getStringOption;
exports.stripQuotes = stripQuotes;
var _util = __w_pdfjs_require__(2);
const dimConverters = {
  pt: x => x,
  cm: x => x / 2.54 * 72,
  mm: x => x / (10 * 2.54) * 72,
  in: x => x * 72,
  px: x => x
};
const measurementPattern = /([+-]?\d+\.?\d*)(.*)/;
function stripQuotes(str) {
  if (str.startsWith("'") || str.startsWith('"')) {
    return str.slice(1, -1);
  }
  return str;
}
function getInteger({
  data,
  defaultValue,
  validate
}) {
  if (!data) {
    return defaultValue;
  }
  data = data.trim();
  const n = parseInt(data, 10);
  if (!isNaN(n) && validate(n)) {
    return n;
  }
  return defaultValue;
}
function getFloat({
  data,
  defaultValue,
  validate
}) {
  if (!data) {
    return defaultValue;
  }
  data = data.trim();
  const n = parseFloat(data);
  if (!isNaN(n) && validate(n)) {
    return n;
  }
  return defaultValue;
}
function getKeyword({
  data,
  defaultValue,
  validate
}) {
  if (!data) {
    return defaultValue;
  }
  data = data.trim();
  if (validate(data)) {
    return data;
  }
  return defaultValue;
}
function getStringOption(data, options) {
  return getKeyword({
    data,
    defaultValue: options[0],
    validate: k => options.includes(k)
  });
}
function getMeasurement(str, def = "0") {
  def ||= "0";
  if (!str) {
    return getMeasurement(def);
  }
  const match = str.trim().match(measurementPattern);
  if (!match) {
    return getMeasurement(def);
  }
  const [, valueStr, unit] = match;
  const value = parseFloat(valueStr);
  if (isNaN(value)) {
    return getMeasurement(def);
  }
  if (value === 0) {
    return 0;
  }
  const conv = dimConverters[unit];
  if (conv) {
    return conv(value);
  }
  return value;
}
function getRatio(data) {
  if (!data) {
    return {
      num: 1,
      den: 1
    };
  }
  const ratio = data.trim().split(/\s*:\s*/).map(x => parseFloat(x)).filter(x => !isNaN(x));
  if (ratio.length === 1) {
    ratio.push(1);
  }
  if (ratio.length === 0) {
    return {
      num: 1,
      den: 1
    };
  }
  const [num, den] = ratio;
  return {
    num,
    den
  };
}
function getRelevant(data) {
  if (!data) {
    return [];
  }
  return data.trim().split(/\s+/).map(e => {
    return {
      excluded: e[0] === "-",
      viewname: e.substring(1)
    };
  });
}
function getColor(data, def = [0, 0, 0]) {
  let [r, g, b] = def;
  if (!data) {
    return {
      r,
      g,
      b
    };
  }
  const color = data.trim().split(/\s*,\s*/).map(c => Math.min(Math.max(0, parseInt(c.trim(), 10)), 255)).map(c => isNaN(c) ? 0 : c);
  if (color.length < 3) {
    return {
      r,
      g,
      b
    };
  }
  [r, g, b] = color;
  return {
    r,
    g,
    b
  };
}
function getBBox(data) {
  const def = -1;
  if (!data) {
    return {
      x: def,
      y: def,
      width: def,
      height: def
    };
  }
  const bbox = data.trim().split(/\s*,\s*/).map(m => getMeasurement(m, "-1"));
  if (bbox.length < 4 || bbox[2] < 0 || bbox[3] < 0) {
    return {
      x: def,
      y: def,
      width: def,
      height: def
    };
  }
  const [x, y, width, height] = bbox;
  return {
    x,
    y,
    width,
    height
  };
}
class HTMLResult {
  static get FAILURE() {
    return (0, _util.shadow)(this, "FAILURE", new HTMLResult(false, null, null, null));
  }
  static get EMPTY() {
    return (0, _util.shadow)(this, "EMPTY", new HTMLResult(true, null, null, null));
  }
  constructor(success, html, bbox, breakNode) {
    this.success = success;
    this.html = html;
    this.bbox = bbox;
    this.breakNode = breakNode;
  }
  isBreak() {
    return !!this.breakNode;
  }
  static breakNode(node) {
    return new HTMLResult(false, null, null, node);
  }
  static success(html, bbox = null) {
    return new HTMLResult(true, html, bbox, null);
  }
}
exports.HTMLResult = HTMLResult;

/***/ }),
/* 85 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FontFinder = void 0;
exports.getMetrics = getMetrics;
exports.selectFont = selectFont;
var _symbol_utils = __w_pdfjs_require__(78);
var _utils = __w_pdfjs_require__(84);
var _util = __w_pdfjs_require__(2);
class FontFinder {
  constructor(pdfFonts) {
    this.fonts = new Map();
    this.cache = new Map();
    this.warned = new Set();
    this.defaultFont = null;
    this.add(pdfFonts);
  }
  add(pdfFonts, reallyMissingFonts = null) {
    for (const pdfFont of pdfFonts) {
      this.addPdfFont(pdfFont);
    }
    for (const pdfFont of this.fonts.values()) {
      if (!pdfFont.regular) {
        pdfFont.regular = pdfFont.italic || pdfFont.bold || pdfFont.bolditalic;
      }
    }
    if (!reallyMissingFonts || reallyMissingFonts.size === 0) {
      return;
    }
    const myriad = this.fonts.get("PdfJS-Fallback-PdfJS-XFA");
    for (const missing of reallyMissingFonts) {
      this.fonts.set(missing, myriad);
    }
  }
  addPdfFont(pdfFont) {
    const cssFontInfo = pdfFont.cssFontInfo;
    const name = cssFontInfo.fontFamily;
    let font = this.fonts.get(name);
    if (!font) {
      font = Object.create(null);
      this.fonts.set(name, font);
      if (!this.defaultFont) {
        this.defaultFont = font;
      }
    }
    let property = "";
    const fontWeight = parseFloat(cssFontInfo.fontWeight);
    if (parseFloat(cssFontInfo.italicAngle) !== 0) {
      property = fontWeight >= 700 ? "bolditalic" : "italic";
    } else if (fontWeight >= 700) {
      property = "bold";
    }
    if (!property) {
      if (pdfFont.name.includes("Bold") || pdfFont.psName?.includes("Bold")) {
        property = "bold";
      }
      if (pdfFont.name.includes("Italic") || pdfFont.name.endsWith("It") || pdfFont.psName?.includes("Italic") || pdfFont.psName?.endsWith("It")) {
        property += "italic";
      }
    }
    if (!property) {
      property = "regular";
    }
    font[property] = pdfFont;
  }
  getDefault() {
    return this.defaultFont;
  }
  find(fontName, mustWarn = true) {
    let font = this.fonts.get(fontName) || this.cache.get(fontName);
    if (font) {
      return font;
    }
    const pattern = /,|-|_| |bolditalic|bold|italic|regular|it/gi;
    let name = fontName.replaceAll(pattern, "");
    font = this.fonts.get(name);
    if (font) {
      this.cache.set(fontName, font);
      return font;
    }
    name = name.toLowerCase();
    const maybe = [];
    for (const [family, pdfFont] of this.fonts.entries()) {
      if (family.replaceAll(pattern, "").toLowerCase().startsWith(name)) {
        maybe.push(pdfFont);
      }
    }
    if (maybe.length === 0) {
      for (const [, pdfFont] of this.fonts.entries()) {
        if (pdfFont.regular.name?.replaceAll(pattern, "").toLowerCase().startsWith(name)) {
          maybe.push(pdfFont);
        }
      }
    }
    if (maybe.length === 0) {
      name = name.replaceAll(/psmt|mt/gi, "");
      for (const [family, pdfFont] of this.fonts.entries()) {
        if (family.replaceAll(pattern, "").toLowerCase().startsWith(name)) {
          maybe.push(pdfFont);
        }
      }
    }
    if (maybe.length === 0) {
      for (const pdfFont of this.fonts.values()) {
        if (pdfFont.regular.name?.replaceAll(pattern, "").toLowerCase().startsWith(name)) {
          maybe.push(pdfFont);
        }
      }
    }
    if (maybe.length >= 1) {
      if (maybe.length !== 1 && mustWarn) {
        (0, _util.warn)(`XFA - Too many choices to guess the correct font: ${fontName}`);
      }
      this.cache.set(fontName, maybe[0]);
      return maybe[0];
    }
    if (mustWarn && !this.warned.has(fontName)) {
      this.warned.add(fontName);
      (0, _util.warn)(`XFA - Cannot find the font: ${fontName}`);
    }
    return null;
  }
}
exports.FontFinder = FontFinder;
function selectFont(xfaFont, typeface) {
  if (xfaFont.posture === "italic") {
    if (xfaFont.weight === "bold") {
      return typeface.bolditalic;
    }
    return typeface.italic;
  } else if (xfaFont.weight === "bold") {
    return typeface.bold;
  }
  return typeface.regular;
}
function getMetrics(xfaFont, real = false) {
  let pdfFont = null;
  if (xfaFont) {
    const name = (0, _utils.stripQuotes)(xfaFont.typeface);
    const typeface = xfaFont[_symbol_utils.$globalData].fontFinder.find(name);
    pdfFont = selectFont(xfaFont, typeface);
  }
  if (!pdfFont) {
    return {
      lineHeight: 12,
      lineGap: 2,
      lineNoGap: 10
    };
  }
  const size = xfaFont.size || 10;
  const lineHeight = pdfFont.lineHeight ? Math.max(real ? 0 : 1.2, pdfFont.lineHeight) : 1.2;
  const lineGap = pdfFont.lineGap === undefined ? 0.2 : pdfFont.lineGap;
  return {
    lineHeight: lineHeight * size,
    lineGap: lineGap * size,
    lineNoGap: Math.max(1, lineHeight - lineGap) * size
  };
}

/***/ }),
/* 86 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TextMeasure = void 0;
var _fonts = __w_pdfjs_require__(85);
const WIDTH_FACTOR = 1.02;
class FontInfo {
  constructor(xfaFont, margin, lineHeight, fontFinder) {
    this.lineHeight = lineHeight;
    this.paraMargin = margin || {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    };
    if (!xfaFont) {
      [this.pdfFont, this.xfaFont] = this.defaultFont(fontFinder);
      return;
    }
    this.xfaFont = {
      typeface: xfaFont.typeface,
      posture: xfaFont.posture,
      weight: xfaFont.weight,
      size: xfaFont.size,
      letterSpacing: xfaFont.letterSpacing
    };
    const typeface = fontFinder.find(xfaFont.typeface);
    if (!typeface) {
      [this.pdfFont, this.xfaFont] = this.defaultFont(fontFinder);
      return;
    }
    this.pdfFont = (0, _fonts.selectFont)(xfaFont, typeface);
    if (!this.pdfFont) {
      [this.pdfFont, this.xfaFont] = this.defaultFont(fontFinder);
    }
  }
  defaultFont(fontFinder) {
    const font = fontFinder.find("Helvetica", false) || fontFinder.find("Myriad Pro", false) || fontFinder.find("Arial", false) || fontFinder.getDefault();
    if (font?.regular) {
      const pdfFont = font.regular;
      const info = pdfFont.cssFontInfo;
      const xfaFont = {
        typeface: info.fontFamily,
        posture: "normal",
        weight: "normal",
        size: 10,
        letterSpacing: 0
      };
      return [pdfFont, xfaFont];
    }
    const xfaFont = {
      typeface: "Courier",
      posture: "normal",
      weight: "normal",
      size: 10,
      letterSpacing: 0
    };
    return [null, xfaFont];
  }
}
class FontSelector {
  constructor(defaultXfaFont, defaultParaMargin, defaultLineHeight, fontFinder) {
    this.fontFinder = fontFinder;
    this.stack = [new FontInfo(defaultXfaFont, defaultParaMargin, defaultLineHeight, fontFinder)];
  }
  pushData(xfaFont, margin, lineHeight) {
    const lastFont = this.stack.at(-1);
    for (const name of ["typeface", "posture", "weight", "size", "letterSpacing"]) {
      if (!xfaFont[name]) {
        xfaFont[name] = lastFont.xfaFont[name];
      }
    }
    for (const name of ["top", "bottom", "left", "right"]) {
      if (isNaN(margin[name])) {
        margin[name] = lastFont.paraMargin[name];
      }
    }
    const fontInfo = new FontInfo(xfaFont, margin, lineHeight || lastFont.lineHeight, this.fontFinder);
    if (!fontInfo.pdfFont) {
      fontInfo.pdfFont = lastFont.pdfFont;
    }
    this.stack.push(fontInfo);
  }
  popFont() {
    this.stack.pop();
  }
  topFont() {
    return this.stack.at(-1);
  }
}
class TextMeasure {
  constructor(defaultXfaFont, defaultParaMargin, defaultLineHeight, fonts) {
    this.glyphs = [];
    this.fontSelector = new FontSelector(defaultXfaFont, defaultParaMargin, defaultLineHeight, fonts);
    this.extraHeight = 0;
  }
  pushData(xfaFont, margin, lineHeight) {
    this.fontSelector.pushData(xfaFont, margin, lineHeight);
  }
  popFont(xfaFont) {
    return this.fontSelector.popFont();
  }
  addPara() {
    const lastFont = this.fontSelector.topFont();
    this.extraHeight += lastFont.paraMargin.top + lastFont.paraMargin.bottom;
  }
  addString(str) {
    if (!str) {
      return;
    }
    const lastFont = this.fontSelector.topFont();
    const fontSize = lastFont.xfaFont.size;
    if (lastFont.pdfFont) {
      const letterSpacing = lastFont.xfaFont.letterSpacing;
      const pdfFont = lastFont.pdfFont;
      const fontLineHeight = pdfFont.lineHeight || 1.2;
      const lineHeight = lastFont.lineHeight || Math.max(1.2, fontLineHeight) * fontSize;
      const lineGap = pdfFont.lineGap === undefined ? 0.2 : pdfFont.lineGap;
      const noGap = fontLineHeight - lineGap;
      const firstLineHeight = Math.max(1, noGap) * fontSize;
      const scale = fontSize / 1000;
      const fallbackWidth = pdfFont.defaultWidth || pdfFont.charsToGlyphs(" ")[0].width;
      for (const line of str.split(/[\u2029\n]/)) {
        const encodedLine = pdfFont.encodeString(line).join("");
        const glyphs = pdfFont.charsToGlyphs(encodedLine);
        for (const glyph of glyphs) {
          const width = glyph.width || fallbackWidth;
          this.glyphs.push([width * scale + letterSpacing, lineHeight, firstLineHeight, glyph.unicode, false]);
        }
        this.glyphs.push([0, 0, 0, "\n", true]);
      }
      this.glyphs.pop();
      return;
    }
    for (const line of str.split(/[\u2029\n]/)) {
      for (const char of line.split("")) {
        this.glyphs.push([fontSize, 1.2 * fontSize, fontSize, char, false]);
      }
      this.glyphs.push([0, 0, 0, "\n", true]);
    }
    this.glyphs.pop();
  }
  compute(maxWidth) {
    let lastSpacePos = -1,
      lastSpaceWidth = 0,
      width = 0,
      height = 0,
      currentLineWidth = 0,
      currentLineHeight = 0;
    let isBroken = false;
    let isFirstLine = true;
    for (let i = 0, ii = this.glyphs.length; i < ii; i++) {
      const [glyphWidth, lineHeight, firstLineHeight, char, isEOL] = this.glyphs[i];
      const isSpace = char === " ";
      const glyphHeight = isFirstLine ? firstLineHeight : lineHeight;
      if (isEOL) {
        width = Math.max(width, currentLineWidth);
        currentLineWidth = 0;
        height += currentLineHeight;
        currentLineHeight = glyphHeight;
        lastSpacePos = -1;
        lastSpaceWidth = 0;
        isFirstLine = false;
        continue;
      }
      if (isSpace) {
        if (currentLineWidth + glyphWidth > maxWidth) {
          width = Math.max(width, currentLineWidth);
          currentLineWidth = 0;
          height += currentLineHeight;
          currentLineHeight = glyphHeight;
          lastSpacePos = -1;
          lastSpaceWidth = 0;
          isBroken = true;
          isFirstLine = false;
        } else {
          currentLineHeight = Math.max(glyphHeight, currentLineHeight);
          lastSpaceWidth = currentLineWidth;
          currentLineWidth += glyphWidth;
          lastSpacePos = i;
        }
        continue;
      }
      if (currentLineWidth + glyphWidth > maxWidth) {
        height += currentLineHeight;
        currentLineHeight = glyphHeight;
        if (lastSpacePos !== -1) {
          i = lastSpacePos;
          width = Math.max(width, lastSpaceWidth);
          currentLineWidth = 0;
          lastSpacePos = -1;
          lastSpaceWidth = 0;
        } else {
          width = Math.max(width, currentLineWidth);
          currentLineWidth = glyphWidth;
        }
        isBroken = true;
        isFirstLine = false;
        continue;
      }
      currentLineWidth += glyphWidth;
      currentLineHeight = Math.max(glyphHeight, currentLineHeight);
    }
    width = Math.max(width, currentLineWidth);
    height += currentLineHeight + this.extraHeight;
    return {
      width: WIDTH_FACTOR * width,
      height,
      isBroken
    };
  }
}
exports.TextMeasure = TextMeasure;

/***/ }),
/* 87 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XmlObject = exports.XFAObjectArray = exports.XFAObject = exports.XFAAttribute = exports.StringObject = exports.OptionObject = exports.Option10 = exports.Option01 = exports.IntegerObject = exports.ContentObject = void 0;
var _symbol_utils = __w_pdfjs_require__(78);
var _utils = __w_pdfjs_require__(84);
var _util = __w_pdfjs_require__(2);
var _core_utils = __w_pdfjs_require__(3);
var _namespaces = __w_pdfjs_require__(81);
var _som = __w_pdfjs_require__(88);
const _applyPrototype = Symbol();
const _attributes = Symbol();
const _attributeNames = Symbol();
const _children = Symbol("_children");
const _cloneAttribute = Symbol();
const _dataValue = Symbol();
const _defaultValue = Symbol();
const _filteredChildrenGenerator = Symbol();
const _getPrototype = Symbol();
const _getUnsetAttributes = Symbol();
const _hasChildren = Symbol();
const _max = Symbol();
const _options = Symbol();
const _parent = Symbol("parent");
const _resolvePrototypesHelper = Symbol();
const _setAttributes = Symbol();
const _validator = Symbol();
let uid = 0;
const NS_DATASETS = _namespaces.NamespaceIds.datasets.id;
class XFAObject {
  constructor(nsId, name, hasChildren = false) {
    this[_symbol_utils.$namespaceId] = nsId;
    this[_symbol_utils.$nodeName] = name;
    this[_hasChildren] = hasChildren;
    this[_parent] = null;
    this[_children] = [];
    this[_symbol_utils.$uid] = `${name}${uid++}`;
    this[_symbol_utils.$globalData] = null;
  }
  get isXFAObject() {
    return true;
  }
  get isXFAObjectArray() {
    return false;
  }
  createNodes(path) {
    let root = this,
      node = null;
    for (const {
      name,
      index
    } of path) {
      for (let i = 0, ii = isFinite(index) ? index : 0; i <= ii; i++) {
        const nsId = root[_symbol_utils.$namespaceId] === NS_DATASETS ? -1 : root[_symbol_utils.$namespaceId];
        node = new XmlObject(nsId, name);
        root[_symbol_utils.$appendChild](node);
      }
      root = node;
    }
    return node;
  }
  [_symbol_utils.$onChild](child) {
    if (!this[_hasChildren] || !this[_symbol_utils.$onChildCheck](child)) {
      return false;
    }
    const name = child[_symbol_utils.$nodeName];
    const node = this[name];
    if (node instanceof XFAObjectArray) {
      if (node.push(child)) {
        this[_symbol_utils.$appendChild](child);
        return true;
      }
    } else {
      if (node !== null) {
        this[_symbol_utils.$removeChild](node);
      }
      this[name] = child;
      this[_symbol_utils.$appendChild](child);
      return true;
    }
    let id = "";
    if (this.id) {
      id = ` (id: ${this.id})`;
    } else if (this.name) {
      id = ` (name: ${this.name} ${this.h.value})`;
    }
    (0, _util.warn)(`XFA - node "${this[_symbol_utils.$nodeName]}"${id} has already enough "${name}"!`);
    return false;
  }
  [_symbol_utils.$onChildCheck](child) {
    return this.hasOwnProperty(child[_symbol_utils.$nodeName]) && child[_symbol_utils.$namespaceId] === this[_symbol_utils.$namespaceId];
  }
  [_symbol_utils.$isNsAgnostic]() {
    return false;
  }
  [_symbol_utils.$acceptWhitespace]() {
    return false;
  }
  [_symbol_utils.$isCDATAXml]() {
    return false;
  }
  [_symbol_utils.$isBindable]() {
    return false;
  }
  [_symbol_utils.$popPara]() {
    if (this.para) {
      this[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].paraStack.pop();
    }
  }
  [_symbol_utils.$pushPara]() {
    this[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].paraStack.push(this.para);
  }
  [_symbol_utils.$setId](ids) {
    if (this.id && this[_symbol_utils.$namespaceId] === _namespaces.NamespaceIds.template.id) {
      ids.set(this.id, this);
    }
  }
  [_symbol_utils.$getTemplateRoot]() {
    return this[_symbol_utils.$globalData].template;
  }
  [_symbol_utils.$isSplittable]() {
    return false;
  }
  [_symbol_utils.$isThereMoreWidth]() {
    return false;
  }
  [_symbol_utils.$appendChild](child) {
    child[_parent] = this;
    this[_children].push(child);
    if (!child[_symbol_utils.$globalData] && this[_symbol_utils.$globalData]) {
      child[_symbol_utils.$globalData] = this[_symbol_utils.$globalData];
    }
  }
  [_symbol_utils.$removeChild](child) {
    const i = this[_children].indexOf(child);
    this[_children].splice(i, 1);
  }
  [_symbol_utils.$hasSettableValue]() {
    return this.hasOwnProperty("value");
  }
  [_symbol_utils.$setValue](_) {}
  [_symbol_utils.$onText](_) {}
  [_symbol_utils.$finalize]() {}
  [_symbol_utils.$clean](builder) {
    delete this[_hasChildren];
    if (this[_symbol_utils.$cleanup]) {
      builder.clean(this[_symbol_utils.$cleanup]);
      delete this[_symbol_utils.$cleanup];
    }
  }
  [_symbol_utils.$indexOf](child) {
    return this[_children].indexOf(child);
  }
  [_symbol_utils.$insertAt](i, child) {
    child[_parent] = this;
    this[_children].splice(i, 0, child);
    if (!child[_symbol_utils.$globalData] && this[_symbol_utils.$globalData]) {
      child[_symbol_utils.$globalData] = this[_symbol_utils.$globalData];
    }
  }
  [_symbol_utils.$isTransparent]() {
    return !this.name;
  }
  [_symbol_utils.$lastAttribute]() {
    return "";
  }
  [_symbol_utils.$text]() {
    if (this[_children].length === 0) {
      return this[_symbol_utils.$content];
    }
    return this[_children].map(c => c[_symbol_utils.$text]()).join("");
  }
  get [_attributeNames]() {
    const proto = Object.getPrototypeOf(this);
    if (!proto._attributes) {
      const attributes = proto._attributes = new Set();
      for (const name of Object.getOwnPropertyNames(this)) {
        if (this[name] === null || this[name] instanceof XFAObject || this[name] instanceof XFAObjectArray) {
          break;
        }
        attributes.add(name);
      }
    }
    return (0, _util.shadow)(this, _attributeNames, proto._attributes);
  }
  [_symbol_utils.$isDescendent](parent) {
    let node = this;
    while (node) {
      if (node === parent) {
        return true;
      }
      node = node[_symbol_utils.$getParent]();
    }
    return false;
  }
  [_symbol_utils.$getParent]() {
    return this[_parent];
  }
  [_symbol_utils.$getSubformParent]() {
    return this[_symbol_utils.$getParent]();
  }
  [_symbol_utils.$getChildren](name = null) {
    if (!name) {
      return this[_children];
    }
    return this[name];
  }
  [_symbol_utils.$dump]() {
    const dumped = Object.create(null);
    if (this[_symbol_utils.$content]) {
      dumped.$content = this[_symbol_utils.$content];
    }
    for (const name of Object.getOwnPropertyNames(this)) {
      const value = this[name];
      if (value === null) {
        continue;
      }
      if (value instanceof XFAObject) {
        dumped[name] = value[_symbol_utils.$dump]();
      } else if (value instanceof XFAObjectArray) {
        if (!value.isEmpty()) {
          dumped[name] = value.dump();
        }
      } else {
        dumped[name] = value;
      }
    }
    return dumped;
  }
  [_symbol_utils.$toStyle]() {
    return null;
  }
  [_symbol_utils.$toHTML]() {
    return _utils.HTMLResult.EMPTY;
  }
  *[_symbol_utils.$getContainedChildren]() {
    for (const node of this[_symbol_utils.$getChildren]()) {
      yield node;
    }
  }
  *[_filteredChildrenGenerator](filter, include) {
    for (const node of this[_symbol_utils.$getContainedChildren]()) {
      if (!filter || include === filter.has(node[_symbol_utils.$nodeName])) {
        const availableSpace = this[_symbol_utils.$getAvailableSpace]();
        const res = node[_symbol_utils.$toHTML](availableSpace);
        if (!res.success) {
          this[_symbol_utils.$extra].failingNode = node;
        }
        yield res;
      }
    }
  }
  [_symbol_utils.$flushHTML]() {
    return null;
  }
  [_symbol_utils.$addHTML](html, bbox) {
    this[_symbol_utils.$extra].children.push(html);
  }
  [_symbol_utils.$getAvailableSpace]() {}
  [_symbol_utils.$childrenToHTML]({
    filter = null,
    include = true
  }) {
    if (!this[_symbol_utils.$extra].generator) {
      this[_symbol_utils.$extra].generator = this[_filteredChildrenGenerator](filter, include);
    } else {
      const availableSpace = this[_symbol_utils.$getAvailableSpace]();
      const res = this[_symbol_utils.$extra].failingNode[_symbol_utils.$toHTML](availableSpace);
      if (!res.success) {
        return res;
      }
      if (res.html) {
        this[_symbol_utils.$addHTML](res.html, res.bbox);
      }
      delete this[_symbol_utils.$extra].failingNode;
    }
    while (true) {
      const gen = this[_symbol_utils.$extra].generator.next();
      if (gen.done) {
        break;
      }
      const res = gen.value;
      if (!res.success) {
        return res;
      }
      if (res.html) {
        this[_symbol_utils.$addHTML](res.html, res.bbox);
      }
    }
    this[_symbol_utils.$extra].generator = null;
    return _utils.HTMLResult.EMPTY;
  }
  [_symbol_utils.$setSetAttributes](attributes) {
    this[_setAttributes] = new Set(Object.keys(attributes));
  }
  [_getUnsetAttributes](protoAttributes) {
    const allAttr = this[_attributeNames];
    const setAttr = this[_setAttributes];
    return [...protoAttributes].filter(x => allAttr.has(x) && !setAttr.has(x));
  }
  [_symbol_utils.$resolvePrototypes](ids, ancestors = new Set()) {
    for (const child of this[_children]) {
      child[_resolvePrototypesHelper](ids, ancestors);
    }
  }
  [_resolvePrototypesHelper](ids, ancestors) {
    const proto = this[_getPrototype](ids, ancestors);
    if (proto) {
      this[_applyPrototype](proto, ids, ancestors);
    } else {
      this[_symbol_utils.$resolvePrototypes](ids, ancestors);
    }
  }
  [_getPrototype](ids, ancestors) {
    const {
      use,
      usehref
    } = this;
    if (!use && !usehref) {
      return null;
    }
    let proto = null;
    let somExpression = null;
    let id = null;
    let ref = use;
    if (usehref) {
      ref = usehref;
      if (usehref.startsWith("#som(") && usehref.endsWith(")")) {
        somExpression = usehref.slice("#som(".length, -1);
      } else if (usehref.startsWith(".#som(") && usehref.endsWith(")")) {
        somExpression = usehref.slice(".#som(".length, -1);
      } else if (usehref.startsWith("#")) {
        id = usehref.slice(1);
      } else if (usehref.startsWith(".#")) {
        id = usehref.slice(2);
      }
    } else if (use.startsWith("#")) {
      id = use.slice(1);
    } else {
      somExpression = use;
    }
    this.use = this.usehref = "";
    if (id) {
      proto = ids.get(id);
    } else {
      proto = (0, _som.searchNode)(ids.get(_symbol_utils.$root), this, somExpression, true, false);
      if (proto) {
        proto = proto[0];
      }
    }
    if (!proto) {
      (0, _util.warn)(`XFA - Invalid prototype reference: ${ref}.`);
      return null;
    }
    if (proto[_symbol_utils.$nodeName] !== this[_symbol_utils.$nodeName]) {
      (0, _util.warn)(`XFA - Incompatible prototype: ${proto[_symbol_utils.$nodeName]} !== ${this[_symbol_utils.$nodeName]}.`);
      return null;
    }
    if (ancestors.has(proto)) {
      (0, _util.warn)(`XFA - Cycle detected in prototypes use.`);
      return null;
    }
    ancestors.add(proto);
    const protoProto = proto[_getPrototype](ids, ancestors);
    if (protoProto) {
      proto[_applyPrototype](protoProto, ids, ancestors);
    }
    proto[_symbol_utils.$resolvePrototypes](ids, ancestors);
    ancestors.delete(proto);
    return proto;
  }
  [_applyPrototype](proto, ids, ancestors) {
    if (ancestors.has(proto)) {
      (0, _util.warn)(`XFA - Cycle detected in prototypes use.`);
      return;
    }
    if (!this[_symbol_utils.$content] && proto[_symbol_utils.$content]) {
      this[_symbol_utils.$content] = proto[_symbol_utils.$content];
    }
    const newAncestors = new Set(ancestors);
    newAncestors.add(proto);
    for (const unsetAttrName of this[_getUnsetAttributes](proto[_setAttributes])) {
      this[unsetAttrName] = proto[unsetAttrName];
      if (this[_setAttributes]) {
        this[_setAttributes].add(unsetAttrName);
      }
    }
    for (const name of Object.getOwnPropertyNames(this)) {
      if (this[_attributeNames].has(name)) {
        continue;
      }
      const value = this[name];
      const protoValue = proto[name];
      if (value instanceof XFAObjectArray) {
        for (const child of value[_children]) {
          child[_resolvePrototypesHelper](ids, ancestors);
        }
        for (let i = value[_children].length, ii = protoValue[_children].length; i < ii; i++) {
          const child = proto[_children][i][_symbol_utils.$clone]();
          if (value.push(child)) {
            child[_parent] = this;
            this[_children].push(child);
            child[_resolvePrototypesHelper](ids, ancestors);
          } else {
            break;
          }
        }
        continue;
      }
      if (value !== null) {
        value[_symbol_utils.$resolvePrototypes](ids, ancestors);
        if (protoValue) {
          value[_applyPrototype](protoValue, ids, ancestors);
        }
        continue;
      }
      if (protoValue !== null) {
        const child = protoValue[_symbol_utils.$clone]();
        child[_parent] = this;
        this[name] = child;
        this[_children].push(child);
        child[_resolvePrototypesHelper](ids, ancestors);
      }
    }
  }
  static [_cloneAttribute](obj) {
    if (Array.isArray(obj)) {
      return obj.map(x => XFAObject[_cloneAttribute](x));
    }
    if (typeof obj === "object" && obj !== null) {
      return Object.assign({}, obj);
    }
    return obj;
  }
  [_symbol_utils.$clone]() {
    const clone = Object.create(Object.getPrototypeOf(this));
    for (const $symbol of Object.getOwnPropertySymbols(this)) {
      try {
        clone[$symbol] = this[$symbol];
      } catch {
        (0, _util.shadow)(clone, $symbol, this[$symbol]);
      }
    }
    clone[_symbol_utils.$uid] = `${clone[_symbol_utils.$nodeName]}${uid++}`;
    clone[_children] = [];
    for (const name of Object.getOwnPropertyNames(this)) {
      if (this[_attributeNames].has(name)) {
        clone[name] = XFAObject[_cloneAttribute](this[name]);
        continue;
      }
      const value = this[name];
      clone[name] = value instanceof XFAObjectArray ? new XFAObjectArray(value[_max]) : null;
    }
    for (const child of this[_children]) {
      const name = child[_symbol_utils.$nodeName];
      const clonedChild = child[_symbol_utils.$clone]();
      clone[_children].push(clonedChild);
      clonedChild[_parent] = clone;
      if (clone[name] === null) {
        clone[name] = clonedChild;
      } else {
        clone[name][_children].push(clonedChild);
      }
    }
    return clone;
  }
  [_symbol_utils.$getChildren](name = null) {
    if (!name) {
      return this[_children];
    }
    return this[_children].filter(c => c[_symbol_utils.$nodeName] === name);
  }
  [_symbol_utils.$getChildrenByClass](name) {
    return this[name];
  }
  [_symbol_utils.$getChildrenByName](name, allTransparent, first = true) {
    return Array.from(this[_symbol_utils.$getChildrenByNameIt](name, allTransparent, first));
  }
  *[_symbol_utils.$getChildrenByNameIt](name, allTransparent, first = true) {
    if (name === "parent") {
      yield this[_parent];
      return;
    }
    for (const child of this[_children]) {
      if (child[_symbol_utils.$nodeName] === name) {
        yield child;
      }
      if (child.name === name) {
        yield child;
      }
      if (allTransparent || child[_symbol_utils.$isTransparent]()) {
        yield* child[_symbol_utils.$getChildrenByNameIt](name, allTransparent, false);
      }
    }
    if (first && this[_attributeNames].has(name)) {
      yield new XFAAttribute(this, name, this[name]);
    }
  }
}
exports.XFAObject = XFAObject;
class XFAObjectArray {
  constructor(max = Infinity) {
    this[_max] = max;
    this[_children] = [];
  }
  get isXFAObject() {
    return false;
  }
  get isXFAObjectArray() {
    return true;
  }
  push(child) {
    const len = this[_children].length;
    if (len <= this[_max]) {
      this[_children].push(child);
      return true;
    }
    (0, _util.warn)(`XFA - node "${child[_symbol_utils.$nodeName]}" accepts no more than ${this[_max]} children`);
    return false;
  }
  isEmpty() {
    return this[_children].length === 0;
  }
  dump() {
    return this[_children].length === 1 ? this[_children][0][_symbol_utils.$dump]() : this[_children].map(x => x[_symbol_utils.$dump]());
  }
  [_symbol_utils.$clone]() {
    const clone = new XFAObjectArray(this[_max]);
    clone[_children] = this[_children].map(c => c[_symbol_utils.$clone]());
    return clone;
  }
  get children() {
    return this[_children];
  }
  clear() {
    this[_children].length = 0;
  }
}
exports.XFAObjectArray = XFAObjectArray;
class XFAAttribute {
  constructor(node, name, value) {
    this[_parent] = node;
    this[_symbol_utils.$nodeName] = name;
    this[_symbol_utils.$content] = value;
    this[_symbol_utils.$consumed] = false;
    this[_symbol_utils.$uid] = `attribute${uid++}`;
  }
  [_symbol_utils.$getParent]() {
    return this[_parent];
  }
  [_symbol_utils.$isDataValue]() {
    return true;
  }
  [_symbol_utils.$getDataValue]() {
    return this[_symbol_utils.$content].trim();
  }
  [_symbol_utils.$setValue](value) {
    value = value.value || "";
    this[_symbol_utils.$content] = value.toString();
  }
  [_symbol_utils.$text]() {
    return this[_symbol_utils.$content];
  }
  [_symbol_utils.$isDescendent](parent) {
    return this[_parent] === parent || this[_parent][_symbol_utils.$isDescendent](parent);
  }
}
exports.XFAAttribute = XFAAttribute;
class XmlObject extends XFAObject {
  constructor(nsId, name, attributes = {}) {
    super(nsId, name);
    this[_symbol_utils.$content] = "";
    this[_dataValue] = null;
    if (name !== "#text") {
      const map = new Map();
      this[_attributes] = map;
      for (const [attrName, value] of Object.entries(attributes)) {
        map.set(attrName, new XFAAttribute(this, attrName, value));
      }
      if (attributes.hasOwnProperty(_symbol_utils.$nsAttributes)) {
        const dataNode = attributes[_symbol_utils.$nsAttributes].xfa.dataNode;
        if (dataNode !== undefined) {
          if (dataNode === "dataGroup") {
            this[_dataValue] = false;
          } else if (dataNode === "dataValue") {
            this[_dataValue] = true;
          }
        }
      }
    }
    this[_symbol_utils.$consumed] = false;
  }
  [_symbol_utils.$toString](buf) {
    const tagName = this[_symbol_utils.$nodeName];
    if (tagName === "#text") {
      buf.push((0, _core_utils.encodeToXmlString)(this[_symbol_utils.$content]));
      return;
    }
    const utf8TagName = (0, _util.utf8StringToString)(tagName);
    const prefix = this[_symbol_utils.$namespaceId] === NS_DATASETS ? "xfa:" : "";
    buf.push(`<${prefix}${utf8TagName}`);
    for (const [name, value] of this[_attributes].entries()) {
      const utf8Name = (0, _util.utf8StringToString)(name);
      buf.push(` ${utf8Name}="${(0, _core_utils.encodeToXmlString)(value[_symbol_utils.$content])}"`);
    }
    if (this[_dataValue] !== null) {
      if (this[_dataValue]) {
        buf.push(` xfa:dataNode="dataValue"`);
      } else {
        buf.push(` xfa:dataNode="dataGroup"`);
      }
    }
    if (!this[_symbol_utils.$content] && this[_children].length === 0) {
      buf.push("/>");
      return;
    }
    buf.push(">");
    if (this[_symbol_utils.$content]) {
      if (typeof this[_symbol_utils.$content] === "string") {
        buf.push((0, _core_utils.encodeToXmlString)(this[_symbol_utils.$content]));
      } else {
        this[_symbol_utils.$content][_symbol_utils.$toString](buf);
      }
    } else {
      for (const child of this[_children]) {
        child[_symbol_utils.$toString](buf);
      }
    }
    buf.push(`</${prefix}${utf8TagName}>`);
  }
  [_symbol_utils.$onChild](child) {
    if (this[_symbol_utils.$content]) {
      const node = new XmlObject(this[_symbol_utils.$namespaceId], "#text");
      this[_symbol_utils.$appendChild](node);
      node[_symbol_utils.$content] = this[_symbol_utils.$content];
      this[_symbol_utils.$content] = "";
    }
    this[_symbol_utils.$appendChild](child);
    return true;
  }
  [_symbol_utils.$onText](str) {
    this[_symbol_utils.$content] += str;
  }
  [_symbol_utils.$finalize]() {
    if (this[_symbol_utils.$content] && this[_children].length > 0) {
      const node = new XmlObject(this[_symbol_utils.$namespaceId], "#text");
      this[_symbol_utils.$appendChild](node);
      node[_symbol_utils.$content] = this[_symbol_utils.$content];
      delete this[_symbol_utils.$content];
    }
  }
  [_symbol_utils.$toHTML]() {
    if (this[_symbol_utils.$nodeName] === "#text") {
      return _utils.HTMLResult.success({
        name: "#text",
        value: this[_symbol_utils.$content]
      });
    }
    return _utils.HTMLResult.EMPTY;
  }
  [_symbol_utils.$getChildren](name = null) {
    if (!name) {
      return this[_children];
    }
    return this[_children].filter(c => c[_symbol_utils.$nodeName] === name);
  }
  [_symbol_utils.$getAttributes]() {
    return this[_attributes];
  }
  [_symbol_utils.$getChildrenByClass](name) {
    const value = this[_attributes].get(name);
    if (value !== undefined) {
      return value;
    }
    return this[_symbol_utils.$getChildren](name);
  }
  *[_symbol_utils.$getChildrenByNameIt](name, allTransparent) {
    const value = this[_attributes].get(name);
    if (value) {
      yield value;
    }
    for (const child of this[_children]) {
      if (child[_symbol_utils.$nodeName] === name) {
        yield child;
      }
      if (allTransparent) {
        yield* child[_symbol_utils.$getChildrenByNameIt](name, allTransparent);
      }
    }
  }
  *[_symbol_utils.$getAttributeIt](name, skipConsumed) {
    const value = this[_attributes].get(name);
    if (value && (!skipConsumed || !value[_symbol_utils.$consumed])) {
      yield value;
    }
    for (const child of this[_children]) {
      yield* child[_symbol_utils.$getAttributeIt](name, skipConsumed);
    }
  }
  *[_symbol_utils.$getRealChildrenByNameIt](name, allTransparent, skipConsumed) {
    for (const child of this[_children]) {
      if (child[_symbol_utils.$nodeName] === name && (!skipConsumed || !child[_symbol_utils.$consumed])) {
        yield child;
      }
      if (allTransparent) {
        yield* child[_symbol_utils.$getRealChildrenByNameIt](name, allTransparent, skipConsumed);
      }
    }
  }
  [_symbol_utils.$isDataValue]() {
    if (this[_dataValue] === null) {
      return this[_children].length === 0 || this[_children][0][_symbol_utils.$namespaceId] === _namespaces.NamespaceIds.xhtml.id;
    }
    return this[_dataValue];
  }
  [_symbol_utils.$getDataValue]() {
    if (this[_dataValue] === null) {
      if (this[_children].length === 0) {
        return this[_symbol_utils.$content].trim();
      }
      if (this[_children][0][_symbol_utils.$namespaceId] === _namespaces.NamespaceIds.xhtml.id) {
        return this[_children][0][_symbol_utils.$text]().trim();
      }
      return null;
    }
    return this[_symbol_utils.$content].trim();
  }
  [_symbol_utils.$setValue](value) {
    value = value.value || "";
    this[_symbol_utils.$content] = value.toString();
  }
  [_symbol_utils.$dump](hasNS = false) {
    const dumped = Object.create(null);
    if (hasNS) {
      dumped.$ns = this[_symbol_utils.$namespaceId];
    }
    if (this[_symbol_utils.$content]) {
      dumped.$content = this[_symbol_utils.$content];
    }
    dumped.$name = this[_symbol_utils.$nodeName];
    dumped.children = [];
    for (const child of this[_children]) {
      dumped.children.push(child[_symbol_utils.$dump](hasNS));
    }
    dumped.attributes = Object.create(null);
    for (const [name, value] of this[_attributes]) {
      dumped.attributes[name] = value[_symbol_utils.$content];
    }
    return dumped;
  }
}
exports.XmlObject = XmlObject;
class ContentObject extends XFAObject {
  constructor(nsId, name) {
    super(nsId, name);
    this[_symbol_utils.$content] = "";
  }
  [_symbol_utils.$onText](text) {
    this[_symbol_utils.$content] += text;
  }
  [_symbol_utils.$finalize]() {}
}
exports.ContentObject = ContentObject;
class OptionObject extends ContentObject {
  constructor(nsId, name, options) {
    super(nsId, name);
    this[_options] = options;
  }
  [_symbol_utils.$finalize]() {
    this[_symbol_utils.$content] = (0, _utils.getKeyword)({
      data: this[_symbol_utils.$content],
      defaultValue: this[_options][0],
      validate: k => this[_options].includes(k)
    });
  }
  [_symbol_utils.$clean](builder) {
    super[_symbol_utils.$clean](builder);
    delete this[_options];
  }
}
exports.OptionObject = OptionObject;
class StringObject extends ContentObject {
  [_symbol_utils.$finalize]() {
    this[_symbol_utils.$content] = this[_symbol_utils.$content].trim();
  }
}
exports.StringObject = StringObject;
class IntegerObject extends ContentObject {
  constructor(nsId, name, defaultValue, validator) {
    super(nsId, name);
    this[_defaultValue] = defaultValue;
    this[_validator] = validator;
  }
  [_symbol_utils.$finalize]() {
    this[_symbol_utils.$content] = (0, _utils.getInteger)({
      data: this[_symbol_utils.$content],
      defaultValue: this[_defaultValue],
      validate: this[_validator]
    });
  }
  [_symbol_utils.$clean](builder) {
    super[_symbol_utils.$clean](builder);
    delete this[_defaultValue];
    delete this[_validator];
  }
}
exports.IntegerObject = IntegerObject;
class Option01 extends IntegerObject {
  constructor(nsId, name) {
    super(nsId, name, 0, n => n === 1);
  }
}
exports.Option01 = Option01;
class Option10 extends IntegerObject {
  constructor(nsId, name) {
    super(nsId, name, 1, n => n === 0);
  }
}
exports.Option10 = Option10;

/***/ }),
/* 88 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createDataNode = createDataNode;
exports.searchNode = searchNode;
var _symbol_utils = __w_pdfjs_require__(78);
var _util = __w_pdfjs_require__(2);
const namePattern = /^[^.[]+/;
const indexPattern = /^[^\]]+/;
const operators = {
  dot: 0,
  dotDot: 1,
  dotHash: 2,
  dotBracket: 3,
  dotParen: 4
};
const shortcuts = new Map([["$data", (root, current) => root.datasets ? root.datasets.data : root], ["$record", (root, current) => (root.datasets ? root.datasets.data : root)[_symbol_utils.$getChildren]()[0]], ["$template", (root, current) => root.template], ["$connectionSet", (root, current) => root.connectionSet], ["$form", (root, current) => root.form], ["$layout", (root, current) => root.layout], ["$host", (root, current) => root.host], ["$dataWindow", (root, current) => root.dataWindow], ["$event", (root, current) => root.event], ["!", (root, current) => root.datasets], ["$xfa", (root, current) => root], ["xfa", (root, current) => root], ["$", (root, current) => current]]);
const somCache = new WeakMap();
function parseIndex(index) {
  index = index.trim();
  if (index === "*") {
    return Infinity;
  }
  return parseInt(index, 10) || 0;
}
function parseExpression(expr, dotDotAllowed, noExpr = true) {
  let match = expr.match(namePattern);
  if (!match) {
    return null;
  }
  let [name] = match;
  const parsed = [{
    name,
    cacheName: "." + name,
    index: 0,
    js: null,
    formCalc: null,
    operator: operators.dot
  }];
  let pos = name.length;
  while (pos < expr.length) {
    const spos = pos;
    const char = expr.charAt(pos++);
    if (char === "[") {
      match = expr.slice(pos).match(indexPattern);
      if (!match) {
        (0, _util.warn)("XFA - Invalid index in SOM expression");
        return null;
      }
      parsed.at(-1).index = parseIndex(match[0]);
      pos += match[0].length + 1;
      continue;
    }
    let operator;
    switch (expr.charAt(pos)) {
      case ".":
        if (!dotDotAllowed) {
          return null;
        }
        pos++;
        operator = operators.dotDot;
        break;
      case "#":
        pos++;
        operator = operators.dotHash;
        break;
      case "[":
        if (noExpr) {
          (0, _util.warn)("XFA - SOM expression contains a FormCalc subexpression which is not supported for now.");
          return null;
        }
        operator = operators.dotBracket;
        break;
      case "(":
        if (noExpr) {
          (0, _util.warn)("XFA - SOM expression contains a JavaScript subexpression which is not supported for now.");
          return null;
        }
        operator = operators.dotParen;
        break;
      default:
        operator = operators.dot;
        break;
    }
    match = expr.slice(pos).match(namePattern);
    if (!match) {
      break;
    }
    [name] = match;
    pos += name.length;
    parsed.push({
      name,
      cacheName: expr.slice(spos, pos),
      operator,
      index: 0,
      js: null,
      formCalc: null
    });
  }
  return parsed;
}
function searchNode(root, container, expr, dotDotAllowed = true, useCache = true) {
  const parsed = parseExpression(expr, dotDotAllowed);
  if (!parsed) {
    return null;
  }
  const fn = shortcuts.get(parsed[0].name);
  let i = 0;
  let isQualified;
  if (fn) {
    isQualified = true;
    root = [fn(root, container)];
    i = 1;
  } else {
    isQualified = container === null;
    root = [container || root];
  }
  for (let ii = parsed.length; i < ii; i++) {
    const {
      name,
      cacheName,
      operator,
      index
    } = parsed[i];
    const nodes = [];
    for (const node of root) {
      if (!node.isXFAObject) {
        continue;
      }
      let children, cached;
      if (useCache) {
        cached = somCache.get(node);
        if (!cached) {
          cached = new Map();
          somCache.set(node, cached);
        }
        children = cached.get(cacheName);
      }
      if (!children) {
        switch (operator) {
          case operators.dot:
            children = node[_symbol_utils.$getChildrenByName](name, false);
            break;
          case operators.dotDot:
            children = node[_symbol_utils.$getChildrenByName](name, true);
            break;
          case operators.dotHash:
            children = node[_symbol_utils.$getChildrenByClass](name);
            children = children.isXFAObjectArray ? children.children : [children];
            break;
          default:
            break;
        }
        if (useCache) {
          cached.set(cacheName, children);
        }
      }
      if (children.length > 0) {
        nodes.push(children);
      }
    }
    if (nodes.length === 0 && !isQualified && i === 0) {
      const parent = container[_symbol_utils.$getParent]();
      container = parent;
      if (!container) {
        return null;
      }
      i = -1;
      root = [container];
      continue;
    }
    root = isFinite(index) ? nodes.filter(node => index < node.length).map(node => node[index]) : nodes.flat();
  }
  if (root.length === 0) {
    return null;
  }
  return root;
}
function createDataNode(root, container, expr) {
  const parsed = parseExpression(expr);
  if (!parsed) {
    return null;
  }
  if (parsed.some(x => x.operator === operators.dotDot)) {
    return null;
  }
  const fn = shortcuts.get(parsed[0].name);
  let i = 0;
  if (fn) {
    root = fn(root, container);
    i = 1;
  } else {
    root = container || root;
  }
  for (let ii = parsed.length; i < ii; i++) {
    const {
      name,
      operator,
      index
    } = parsed[i];
    if (!isFinite(index)) {
      parsed[i].index = 0;
      return root.createNodes(parsed.slice(i));
    }
    let children;
    switch (operator) {
      case operators.dot:
        children = root[_symbol_utils.$getChildrenByName](name, false);
        break;
      case operators.dotDot:
        children = root[_symbol_utils.$getChildrenByName](name, true);
        break;
      case operators.dotHash:
        children = root[_symbol_utils.$getChildrenByClass](name);
        children = children.isXFAObjectArray ? children.children : [children];
        break;
      default:
        break;
    }
    if (children.length === 0) {
      return root.createNodes(parsed.slice(i));
    }
    if (index < children.length) {
      const child = children[index];
      if (!child.isXFAObject) {
        (0, _util.warn)(`XFA - Cannot create a node.`);
        return null;
      }
      root = child;
    } else {
      parsed[i].index = index - children.length;
      return root.createNodes(parsed.slice(i));
    }
  }
  return null;
}

/***/ }),
/* 89 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DataHandler = void 0;
var _symbol_utils = __w_pdfjs_require__(78);
class DataHandler {
  constructor(root, data) {
    this.data = data;
    this.dataset = root.datasets || null;
  }
  serialize(storage) {
    const stack = [[-1, this.data[_symbol_utils.$getChildren]()]];
    while (stack.length > 0) {
      const last = stack.at(-1);
      const [i, children] = last;
      if (i + 1 === children.length) {
        stack.pop();
        continue;
      }
      const child = children[++last[0]];
      const storageEntry = storage.get(child[_symbol_utils.$uid]);
      if (storageEntry) {
        child[_symbol_utils.$setValue](storageEntry);
      } else {
        const attributes = child[_symbol_utils.$getAttributes]();
        for (const value of attributes.values()) {
          const entry = storage.get(value[_symbol_utils.$uid]);
          if (entry) {
            value[_symbol_utils.$setValue](entry);
            break;
          }
        }
      }
      const nodes = child[_symbol_utils.$getChildren]();
      if (nodes.length > 0) {
        stack.push([-1, nodes]);
      }
    }
    const buf = [`<xfa:datasets xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/">`];
    if (this.dataset) {
      for (const child of this.dataset[_symbol_utils.$getChildren]()) {
        if (child[_symbol_utils.$nodeName] !== "data") {
          child[_symbol_utils.$toString](buf);
        }
      }
    }
    this.data[_symbol_utils.$toString](buf);
    buf.push("</xfa:datasets>");
    return buf.join("");
  }
}
exports.DataHandler = DataHandler;

/***/ }),
/* 90 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XFAParser = void 0;
var _symbol_utils = __w_pdfjs_require__(78);
var _xml_parser = __w_pdfjs_require__(71);
var _builder = __w_pdfjs_require__(91);
var _util = __w_pdfjs_require__(2);
class XFAParser extends _xml_parser.XMLParserBase {
  constructor(rootNameSpace = null, richText = false) {
    super();
    this._builder = new _builder.Builder(rootNameSpace);
    this._stack = [];
    this._globalData = {
      usedTypefaces: new Set()
    };
    this._ids = new Map();
    this._current = this._builder.buildRoot(this._ids);
    this._errorCode = _xml_parser.XMLParserErrorCode.NoError;
    this._whiteRegex = /^\s+$/;
    this._nbsps = /\xa0+/g;
    this._richText = richText;
  }
  parse(data) {
    this.parseXml(data);
    if (this._errorCode !== _xml_parser.XMLParserErrorCode.NoError) {
      return undefined;
    }
    this._current[_symbol_utils.$finalize]();
    return this._current.element;
  }
  onText(text) {
    text = text.replace(this._nbsps, match => match.slice(1) + " ");
    if (this._richText || this._current[_symbol_utils.$acceptWhitespace]()) {
      this._current[_symbol_utils.$onText](text, this._richText);
      return;
    }
    if (this._whiteRegex.test(text)) {
      return;
    }
    this._current[_symbol_utils.$onText](text.trim());
  }
  onCdata(text) {
    this._current[_symbol_utils.$onText](text);
  }
  _mkAttributes(attributes, tagName) {
    let namespace = null;
    let prefixes = null;
    const attributeObj = Object.create({});
    for (const {
      name,
      value
    } of attributes) {
      if (name === "xmlns") {
        if (!namespace) {
          namespace = value;
        } else {
          (0, _util.warn)(`XFA - multiple namespace definition in <${tagName}>`);
        }
      } else if (name.startsWith("xmlns:")) {
        const prefix = name.substring("xmlns:".length);
        if (!prefixes) {
          prefixes = [];
        }
        prefixes.push({
          prefix,
          value
        });
      } else {
        const i = name.indexOf(":");
        if (i === -1) {
          attributeObj[name] = value;
        } else {
          let nsAttrs = attributeObj[_symbol_utils.$nsAttributes];
          if (!nsAttrs) {
            nsAttrs = attributeObj[_symbol_utils.$nsAttributes] = Object.create(null);
          }
          const [ns, attrName] = [name.slice(0, i), name.slice(i + 1)];
          const attrs = nsAttrs[ns] ||= Object.create(null);
          attrs[attrName] = value;
        }
      }
    }
    return [namespace, prefixes, attributeObj];
  }
  _getNameAndPrefix(name, nsAgnostic) {
    const i = name.indexOf(":");
    if (i === -1) {
      return [name, null];
    }
    return [name.substring(i + 1), nsAgnostic ? "" : name.substring(0, i)];
  }
  onBeginElement(tagName, attributes, isEmpty) {
    const [namespace, prefixes, attributesObj] = this._mkAttributes(attributes, tagName);
    const [name, nsPrefix] = this._getNameAndPrefix(tagName, this._builder.isNsAgnostic());
    const node = this._builder.build({
      nsPrefix,
      name,
      attributes: attributesObj,
      namespace,
      prefixes
    });
    node[_symbol_utils.$globalData] = this._globalData;
    if (isEmpty) {
      node[_symbol_utils.$finalize]();
      if (this._current[_symbol_utils.$onChild](node)) {
        node[_symbol_utils.$setId](this._ids);
      }
      node[_symbol_utils.$clean](this._builder);
      return;
    }
    this._stack.push(this._current);
    this._current = node;
  }
  onEndElement(name) {
    const node = this._current;
    if (node[_symbol_utils.$isCDATAXml]() && typeof node[_symbol_utils.$content] === "string") {
      const parser = new XFAParser();
      parser._globalData = this._globalData;
      const root = parser.parse(node[_symbol_utils.$content]);
      node[_symbol_utils.$content] = null;
      node[_symbol_utils.$onChild](root);
    }
    node[_symbol_utils.$finalize]();
    this._current = this._stack.pop();
    if (this._current[_symbol_utils.$onChild](node)) {
      node[_symbol_utils.$setId](this._ids);
    }
    node[_symbol_utils.$clean](this._builder);
  }
  onError(code) {
    this._errorCode = code;
  }
}
exports.XFAParser = XFAParser;

/***/ }),
/* 91 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Builder = void 0;
var _namespaces = __w_pdfjs_require__(81);
var _symbol_utils = __w_pdfjs_require__(78);
var _setup = __w_pdfjs_require__(92);
var _template = __w_pdfjs_require__(80);
var _unknown = __w_pdfjs_require__(101);
var _util = __w_pdfjs_require__(2);
var _xfa_object = __w_pdfjs_require__(87);
class Root extends _xfa_object.XFAObject {
  constructor(ids) {
    super(-1, "root", Object.create(null));
    this.element = null;
    this[_symbol_utils.$ids] = ids;
  }
  [_symbol_utils.$onChild](child) {
    this.element = child;
    return true;
  }
  [_symbol_utils.$finalize]() {
    super[_symbol_utils.$finalize]();
    if (this.element.template instanceof _template.Template) {
      this[_symbol_utils.$ids].set(_symbol_utils.$root, this.element);
      this.element.template[_symbol_utils.$resolvePrototypes](this[_symbol_utils.$ids]);
      this.element.template[_symbol_utils.$ids] = this[_symbol_utils.$ids];
    }
  }
}
class Empty extends _xfa_object.XFAObject {
  constructor() {
    super(-1, "", Object.create(null));
  }
  [_symbol_utils.$onChild](_) {
    return false;
  }
}
class Builder {
  constructor(rootNameSpace = null) {
    this._namespaceStack = [];
    this._nsAgnosticLevel = 0;
    this._namespacePrefixes = new Map();
    this._namespaces = new Map();
    this._nextNsId = Math.max(...Object.values(_namespaces.NamespaceIds).map(({
      id
    }) => id));
    this._currentNamespace = rootNameSpace || new _unknown.UnknownNamespace(++this._nextNsId);
  }
  buildRoot(ids) {
    return new Root(ids);
  }
  build({
    nsPrefix,
    name,
    attributes,
    namespace,
    prefixes
  }) {
    const hasNamespaceDef = namespace !== null;
    if (hasNamespaceDef) {
      this._namespaceStack.push(this._currentNamespace);
      this._currentNamespace = this._searchNamespace(namespace);
    }
    if (prefixes) {
      this._addNamespacePrefix(prefixes);
    }
    if (attributes.hasOwnProperty(_symbol_utils.$nsAttributes)) {
      const dataTemplate = _setup.NamespaceSetUp.datasets;
      const nsAttrs = attributes[_symbol_utils.$nsAttributes];
      let xfaAttrs = null;
      for (const [ns, attrs] of Object.entries(nsAttrs)) {
        const nsToUse = this._getNamespaceToUse(ns);
        if (nsToUse === dataTemplate) {
          xfaAttrs = {
            xfa: attrs
          };
          break;
        }
      }
      if (xfaAttrs) {
        attributes[_symbol_utils.$nsAttributes] = xfaAttrs;
      } else {
        delete attributes[_symbol_utils.$nsAttributes];
      }
    }
    const namespaceToUse = this._getNamespaceToUse(nsPrefix);
    const node = namespaceToUse?.[_namespaces.$buildXFAObject](name, attributes) || new Empty();
    if (node[_symbol_utils.$isNsAgnostic]()) {
      this._nsAgnosticLevel++;
    }
    if (hasNamespaceDef || prefixes || node[_symbol_utils.$isNsAgnostic]()) {
      node[_symbol_utils.$cleanup] = {
        hasNamespace: hasNamespaceDef,
        prefixes,
        nsAgnostic: node[_symbol_utils.$isNsAgnostic]()
      };
    }
    return node;
  }
  isNsAgnostic() {
    return this._nsAgnosticLevel > 0;
  }
  _searchNamespace(nsName) {
    let ns = this._namespaces.get(nsName);
    if (ns) {
      return ns;
    }
    for (const [name, {
      check
    }] of Object.entries(_namespaces.NamespaceIds)) {
      if (check(nsName)) {
        ns = _setup.NamespaceSetUp[name];
        if (ns) {
          this._namespaces.set(nsName, ns);
          return ns;
        }
        break;
      }
    }
    ns = new _unknown.UnknownNamespace(++this._nextNsId);
    this._namespaces.set(nsName, ns);
    return ns;
  }
  _addNamespacePrefix(prefixes) {
    for (const {
      prefix,
      value
    } of prefixes) {
      const namespace = this._searchNamespace(value);
      let prefixStack = this._namespacePrefixes.get(prefix);
      if (!prefixStack) {
        prefixStack = [];
        this._namespacePrefixes.set(prefix, prefixStack);
      }
      prefixStack.push(namespace);
    }
  }
  _getNamespaceToUse(prefix) {
    if (!prefix) {
      return this._currentNamespace;
    }
    const prefixStack = this._namespacePrefixes.get(prefix);
    if (prefixStack?.length > 0) {
      return prefixStack.at(-1);
    }
    (0, _util.warn)(`Unknown namespace prefix: ${prefix}.`);
    return null;
  }
  clean(data) {
    const {
      hasNamespace,
      prefixes,
      nsAgnostic
    } = data;
    if (hasNamespace) {
      this._currentNamespace = this._namespaceStack.pop();
    }
    if (prefixes) {
      prefixes.forEach(({
        prefix
      }) => {
        this._namespacePrefixes.get(prefix).pop();
      });
    }
    if (nsAgnostic) {
      this._nsAgnosticLevel--;
    }
  }
}
exports.Builder = Builder;

/***/ }),
/* 92 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.NamespaceSetUp = void 0;
var _config = __w_pdfjs_require__(93);
var _connection_set = __w_pdfjs_require__(94);
var _datasets = __w_pdfjs_require__(95);
var _locale_set = __w_pdfjs_require__(96);
var _signature = __w_pdfjs_require__(97);
var _stylesheet = __w_pdfjs_require__(98);
var _template = __w_pdfjs_require__(80);
var _xdp = __w_pdfjs_require__(99);
var _xhtml = __w_pdfjs_require__(100);
const NamespaceSetUp = {
  config: _config.ConfigNamespace,
  connection: _connection_set.ConnectionSetNamespace,
  datasets: _datasets.DatasetsNamespace,
  localeSet: _locale_set.LocaleSetNamespace,
  signature: _signature.SignatureNamespace,
  stylesheet: _stylesheet.StylesheetNamespace,
  template: _template.TemplateNamespace,
  xdp: _xdp.XdpNamespace,
  xhtml: _xhtml.XhtmlNamespace
};
exports.NamespaceSetUp = NamespaceSetUp;

/***/ }),
/* 93 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConfigNamespace = void 0;
var _namespaces = __w_pdfjs_require__(81);
var _symbol_utils = __w_pdfjs_require__(78);
var _xfa_object = __w_pdfjs_require__(87);
var _utils = __w_pdfjs_require__(84);
var _util = __w_pdfjs_require__(2);
const CONFIG_NS_ID = _namespaces.NamespaceIds.config.id;
class Acrobat extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "acrobat", true);
    this.acrobat7 = null;
    this.autoSave = null;
    this.common = null;
    this.validate = null;
    this.validateApprovalSignatures = null;
    this.submitUrl = new _xfa_object.XFAObjectArray();
  }
}
class Acrobat7 extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "acrobat7", true);
    this.dynamicRender = null;
  }
}
class ADBE_JSConsole extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "ADBE_JSConsole", ["delegate", "Enable", "Disable"]);
  }
}
class ADBE_JSDebugger extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "ADBE_JSDebugger", ["delegate", "Enable", "Disable"]);
  }
}
class AddSilentPrint extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "addSilentPrint");
  }
}
class AddViewerPreferences extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "addViewerPreferences");
  }
}
class AdjustData extends _xfa_object.Option10 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "adjustData");
  }
}
class AdobeExtensionLevel extends _xfa_object.IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "adobeExtensionLevel", 0, n => n >= 1 && n <= 8);
  }
}
class Agent extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "agent", true);
    this.name = attributes.name ? attributes.name.trim() : "";
    this.common = new _xfa_object.XFAObjectArray();
  }
}
class AlwaysEmbed extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "alwaysEmbed");
  }
}
class Amd extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "amd");
  }
}
class Area extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "area");
    this.level = (0, _utils.getInteger)({
      data: attributes.level,
      defaultValue: 0,
      validate: n => n >= 1 && n <= 3
    });
    this.name = (0, _utils.getStringOption)(attributes.name, ["", "barcode", "coreinit", "deviceDriver", "font", "general", "layout", "merge", "script", "signature", "sourceSet", "templateCache"]);
  }
}
class Attributes extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "attributes", ["preserve", "delegate", "ignore"]);
  }
}
class AutoSave extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "autoSave", ["disabled", "enabled"]);
  }
}
class Base extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "base");
  }
}
class BatchOutput extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "batchOutput");
    this.format = (0, _utils.getStringOption)(attributes.format, ["none", "concat", "zip", "zipCompress"]);
  }
}
class BehaviorOverride extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "behaviorOverride");
  }
  [_symbol_utils.$finalize]() {
    this[_symbol_utils.$content] = new Map(this[_symbol_utils.$content].trim().split(/\s+/).filter(x => x.includes(":")).map(x => x.split(":", 2)));
  }
}
class Cache extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "cache", true);
    this.templateCache = null;
  }
}
class Change extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "change");
  }
}
class Common extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "common", true);
    this.data = null;
    this.locale = null;
    this.localeSet = null;
    this.messaging = null;
    this.suppressBanner = null;
    this.template = null;
    this.validationMessaging = null;
    this.versionControl = null;
    this.log = new _xfa_object.XFAObjectArray();
  }
}
class Compress extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "compress");
    this.scope = (0, _utils.getStringOption)(attributes.scope, ["imageOnly", "document"]);
  }
}
class CompressLogicalStructure extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "compressLogicalStructure");
  }
}
class CompressObjectStream extends _xfa_object.Option10 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "compressObjectStream");
  }
}
class Compression extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "compression", true);
    this.compressLogicalStructure = null;
    this.compressObjectStream = null;
    this.level = null;
    this.type = null;
  }
}
class Config extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "config", true);
    this.acrobat = null;
    this.present = null;
    this.trace = null;
    this.agent = new _xfa_object.XFAObjectArray();
  }
}
class Conformance extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "conformance", ["A", "B"]);
  }
}
class ContentCopy extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "contentCopy");
  }
}
class Copies extends _xfa_object.IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "copies", 1, n => n >= 1);
  }
}
class Creator extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "creator");
  }
}
class CurrentPage extends _xfa_object.IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "currentPage", 0, n => n >= 0);
  }
}
class Data extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "data", true);
    this.adjustData = null;
    this.attributes = null;
    this.incrementalLoad = null;
    this.outputXSL = null;
    this.range = null;
    this.record = null;
    this.startNode = null;
    this.uri = null;
    this.window = null;
    this.xsl = null;
    this.excludeNS = new _xfa_object.XFAObjectArray();
    this.transform = new _xfa_object.XFAObjectArray();
  }
}
class Debug extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "debug", true);
    this.uri = null;
  }
}
class DefaultTypeface extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "defaultTypeface");
    this.writingScript = (0, _utils.getStringOption)(attributes.writingScript, ["*", "Arabic", "Cyrillic", "EastEuropeanRoman", "Greek", "Hebrew", "Japanese", "Korean", "Roman", "SimplifiedChinese", "Thai", "TraditionalChinese", "Vietnamese"]);
  }
}
class Destination extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "destination", ["pdf", "pcl", "ps", "webClient", "zpl"]);
  }
}
class DocumentAssembly extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "documentAssembly");
  }
}
class Driver extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "driver", true);
    this.name = attributes.name ? attributes.name.trim() : "";
    this.fontInfo = null;
    this.xdc = null;
  }
}
class DuplexOption extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "duplexOption", ["simplex", "duplexFlipLongEdge", "duplexFlipShortEdge"]);
  }
}
class DynamicRender extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "dynamicRender", ["forbidden", "required"]);
  }
}
class Embed extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "embed");
  }
}
class Encrypt extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "encrypt");
  }
}
class Encryption extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "encryption", true);
    this.encrypt = null;
    this.encryptionLevel = null;
    this.permissions = null;
  }
}
class EncryptionLevel extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "encryptionLevel", ["40bit", "128bit"]);
  }
}
class Enforce extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "enforce");
  }
}
class Equate extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "equate");
    this.force = (0, _utils.getInteger)({
      data: attributes.force,
      defaultValue: 1,
      validate: n => n === 0
    });
    this.from = attributes.from || "";
    this.to = attributes.to || "";
  }
}
class EquateRange extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "equateRange");
    this.from = attributes.from || "";
    this.to = attributes.to || "";
    this._unicodeRange = attributes.unicodeRange || "";
  }
  get unicodeRange() {
    const ranges = [];
    const unicodeRegex = /U\+([0-9a-fA-F]+)/;
    const unicodeRange = this._unicodeRange;
    for (let range of unicodeRange.split(",").map(x => x.trim()).filter(x => !!x)) {
      range = range.split("-", 2).map(x => {
        const found = x.match(unicodeRegex);
        if (!found) {
          return 0;
        }
        return parseInt(found[1], 16);
      });
      if (range.length === 1) {
        range.push(range[0]);
      }
      ranges.push(range);
    }
    return (0, _util.shadow)(this, "unicodeRange", ranges);
  }
}
class Exclude extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "exclude");
  }
  [_symbol_utils.$finalize]() {
    this[_symbol_utils.$content] = this[_symbol_utils.$content].trim().split(/\s+/).filter(x => x && ["calculate", "close", "enter", "exit", "initialize", "ready", "validate"].includes(x));
  }
}
class ExcludeNS extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "excludeNS");
  }
}
class FlipLabel extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "flipLabel", ["usePrinterSetting", "on", "off"]);
  }
}
class FontInfo extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "fontInfo", true);
    this.embed = null;
    this.map = null;
    this.subsetBelow = null;
    this.alwaysEmbed = new _xfa_object.XFAObjectArray();
    this.defaultTypeface = new _xfa_object.XFAObjectArray();
    this.neverEmbed = new _xfa_object.XFAObjectArray();
  }
}
class FormFieldFilling extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "formFieldFilling");
  }
}
class GroupParent extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "groupParent");
  }
}
class IfEmpty extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "ifEmpty", ["dataValue", "dataGroup", "ignore", "remove"]);
  }
}
class IncludeXDPContent extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "includeXDPContent");
  }
}
class IncrementalLoad extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "incrementalLoad", ["none", "forwardOnly"]);
  }
}
class IncrementalMerge extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "incrementalMerge");
  }
}
class Interactive extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "interactive");
  }
}
class Jog extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "jog", ["usePrinterSetting", "none", "pageSet"]);
  }
}
class LabelPrinter extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "labelPrinter", true);
    this.name = (0, _utils.getStringOption)(attributes.name, ["zpl", "dpl", "ipl", "tcpl"]);
    this.batchOutput = null;
    this.flipLabel = null;
    this.fontInfo = null;
    this.xdc = null;
  }
}
class Layout extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "layout", ["paginate", "panel"]);
  }
}
class Level extends _xfa_object.IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "level", 0, n => n > 0);
  }
}
class Linearized extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "linearized");
  }
}
class Locale extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "locale");
  }
}
class LocaleSet extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "localeSet");
  }
}
class Log extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "log", true);
    this.mode = null;
    this.threshold = null;
    this.to = null;
    this.uri = null;
  }
}
class MapElement extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "map", true);
    this.equate = new _xfa_object.XFAObjectArray();
    this.equateRange = new _xfa_object.XFAObjectArray();
  }
}
class MediumInfo extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "mediumInfo", true);
    this.map = null;
  }
}
class Message extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "message", true);
    this.msgId = null;
    this.severity = null;
  }
}
class Messaging extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "messaging", true);
    this.message = new _xfa_object.XFAObjectArray();
  }
}
class Mode extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "mode", ["append", "overwrite"]);
  }
}
class ModifyAnnots extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "modifyAnnots");
  }
}
class MsgId extends _xfa_object.IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "msgId", 1, n => n >= 1);
  }
}
class NameAttr extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "nameAttr");
  }
}
class NeverEmbed extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "neverEmbed");
  }
}
class NumberOfCopies extends _xfa_object.IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "numberOfCopies", null, n => n >= 2 && n <= 5);
  }
}
class OpenAction extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "openAction", true);
    this.destination = null;
  }
}
class Output extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "output", true);
    this.to = null;
    this.type = null;
    this.uri = null;
  }
}
class OutputBin extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "outputBin");
  }
}
class OutputXSL extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "outputXSL", true);
    this.uri = null;
  }
}
class Overprint extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "overprint", ["none", "both", "draw", "field"]);
  }
}
class Packets extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "packets");
  }
  [_symbol_utils.$finalize]() {
    if (this[_symbol_utils.$content] === "*") {
      return;
    }
    this[_symbol_utils.$content] = this[_symbol_utils.$content].trim().split(/\s+/).filter(x => ["config", "datasets", "template", "xfdf", "xslt"].includes(x));
  }
}
class PageOffset extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "pageOffset");
    this.x = (0, _utils.getInteger)({
      data: attributes.x,
      defaultValue: "useXDCSetting",
      validate: n => true
    });
    this.y = (0, _utils.getInteger)({
      data: attributes.y,
      defaultValue: "useXDCSetting",
      validate: n => true
    });
  }
}
class PageRange extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "pageRange");
  }
  [_symbol_utils.$finalize]() {
    const numbers = this[_symbol_utils.$content].trim().split(/\s+/).map(x => parseInt(x, 10));
    const ranges = [];
    for (let i = 0, ii = numbers.length; i < ii; i += 2) {
      ranges.push(numbers.slice(i, i + 2));
    }
    this[_symbol_utils.$content] = ranges;
  }
}
class Pagination extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "pagination", ["simplex", "duplexShortEdge", "duplexLongEdge"]);
  }
}
class PaginationOverride extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "paginationOverride", ["none", "forceDuplex", "forceDuplexLongEdge", "forceDuplexShortEdge", "forceSimplex"]);
  }
}
class Part extends _xfa_object.IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "part", 1, n => false);
  }
}
class Pcl extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "pcl", true);
    this.name = attributes.name || "";
    this.batchOutput = null;
    this.fontInfo = null;
    this.jog = null;
    this.mediumInfo = null;
    this.outputBin = null;
    this.pageOffset = null;
    this.staple = null;
    this.xdc = null;
  }
}
class Pdf extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "pdf", true);
    this.name = attributes.name || "";
    this.adobeExtensionLevel = null;
    this.batchOutput = null;
    this.compression = null;
    this.creator = null;
    this.encryption = null;
    this.fontInfo = null;
    this.interactive = null;
    this.linearized = null;
    this.openAction = null;
    this.pdfa = null;
    this.producer = null;
    this.renderPolicy = null;
    this.scriptModel = null;
    this.silentPrint = null;
    this.submitFormat = null;
    this.tagged = null;
    this.version = null;
    this.viewerPreferences = null;
    this.xdc = null;
  }
}
class Pdfa extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "pdfa", true);
    this.amd = null;
    this.conformance = null;
    this.includeXDPContent = null;
    this.part = null;
  }
}
class Permissions extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "permissions", true);
    this.accessibleContent = null;
    this.change = null;
    this.contentCopy = null;
    this.documentAssembly = null;
    this.formFieldFilling = null;
    this.modifyAnnots = null;
    this.plaintextMetadata = null;
    this.print = null;
    this.printHighQuality = null;
  }
}
class PickTrayByPDFSize extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "pickTrayByPDFSize");
  }
}
class Picture extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "picture");
  }
}
class PlaintextMetadata extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "plaintextMetadata");
  }
}
class Presence extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "presence", ["preserve", "dissolve", "dissolveStructure", "ignore", "remove"]);
  }
}
class Present extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "present", true);
    this.behaviorOverride = null;
    this.cache = null;
    this.common = null;
    this.copies = null;
    this.destination = null;
    this.incrementalMerge = null;
    this.layout = null;
    this.output = null;
    this.overprint = null;
    this.pagination = null;
    this.paginationOverride = null;
    this.script = null;
    this.validate = null;
    this.xdp = null;
    this.driver = new _xfa_object.XFAObjectArray();
    this.labelPrinter = new _xfa_object.XFAObjectArray();
    this.pcl = new _xfa_object.XFAObjectArray();
    this.pdf = new _xfa_object.XFAObjectArray();
    this.ps = new _xfa_object.XFAObjectArray();
    this.submitUrl = new _xfa_object.XFAObjectArray();
    this.webClient = new _xfa_object.XFAObjectArray();
    this.zpl = new _xfa_object.XFAObjectArray();
  }
}
class Print extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "print");
  }
}
class PrintHighQuality extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "printHighQuality");
  }
}
class PrintScaling extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "printScaling", ["appdefault", "noScaling"]);
  }
}
class PrinterName extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "printerName");
  }
}
class Producer extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "producer");
  }
}
class Ps extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "ps", true);
    this.name = attributes.name || "";
    this.batchOutput = null;
    this.fontInfo = null;
    this.jog = null;
    this.mediumInfo = null;
    this.outputBin = null;
    this.staple = null;
    this.xdc = null;
  }
}
class Range extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "range");
  }
  [_symbol_utils.$finalize]() {
    this[_symbol_utils.$content] = this[_symbol_utils.$content].trim().split(/\s*,\s*/, 2).map(range => range.split("-").map(x => parseInt(x.trim(), 10))).filter(range => range.every(x => !isNaN(x))).map(range => {
      if (range.length === 1) {
        range.push(range[0]);
      }
      return range;
    });
  }
}
class Record extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "record");
  }
  [_symbol_utils.$finalize]() {
    this[_symbol_utils.$content] = this[_symbol_utils.$content].trim();
    const n = parseInt(this[_symbol_utils.$content], 10);
    if (!isNaN(n) && n >= 0) {
      this[_symbol_utils.$content] = n;
    }
  }
}
class Relevant extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "relevant");
  }
  [_symbol_utils.$finalize]() {
    this[_symbol_utils.$content] = this[_symbol_utils.$content].trim().split(/\s+/);
  }
}
class Rename extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "rename");
  }
  [_symbol_utils.$finalize]() {
    this[_symbol_utils.$content] = this[_symbol_utils.$content].trim();
    if (this[_symbol_utils.$content].toLowerCase().startsWith("xml") || new RegExp("[\\p{L}_][\\p{L}\\d._\\p{M}-]*", "u").test(this[_symbol_utils.$content])) {
      (0, _util.warn)("XFA - Rename: invalid XFA name");
    }
  }
}
class RenderPolicy extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "renderPolicy", ["server", "client"]);
  }
}
class RunScripts extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "runScripts", ["both", "client", "none", "server"]);
  }
}
class Script extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "script", true);
    this.currentPage = null;
    this.exclude = null;
    this.runScripts = null;
  }
}
class ScriptModel extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "scriptModel", ["XFA", "none"]);
  }
}
class Severity extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "severity", ["ignore", "error", "information", "trace", "warning"]);
  }
}
class SilentPrint extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "silentPrint", true);
    this.addSilentPrint = null;
    this.printerName = null;
  }
}
class Staple extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "staple");
    this.mode = (0, _utils.getStringOption)(attributes.mode, ["usePrinterSetting", "on", "off"]);
  }
}
class StartNode extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "startNode");
  }
}
class StartPage extends _xfa_object.IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "startPage", 0, n => true);
  }
}
class SubmitFormat extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "submitFormat", ["html", "delegate", "fdf", "xml", "pdf"]);
  }
}
class SubmitUrl extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "submitUrl");
  }
}
class SubsetBelow extends _xfa_object.IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "subsetBelow", 100, n => n >= 0 && n <= 100);
  }
}
class SuppressBanner extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "suppressBanner");
  }
}
class Tagged extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "tagged");
  }
}
class Template extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "template", true);
    this.base = null;
    this.relevant = null;
    this.startPage = null;
    this.uri = null;
    this.xsl = null;
  }
}
class Threshold extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "threshold", ["trace", "error", "information", "warning"]);
  }
}
class To extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "to", ["null", "memory", "stderr", "stdout", "system", "uri"]);
  }
}
class TemplateCache extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "templateCache");
    this.maxEntries = (0, _utils.getInteger)({
      data: attributes.maxEntries,
      defaultValue: 5,
      validate: n => n >= 0
    });
  }
}
class Trace extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "trace", true);
    this.area = new _xfa_object.XFAObjectArray();
  }
}
class Transform extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "transform", true);
    this.groupParent = null;
    this.ifEmpty = null;
    this.nameAttr = null;
    this.picture = null;
    this.presence = null;
    this.rename = null;
    this.whitespace = null;
  }
}
class Type extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "type", ["none", "ascii85", "asciiHex", "ccittfax", "flate", "lzw", "runLength", "native", "xdp", "mergedXDP"]);
  }
}
class Uri extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "uri");
  }
}
class Validate extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "validate", ["preSubmit", "prePrint", "preExecute", "preSave"]);
  }
}
class ValidateApprovalSignatures extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "validateApprovalSignatures");
  }
  [_symbol_utils.$finalize]() {
    this[_symbol_utils.$content] = this[_symbol_utils.$content].trim().split(/\s+/).filter(x => ["docReady", "postSign"].includes(x));
  }
}
class ValidationMessaging extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "validationMessaging", ["allMessagesIndividually", "allMessagesTogether", "firstMessageOnly", "noMessages"]);
  }
}
class Version extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "version", ["1.7", "1.6", "1.5", "1.4", "1.3", "1.2"]);
  }
}
class VersionControl extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "VersionControl");
    this.outputBelow = (0, _utils.getStringOption)(attributes.outputBelow, ["warn", "error", "update"]);
    this.sourceAbove = (0, _utils.getStringOption)(attributes.sourceAbove, ["warn", "error"]);
    this.sourceBelow = (0, _utils.getStringOption)(attributes.sourceBelow, ["update", "maintain"]);
  }
}
class ViewerPreferences extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "viewerPreferences", true);
    this.ADBE_JSConsole = null;
    this.ADBE_JSDebugger = null;
    this.addViewerPreferences = null;
    this.duplexOption = null;
    this.enforce = null;
    this.numberOfCopies = null;
    this.pageRange = null;
    this.pickTrayByPDFSize = null;
    this.printScaling = null;
  }
}
class WebClient extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "webClient", true);
    this.name = attributes.name ? attributes.name.trim() : "";
    this.fontInfo = null;
    this.xdc = null;
  }
}
class Whitespace extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "whitespace", ["preserve", "ltrim", "normalize", "rtrim", "trim"]);
  }
}
class Window extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "window");
  }
  [_symbol_utils.$finalize]() {
    const pair = this[_symbol_utils.$content].trim().split(/\s*,\s*/, 2).map(x => parseInt(x, 10));
    if (pair.some(x => isNaN(x))) {
      this[_symbol_utils.$content] = [0, 0];
      return;
    }
    if (pair.length === 1) {
      pair.push(pair[0]);
    }
    this[_symbol_utils.$content] = pair;
  }
}
class Xdc extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "xdc", true);
    this.uri = new _xfa_object.XFAObjectArray();
    this.xsl = new _xfa_object.XFAObjectArray();
  }
}
class Xdp extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "xdp", true);
    this.packets = null;
  }
}
class Xsl extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "xsl", true);
    this.debug = null;
    this.uri = null;
  }
}
class Zpl extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "zpl", true);
    this.name = attributes.name ? attributes.name.trim() : "";
    this.batchOutput = null;
    this.flipLabel = null;
    this.fontInfo = null;
    this.xdc = null;
  }
}
class ConfigNamespace {
  static [_namespaces.$buildXFAObject](name, attributes) {
    if (ConfigNamespace.hasOwnProperty(name)) {
      return ConfigNamespace[name](attributes);
    }
    return undefined;
  }
  static acrobat(attrs) {
    return new Acrobat(attrs);
  }
  static acrobat7(attrs) {
    return new Acrobat7(attrs);
  }
  static ADBE_JSConsole(attrs) {
    return new ADBE_JSConsole(attrs);
  }
  static ADBE_JSDebugger(attrs) {
    return new ADBE_JSDebugger(attrs);
  }
  static addSilentPrint(attrs) {
    return new AddSilentPrint(attrs);
  }
  static addViewerPreferences(attrs) {
    return new AddViewerPreferences(attrs);
  }
  static adjustData(attrs) {
    return new AdjustData(attrs);
  }
  static adobeExtensionLevel(attrs) {
    return new AdobeExtensionLevel(attrs);
  }
  static agent(attrs) {
    return new Agent(attrs);
  }
  static alwaysEmbed(attrs) {
    return new AlwaysEmbed(attrs);
  }
  static amd(attrs) {
    return new Amd(attrs);
  }
  static area(attrs) {
    return new Area(attrs);
  }
  static attributes(attrs) {
    return new Attributes(attrs);
  }
  static autoSave(attrs) {
    return new AutoSave(attrs);
  }
  static base(attrs) {
    return new Base(attrs);
  }
  static batchOutput(attrs) {
    return new BatchOutput(attrs);
  }
  static behaviorOverride(attrs) {
    return new BehaviorOverride(attrs);
  }
  static cache(attrs) {
    return new Cache(attrs);
  }
  static change(attrs) {
    return new Change(attrs);
  }
  static common(attrs) {
    return new Common(attrs);
  }
  static compress(attrs) {
    return new Compress(attrs);
  }
  static compressLogicalStructure(attrs) {
    return new CompressLogicalStructure(attrs);
  }
  static compressObjectStream(attrs) {
    return new CompressObjectStream(attrs);
  }
  static compression(attrs) {
    return new Compression(attrs);
  }
  static config(attrs) {
    return new Config(attrs);
  }
  static conformance(attrs) {
    return new Conformance(attrs);
  }
  static contentCopy(attrs) {
    return new ContentCopy(attrs);
  }
  static copies(attrs) {
    return new Copies(attrs);
  }
  static creator(attrs) {
    return new Creator(attrs);
  }
  static currentPage(attrs) {
    return new CurrentPage(attrs);
  }
  static data(attrs) {
    return new Data(attrs);
  }
  static debug(attrs) {
    return new Debug(attrs);
  }
  static defaultTypeface(attrs) {
    return new DefaultTypeface(attrs);
  }
  static destination(attrs) {
    return new Destination(attrs);
  }
  static documentAssembly(attrs) {
    return new DocumentAssembly(attrs);
  }
  static driver(attrs) {
    return new Driver(attrs);
  }
  static duplexOption(attrs) {
    return new DuplexOption(attrs);
  }
  static dynamicRender(attrs) {
    return new DynamicRender(attrs);
  }
  static embed(attrs) {
    return new Embed(attrs);
  }
  static encrypt(attrs) {
    return new Encrypt(attrs);
  }
  static encryption(attrs) {
    return new Encryption(attrs);
  }
  static encryptionLevel(attrs) {
    return new EncryptionLevel(attrs);
  }
  static enforce(attrs) {
    return new Enforce(attrs);
  }
  static equate(attrs) {
    return new Equate(attrs);
  }
  static equateRange(attrs) {
    return new EquateRange(attrs);
  }
  static exclude(attrs) {
    return new Exclude(attrs);
  }
  static excludeNS(attrs) {
    return new ExcludeNS(attrs);
  }
  static flipLabel(attrs) {
    return new FlipLabel(attrs);
  }
  static fontInfo(attrs) {
    return new FontInfo(attrs);
  }
  static formFieldFilling(attrs) {
    return new FormFieldFilling(attrs);
  }
  static groupParent(attrs) {
    return new GroupParent(attrs);
  }
  static ifEmpty(attrs) {
    return new IfEmpty(attrs);
  }
  static includeXDPContent(attrs) {
    return new IncludeXDPContent(attrs);
  }
  static incrementalLoad(attrs) {
    return new IncrementalLoad(attrs);
  }
  static incrementalMerge(attrs) {
    return new IncrementalMerge(attrs);
  }
  static interactive(attrs) {
    return new Interactive(attrs);
  }
  static jog(attrs) {
    return new Jog(attrs);
  }
  static labelPrinter(attrs) {
    return new LabelPrinter(attrs);
  }
  static layout(attrs) {
    return new Layout(attrs);
  }
  static level(attrs) {
    return new Level(attrs);
  }
  static linearized(attrs) {
    return new Linearized(attrs);
  }
  static locale(attrs) {
    return new Locale(attrs);
  }
  static localeSet(attrs) {
    return new LocaleSet(attrs);
  }
  static log(attrs) {
    return new Log(attrs);
  }
  static map(attrs) {
    return new MapElement(attrs);
  }
  static mediumInfo(attrs) {
    return new MediumInfo(attrs);
  }
  static message(attrs) {
    return new Message(attrs);
  }
  static messaging(attrs) {
    return new Messaging(attrs);
  }
  static mode(attrs) {
    return new Mode(attrs);
  }
  static modifyAnnots(attrs) {
    return new ModifyAnnots(attrs);
  }
  static msgId(attrs) {
    return new MsgId(attrs);
  }
  static nameAttr(attrs) {
    return new NameAttr(attrs);
  }
  static neverEmbed(attrs) {
    return new NeverEmbed(attrs);
  }
  static numberOfCopies(attrs) {
    return new NumberOfCopies(attrs);
  }
  static openAction(attrs) {
    return new OpenAction(attrs);
  }
  static output(attrs) {
    return new Output(attrs);
  }
  static outputBin(attrs) {
    return new OutputBin(attrs);
  }
  static outputXSL(attrs) {
    return new OutputXSL(attrs);
  }
  static overprint(attrs) {
    return new Overprint(attrs);
  }
  static packets(attrs) {
    return new Packets(attrs);
  }
  static pageOffset(attrs) {
    return new PageOffset(attrs);
  }
  static pageRange(attrs) {
    return new PageRange(attrs);
  }
  static pagination(attrs) {
    return new Pagination(attrs);
  }
  static paginationOverride(attrs) {
    return new PaginationOverride(attrs);
  }
  static part(attrs) {
    return new Part(attrs);
  }
  static pcl(attrs) {
    return new Pcl(attrs);
  }
  static pdf(attrs) {
    return new Pdf(attrs);
  }
  static pdfa(attrs) {
    return new Pdfa(attrs);
  }
  static permissions(attrs) {
    return new Permissions(attrs);
  }
  static pickTrayByPDFSize(attrs) {
    return new PickTrayByPDFSize(attrs);
  }
  static picture(attrs) {
    return new Picture(attrs);
  }
  static plaintextMetadata(attrs) {
    return new PlaintextMetadata(attrs);
  }
  static presence(attrs) {
    return new Presence(attrs);
  }
  static present(attrs) {
    return new Present(attrs);
  }
  static print(attrs) {
    return new Print(attrs);
  }
  static printHighQuality(attrs) {
    return new PrintHighQuality(attrs);
  }
  static printScaling(attrs) {
    return new PrintScaling(attrs);
  }
  static printerName(attrs) {
    return new PrinterName(attrs);
  }
  static producer(attrs) {
    return new Producer(attrs);
  }
  static ps(attrs) {
    return new Ps(attrs);
  }
  static range(attrs) {
    return new Range(attrs);
  }
  static record(attrs) {
    return new Record(attrs);
  }
  static relevant(attrs) {
    return new Relevant(attrs);
  }
  static rename(attrs) {
    return new Rename(attrs);
  }
  static renderPolicy(attrs) {
    return new RenderPolicy(attrs);
  }
  static runScripts(attrs) {
    return new RunScripts(attrs);
  }
  static script(attrs) {
    return new Script(attrs);
  }
  static scriptModel(attrs) {
    return new ScriptModel(attrs);
  }
  static severity(attrs) {
    return new Severity(attrs);
  }
  static silentPrint(attrs) {
    return new SilentPrint(attrs);
  }
  static staple(attrs) {
    return new Staple(attrs);
  }
  static startNode(attrs) {
    return new StartNode(attrs);
  }
  static startPage(attrs) {
    return new StartPage(attrs);
  }
  static submitFormat(attrs) {
    return new SubmitFormat(attrs);
  }
  static submitUrl(attrs) {
    return new SubmitUrl(attrs);
  }
  static subsetBelow(attrs) {
    return new SubsetBelow(attrs);
  }
  static suppressBanner(attrs) {
    return new SuppressBanner(attrs);
  }
  static tagged(attrs) {
    return new Tagged(attrs);
  }
  static template(attrs) {
    return new Template(attrs);
  }
  static templateCache(attrs) {
    return new TemplateCache(attrs);
  }
  static threshold(attrs) {
    return new Threshold(attrs);
  }
  static to(attrs) {
    return new To(attrs);
  }
  static trace(attrs) {
    return new Trace(attrs);
  }
  static transform(attrs) {
    return new Transform(attrs);
  }
  static type(attrs) {
    return new Type(attrs);
  }
  static uri(attrs) {
    return new Uri(attrs);
  }
  static validate(attrs) {
    return new Validate(attrs);
  }
  static validateApprovalSignatures(attrs) {
    return new ValidateApprovalSignatures(attrs);
  }
  static validationMessaging(attrs) {
    return new ValidationMessaging(attrs);
  }
  static version(attrs) {
    return new Version(attrs);
  }
  static versionControl(attrs) {
    return new VersionControl(attrs);
  }
  static viewerPreferences(attrs) {
    return new ViewerPreferences(attrs);
  }
  static webClient(attrs) {
    return new WebClient(attrs);
  }
  static whitespace(attrs) {
    return new Whitespace(attrs);
  }
  static window(attrs) {
    return new Window(attrs);
  }
  static xdc(attrs) {
    return new Xdc(attrs);
  }
  static xdp(attrs) {
    return new Xdp(attrs);
  }
  static xsl(attrs) {
    return new Xsl(attrs);
  }
  static zpl(attrs) {
    return new Zpl(attrs);
  }
}
exports.ConfigNamespace = ConfigNamespace;

/***/ }),
/* 94 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConnectionSetNamespace = void 0;
var _namespaces = __w_pdfjs_require__(81);
var _xfa_object = __w_pdfjs_require__(87);
const CONNECTION_SET_NS_ID = _namespaces.NamespaceIds.connectionSet.id;
class ConnectionSet extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "connectionSet", true);
    this.wsdlConnection = new _xfa_object.XFAObjectArray();
    this.xmlConnection = new _xfa_object.XFAObjectArray();
    this.xsdConnection = new _xfa_object.XFAObjectArray();
  }
}
class EffectiveInputPolicy extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "effectiveInputPolicy");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class EffectiveOutputPolicy extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "effectiveOutputPolicy");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Operation extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "operation");
    this.id = attributes.id || "";
    this.input = attributes.input || "";
    this.name = attributes.name || "";
    this.output = attributes.output || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class RootElement extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "rootElement");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class SoapAction extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "soapAction");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class SoapAddress extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "soapAddress");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Uri extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "uri");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class WsdlAddress extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "wsdlAddress");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class WsdlConnection extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "wsdlConnection", true);
    this.dataDescription = attributes.dataDescription || "";
    this.name = attributes.name || "";
    this.effectiveInputPolicy = null;
    this.effectiveOutputPolicy = null;
    this.operation = null;
    this.soapAction = null;
    this.soapAddress = null;
    this.wsdlAddress = null;
  }
}
class XmlConnection extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "xmlConnection", true);
    this.dataDescription = attributes.dataDescription || "";
    this.name = attributes.name || "";
    this.uri = null;
  }
}
class XsdConnection extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "xsdConnection", true);
    this.dataDescription = attributes.dataDescription || "";
    this.name = attributes.name || "";
    this.rootElement = null;
    this.uri = null;
  }
}
class ConnectionSetNamespace {
  static [_namespaces.$buildXFAObject](name, attributes) {
    if (ConnectionSetNamespace.hasOwnProperty(name)) {
      return ConnectionSetNamespace[name](attributes);
    }
    return undefined;
  }
  static connectionSet(attrs) {
    return new ConnectionSet(attrs);
  }
  static effectiveInputPolicy(attrs) {
    return new EffectiveInputPolicy(attrs);
  }
  static effectiveOutputPolicy(attrs) {
    return new EffectiveOutputPolicy(attrs);
  }
  static operation(attrs) {
    return new Operation(attrs);
  }
  static rootElement(attrs) {
    return new RootElement(attrs);
  }
  static soapAction(attrs) {
    return new SoapAction(attrs);
  }
  static soapAddress(attrs) {
    return new SoapAddress(attrs);
  }
  static uri(attrs) {
    return new Uri(attrs);
  }
  static wsdlAddress(attrs) {
    return new WsdlAddress(attrs);
  }
  static wsdlConnection(attrs) {
    return new WsdlConnection(attrs);
  }
  static xmlConnection(attrs) {
    return new XmlConnection(attrs);
  }
  static xsdConnection(attrs) {
    return new XsdConnection(attrs);
  }
}
exports.ConnectionSetNamespace = ConnectionSetNamespace;

/***/ }),
/* 95 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DatasetsNamespace = void 0;
var _symbol_utils = __w_pdfjs_require__(78);
var _namespaces = __w_pdfjs_require__(81);
var _xfa_object = __w_pdfjs_require__(87);
const DATASETS_NS_ID = _namespaces.NamespaceIds.datasets.id;
class Data extends _xfa_object.XmlObject {
  constructor(attributes) {
    super(DATASETS_NS_ID, "data", attributes);
  }
  [_symbol_utils.$isNsAgnostic]() {
    return true;
  }
}
class Datasets extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(DATASETS_NS_ID, "datasets", true);
    this.data = null;
    this.Signature = null;
  }
  [_symbol_utils.$onChild](child) {
    const name = child[_symbol_utils.$nodeName];
    if (name === "data" && child[_symbol_utils.$namespaceId] === DATASETS_NS_ID || name === "Signature" && child[_symbol_utils.$namespaceId] === _namespaces.NamespaceIds.signature.id) {
      this[name] = child;
    }
    this[_symbol_utils.$appendChild](child);
  }
}
class DatasetsNamespace {
  static [_namespaces.$buildXFAObject](name, attributes) {
    if (DatasetsNamespace.hasOwnProperty(name)) {
      return DatasetsNamespace[name](attributes);
    }
    return undefined;
  }
  static datasets(attributes) {
    return new Datasets(attributes);
  }
  static data(attributes) {
    return new Data(attributes);
  }
}
exports.DatasetsNamespace = DatasetsNamespace;

/***/ }),
/* 96 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.LocaleSetNamespace = void 0;
var _namespaces = __w_pdfjs_require__(81);
var _xfa_object = __w_pdfjs_require__(87);
var _utils = __w_pdfjs_require__(84);
const LOCALE_SET_NS_ID = _namespaces.NamespaceIds.localeSet.id;
class CalendarSymbols extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "calendarSymbols", true);
    this.name = "gregorian";
    this.dayNames = new _xfa_object.XFAObjectArray(2);
    this.eraNames = null;
    this.meridiemNames = null;
    this.monthNames = new _xfa_object.XFAObjectArray(2);
  }
}
class CurrencySymbol extends _xfa_object.StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "currencySymbol");
    this.name = (0, _utils.getStringOption)(attributes.name, ["symbol", "isoname", "decimal"]);
  }
}
class CurrencySymbols extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "currencySymbols", true);
    this.currencySymbol = new _xfa_object.XFAObjectArray(3);
  }
}
class DatePattern extends _xfa_object.StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "datePattern");
    this.name = (0, _utils.getStringOption)(attributes.name, ["full", "long", "med", "short"]);
  }
}
class DatePatterns extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "datePatterns", true);
    this.datePattern = new _xfa_object.XFAObjectArray(4);
  }
}
class DateTimeSymbols extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "dateTimeSymbols");
  }
}
class Day extends _xfa_object.StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "day");
  }
}
class DayNames extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "dayNames", true);
    this.abbr = (0, _utils.getInteger)({
      data: attributes.abbr,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.day = new _xfa_object.XFAObjectArray(7);
  }
}
class Era extends _xfa_object.StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "era");
  }
}
class EraNames extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "eraNames", true);
    this.era = new _xfa_object.XFAObjectArray(2);
  }
}
class Locale extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "locale", true);
    this.desc = attributes.desc || "";
    this.name = "isoname";
    this.calendarSymbols = null;
    this.currencySymbols = null;
    this.datePatterns = null;
    this.dateTimeSymbols = null;
    this.numberPatterns = null;
    this.numberSymbols = null;
    this.timePatterns = null;
    this.typeFaces = null;
  }
}
class LocaleSet extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "localeSet", true);
    this.locale = new _xfa_object.XFAObjectArray();
  }
}
class Meridiem extends _xfa_object.StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "meridiem");
  }
}
class MeridiemNames extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "meridiemNames", true);
    this.meridiem = new _xfa_object.XFAObjectArray(2);
  }
}
class Month extends _xfa_object.StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "month");
  }
}
class MonthNames extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "monthNames", true);
    this.abbr = (0, _utils.getInteger)({
      data: attributes.abbr,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.month = new _xfa_object.XFAObjectArray(12);
  }
}
class NumberPattern extends _xfa_object.StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "numberPattern");
    this.name = (0, _utils.getStringOption)(attributes.name, ["full", "long", "med", "short"]);
  }
}
class NumberPatterns extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "numberPatterns", true);
    this.numberPattern = new _xfa_object.XFAObjectArray(4);
  }
}
class NumberSymbol extends _xfa_object.StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "numberSymbol");
    this.name = (0, _utils.getStringOption)(attributes.name, ["decimal", "grouping", "percent", "minus", "zero"]);
  }
}
class NumberSymbols extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "numberSymbols", true);
    this.numberSymbol = new _xfa_object.XFAObjectArray(5);
  }
}
class TimePattern extends _xfa_object.StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "timePattern");
    this.name = (0, _utils.getStringOption)(attributes.name, ["full", "long", "med", "short"]);
  }
}
class TimePatterns extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "timePatterns", true);
    this.timePattern = new _xfa_object.XFAObjectArray(4);
  }
}
class TypeFace extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "typeFace", true);
    this.name = attributes.name | "";
  }
}
class TypeFaces extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "typeFaces", true);
    this.typeFace = new _xfa_object.XFAObjectArray();
  }
}
class LocaleSetNamespace {
  static [_namespaces.$buildXFAObject](name, attributes) {
    if (LocaleSetNamespace.hasOwnProperty(name)) {
      return LocaleSetNamespace[name](attributes);
    }
    return undefined;
  }
  static calendarSymbols(attrs) {
    return new CalendarSymbols(attrs);
  }
  static currencySymbol(attrs) {
    return new CurrencySymbol(attrs);
  }
  static currencySymbols(attrs) {
    return new CurrencySymbols(attrs);
  }
  static datePattern(attrs) {
    return new DatePattern(attrs);
  }
  static datePatterns(attrs) {
    return new DatePatterns(attrs);
  }
  static dateTimeSymbols(attrs) {
    return new DateTimeSymbols(attrs);
  }
  static day(attrs) {
    return new Day(attrs);
  }
  static dayNames(attrs) {
    return new DayNames(attrs);
  }
  static era(attrs) {
    return new Era(attrs);
  }
  static eraNames(attrs) {
    return new EraNames(attrs);
  }
  static locale(attrs) {
    return new Locale(attrs);
  }
  static localeSet(attrs) {
    return new LocaleSet(attrs);
  }
  static meridiem(attrs) {
    return new Meridiem(attrs);
  }
  static meridiemNames(attrs) {
    return new MeridiemNames(attrs);
  }
  static month(attrs) {
    return new Month(attrs);
  }
  static monthNames(attrs) {
    return new MonthNames(attrs);
  }
  static numberPattern(attrs) {
    return new NumberPattern(attrs);
  }
  static numberPatterns(attrs) {
    return new NumberPatterns(attrs);
  }
  static numberSymbol(attrs) {
    return new NumberSymbol(attrs);
  }
  static numberSymbols(attrs) {
    return new NumberSymbols(attrs);
  }
  static timePattern(attrs) {
    return new TimePattern(attrs);
  }
  static timePatterns(attrs) {
    return new TimePatterns(attrs);
  }
  static typeFace(attrs) {
    return new TypeFace(attrs);
  }
  static typeFaces(attrs) {
    return new TypeFaces(attrs);
  }
}
exports.LocaleSetNamespace = LocaleSetNamespace;

/***/ }),
/* 97 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SignatureNamespace = void 0;
var _namespaces = __w_pdfjs_require__(81);
var _xfa_object = __w_pdfjs_require__(87);
const SIGNATURE_NS_ID = _namespaces.NamespaceIds.signature.id;
class Signature extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(SIGNATURE_NS_ID, "signature", true);
  }
}
class SignatureNamespace {
  static [_namespaces.$buildXFAObject](name, attributes) {
    if (SignatureNamespace.hasOwnProperty(name)) {
      return SignatureNamespace[name](attributes);
    }
    return undefined;
  }
  static signature(attributes) {
    return new Signature(attributes);
  }
}
exports.SignatureNamespace = SignatureNamespace;

/***/ }),
/* 98 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StylesheetNamespace = void 0;
var _namespaces = __w_pdfjs_require__(81);
var _xfa_object = __w_pdfjs_require__(87);
const STYLESHEET_NS_ID = _namespaces.NamespaceIds.stylesheet.id;
class Stylesheet extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(STYLESHEET_NS_ID, "stylesheet", true);
  }
}
class StylesheetNamespace {
  static [_namespaces.$buildXFAObject](name, attributes) {
    if (StylesheetNamespace.hasOwnProperty(name)) {
      return StylesheetNamespace[name](attributes);
    }
    return undefined;
  }
  static stylesheet(attributes) {
    return new Stylesheet(attributes);
  }
}
exports.StylesheetNamespace = StylesheetNamespace;

/***/ }),
/* 99 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XdpNamespace = void 0;
var _namespaces = __w_pdfjs_require__(81);
var _symbol_utils = __w_pdfjs_require__(78);
var _xfa_object = __w_pdfjs_require__(87);
const XDP_NS_ID = _namespaces.NamespaceIds.xdp.id;
class Xdp extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(XDP_NS_ID, "xdp", true);
    this.uuid = attributes.uuid || "";
    this.timeStamp = attributes.timeStamp || "";
    this.config = null;
    this.connectionSet = null;
    this.datasets = null;
    this.localeSet = null;
    this.stylesheet = new _xfa_object.XFAObjectArray();
    this.template = null;
  }
  [_symbol_utils.$onChildCheck](child) {
    const ns = _namespaces.NamespaceIds[child[_symbol_utils.$nodeName]];
    return ns && child[_symbol_utils.$namespaceId] === ns.id;
  }
}
class XdpNamespace {
  static [_namespaces.$buildXFAObject](name, attributes) {
    if (XdpNamespace.hasOwnProperty(name)) {
      return XdpNamespace[name](attributes);
    }
    return undefined;
  }
  static xdp(attributes) {
    return new Xdp(attributes);
  }
}
exports.XdpNamespace = XdpNamespace;

/***/ }),
/* 100 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XhtmlNamespace = void 0;
var _symbol_utils = __w_pdfjs_require__(78);
var _namespaces = __w_pdfjs_require__(81);
var _html_utils = __w_pdfjs_require__(83);
var _utils = __w_pdfjs_require__(84);
var _xfa_object = __w_pdfjs_require__(87);
const XHTML_NS_ID = _namespaces.NamespaceIds.xhtml.id;
const $richText = Symbol();
const VALID_STYLES = new Set(["color", "font", "font-family", "font-size", "font-stretch", "font-style", "font-weight", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "letter-spacing", "line-height", "orphans", "page-break-after", "page-break-before", "page-break-inside", "tab-interval", "tab-stop", "text-align", "text-decoration", "text-indent", "vertical-align", "widows", "kerning-mode", "xfa-font-horizontal-scale", "xfa-font-vertical-scale", "xfa-spacerun", "xfa-tab-stops"]);
const StyleMapping = new Map([["page-break-after", "breakAfter"], ["page-break-before", "breakBefore"], ["page-break-inside", "breakInside"], ["kerning-mode", value => value === "none" ? "none" : "normal"], ["xfa-font-horizontal-scale", value => `scaleX(${Math.max(0, Math.min(parseInt(value) / 100)).toFixed(2)})`], ["xfa-font-vertical-scale", value => `scaleY(${Math.max(0, Math.min(parseInt(value) / 100)).toFixed(2)})`], ["xfa-spacerun", ""], ["xfa-tab-stops", ""], ["font-size", (value, original) => {
  value = original.fontSize = (0, _utils.getMeasurement)(value);
  return (0, _html_utils.measureToString)(0.99 * value);
}], ["letter-spacing", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["line-height", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["margin", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["margin-bottom", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["margin-left", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["margin-right", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["margin-top", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["text-indent", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["font-family", value => value], ["vertical-align", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))]]);
const spacesRegExp = /\s+/g;
const crlfRegExp = /[\r\n]+/g;
const crlfForRichTextRegExp = /\r\n?/g;
function mapStyle(styleStr, node, richText) {
  const style = Object.create(null);
  if (!styleStr) {
    return style;
  }
  const original = Object.create(null);
  for (const [key, value] of styleStr.split(";").map(s => s.split(":", 2))) {
    const mapping = StyleMapping.get(key);
    if (mapping === "") {
      continue;
    }
    let newValue = value;
    if (mapping) {
      newValue = typeof mapping === "string" ? mapping : mapping(value, original);
    }
    if (key.endsWith("scale")) {
      style.transform = style.transform ? `${style[key]} ${newValue}` : newValue;
    } else {
      style[key.replaceAll(/-([a-zA-Z])/g, (_, x) => x.toUpperCase())] = newValue;
    }
  }
  if (style.fontFamily) {
    (0, _html_utils.setFontFamily)({
      typeface: style.fontFamily,
      weight: style.fontWeight || "normal",
      posture: style.fontStyle || "normal",
      size: original.fontSize || 0
    }, node, node[_symbol_utils.$globalData].fontFinder, style);
  }
  if (richText && style.verticalAlign && style.verticalAlign !== "0px" && style.fontSize) {
    const SUB_SUPER_SCRIPT_FACTOR = 0.583;
    const VERTICAL_FACTOR = 0.333;
    const fontSize = (0, _utils.getMeasurement)(style.fontSize);
    style.fontSize = (0, _html_utils.measureToString)(fontSize * SUB_SUPER_SCRIPT_FACTOR);
    style.verticalAlign = (0, _html_utils.measureToString)(Math.sign((0, _utils.getMeasurement)(style.verticalAlign)) * fontSize * VERTICAL_FACTOR);
  }
  if (richText && style.fontSize) {
    style.fontSize = `calc(${style.fontSize} * var(--scale-factor))`;
  }
  (0, _html_utils.fixTextIndent)(style);
  return style;
}
function checkStyle(node) {
  if (!node.style) {
    return "";
  }
  return node.style.trim().split(/\s*;\s*/).filter(s => !!s).map(s => s.split(/\s*:\s*/, 2)).filter(([key, value]) => {
    if (key === "font-family") {
      node[_symbol_utils.$globalData].usedTypefaces.add(value);
    }
    return VALID_STYLES.has(key);
  }).map(kv => kv.join(":")).join(";");
}
const NoWhites = new Set(["body", "html"]);
class XhtmlObject extends _xfa_object.XmlObject {
  constructor(attributes, name) {
    super(XHTML_NS_ID, name);
    this[$richText] = false;
    this.style = attributes.style || "";
  }
  [_symbol_utils.$clean](builder) {
    super[_symbol_utils.$clean](builder);
    this.style = checkStyle(this);
  }
  [_symbol_utils.$acceptWhitespace]() {
    return !NoWhites.has(this[_symbol_utils.$nodeName]);
  }
  [_symbol_utils.$onText](str, richText = false) {
    if (!richText) {
      str = str.replaceAll(crlfRegExp, "");
      if (!this.style.includes("xfa-spacerun:yes")) {
        str = str.replaceAll(spacesRegExp, " ");
      }
    } else {
      this[$richText] = true;
    }
    if (str) {
      this[_symbol_utils.$content] += str;
    }
  }
  [_symbol_utils.$pushGlyphs](measure, mustPop = true) {
    const xfaFont = Object.create(null);
    const margin = {
      top: NaN,
      bottom: NaN,
      left: NaN,
      right: NaN
    };
    let lineHeight = null;
    for (const [key, value] of this.style.split(";").map(s => s.split(":", 2))) {
      switch (key) {
        case "font-family":
          xfaFont.typeface = (0, _utils.stripQuotes)(value);
          break;
        case "font-size":
          xfaFont.size = (0, _utils.getMeasurement)(value);
          break;
        case "font-weight":
          xfaFont.weight = value;
          break;
        case "font-style":
          xfaFont.posture = value;
          break;
        case "letter-spacing":
          xfaFont.letterSpacing = (0, _utils.getMeasurement)(value);
          break;
        case "margin":
          const values = value.split(/ \t/).map(x => (0, _utils.getMeasurement)(x));
          switch (values.length) {
            case 1:
              margin.top = margin.bottom = margin.left = margin.right = values[0];
              break;
            case 2:
              margin.top = margin.bottom = values[0];
              margin.left = margin.right = values[1];
              break;
            case 3:
              margin.top = values[0];
              margin.bottom = values[2];
              margin.left = margin.right = values[1];
              break;
            case 4:
              margin.top = values[0];
              margin.left = values[1];
              margin.bottom = values[2];
              margin.right = values[3];
              break;
          }
          break;
        case "margin-top":
          margin.top = (0, _utils.getMeasurement)(value);
          break;
        case "margin-bottom":
          margin.bottom = (0, _utils.getMeasurement)(value);
          break;
        case "margin-left":
          margin.left = (0, _utils.getMeasurement)(value);
          break;
        case "margin-right":
          margin.right = (0, _utils.getMeasurement)(value);
          break;
        case "line-height":
          lineHeight = (0, _utils.getMeasurement)(value);
          break;
      }
    }
    measure.pushData(xfaFont, margin, lineHeight);
    if (this[_symbol_utils.$content]) {
      measure.addString(this[_symbol_utils.$content]);
    } else {
      for (const child of this[_symbol_utils.$getChildren]()) {
        if (child[_symbol_utils.$nodeName] === "#text") {
          measure.addString(child[_symbol_utils.$content]);
          continue;
        }
        child[_symbol_utils.$pushGlyphs](measure);
      }
    }
    if (mustPop) {
      measure.popFont();
    }
  }
  [_symbol_utils.$toHTML](availableSpace) {
    const children = [];
    this[_symbol_utils.$extra] = {
      children
    };
    this[_symbol_utils.$childrenToHTML]({});
    if (children.length === 0 && !this[_symbol_utils.$content]) {
      return _utils.HTMLResult.EMPTY;
    }
    let value;
    if (this[$richText]) {
      value = this[_symbol_utils.$content] ? this[_symbol_utils.$content].replaceAll(crlfForRichTextRegExp, "\n") : undefined;
    } else {
      value = this[_symbol_utils.$content] || undefined;
    }
    return _utils.HTMLResult.success({
      name: this[_symbol_utils.$nodeName],
      attributes: {
        href: this.href,
        style: mapStyle(this.style, this, this[$richText])
      },
      children,
      value
    });
  }
}
class A extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "a");
    this.href = (0, _html_utils.fixURL)(attributes.href) || "";
  }
}
class B extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "b");
  }
  [_symbol_utils.$pushGlyphs](measure) {
    measure.pushFont({
      weight: "bold"
    });
    super[_symbol_utils.$pushGlyphs](measure);
    measure.popFont();
  }
}
class Body extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "body");
  }
  [_symbol_utils.$toHTML](availableSpace) {
    const res = super[_symbol_utils.$toHTML](availableSpace);
    const {
      html
    } = res;
    if (!html) {
      return _utils.HTMLResult.EMPTY;
    }
    html.name = "div";
    html.attributes.class = ["xfaRich"];
    return res;
  }
}
class Br extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "br");
  }
  [_symbol_utils.$text]() {
    return "\n";
  }
  [_symbol_utils.$pushGlyphs](measure) {
    measure.addString("\n");
  }
  [_symbol_utils.$toHTML](availableSpace) {
    return _utils.HTMLResult.success({
      name: "br"
    });
  }
}
class Html extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "html");
  }
  [_symbol_utils.$toHTML](availableSpace) {
    const children = [];
    this[_symbol_utils.$extra] = {
      children
    };
    this[_symbol_utils.$childrenToHTML]({});
    if (children.length === 0) {
      return _utils.HTMLResult.success({
        name: "div",
        attributes: {
          class: ["xfaRich"],
          style: {}
        },
        value: this[_symbol_utils.$content] || ""
      });
    }
    if (children.length === 1) {
      const child = children[0];
      if (child.attributes?.class.includes("xfaRich")) {
        return _utils.HTMLResult.success(child);
      }
    }
    return _utils.HTMLResult.success({
      name: "div",
      attributes: {
        class: ["xfaRich"],
        style: {}
      },
      children
    });
  }
}
class I extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "i");
  }
  [_symbol_utils.$pushGlyphs](measure) {
    measure.pushFont({
      posture: "italic"
    });
    super[_symbol_utils.$pushGlyphs](measure);
    measure.popFont();
  }
}
class Li extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "li");
  }
}
class Ol extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "ol");
  }
}
class P extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "p");
  }
  [_symbol_utils.$pushGlyphs](measure) {
    super[_symbol_utils.$pushGlyphs](measure, false);
    measure.addString("\n");
    measure.addPara();
    measure.popFont();
  }
  [_symbol_utils.$text]() {
    const siblings = this[_symbol_utils.$getParent]()[_symbol_utils.$getChildren]();
    if (siblings.at(-1) === this) {
      return super[_symbol_utils.$text]();
    }
    return super[_symbol_utils.$text]() + "\n";
  }
}
class Span extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "span");
  }
}
class Sub extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "sub");
  }
}
class Sup extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "sup");
  }
}
class Ul extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "ul");
  }
}
class XhtmlNamespace {
  static [_namespaces.$buildXFAObject](name, attributes) {
    if (XhtmlNamespace.hasOwnProperty(name)) {
      return XhtmlNamespace[name](attributes);
    }
    return undefined;
  }
  static a(attributes) {
    return new A(attributes);
  }
  static b(attributes) {
    return new B(attributes);
  }
  static body(attributes) {
    return new Body(attributes);
  }
  static br(attributes) {
    return new Br(attributes);
  }
  static html(attributes) {
    return new Html(attributes);
  }
  static i(attributes) {
    return new I(attributes);
  }
  static li(attributes) {
    return new Li(attributes);
  }
  static ol(attributes) {
    return new Ol(attributes);
  }
  static p(attributes) {
    return new P(attributes);
  }
  static span(attributes) {
    return new Span(attributes);
  }
  static sub(attributes) {
    return new Sub(attributes);
  }
  static sup(attributes) {
    return new Sup(attributes);
  }
  static ul(attributes) {
    return new Ul(attributes);
  }
}
exports.XhtmlNamespace = XhtmlNamespace;

/***/ }),
/* 101 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.UnknownNamespace = void 0;
var _namespaces = __w_pdfjs_require__(81);
var _xfa_object = __w_pdfjs_require__(87);
class UnknownNamespace {
  constructor(nsId) {
    this.namespaceId = nsId;
  }
  [_namespaces.$buildXFAObject](name, attributes) {
    return new _xfa_object.XmlObject(this.namespaceId, name, attributes);
  }
}
exports.UnknownNamespace = UnknownNamespace;

/***/ }),
/* 102 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DatasetReader = void 0;
var _util = __w_pdfjs_require__(2);
var _core_utils = __w_pdfjs_require__(3);
var _xml_parser = __w_pdfjs_require__(71);
function decodeString(str) {
  try {
    return (0, _util.stringToUTF8String)(str);
  } catch (ex) {
    (0, _util.warn)(`UTF-8 decoding failed: "${ex}".`);
    return str;
  }
}
class DatasetXMLParser extends _xml_parser.SimpleXMLParser {
  constructor(options) {
    super(options);
    this.node = null;
  }
  onEndElement(name) {
    const node = super.onEndElement(name);
    if (node && name === "xfa:datasets") {
      this.node = node;
      throw new Error("Aborting DatasetXMLParser.");
    }
  }
}
class DatasetReader {
  constructor(data) {
    if (data.datasets) {
      this.node = new _xml_parser.SimpleXMLParser({
        hasAttributes: true
      }).parseFromString(data.datasets).documentElement;
    } else {
      const parser = new DatasetXMLParser({
        hasAttributes: true
      });
      try {
        parser.parseFromString(data["xdp:xdp"]);
      } catch {}
      this.node = parser.node;
    }
  }
  getValue(path) {
    if (!this.node || !path) {
      return "";
    }
    const node = this.node.searchNode((0, _core_utils.parseXFAPath)(path), 0);
    if (!node) {
      return "";
    }
    const first = node.firstChild;
    if (first?.nodeName === "value") {
      return node.children.map(child => decodeString(child.textContent));
    }
    return decodeString(node.textContent);
  }
}
exports.DatasetReader = DatasetReader;

/***/ }),
/* 103 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XRef = void 0;
var _util = __w_pdfjs_require__(2);
var _primitives = __w_pdfjs_require__(4);
var _parser = __w_pdfjs_require__(16);
var _core_utils = __w_pdfjs_require__(3);
var _base_stream = __w_pdfjs_require__(5);
var _crypto = __w_pdfjs_require__(74);
class XRef {
  #firstXRefStmPos = null;
  constructor(stream, pdfManager) {
    this.stream = stream;
    this.pdfManager = pdfManager;
    this.entries = [];
    this._xrefStms = new Set();
    this._cacheMap = new Map();
    this._pendingRefs = new _primitives.RefSet();
    this._newPersistentRefNum = null;
    this._newTemporaryRefNum = null;
  }
  getNewPersistentRef(obj) {
    if (this._newPersistentRefNum === null) {
      this._newPersistentRefNum = this.entries.length || 1;
    }
    const num = this._newPersistentRefNum++;
    this._cacheMap.set(num, obj);
    return _primitives.Ref.get(num, 0);
  }
  getNewTemporaryRef() {
    if (this._newTemporaryRefNum === null) {
      this._newTemporaryRefNum = this.entries.length || 1;
    }
    return _primitives.Ref.get(this._newTemporaryRefNum++, 0);
  }
  resetNewTemporaryRef() {
    this._newTemporaryRefNum = null;
  }
  setStartXRef(startXRef) {
    this.startXRefQueue = [startXRef];
  }
  parse(recoveryMode = false) {
    let trailerDict;
    if (!recoveryMode) {
      trailerDict = this.readXRef();
    } else {
      (0, _util.warn)("Indexing all PDF objects");
      trailerDict = this.indexObjects();
    }
    trailerDict.assignXref(this);
    this.trailer = trailerDict;
    let encrypt;
    try {
      encrypt = trailerDict.get("Encrypt");
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }
      (0, _util.warn)(`XRef.parse - Invalid "Encrypt" reference: "${ex}".`);
    }
    if (encrypt instanceof _primitives.Dict) {
      const ids = trailerDict.get("ID");
      const fileId = ids?.length ? ids[0] : "";
      encrypt.suppressEncryption = true;
      this.encrypt = new _crypto.CipherTransformFactory(encrypt, fileId, this.pdfManager.password);
    }
    let root;
    try {
      root = trailerDict.get("Root");
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }
      (0, _util.warn)(`XRef.parse - Invalid "Root" reference: "${ex}".`);
    }
    if (root instanceof _primitives.Dict) {
      try {
        const pages = root.get("Pages");
        if (pages instanceof _primitives.Dict) {
          this.root = root;
          return;
        }
      } catch (ex) {
        if (ex instanceof _core_utils.MissingDataException) {
          throw ex;
        }
        (0, _util.warn)(`XRef.parse - Invalid "Pages" reference: "${ex}".`);
      }
    }
    if (!recoveryMode) {
      throw new _core_utils.XRefParseException();
    }
    throw new _util.InvalidPDFException("Invalid Root reference.");
  }
  processXRefTable(parser) {
    if (!("tableState" in this)) {
      this.tableState = {
        entryNum: 0,
        streamPos: parser.lexer.stream.pos,
        parserBuf1: parser.buf1,
        parserBuf2: parser.buf2
      };
    }
    const obj = this.readXRefTable(parser);
    if (!(0, _primitives.isCmd)(obj, "trailer")) {
      throw new _util.FormatError("Invalid XRef table: could not find trailer dictionary");
    }
    let dict = parser.getObj();
    if (!(dict instanceof _primitives.Dict) && dict.dict) {
      dict = dict.dict;
    }
    if (!(dict instanceof _primitives.Dict)) {
      throw new _util.FormatError("Invalid XRef table: could not parse trailer dictionary");
    }
    delete this.tableState;
    return dict;
  }
  readXRefTable(parser) {
    const stream = parser.lexer.stream;
    const tableState = this.tableState;
    stream.pos = tableState.streamPos;
    parser.buf1 = tableState.parserBuf1;
    parser.buf2 = tableState.parserBuf2;
    let obj;
    while (true) {
      if (!("firstEntryNum" in tableState) || !("entryCount" in tableState)) {
        if ((0, _primitives.isCmd)(obj = parser.getObj(), "trailer")) {
          break;
        }
        tableState.firstEntryNum = obj;
        tableState.entryCount = parser.getObj();
      }
      let first = tableState.firstEntryNum;
      const count = tableState.entryCount;
      if (!Number.isInteger(first) || !Number.isInteger(count)) {
        throw new _util.FormatError("Invalid XRef table: wrong types in subsection header");
      }
      for (let i = tableState.entryNum; i < count; i++) {
        tableState.streamPos = stream.pos;
        tableState.entryNum = i;
        tableState.parserBuf1 = parser.buf1;
        tableState.parserBuf2 = parser.buf2;
        const entry = {};
        entry.offset = parser.getObj();
        entry.gen = parser.getObj();
        const type = parser.getObj();
        if (type instanceof _primitives.Cmd) {
          switch (type.cmd) {
            case "f":
              entry.free = true;
              break;
            case "n":
              entry.uncompressed = true;
              break;
          }
        }
        if (!Number.isInteger(entry.offset) || !Number.isInteger(entry.gen) || !(entry.free || entry.uncompressed)) {
          throw new _util.FormatError(`Invalid entry in XRef subsection: ${first}, ${count}`);
        }
        if (i === 0 && entry.free && first === 1) {
          first = 0;
        }
        if (!this.entries[i + first]) {
          this.entries[i + first] = entry;
        }
      }
      tableState.entryNum = 0;
      tableState.streamPos = stream.pos;
      tableState.parserBuf1 = parser.buf1;
      tableState.parserBuf2 = parser.buf2;
      delete tableState.firstEntryNum;
      delete tableState.entryCount;
    }
    if (this.entries[0] && !this.entries[0].free) {
      throw new _util.FormatError("Invalid XRef table: unexpected first object");
    }
    return obj;
  }
  processXRefStream(stream) {
    if (!("streamState" in this)) {
      const streamParameters = stream.dict;
      const byteWidths = streamParameters.get("W");
      let range = streamParameters.get("Index");
      if (!range) {
        range = [0, streamParameters.get("Size")];
      }
      this.streamState = {
        entryRanges: range,
        byteWidths,
        entryNum: 0,
        streamPos: stream.pos
      };
    }
    this.readXRefStream(stream);
    delete this.streamState;
    return stream.dict;
  }
  readXRefStream(stream) {
    const streamState = this.streamState;
    stream.pos = streamState.streamPos;
    const [typeFieldWidth, offsetFieldWidth, generationFieldWidth] = streamState.byteWidths;
    const entryRanges = streamState.entryRanges;
    while (entryRanges.length > 0) {
      const [first, n] = entryRanges;
      if (!Number.isInteger(first) || !Number.isInteger(n)) {
        throw new _util.FormatError(`Invalid XRef range fields: ${first}, ${n}`);
      }
      if (!Number.isInteger(typeFieldWidth) || !Number.isInteger(offsetFieldWidth) || !Number.isInteger(generationFieldWidth)) {
        throw new _util.FormatError(`Invalid XRef entry fields length: ${first}, ${n}`);
      }
      for (let i = streamState.entryNum; i < n; ++i) {
        streamState.entryNum = i;
        streamState.streamPos = stream.pos;
        let type = 0,
          offset = 0,
          generation = 0;
        for (let j = 0; j < typeFieldWidth; ++j) {
          const typeByte = stream.getByte();
          if (typeByte === -1) {
            throw new _util.FormatError("Invalid XRef byteWidths 'type'.");
          }
          type = type << 8 | typeByte;
        }
        if (typeFieldWidth === 0) {
          type = 1;
        }
        for (let j = 0; j < offsetFieldWidth; ++j) {
          const offsetByte = stream.getByte();
          if (offsetByte === -1) {
            throw new _util.FormatError("Invalid XRef byteWidths 'offset'.");
          }
          offset = offset << 8 | offsetByte;
        }
        for (let j = 0; j < generationFieldWidth; ++j) {
          const generationByte = stream.getByte();
          if (generationByte === -1) {
            throw new _util.FormatError("Invalid XRef byteWidths 'generation'.");
          }
          generation = generation << 8 | generationByte;
        }
        const entry = {};
        entry.offset = offset;
        entry.gen = generation;
        switch (type) {
          case 0:
            entry.free = true;
            break;
          case 1:
            entry.uncompressed = true;
            break;
          case 2:
            break;
          default:
            throw new _util.FormatError(`Invalid XRef entry type: ${type}`);
        }
        if (!this.entries[first + i]) {
          this.entries[first + i] = entry;
        }
      }
      streamState.entryNum = 0;
      streamState.streamPos = stream.pos;
      entryRanges.splice(0, 2);
    }
  }
  indexObjects() {
    const TAB = 0x9,
      LF = 0xa,
      CR = 0xd,
      SPACE = 0x20;
    const PERCENT = 0x25,
      LT = 0x3c;
    function readToken(data, offset) {
      let token = "",
        ch = data[offset];
      while (ch !== LF && ch !== CR && ch !== LT) {
        if (++offset >= data.length) {
          break;
        }
        token += String.fromCharCode(ch);
        ch = data[offset];
      }
      return token;
    }
    function skipUntil(data, offset, what) {
      const length = what.length,
        dataLength = data.length;
      let skipped = 0;
      while (offset < dataLength) {
        let i = 0;
        while (i < length && data[offset + i] === what[i]) {
          ++i;
        }
        if (i >= length) {
          break;
        }
        offset++;
        skipped++;
      }
      return skipped;
    }
    const gEndobjRegExp = /\b(endobj|\d+\s+\d+\s+obj|xref|trailer\s*<<)\b/g;
    const gStartxrefRegExp = /\b(startxref|\d+\s+\d+\s+obj)\b/g;
    const objRegExp = /^(\d+)\s+(\d+)\s+obj\b/;
    const trailerBytes = new Uint8Array([116, 114, 97, 105, 108, 101, 114]);
    const startxrefBytes = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);
    const xrefBytes = new Uint8Array([47, 88, 82, 101, 102]);
    this.entries.length = 0;
    this._cacheMap.clear();
    const stream = this.stream;
    stream.pos = 0;
    const buffer = stream.getBytes(),
      bufferStr = (0, _util.bytesToString)(buffer),
      length = buffer.length;
    let position = stream.start;
    const trailers = [],
      xrefStms = [];
    while (position < length) {
      let ch = buffer[position];
      if (ch === TAB || ch === LF || ch === CR || ch === SPACE) {
        ++position;
        continue;
      }
      if (ch === PERCENT) {
        do {
          ++position;
          if (position >= length) {
            break;
          }
          ch = buffer[position];
        } while (ch !== LF && ch !== CR);
        continue;
      }
      const token = readToken(buffer, position);
      let m;
      if (token.startsWith("xref") && (token.length === 4 || /\s/.test(token[4]))) {
        position += skipUntil(buffer, position, trailerBytes);
        trailers.push(position);
        position += skipUntil(buffer, position, startxrefBytes);
      } else if (m = objRegExp.exec(token)) {
        const num = m[1] | 0,
          gen = m[2] | 0;
        const startPos = position + token.length;
        let contentLength,
          updateEntries = false;
        if (!this.entries[num]) {
          updateEntries = true;
        } else if (this.entries[num].gen === gen) {
          try {
            const parser = new _parser.Parser({
              lexer: new _parser.Lexer(stream.makeSubStream(startPos))
            });
            parser.getObj();
            updateEntries = true;
          } catch (ex) {
            if (ex instanceof _core_utils.ParserEOFException) {
              (0, _util.warn)(`indexObjects -- checking object (${token}): "${ex}".`);
            } else {
              updateEntries = true;
            }
          }
        }
        if (updateEntries) {
          this.entries[num] = {
            offset: position - stream.start,
            gen,
            uncompressed: true
          };
        }
        gEndobjRegExp.lastIndex = startPos;
        const match = gEndobjRegExp.exec(bufferStr);
        if (match) {
          const endPos = gEndobjRegExp.lastIndex + 1;
          contentLength = endPos - position;
          if (match[1] !== "endobj") {
            (0, _util.warn)(`indexObjects: Found "${match[1]}" inside of another "obj", ` + 'caused by missing "endobj" -- trying to recover.');
            contentLength -= match[1].length + 1;
          }
        } else {
          contentLength = length - position;
        }
        const content = buffer.subarray(position, position + contentLength);
        const xrefTagOffset = skipUntil(content, 0, xrefBytes);
        if (xrefTagOffset < contentLength && content[xrefTagOffset + 5] < 64) {
          xrefStms.push(position - stream.start);
          this._xrefStms.add(position - stream.start);
        }
        position += contentLength;
      } else if (token.startsWith("trailer") && (token.length === 7 || /\s/.test(token[7]))) {
        trailers.push(position);
        const startPos = position + token.length;
        let contentLength;
        gStartxrefRegExp.lastIndex = startPos;
        const match = gStartxrefRegExp.exec(bufferStr);
        if (match) {
          const endPos = gStartxrefRegExp.lastIndex + 1;
          contentLength = endPos - position;
          if (match[1] !== "startxref") {
            (0, _util.warn)(`indexObjects: Found "${match[1]}" after "trailer", ` + 'caused by missing "startxref" -- trying to recover.');
            contentLength -= match[1].length + 1;
          }
        } else {
          contentLength = length - position;
        }
        position += contentLength;
      } else {
        position += token.length + 1;
      }
    }
    for (const xrefStm of xrefStms) {
      this.startXRefQueue.push(xrefStm);
      this.readXRef(true);
    }
    const trailerDicts = [];
    let isEncrypted = false;
    for (const trailer of trailers) {
      stream.pos = trailer;
      const parser = new _parser.Parser({
        lexer: new _parser.Lexer(stream),
        xref: this,
        allowStreams: true,
        recoveryMode: true
      });
      const obj = parser.getObj();
      if (!(0, _primitives.isCmd)(obj, "trailer")) {
        continue;
      }
      const dict = parser.getObj();
      if (!(dict instanceof _primitives.Dict)) {
        continue;
      }
      trailerDicts.push(dict);
      if (dict.has("Encrypt")) {
        isEncrypted = true;
      }
    }
    let trailerDict, trailerError;
    for (const dict of [...trailerDicts, "genFallback", ...trailerDicts]) {
      if (dict === "genFallback") {
        if (!trailerError) {
          break;
        }
        this._generationFallback = true;
        continue;
      }
      let validPagesDict = false;
      try {
        const rootDict = dict.get("Root");
        if (!(rootDict instanceof _primitives.Dict)) {
          continue;
        }
        const pagesDict = rootDict.get("Pages");
        if (!(pagesDict instanceof _primitives.Dict)) {
          continue;
        }
        const pagesCount = pagesDict.get("Count");
        if (Number.isInteger(pagesCount)) {
          validPagesDict = true;
        }
      } catch (ex) {
        trailerError = ex;
        continue;
      }
      if (validPagesDict && (!isEncrypted || dict.has("Encrypt")) && dict.has("ID")) {
        return dict;
      }
      trailerDict = dict;
    }
    if (trailerDict) {
      return trailerDict;
    }
    if (this.topDict) {
      return this.topDict;
    }
    throw new _util.InvalidPDFException("Invalid PDF structure.");
  }
  readXRef(recoveryMode = false) {
    const stream = this.stream;
    const startXRefParsedCache = new Set();
    while (this.startXRefQueue.length) {
      try {
        const startXRef = this.startXRefQueue[0];
        if (startXRefParsedCache.has(startXRef)) {
          (0, _util.warn)("readXRef - skipping XRef table since it was already parsed.");
          this.startXRefQueue.shift();
          continue;
        }
        startXRefParsedCache.add(startXRef);
        stream.pos = startXRef + stream.start;
        const parser = new _parser.Parser({
          lexer: new _parser.Lexer(stream),
          xref: this,
          allowStreams: true
        });
        let obj = parser.getObj();
        let dict;
        if ((0, _primitives.isCmd)(obj, "xref")) {
          dict = this.processXRefTable(parser);
          if (!this.topDict) {
            this.topDict = dict;
          }
          obj = dict.get("XRefStm");
          if (Number.isInteger(obj) && !this._xrefStms.has(obj)) {
            this._xrefStms.add(obj);
            this.startXRefQueue.push(obj);
            this.#firstXRefStmPos ??= obj;
          }
        } else if (Number.isInteger(obj)) {
          if (!Number.isInteger(parser.getObj()) || !(0, _primitives.isCmd)(parser.getObj(), "obj") || !((obj = parser.getObj()) instanceof _base_stream.BaseStream)) {
            throw new _util.FormatError("Invalid XRef stream");
          }
          dict = this.processXRefStream(obj);
          if (!this.topDict) {
            this.topDict = dict;
          }
          if (!dict) {
            throw new _util.FormatError("Failed to read XRef stream");
          }
        } else {
          throw new _util.FormatError("Invalid XRef stream header");
        }
        obj = dict.get("Prev");
        if (Number.isInteger(obj)) {
          this.startXRefQueue.push(obj);
        } else if (obj instanceof _primitives.Ref) {
          this.startXRefQueue.push(obj.num);
        }
      } catch (e) {
        if (e instanceof _core_utils.MissingDataException) {
          throw e;
        }
        (0, _util.info)("(while reading XRef): " + e);
      }
      this.startXRefQueue.shift();
    }
    if (this.topDict) {
      return this.topDict;
    }
    if (recoveryMode) {
      return undefined;
    }
    throw new _core_utils.XRefParseException();
  }
  get lastXRefStreamPos() {
    return this.#firstXRefStmPos ?? (this._xrefStms.size > 0 ? Math.max(...this._xrefStms) : null);
  }
  getEntry(i) {
    const xrefEntry = this.entries[i];
    if (xrefEntry && !xrefEntry.free && xrefEntry.offset) {
      return xrefEntry;
    }
    return null;
  }
  fetchIfRef(obj, suppressEncryption = false) {
    if (obj instanceof _primitives.Ref) {
      return this.fetch(obj, suppressEncryption);
    }
    return obj;
  }
  fetch(ref, suppressEncryption = false) {
    if (!(ref instanceof _primitives.Ref)) {
      throw new Error("ref object is not a reference");
    }
    const num = ref.num;
    const cacheEntry = this._cacheMap.get(num);
    if (cacheEntry !== undefined) {
      if (cacheEntry instanceof _primitives.Dict && !cacheEntry.objId) {
        cacheEntry.objId = ref.toString();
      }
      return cacheEntry;
    }
    let xrefEntry = this.getEntry(num);
    if (xrefEntry === null) {
      this._cacheMap.set(num, xrefEntry);
      return xrefEntry;
    }
    if (this._pendingRefs.has(ref)) {
      this._pendingRefs.remove(ref);
      (0, _util.warn)(`Ignoring circular reference: ${ref}.`);
      return _primitives.CIRCULAR_REF;
    }
    this._pendingRefs.put(ref);
    try {
      xrefEntry = xrefEntry.uncompressed ? this.fetchUncompressed(ref, xrefEntry, suppressEncryption) : this.fetchCompressed(ref, xrefEntry, suppressEncryption);
      this._pendingRefs.remove(ref);
    } catch (ex) {
      this._pendingRefs.remove(ref);
      throw ex;
    }
    if (xrefEntry instanceof _primitives.Dict) {
      xrefEntry.objId = ref.toString();
    } else if (xrefEntry instanceof _base_stream.BaseStream) {
      xrefEntry.dict.objId = ref.toString();
    }
    return xrefEntry;
  }
  fetchUncompressed(ref, xrefEntry, suppressEncryption = false) {
    const gen = ref.gen;
    let num = ref.num;
    if (xrefEntry.gen !== gen) {
      const msg = `Inconsistent generation in XRef: ${ref}`;
      if (this._generationFallback && xrefEntry.gen < gen) {
        (0, _util.warn)(msg);
        return this.fetchUncompressed(_primitives.Ref.get(num, xrefEntry.gen), xrefEntry, suppressEncryption);
      }
      throw new _core_utils.XRefEntryException(msg);
    }
    const stream = this.stream.makeSubStream(xrefEntry.offset + this.stream.start);
    const parser = new _parser.Parser({
      lexer: new _parser.Lexer(stream),
      xref: this,
      allowStreams: true
    });
    const obj1 = parser.getObj();
    const obj2 = parser.getObj();
    const obj3 = parser.getObj();
    if (obj1 !== num || obj2 !== gen || !(obj3 instanceof _primitives.Cmd)) {
      throw new _core_utils.XRefEntryException(`Bad (uncompressed) XRef entry: ${ref}`);
    }
    if (obj3.cmd !== "obj") {
      if (obj3.cmd.startsWith("obj")) {
        num = parseInt(obj3.cmd.substring(3), 10);
        if (!Number.isNaN(num)) {
          return num;
        }
      }
      throw new _core_utils.XRefEntryException(`Bad (uncompressed) XRef entry: ${ref}`);
    }
    xrefEntry = this.encrypt && !suppressEncryption ? parser.getObj(this.encrypt.createCipherTransform(num, gen)) : parser.getObj();
    if (!(xrefEntry instanceof _base_stream.BaseStream)) {
      this._cacheMap.set(num, xrefEntry);
    }
    return xrefEntry;
  }
  fetchCompressed(ref, xrefEntry, suppressEncryption = false) {
    const tableOffset = xrefEntry.offset;
    const stream = this.fetch(_primitives.Ref.get(tableOffset, 0));
    if (!(stream instanceof _base_stream.BaseStream)) {
      throw new _util.FormatError("bad ObjStm stream");
    }
    const first = stream.dict.get("First");
    const n = stream.dict.get("N");
    if (!Number.isInteger(first) || !Number.isInteger(n)) {
      throw new _util.FormatError("invalid first and n parameters for ObjStm stream");
    }
    let parser = new _parser.Parser({
      lexer: new _parser.Lexer(stream),
      xref: this,
      allowStreams: true
    });
    const nums = new Array(n);
    const offsets = new Array(n);
    for (let i = 0; i < n; ++i) {
      const num = parser.getObj();
      if (!Number.isInteger(num)) {
        throw new _util.FormatError(`invalid object number in the ObjStm stream: ${num}`);
      }
      const offset = parser.getObj();
      if (!Number.isInteger(offset)) {
        throw new _util.FormatError(`invalid object offset in the ObjStm stream: ${offset}`);
      }
      nums[i] = num;
      offsets[i] = offset;
    }
    const start = (stream.start || 0) + first;
    const entries = new Array(n);
    for (let i = 0; i < n; ++i) {
      const length = i < n - 1 ? offsets[i + 1] - offsets[i] : undefined;
      if (length < 0) {
        throw new _util.FormatError("Invalid offset in the ObjStm stream.");
      }
      parser = new _parser.Parser({
        lexer: new _parser.Lexer(stream.makeSubStream(start + offsets[i], length, stream.dict)),
        xref: this,
        allowStreams: true
      });
      const obj = parser.getObj();
      entries[i] = obj;
      if (obj instanceof _base_stream.BaseStream) {
        continue;
      }
      const num = nums[i],
        entry = this.entries[num];
      if (entry && entry.offset === tableOffset && entry.gen === i) {
        this._cacheMap.set(num, obj);
      }
    }
    xrefEntry = entries[xrefEntry.gen];
    if (xrefEntry === undefined) {
      throw new _core_utils.XRefEntryException(`Bad (compressed) XRef entry: ${ref}`);
    }
    return xrefEntry;
  }
  async fetchIfRefAsync(obj, suppressEncryption) {
    if (obj instanceof _primitives.Ref) {
      return this.fetchAsync(obj, suppressEncryption);
    }
    return obj;
  }
  async fetchAsync(ref, suppressEncryption) {
    try {
      return this.fetch(ref, suppressEncryption);
    } catch (ex) {
      if (!(ex instanceof _core_utils.MissingDataException)) {
        throw ex;
      }
      await this.pdfManager.requestRange(ex.begin, ex.end);
      return this.fetchAsync(ref, suppressEncryption);
    }
  }
  getCatalogObj() {
    return this.root;
  }
}
exports.XRef = XRef;

/***/ }),
/* 104 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MessageHandler = void 0;
var _util = __w_pdfjs_require__(2);
const CallbackKind = {
  UNKNOWN: 0,
  DATA: 1,
  ERROR: 2
};
const StreamKind = {
  UNKNOWN: 0,
  CANCEL: 1,
  CANCEL_COMPLETE: 2,
  CLOSE: 3,
  ENQUEUE: 4,
  ERROR: 5,
  PULL: 6,
  PULL_COMPLETE: 7,
  START_COMPLETE: 8
};
function wrapReason(reason) {
  if (!(reason instanceof Error || typeof reason === "object" && reason !== null)) {
    (0, _util.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
  }
  switch (reason.name) {
    case "AbortException":
      return new _util.AbortException(reason.message);
    case "MissingPDFException":
      return new _util.MissingPDFException(reason.message);
    case "PasswordException":
      return new _util.PasswordException(reason.message, reason.code);
    case "UnexpectedResponseException":
      return new _util.UnexpectedResponseException(reason.message, reason.status);
    case "UnknownErrorException":
      return new _util.UnknownErrorException(reason.message, reason.details);
    default:
      return new _util.UnknownErrorException(reason.message, reason.toString());
  }
}
class MessageHandler {
  constructor(sourceName, targetName, comObj) {
    this.sourceName = sourceName;
    this.targetName = targetName;
    this.comObj = comObj;
    this.callbackId = 1;
    this.streamId = 1;
    this.streamSinks = Object.create(null);
    this.streamControllers = Object.create(null);
    this.callbackCapabilities = Object.create(null);
    this.actionHandler = Object.create(null);
    this._onComObjOnMessage = event => {
      const data = event.data;
      if (data.targetName !== this.sourceName) {
        return;
      }
      if (data.stream) {
        this.#processStreamMessage(data);
        return;
      }
      if (data.callback) {
        const callbackId = data.callbackId;
        const capability = this.callbackCapabilities[callbackId];
        if (!capability) {
          throw new Error(`Cannot resolve callback ${callbackId}`);
        }
        delete this.callbackCapabilities[callbackId];
        if (data.callback === CallbackKind.DATA) {
          capability.resolve(data.data);
        } else if (data.callback === CallbackKind.ERROR) {
          capability.reject(wrapReason(data.reason));
        } else {
          throw new Error("Unexpected callback case");
        }
        return;
      }
      const action = this.actionHandler[data.action];
      if (!action) {
        throw new Error(`Unknown action from worker: ${data.action}`);
      }
      if (data.callbackId) {
        const cbSourceName = this.sourceName;
        const cbTargetName = data.sourceName;
        new Promise(function (resolve) {
          resolve(action(data.data));
        }).then(function (result) {
          comObj.postMessage({
            sourceName: cbSourceName,
            targetName: cbTargetName,
            callback: CallbackKind.DATA,
            callbackId: data.callbackId,
            data: result
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName: cbSourceName,
            targetName: cbTargetName,
            callback: CallbackKind.ERROR,
            callbackId: data.callbackId,
            reason: wrapReason(reason)
          });
        });
        return;
      }
      if (data.streamId) {
        this.#createStreamSink(data);
        return;
      }
      action(data.data);
    };
    comObj.addEventListener("message", this._onComObjOnMessage);
  }
  on(actionName, handler) {
    const ah = this.actionHandler;
    if (ah[actionName]) {
      throw new Error(`There is already an actionName called "${actionName}"`);
    }
    ah[actionName] = handler;
  }
  send(actionName, data, transfers) {
    this.comObj.postMessage({
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: actionName,
      data
    }, transfers);
  }
  sendWithPromise(actionName, data, transfers) {
    const callbackId = this.callbackId++;
    const capability = new _util.PromiseCapability();
    this.callbackCapabilities[callbackId] = capability;
    try {
      this.comObj.postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: actionName,
        callbackId,
        data
      }, transfers);
    } catch (ex) {
      capability.reject(ex);
    }
    return capability.promise;
  }
  sendWithStream(actionName, data, queueingStrategy, transfers) {
    const streamId = this.streamId++,
      sourceName = this.sourceName,
      targetName = this.targetName,
      comObj = this.comObj;
    return new ReadableStream({
      start: controller => {
        const startCapability = new _util.PromiseCapability();
        this.streamControllers[streamId] = {
          controller,
          startCall: startCapability,
          pullCall: null,
          cancelCall: null,
          isClosed: false
        };
        comObj.postMessage({
          sourceName,
          targetName,
          action: actionName,
          streamId,
          data,
          desiredSize: controller.desiredSize
        }, transfers);
        return startCapability.promise;
      },
      pull: controller => {
        const pullCapability = new _util.PromiseCapability();
        this.streamControllers[streamId].pullCall = pullCapability;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.PULL,
          streamId,
          desiredSize: controller.desiredSize
        });
        return pullCapability.promise;
      },
      cancel: reason => {
        (0, _util.assert)(reason instanceof Error, "cancel must have a valid reason");
        const cancelCapability = new _util.PromiseCapability();
        this.streamControllers[streamId].cancelCall = cancelCapability;
        this.streamControllers[streamId].isClosed = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CANCEL,
          streamId,
          reason: wrapReason(reason)
        });
        return cancelCapability.promise;
      }
    }, queueingStrategy);
  }
  #createStreamSink(data) {
    const streamId = data.streamId,
      sourceName = this.sourceName,
      targetName = data.sourceName,
      comObj = this.comObj;
    const self = this,
      action = this.actionHandler[data.action];
    const streamSink = {
      enqueue(chunk, size = 1, transfers) {
        if (this.isCancelled) {
          return;
        }
        const lastDesiredSize = this.desiredSize;
        this.desiredSize -= size;
        if (lastDesiredSize > 0 && this.desiredSize <= 0) {
          this.sinkCapability = new _util.PromiseCapability();
          this.ready = this.sinkCapability.promise;
        }
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.ENQUEUE,
          streamId,
          chunk
        }, transfers);
      },
      close() {
        if (this.isCancelled) {
          return;
        }
        this.isCancelled = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CLOSE,
          streamId
        });
        delete self.streamSinks[streamId];
      },
      error(reason) {
        (0, _util.assert)(reason instanceof Error, "error must have a valid reason");
        if (this.isCancelled) {
          return;
        }
        this.isCancelled = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.ERROR,
          streamId,
          reason: wrapReason(reason)
        });
      },
      sinkCapability: new _util.PromiseCapability(),
      onPull: null,
      onCancel: null,
      isCancelled: false,
      desiredSize: data.desiredSize,
      ready: null
    };
    streamSink.sinkCapability.resolve();
    streamSink.ready = streamSink.sinkCapability.promise;
    this.streamSinks[streamId] = streamSink;
    new Promise(function (resolve) {
      resolve(action(data.data, streamSink));
    }).then(function () {
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.START_COMPLETE,
        streamId,
        success: true
      });
    }, function (reason) {
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.START_COMPLETE,
        streamId,
        reason: wrapReason(reason)
      });
    });
  }
  #processStreamMessage(data) {
    const streamId = data.streamId,
      sourceName = this.sourceName,
      targetName = data.sourceName,
      comObj = this.comObj;
    const streamController = this.streamControllers[streamId],
      streamSink = this.streamSinks[streamId];
    switch (data.stream) {
      case StreamKind.START_COMPLETE:
        if (data.success) {
          streamController.startCall.resolve();
        } else {
          streamController.startCall.reject(wrapReason(data.reason));
        }
        break;
      case StreamKind.PULL_COMPLETE:
        if (data.success) {
          streamController.pullCall.resolve();
        } else {
          streamController.pullCall.reject(wrapReason(data.reason));
        }
        break;
      case StreamKind.PULL:
        if (!streamSink) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            success: true
          });
          break;
        }
        if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
          streamSink.sinkCapability.resolve();
        }
        streamSink.desiredSize = data.desiredSize;
        new Promise(function (resolve) {
          resolve(streamSink.onPull?.());
        }).then(function () {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            success: true
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            reason: wrapReason(reason)
          });
        });
        break;
      case StreamKind.ENQUEUE:
        (0, _util.assert)(streamController, "enqueue should have stream controller");
        if (streamController.isClosed) {
          break;
        }
        streamController.controller.enqueue(data.chunk);
        break;
      case StreamKind.CLOSE:
        (0, _util.assert)(streamController, "close should have stream controller");
        if (streamController.isClosed) {
          break;
        }
        streamController.isClosed = true;
        streamController.controller.close();
        this.#deleteStreamController(streamController, streamId);
        break;
      case StreamKind.ERROR:
        (0, _util.assert)(streamController, "error should have stream controller");
        streamController.controller.error(wrapReason(data.reason));
        this.#deleteStreamController(streamController, streamId);
        break;
      case StreamKind.CANCEL_COMPLETE:
        if (data.success) {
          streamController.cancelCall.resolve();
        } else {
          streamController.cancelCall.reject(wrapReason(data.reason));
        }
        this.#deleteStreamController(streamController, streamId);
        break;
      case StreamKind.CANCEL:
        if (!streamSink) {
          break;
        }
        new Promise(function (resolve) {
          resolve(streamSink.onCancel?.(wrapReason(data.reason)));
        }).then(function () {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.CANCEL_COMPLETE,
            streamId,
            success: true
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.CANCEL_COMPLETE,
            streamId,
            reason: wrapReason(reason)
          });
        });
        streamSink.sinkCapability.reject(wrapReason(data.reason));
        streamSink.isCancelled = true;
        delete this.streamSinks[streamId];
        break;
      default:
        throw new Error("Unexpected stream case");
    }
  }
  async #deleteStreamController(streamController, streamId) {
    await Promise.allSettled([streamController.startCall?.promise, streamController.pullCall?.promise, streamController.cancelCall?.promise]);
    delete this.streamControllers[streamId];
  }
  destroy() {
    this.comObj.removeEventListener("message", this._onComObjOnMessage);
  }
}
exports.MessageHandler = MessageHandler;

/***/ }),
/* 105 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFWorkerStream = void 0;
var _util = __w_pdfjs_require__(2);
class PDFWorkerStream {
  constructor(msgHandler) {
    this._msgHandler = msgHandler;
    this._contentLength = null;
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }
  getFullReader() {
    (0, _util.assert)(!this._fullRequestReader, "PDFWorkerStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFWorkerStreamReader(this._msgHandler);
    return this._fullRequestReader;
  }
  getRangeReader(begin, end) {
    const reader = new PDFWorkerStreamRangeReader(begin, end, this._msgHandler);
    this._rangeRequestReaders.push(reader);
    return reader;
  }
  cancelAllRequests(reason) {
    this._fullRequestReader?.cancel(reason);
    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }
}
exports.PDFWorkerStream = PDFWorkerStream;
class PDFWorkerStreamReader {
  constructor(msgHandler) {
    this._msgHandler = msgHandler;
    this.onProgress = null;
    this._contentLength = null;
    this._isRangeSupported = false;
    this._isStreamingSupported = false;
    const readableStream = this._msgHandler.sendWithStream("GetReader");
    this._reader = readableStream.getReader();
    this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then(data => {
      this._isStreamingSupported = data.isStreamingSupported;
      this._isRangeSupported = data.isRangeSupported;
      this._contentLength = data.contentLength;
    });
  }
  get headersReady() {
    return this._headersReady;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  async read() {
    const {
      value,
      done
    } = await this._reader.read();
    if (done) {
      return {
        value: undefined,
        done: true
      };
    }
    return {
      value: value.buffer,
      done: false
    };
  }
  cancel(reason) {
    this._reader.cancel(reason);
  }
}
class PDFWorkerStreamRangeReader {
  constructor(begin, end, msgHandler) {
    this._msgHandler = msgHandler;
    this.onProgress = null;
    const readableStream = this._msgHandler.sendWithStream("GetRangeReader", {
      begin,
      end
    });
    this._reader = readableStream.getReader();
  }
  get isStreamingSupported() {
    return false;
  }
  async read() {
    const {
      value,
      done
    } = await this._reader.read();
    if (done) {
      return {
        value: undefined,
        done: true
      };
    }
    return {
      value: value.buffer,
      done: false
    };
  }
  cancel(reason) {
    this._reader.cancel(reason);
  }
}

/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __w_pdfjs_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
var exports = __webpack_exports__;


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "WorkerMessageHandler", ({
  enumerable: true,
  get: function () {
    return _worker.WorkerMessageHandler;
  }
}));
var _worker = __w_pdfjs_require__(1);
const pdfjsVersion = '3.11.174';
const pdfjsBuild = 'ce8716743';
})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=pdf.worker.js.map